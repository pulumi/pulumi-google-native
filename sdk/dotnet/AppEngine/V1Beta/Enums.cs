// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.AppEngine.V1Beta
{
    /// <summary>
    /// Action to take when users access resources that require authentication. Defaults to redirect.
    /// </summary>
    [EnumType]
    public readonly struct ApiConfigHandlerAuthFailAction : IEquatable<ApiConfigHandlerAuthFailAction>
    {
        private readonly string _value;

        private ApiConfigHandlerAuthFailAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not specified. AUTH_FAIL_ACTION_REDIRECT is assumed.
        /// </summary>
        public static ApiConfigHandlerAuthFailAction AuthFailActionUnspecified { get; } = new ApiConfigHandlerAuthFailAction("AUTH_FAIL_ACTION_UNSPECIFIED");
        /// <summary>
        /// Redirects user to "accounts.google.com". The user is redirected back to the application URL after signing in or creating an account.
        /// </summary>
        public static ApiConfigHandlerAuthFailAction AuthFailActionRedirect { get; } = new ApiConfigHandlerAuthFailAction("AUTH_FAIL_ACTION_REDIRECT");
        /// <summary>
        /// Rejects request with a 401 HTTP status code and an error message.
        /// </summary>
        public static ApiConfigHandlerAuthFailAction AuthFailActionUnauthorized { get; } = new ApiConfigHandlerAuthFailAction("AUTH_FAIL_ACTION_UNAUTHORIZED");

        public static bool operator ==(ApiConfigHandlerAuthFailAction left, ApiConfigHandlerAuthFailAction right) => left.Equals(right);
        public static bool operator !=(ApiConfigHandlerAuthFailAction left, ApiConfigHandlerAuthFailAction right) => !left.Equals(right);

        public static explicit operator string(ApiConfigHandlerAuthFailAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ApiConfigHandlerAuthFailAction other && Equals(other);
        public bool Equals(ApiConfigHandlerAuthFailAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Level of login required to access this resource. Defaults to optional.
    /// </summary>
    [EnumType]
    public readonly struct ApiConfigHandlerLogin : IEquatable<ApiConfigHandlerLogin>
    {
        private readonly string _value;

        private ApiConfigHandlerLogin(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not specified. LOGIN_OPTIONAL is assumed.
        /// </summary>
        public static ApiConfigHandlerLogin LoginUnspecified { get; } = new ApiConfigHandlerLogin("LOGIN_UNSPECIFIED");
        /// <summary>
        /// Does not require that the user is signed in.
        /// </summary>
        public static ApiConfigHandlerLogin LoginOptional { get; } = new ApiConfigHandlerLogin("LOGIN_OPTIONAL");
        /// <summary>
        /// If the user is not signed in, the auth_fail_action is taken. In addition, if the user is not an administrator for the application, they are given an error message regardless of auth_fail_action. If the user is an administrator, the handler proceeds.
        /// </summary>
        public static ApiConfigHandlerLogin LoginAdmin { get; } = new ApiConfigHandlerLogin("LOGIN_ADMIN");
        /// <summary>
        /// If the user has signed in, the handler proceeds normally. Otherwise, the auth_fail_action is taken.
        /// </summary>
        public static ApiConfigHandlerLogin LoginRequired { get; } = new ApiConfigHandlerLogin("LOGIN_REQUIRED");

        public static bool operator ==(ApiConfigHandlerLogin left, ApiConfigHandlerLogin right) => left.Equals(right);
        public static bool operator !=(ApiConfigHandlerLogin left, ApiConfigHandlerLogin right) => !left.Equals(right);

        public static explicit operator string(ApiConfigHandlerLogin value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ApiConfigHandlerLogin other && Equals(other);
        public bool Equals(ApiConfigHandlerLogin other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Security (HTTPS) enforcement for this URL.
    /// </summary>
    [EnumType]
    public readonly struct ApiConfigHandlerSecurityLevel : IEquatable<ApiConfigHandlerSecurityLevel>
    {
        private readonly string _value;

        private ApiConfigHandlerSecurityLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not specified.
        /// </summary>
        public static ApiConfigHandlerSecurityLevel SecureUnspecified { get; } = new ApiConfigHandlerSecurityLevel("SECURE_UNSPECIFIED");
        /// <summary>
        /// Both HTTP and HTTPS requests with URLs that match the handler succeed without redirects. The application can examine the request to determine which protocol was used, and respond accordingly.
        /// </summary>
        public static ApiConfigHandlerSecurityLevel SecureDefault { get; } = new ApiConfigHandlerSecurityLevel("SECURE_DEFAULT");
        /// <summary>
        /// Requests for a URL that match this handler that use HTTPS are automatically redirected to the HTTP equivalent URL.
        /// </summary>
        public static ApiConfigHandlerSecurityLevel SecureNever { get; } = new ApiConfigHandlerSecurityLevel("SECURE_NEVER");
        /// <summary>
        /// Both HTTP and HTTPS requests with URLs that match the handler succeed without redirects. The application can examine the request to determine which protocol was used and respond accordingly.
        /// </summary>
        public static ApiConfigHandlerSecurityLevel SecureOptional { get; } = new ApiConfigHandlerSecurityLevel("SECURE_OPTIONAL");
        /// <summary>
        /// Requests for a URL that match this handler that do not use HTTPS are automatically redirected to the HTTPS URL with the same path. Query parameters are reserved for the redirect.
        /// </summary>
        public static ApiConfigHandlerSecurityLevel SecureAlways { get; } = new ApiConfigHandlerSecurityLevel("SECURE_ALWAYS");

        public static bool operator ==(ApiConfigHandlerSecurityLevel left, ApiConfigHandlerSecurityLevel right) => left.Equals(right);
        public static bool operator !=(ApiConfigHandlerSecurityLevel left, ApiConfigHandlerSecurityLevel right) => !left.Equals(right);

        public static explicit operator string(ApiConfigHandlerSecurityLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ApiConfigHandlerSecurityLevel other && Equals(other);
        public bool Equals(ApiConfigHandlerSecurityLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the Cloud Firestore or Cloud Datastore database associated with this application.
    /// </summary>
    [EnumType]
    public readonly struct AppDatabaseType : IEquatable<AppDatabaseType>
    {
        private readonly string _value;

        private AppDatabaseType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Database type is unspecified.
        /// </summary>
        public static AppDatabaseType DatabaseTypeUnspecified { get; } = new AppDatabaseType("DATABASE_TYPE_UNSPECIFIED");
        /// <summary>
        /// Cloud Datastore
        /// </summary>
        public static AppDatabaseType CloudDatastore { get; } = new AppDatabaseType("CLOUD_DATASTORE");
        /// <summary>
        /// Cloud Firestore Native
        /// </summary>
        public static AppDatabaseType CloudFirestore { get; } = new AppDatabaseType("CLOUD_FIRESTORE");
        /// <summary>
        /// Cloud Firestore in Datastore Mode
        /// </summary>
        public static AppDatabaseType CloudDatastoreCompatibility { get; } = new AppDatabaseType("CLOUD_DATASTORE_COMPATIBILITY");

        public static bool operator ==(AppDatabaseType left, AppDatabaseType right) => left.Equals(right);
        public static bool operator !=(AppDatabaseType left, AppDatabaseType right) => !left.Equals(right);

        public static explicit operator string(AppDatabaseType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AppDatabaseType other && Equals(other);
        public bool Equals(AppDatabaseType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Serving status of this application.
    /// </summary>
    [EnumType]
    public readonly struct AppServingStatus : IEquatable<AppServingStatus>
    {
        private readonly string _value;

        private AppServingStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Serving status is unspecified.
        /// </summary>
        public static AppServingStatus Unspecified { get; } = new AppServingStatus("UNSPECIFIED");
        /// <summary>
        /// Application is serving.
        /// </summary>
        public static AppServingStatus Serving { get; } = new AppServingStatus("SERVING");
        /// <summary>
        /// Application has been disabled by the user.
        /// </summary>
        public static AppServingStatus UserDisabled { get; } = new AppServingStatus("USER_DISABLED");
        /// <summary>
        /// Application has been disabled by the system.
        /// </summary>
        public static AppServingStatus SystemDisabled { get; } = new AppServingStatus("SYSTEM_DISABLED");

        public static bool operator ==(AppServingStatus left, AppServingStatus right) => left.Equals(right);
        public static bool operator !=(AppServingStatus left, AppServingStatus right) => !left.Equals(right);

        public static explicit operator string(AppServingStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AppServingStatus other && Equals(other);
        public bool Equals(AppServingStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Endpoints rollout strategy. If FIXED, config_id must be specified. If MANAGED, config_id must be omitted.
    /// </summary>
    [EnumType]
    public readonly struct EndpointsApiServiceRolloutStrategy : IEquatable<EndpointsApiServiceRolloutStrategy>
    {
        private readonly string _value;

        private EndpointsApiServiceRolloutStrategy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not specified. Defaults to FIXED.
        /// </summary>
        public static EndpointsApiServiceRolloutStrategy UnspecifiedRolloutStrategy { get; } = new EndpointsApiServiceRolloutStrategy("UNSPECIFIED_ROLLOUT_STRATEGY");
        /// <summary>
        /// Endpoints service configuration ID will be fixed to the configuration ID specified by config_id.
        /// </summary>
        public static EndpointsApiServiceRolloutStrategy Fixed { get; } = new EndpointsApiServiceRolloutStrategy("FIXED");
        /// <summary>
        /// Endpoints service configuration ID will be updated with each rollout.
        /// </summary>
        public static EndpointsApiServiceRolloutStrategy Managed { get; } = new EndpointsApiServiceRolloutStrategy("MANAGED");

        public static bool operator ==(EndpointsApiServiceRolloutStrategy left, EndpointsApiServiceRolloutStrategy right) => left.Equals(right);
        public static bool operator !=(EndpointsApiServiceRolloutStrategy left, EndpointsApiServiceRolloutStrategy right) => !left.Equals(right);

        public static explicit operator string(EndpointsApiServiceRolloutStrategy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EndpointsApiServiceRolloutStrategy other && Equals(other);
        public bool Equals(EndpointsApiServiceRolloutStrategy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Error condition this handler applies to.
    /// </summary>
    [EnumType]
    public readonly struct ErrorHandlerErrorCode : IEquatable<ErrorHandlerErrorCode>
    {
        private readonly string _value;

        private ErrorHandlerErrorCode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not specified. ERROR_CODE_DEFAULT is assumed.
        /// </summary>
        public static ErrorHandlerErrorCode ErrorCodeUnspecified { get; } = new ErrorHandlerErrorCode("ERROR_CODE_UNSPECIFIED");
        /// <summary>
        /// All other error types.
        /// </summary>
        public static ErrorHandlerErrorCode ErrorCodeDefault { get; } = new ErrorHandlerErrorCode("ERROR_CODE_DEFAULT");
        /// <summary>
        /// Application has exceeded a resource quota.
        /// </summary>
        public static ErrorHandlerErrorCode ErrorCodeOverQuota { get; } = new ErrorHandlerErrorCode("ERROR_CODE_OVER_QUOTA");
        /// <summary>
        /// Client blocked by the application's Denial of Service protection configuration.
        /// </summary>
        public static ErrorHandlerErrorCode ErrorCodeDosApiDenial { get; } = new ErrorHandlerErrorCode("ERROR_CODE_DOS_API_DENIAL");
        /// <summary>
        /// Deadline reached before the application responds.
        /// </summary>
        public static ErrorHandlerErrorCode ErrorCodeTimeout { get; } = new ErrorHandlerErrorCode("ERROR_CODE_TIMEOUT");

        public static bool operator ==(ErrorHandlerErrorCode left, ErrorHandlerErrorCode right) => left.Equals(right);
        public static bool operator !=(ErrorHandlerErrorCode left, ErrorHandlerErrorCode right) => !left.Equals(right);

        public static explicit operator string(ErrorHandlerErrorCode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ErrorHandlerErrorCode other && Equals(other);
        public bool Equals(ErrorHandlerErrorCode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The action to take on matched requests.
    /// </summary>
    [EnumType]
    public readonly struct IngressRuleAction : IEquatable<IngressRuleAction>
    {
        private readonly string _value;

        private IngressRuleAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IngressRuleAction UnspecifiedAction { get; } = new IngressRuleAction("UNSPECIFIED_ACTION");
        /// <summary>
        /// Matching requests are allowed.
        /// </summary>
        public static IngressRuleAction Allow { get; } = new IngressRuleAction("ALLOW");
        /// <summary>
        /// Matching requests are denied.
        /// </summary>
        public static IngressRuleAction Deny { get; } = new IngressRuleAction("DENY");

        public static bool operator ==(IngressRuleAction left, IngressRuleAction right) => left.Equals(right);
        public static bool operator !=(IngressRuleAction left, IngressRuleAction right) => !left.Equals(right);

        public static explicit operator string(IngressRuleAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IngressRuleAction other && Equals(other);
        public bool Equals(IngressRuleAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// SSL management type for this domain. If AUTOMATIC, a managed certificate is automatically provisioned. If MANUAL, certificate_id must be manually specified in order to configure SSL for this domain.
    /// </summary>
    [EnumType]
    public readonly struct SslSettingsSslManagementType : IEquatable<SslSettingsSslManagementType>
    {
        private readonly string _value;

        private SslSettingsSslManagementType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// SSL support for this domain is configured automatically. The mapped SSL certificate will be automatically renewed.
        /// </summary>
        public static SslSettingsSslManagementType Automatic { get; } = new SslSettingsSslManagementType("AUTOMATIC");
        /// <summary>
        /// SSL support for this domain is configured manually by the user. Either the domain has no SSL support or a user-obtained SSL certificate has been explictly mapped to this domain.
        /// </summary>
        public static SslSettingsSslManagementType Manual { get; } = new SslSettingsSslManagementType("MANUAL");

        public static bool operator ==(SslSettingsSslManagementType left, SslSettingsSslManagementType right) => left.Equals(right);
        public static bool operator !=(SslSettingsSslManagementType left, SslSettingsSslManagementType right) => !left.Equals(right);

        public static explicit operator string(SslSettingsSslManagementType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SslSettingsSslManagementType other && Equals(other);
        public bool Equals(SslSettingsSslManagementType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Action to take when users access resources that require authentication. Defaults to redirect.
    /// </summary>
    [EnumType]
    public readonly struct UrlMapAuthFailAction : IEquatable<UrlMapAuthFailAction>
    {
        private readonly string _value;

        private UrlMapAuthFailAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not specified. AUTH_FAIL_ACTION_REDIRECT is assumed.
        /// </summary>
        public static UrlMapAuthFailAction AuthFailActionUnspecified { get; } = new UrlMapAuthFailAction("AUTH_FAIL_ACTION_UNSPECIFIED");
        /// <summary>
        /// Redirects user to "accounts.google.com". The user is redirected back to the application URL after signing in or creating an account.
        /// </summary>
        public static UrlMapAuthFailAction AuthFailActionRedirect { get; } = new UrlMapAuthFailAction("AUTH_FAIL_ACTION_REDIRECT");
        /// <summary>
        /// Rejects request with a 401 HTTP status code and an error message.
        /// </summary>
        public static UrlMapAuthFailAction AuthFailActionUnauthorized { get; } = new UrlMapAuthFailAction("AUTH_FAIL_ACTION_UNAUTHORIZED");

        public static bool operator ==(UrlMapAuthFailAction left, UrlMapAuthFailAction right) => left.Equals(right);
        public static bool operator !=(UrlMapAuthFailAction left, UrlMapAuthFailAction right) => !left.Equals(right);

        public static explicit operator string(UrlMapAuthFailAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UrlMapAuthFailAction other && Equals(other);
        public bool Equals(UrlMapAuthFailAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Level of login required to access this resource. Not supported for Node.js in the App Engine standard environment.
    /// </summary>
    [EnumType]
    public readonly struct UrlMapLogin : IEquatable<UrlMapLogin>
    {
        private readonly string _value;

        private UrlMapLogin(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not specified. LOGIN_OPTIONAL is assumed.
        /// </summary>
        public static UrlMapLogin LoginUnspecified { get; } = new UrlMapLogin("LOGIN_UNSPECIFIED");
        /// <summary>
        /// Does not require that the user is signed in.
        /// </summary>
        public static UrlMapLogin LoginOptional { get; } = new UrlMapLogin("LOGIN_OPTIONAL");
        /// <summary>
        /// If the user is not signed in, the auth_fail_action is taken. In addition, if the user is not an administrator for the application, they are given an error message regardless of auth_fail_action. If the user is an administrator, the handler proceeds.
        /// </summary>
        public static UrlMapLogin LoginAdmin { get; } = new UrlMapLogin("LOGIN_ADMIN");
        /// <summary>
        /// If the user has signed in, the handler proceeds normally. Otherwise, the auth_fail_action is taken.
        /// </summary>
        public static UrlMapLogin LoginRequired { get; } = new UrlMapLogin("LOGIN_REQUIRED");

        public static bool operator ==(UrlMapLogin left, UrlMapLogin right) => left.Equals(right);
        public static bool operator !=(UrlMapLogin left, UrlMapLogin right) => !left.Equals(right);

        public static explicit operator string(UrlMapLogin value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UrlMapLogin other && Equals(other);
        public bool Equals(UrlMapLogin other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// 30x code to use when performing redirects for the secure field. Defaults to 302.
    /// </summary>
    [EnumType]
    public readonly struct UrlMapRedirectHttpResponseCode : IEquatable<UrlMapRedirectHttpResponseCode>
    {
        private readonly string _value;

        private UrlMapRedirectHttpResponseCode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not specified. 302 is assumed.
        /// </summary>
        public static UrlMapRedirectHttpResponseCode RedirectHttpResponseCodeUnspecified { get; } = new UrlMapRedirectHttpResponseCode("REDIRECT_HTTP_RESPONSE_CODE_UNSPECIFIED");
        /// <summary>
        /// 301 Moved Permanently code.
        /// </summary>
        public static UrlMapRedirectHttpResponseCode RedirectHttpResponseCode301 { get; } = new UrlMapRedirectHttpResponseCode("REDIRECT_HTTP_RESPONSE_CODE_301");
        /// <summary>
        /// 302 Moved Temporarily code.
        /// </summary>
        public static UrlMapRedirectHttpResponseCode RedirectHttpResponseCode302 { get; } = new UrlMapRedirectHttpResponseCode("REDIRECT_HTTP_RESPONSE_CODE_302");
        /// <summary>
        /// 303 See Other code.
        /// </summary>
        public static UrlMapRedirectHttpResponseCode RedirectHttpResponseCode303 { get; } = new UrlMapRedirectHttpResponseCode("REDIRECT_HTTP_RESPONSE_CODE_303");
        /// <summary>
        /// 307 Temporary Redirect code.
        /// </summary>
        public static UrlMapRedirectHttpResponseCode RedirectHttpResponseCode307 { get; } = new UrlMapRedirectHttpResponseCode("REDIRECT_HTTP_RESPONSE_CODE_307");

        public static bool operator ==(UrlMapRedirectHttpResponseCode left, UrlMapRedirectHttpResponseCode right) => left.Equals(right);
        public static bool operator !=(UrlMapRedirectHttpResponseCode left, UrlMapRedirectHttpResponseCode right) => !left.Equals(right);

        public static explicit operator string(UrlMapRedirectHttpResponseCode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UrlMapRedirectHttpResponseCode other && Equals(other);
        public bool Equals(UrlMapRedirectHttpResponseCode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Security (HTTPS) enforcement for this URL.
    /// </summary>
    [EnumType]
    public readonly struct UrlMapSecurityLevel : IEquatable<UrlMapSecurityLevel>
    {
        private readonly string _value;

        private UrlMapSecurityLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not specified.
        /// </summary>
        public static UrlMapSecurityLevel SecureUnspecified { get; } = new UrlMapSecurityLevel("SECURE_UNSPECIFIED");
        /// <summary>
        /// Both HTTP and HTTPS requests with URLs that match the handler succeed without redirects. The application can examine the request to determine which protocol was used, and respond accordingly.
        /// </summary>
        public static UrlMapSecurityLevel SecureDefault { get; } = new UrlMapSecurityLevel("SECURE_DEFAULT");
        /// <summary>
        /// Requests for a URL that match this handler that use HTTPS are automatically redirected to the HTTP equivalent URL.
        /// </summary>
        public static UrlMapSecurityLevel SecureNever { get; } = new UrlMapSecurityLevel("SECURE_NEVER");
        /// <summary>
        /// Both HTTP and HTTPS requests with URLs that match the handler succeed without redirects. The application can examine the request to determine which protocol was used and respond accordingly.
        /// </summary>
        public static UrlMapSecurityLevel SecureOptional { get; } = new UrlMapSecurityLevel("SECURE_OPTIONAL");
        /// <summary>
        /// Requests for a URL that match this handler that do not use HTTPS are automatically redirected to the HTTPS URL with the same path. Query parameters are reserved for the redirect.
        /// </summary>
        public static UrlMapSecurityLevel SecureAlways { get; } = new UrlMapSecurityLevel("SECURE_ALWAYS");

        public static bool operator ==(UrlMapSecurityLevel left, UrlMapSecurityLevel right) => left.Equals(right);
        public static bool operator !=(UrlMapSecurityLevel left, UrlMapSecurityLevel right) => !left.Equals(right);

        public static explicit operator string(UrlMapSecurityLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UrlMapSecurityLevel other && Equals(other);
        public bool Equals(UrlMapSecurityLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct VersionInboundServicesItem : IEquatable<VersionInboundServicesItem>
    {
        private readonly string _value;

        private VersionInboundServicesItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not specified.
        /// </summary>
        public static VersionInboundServicesItem InboundServiceUnspecified { get; } = new VersionInboundServicesItem("INBOUND_SERVICE_UNSPECIFIED");
        /// <summary>
        /// Allows an application to receive mail.
        /// </summary>
        public static VersionInboundServicesItem InboundServiceMail { get; } = new VersionInboundServicesItem("INBOUND_SERVICE_MAIL");
        /// <summary>
        /// Allows an application to receive email-bound notifications.
        /// </summary>
        public static VersionInboundServicesItem InboundServiceMailBounce { get; } = new VersionInboundServicesItem("INBOUND_SERVICE_MAIL_BOUNCE");
        /// <summary>
        /// Allows an application to receive error stanzas.
        /// </summary>
        public static VersionInboundServicesItem InboundServiceXmppError { get; } = new VersionInboundServicesItem("INBOUND_SERVICE_XMPP_ERROR");
        /// <summary>
        /// Allows an application to receive instant messages.
        /// </summary>
        public static VersionInboundServicesItem InboundServiceXmppMessage { get; } = new VersionInboundServicesItem("INBOUND_SERVICE_XMPP_MESSAGE");
        /// <summary>
        /// Allows an application to receive user subscription POSTs.
        /// </summary>
        public static VersionInboundServicesItem InboundServiceXmppSubscribe { get; } = new VersionInboundServicesItem("INBOUND_SERVICE_XMPP_SUBSCRIBE");
        /// <summary>
        /// Allows an application to receive a user's chat presence.
        /// </summary>
        public static VersionInboundServicesItem InboundServiceXmppPresence { get; } = new VersionInboundServicesItem("INBOUND_SERVICE_XMPP_PRESENCE");
        /// <summary>
        /// Registers an application for notifications when a client connects or disconnects from a channel.
        /// </summary>
        public static VersionInboundServicesItem InboundServiceChannelPresence { get; } = new VersionInboundServicesItem("INBOUND_SERVICE_CHANNEL_PRESENCE");
        /// <summary>
        /// Enables warmup requests.
        /// </summary>
        public static VersionInboundServicesItem InboundServiceWarmup { get; } = new VersionInboundServicesItem("INBOUND_SERVICE_WARMUP");

        public static bool operator ==(VersionInboundServicesItem left, VersionInboundServicesItem right) => left.Equals(right);
        public static bool operator !=(VersionInboundServicesItem left, VersionInboundServicesItem right) => !left.Equals(right);

        public static explicit operator string(VersionInboundServicesItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VersionInboundServicesItem other && Equals(other);
        public bool Equals(VersionInboundServicesItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Current serving status of this version. Only the versions with a SERVING status create instances and can be billed.SERVING_STATUS_UNSPECIFIED is an invalid value. Defaults to SERVING.
    /// </summary>
    [EnumType]
    public readonly struct VersionServingStatus : IEquatable<VersionServingStatus>
    {
        private readonly string _value;

        private VersionServingStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not specified.
        /// </summary>
        public static VersionServingStatus ServingStatusUnspecified { get; } = new VersionServingStatus("SERVING_STATUS_UNSPECIFIED");
        /// <summary>
        /// Currently serving. Instances are created according to the scaling settings of the version.
        /// </summary>
        public static VersionServingStatus Serving { get; } = new VersionServingStatus("SERVING");
        /// <summary>
        /// Disabled. No instances will be created and the scaling settings are ignored until the state of the version changes to SERVING.
        /// </summary>
        public static VersionServingStatus Stopped { get; } = new VersionServingStatus("STOPPED");

        public static bool operator ==(VersionServingStatus left, VersionServingStatus right) => left.Equals(right);
        public static bool operator !=(VersionServingStatus left, VersionServingStatus right) => !left.Equals(right);

        public static explicit operator string(VersionServingStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VersionServingStatus other && Equals(other);
        public bool Equals(VersionServingStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The egress setting for the connector, controlling what traffic is diverted through it.
    /// </summary>
    [EnumType]
    public readonly struct VpcAccessConnectorEgressSetting : IEquatable<VpcAccessConnectorEgressSetting>
    {
        private readonly string _value;

        private VpcAccessConnectorEgressSetting(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VpcAccessConnectorEgressSetting EgressSettingUnspecified { get; } = new VpcAccessConnectorEgressSetting("EGRESS_SETTING_UNSPECIFIED");
        /// <summary>
        /// Force the use of VPC Access for all egress traffic from the function.
        /// </summary>
        public static VpcAccessConnectorEgressSetting AllTraffic { get; } = new VpcAccessConnectorEgressSetting("ALL_TRAFFIC");
        /// <summary>
        /// Use the VPC Access Connector for private IP space from RFC1918.
        /// </summary>
        public static VpcAccessConnectorEgressSetting PrivateIpRanges { get; } = new VpcAccessConnectorEgressSetting("PRIVATE_IP_RANGES");

        public static bool operator ==(VpcAccessConnectorEgressSetting left, VpcAccessConnectorEgressSetting right) => left.Equals(right);
        public static bool operator !=(VpcAccessConnectorEgressSetting left, VpcAccessConnectorEgressSetting right) => !left.Equals(right);

        public static explicit operator string(VpcAccessConnectorEgressSetting value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VpcAccessConnectorEgressSetting other && Equals(other);
        public bool Equals(VpcAccessConnectorEgressSetting other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
