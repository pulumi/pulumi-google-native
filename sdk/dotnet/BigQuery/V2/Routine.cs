// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.GcpNative.BigQuery.V2
{
    /// <summary>
    /// Creates a new routine in the dataset.
    /// </summary>
    [GcpNativeResourceType("google-native:bigquery/v2:Routine")]
    public partial class Routine : Pulumi.CustomResource
    {
        /// <summary>
        /// Optional.
        /// </summary>
        [Output("arguments")]
        public Output<ImmutableArray<Outputs.ArgumentResponse>> Arguments { get; private set; } = null!;

        /// <summary>
        /// The time when this routine was created, in milliseconds since the epoch.
        /// </summary>
        [Output("creationTime")]
        public Output<string> CreationTime { get; private set; } = null!;

        /// <summary>
        /// Required. The body of the routine. For functions, this is the expression in the AS clause. If language=SQL, it is the substring inside (but excluding) the parentheses. For example, for the function created with the following statement: `CREATE FUNCTION JoinLines(x string, y string) as (concat(x, "\n", y))` The definition_body is `concat(x, "\n", y)` (\n is not replaced with linebreak). If language=JAVASCRIPT, it is the evaluated string in the AS clause. For example, for the function created with the following statement: `CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS 'return "\n";\n'` The definition_body is `return "\n";\n` Note that both \n are replaced with linebreaks.
        /// </summary>
        [Output("definitionBody")]
        public Output<string> DefinitionBody { get; private set; } = null!;

        /// <summary>
        /// Optional. [Experimental] The description of the routine if defined.
        /// </summary>
        [Output("description")]
        public Output<string> Description { get; private set; } = null!;

        /// <summary>
        /// Optional. [Experimental] The determinism level of the JavaScript UDF if defined.
        /// </summary>
        [Output("determinismLevel")]
        public Output<string> DeterminismLevel { get; private set; } = null!;

        /// <summary>
        /// A hash of this resource.
        /// </summary>
        [Output("etag")]
        public Output<string> Etag { get; private set; } = null!;

        /// <summary>
        /// Optional. If language = "JAVASCRIPT", this field stores the path of the imported JAVASCRIPT libraries.
        /// </summary>
        [Output("importedLibraries")]
        public Output<ImmutableArray<string>> ImportedLibraries { get; private set; } = null!;

        /// <summary>
        /// Optional. Defaults to "SQL".
        /// </summary>
        [Output("language")]
        public Output<string> Language { get; private set; } = null!;

        /// <summary>
        /// The time when this routine was last modified, in milliseconds since the epoch.
        /// </summary>
        [Output("lastModifiedTime")]
        public Output<string> LastModifiedTime { get; private set; } = null!;

        /// <summary>
        /// Optional. Set only if Routine is a "TABLE_VALUED_FUNCTION".
        /// </summary>
        [Output("returnTableType")]
        public Output<Outputs.StandardSqlTableTypeResponse> ReturnTableType { get; private set; } = null!;

        /// <summary>
        /// Optional if language = "SQL"; required otherwise. If absent, the return type is inferred from definition_body at query time in each query that references this routine. If present, then the evaluated result will be cast to the specified returned type at query time. For example, for the functions created with the following statements: * `CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);` * `CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));` * `CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));` The return_type is `{type_kind: "FLOAT64"}` for `Add` and `Decrement`, and is absent for `Increment` (inferred as FLOAT64 at query time). Suppose the function `Add` is replaced by `CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);` Then the inferred return type of `Increment` is automatically changed to INT64 at query time, while the return type of `Decrement` remains FLOAT64.
        /// </summary>
        [Output("returnType")]
        public Output<Outputs.StandardSqlDataTypeResponse> ReturnType { get; private set; } = null!;

        /// <summary>
        /// Required. Reference describing the ID of this routine.
        /// </summary>
        [Output("routineReference")]
        public Output<Outputs.RoutineReferenceResponse> RoutineReference { get; private set; } = null!;

        /// <summary>
        /// Required. The type of routine.
        /// </summary>
        [Output("routineType")]
        public Output<string> RoutineType { get; private set; } = null!;


        /// <summary>
        /// Create a Routine resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Routine(string name, RoutineArgs args, CustomResourceOptions? options = null)
            : base("google-native:bigquery/v2:Routine", name, args ?? new RoutineArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Routine(string name, Input<string> id, CustomResourceOptions? options = null)
            : base("google-native:bigquery/v2:Routine", name, null, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Routine resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Routine Get(string name, Input<string> id, CustomResourceOptions? options = null)
        {
            return new Routine(name, id, options);
        }
    }

    public sealed class RoutineArgs : Pulumi.ResourceArgs
    {
        [Input("arguments")]
        private InputList<Inputs.ArgumentArgs>? _arguments;

        /// <summary>
        /// Optional.
        /// </summary>
        public InputList<Inputs.ArgumentArgs> Arguments
        {
            get => _arguments ?? (_arguments = new InputList<Inputs.ArgumentArgs>());
            set => _arguments = value;
        }

        [Input("datasetsId", required: true)]
        public Input<string> DatasetsId { get; set; } = null!;

        /// <summary>
        /// Required. The body of the routine. For functions, this is the expression in the AS clause. If language=SQL, it is the substring inside (but excluding) the parentheses. For example, for the function created with the following statement: `CREATE FUNCTION JoinLines(x string, y string) as (concat(x, "\n", y))` The definition_body is `concat(x, "\n", y)` (\n is not replaced with linebreak). If language=JAVASCRIPT, it is the evaluated string in the AS clause. For example, for the function created with the following statement: `CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS 'return "\n";\n'` The definition_body is `return "\n";\n` Note that both \n are replaced with linebreaks.
        /// </summary>
        [Input("definitionBody")]
        public Input<string>? DefinitionBody { get; set; }

        /// <summary>
        /// Optional. [Experimental] The description of the routine if defined.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// Optional. [Experimental] The determinism level of the JavaScript UDF if defined.
        /// </summary>
        [Input("determinismLevel")]
        public Input<string>? DeterminismLevel { get; set; }

        [Input("importedLibraries")]
        private InputList<string>? _importedLibraries;

        /// <summary>
        /// Optional. If language = "JAVASCRIPT", this field stores the path of the imported JAVASCRIPT libraries.
        /// </summary>
        public InputList<string> ImportedLibraries
        {
            get => _importedLibraries ?? (_importedLibraries = new InputList<string>());
            set => _importedLibraries = value;
        }

        /// <summary>
        /// Optional. Defaults to "SQL".
        /// </summary>
        [Input("language")]
        public Input<string>? Language { get; set; }

        [Input("projectsId", required: true)]
        public Input<string> ProjectsId { get; set; } = null!;

        /// <summary>
        /// Optional. Set only if Routine is a "TABLE_VALUED_FUNCTION".
        /// </summary>
        [Input("returnTableType")]
        public Input<Inputs.StandardSqlTableTypeArgs>? ReturnTableType { get; set; }

        /// <summary>
        /// Optional if language = "SQL"; required otherwise. If absent, the return type is inferred from definition_body at query time in each query that references this routine. If present, then the evaluated result will be cast to the specified returned type at query time. For example, for the functions created with the following statements: * `CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);` * `CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));` * `CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));` The return_type is `{type_kind: "FLOAT64"}` for `Add` and `Decrement`, and is absent for `Increment` (inferred as FLOAT64 at query time). Suppose the function `Add` is replaced by `CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);` Then the inferred return type of `Increment` is automatically changed to INT64 at query time, while the return type of `Decrement` remains FLOAT64.
        /// </summary>
        [Input("returnType")]
        public Input<Inputs.StandardSqlDataTypeArgs>? ReturnType { get; set; }

        /// <summary>
        /// Required. Reference describing the ID of this routine.
        /// </summary>
        [Input("routineReference")]
        public Input<Inputs.RoutineReferenceArgs>? RoutineReference { get; set; }

        /// <summary>
        /// Required. The type of routine.
        /// </summary>
        [Input("routineType")]
        public Input<string>? RoutineType { get; set; }

        [Input("routinesId", required: true)]
        public Input<string> RoutinesId { get; set; } = null!;

        public RoutineArgs()
        {
        }
    }
}
