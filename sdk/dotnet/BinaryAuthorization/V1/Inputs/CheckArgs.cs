// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.GoogleNative.BinaryAuthorization.V1.Inputs
{

    /// <summary>
    /// A single check to perform against a Pod. Checks are grouped into `CheckSet` objects, which are defined by the top-level policy.
    /// </summary>
    public sealed class CheckArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Optional. A special-case check that always denies. Note that this still only applies when the scope of the `CheckSet` applies and the image isn't exempted by an image allowlist. This check is primarily useful for testing, or to set the default behavior for all unmatched scopes to "deny".
        /// </summary>
        [Input("alwaysDeny")]
        public Input<bool>? AlwaysDeny { get; set; }

        /// <summary>
        /// Optional. A user-provided name for this check. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
        /// </summary>
        [Input("displayName")]
        public Input<string>? DisplayName { get; set; }

        /// <summary>
        /// Optional. Images exempted from this check. If any of the patterns match the image url, the check will not be evaluated.
        /// </summary>
        [Input("imageAllowlist")]
        public Input<Inputs.ImageAllowlistArgs>? ImageAllowlist { get; set; }

        /// <summary>
        /// Optional. Require that an image is no older than a configured expiration time. Image age is determined by its upload time.
        /// </summary>
        [Input("imageFreshnessCheck")]
        public Input<Inputs.ImageFreshnessCheckArgs>? ImageFreshnessCheck { get; set; }

        /// <summary>
        /// Optional. Require that an image was signed by Cosign with a trusted key. This check requires that both the image and signature are stored in Artifact Registry.
        /// </summary>
        [Input("sigstoreSignatureCheck")]
        public Input<Inputs.SigstoreSignatureCheckArgs>? SigstoreSignatureCheck { get; set; }

        /// <summary>
        /// Optional. Require a SimpleSigning-type attestation for every image in the deployment.
        /// </summary>
        [Input("simpleSigningAttestationCheck")]
        public Input<Inputs.SimpleSigningAttestationCheckArgs>? SimpleSigningAttestationCheck { get; set; }

        /// <summary>
        /// Optional. Require that an image was built by a trusted builder (such as Google Cloud Build), meets requirements for Supply chain Levels for Software Artifacts (SLSA), and was built from a trusted source code repostitory.
        /// </summary>
        [Input("slsaCheck")]
        public Input<Inputs.SlsaCheckArgs>? SlsaCheck { get; set; }

        /// <summary>
        /// Optional. Require that an image lives in a trusted directory.
        /// </summary>
        [Input("trustedDirectoryCheck")]
        public Input<Inputs.TrustedDirectoryCheckArgs>? TrustedDirectoryCheck { get; set; }

        /// <summary>
        /// Optional. Require that an image does not contain vulnerabilities that violate the configured rules, such as based on severity levels.
        /// </summary>
        [Input("vulnerabilityCheck")]
        public Input<Inputs.VulnerabilityCheckArgs>? VulnerabilityCheck { get; set; }

        public CheckArgs()
        {
        }
        public static new CheckArgs Empty => new CheckArgs();
    }
}
