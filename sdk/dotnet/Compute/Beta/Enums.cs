// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.Compute.Beta
{
    /// <summary>
    /// This signifies the networking tier used for configuring this access configuration and can only take the following values: PREMIUM, STANDARD. If an AccessConfig is specified without a valid external IP address, an ephemeral IP will be created with this networkTier. If an AccessConfig with a valid external IP address is specified, it must match that of the networkTier associated with the Address resource owning that IP.
    /// </summary>
    [EnumType]
    public readonly struct AccessConfigNetworkTier : IEquatable<AccessConfigNetworkTier>
    {
        private readonly string _value;

        private AccessConfigNetworkTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Public internet quality with fixed bandwidth.
        /// </summary>
        public static AccessConfigNetworkTier FixedStandard { get; } = new AccessConfigNetworkTier("FIXED_STANDARD");
        /// <summary>
        /// High quality, Google-grade network tier, support for all networking products.
        /// </summary>
        public static AccessConfigNetworkTier Premium { get; } = new AccessConfigNetworkTier("PREMIUM");
        /// <summary>
        /// Public internet quality, only limited support for other networking products.
        /// </summary>
        public static AccessConfigNetworkTier Standard { get; } = new AccessConfigNetworkTier("STANDARD");
        /// <summary>
        /// (Output only) Temporary tier for FIXED_STANDARD when fixed standard tier is expired or not configured.
        /// </summary>
        public static AccessConfigNetworkTier StandardOverridesFixedStandard { get; } = new AccessConfigNetworkTier("STANDARD_OVERRIDES_FIXED_STANDARD");

        public static bool operator ==(AccessConfigNetworkTier left, AccessConfigNetworkTier right) => left.Equals(right);
        public static bool operator !=(AccessConfigNetworkTier left, AccessConfigNetworkTier right) => !left.Equals(right);

        public static explicit operator string(AccessConfigNetworkTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AccessConfigNetworkTier other && Equals(other);
        public bool Equals(AccessConfigNetworkTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of configuration. The default and only option is ONE_TO_ONE_NAT.
    /// </summary>
    [EnumType]
    public readonly struct AccessConfigType : IEquatable<AccessConfigType>
    {
        private readonly string _value;

        private AccessConfigType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AccessConfigType DirectIpv6 { get; } = new AccessConfigType("DIRECT_IPV6");
        public static AccessConfigType OneToOneNat { get; } = new AccessConfigType("ONE_TO_ONE_NAT");

        public static bool operator ==(AccessConfigType left, AccessConfigType right) => left.Equals(right);
        public static bool operator !=(AccessConfigType left, AccessConfigType right) => !left.Equals(right);

        public static explicit operator string(AccessConfigType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AccessConfigType other && Equals(other);
        public bool Equals(AccessConfigType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of address to reserve, either INTERNAL or EXTERNAL. If unspecified, defaults to EXTERNAL.
    /// </summary>
    [EnumType]
    public readonly struct AddressAddressType : IEquatable<AddressAddressType>
    {
        private readonly string _value;

        private AddressAddressType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// A publicly visible external IP address.
        /// </summary>
        public static AddressAddressType External { get; } = new AddressAddressType("EXTERNAL");
        /// <summary>
        /// A private network IP address, for use with an Instance or Internal Load Balancer forwarding rule.
        /// </summary>
        public static AddressAddressType Internal { get; } = new AddressAddressType("INTERNAL");
        public static AddressAddressType UnspecifiedType { get; } = new AddressAddressType("UNSPECIFIED_TYPE");

        public static bool operator ==(AddressAddressType left, AddressAddressType right) => left.Equals(right);
        public static bool operator !=(AddressAddressType left, AddressAddressType right) => !left.Equals(right);

        public static explicit operator string(AddressAddressType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AddressAddressType other && Equals(other);
        public bool Equals(AddressAddressType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The IP version that will be used by this address. Valid options are IPV4 or IPV6. This can only be specified for a global address.
    /// </summary>
    [EnumType]
    public readonly struct AddressIpVersion : IEquatable<AddressIpVersion>
    {
        private readonly string _value;

        private AddressIpVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AddressIpVersion Ipv4 { get; } = new AddressIpVersion("IPV4");
        public static AddressIpVersion Ipv6 { get; } = new AddressIpVersion("IPV6");
        public static AddressIpVersion UnspecifiedVersion { get; } = new AddressIpVersion("UNSPECIFIED_VERSION");

        public static bool operator ==(AddressIpVersion left, AddressIpVersion right) => left.Equals(right);
        public static bool operator !=(AddressIpVersion left, AddressIpVersion right) => !left.Equals(right);

        public static explicit operator string(AddressIpVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AddressIpVersion other && Equals(other);
        public bool Equals(AddressIpVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This signifies the networking tier used for configuring this address and can only take the following values: PREMIUM or STANDARD. Internal IP addresses are always Premium Tier; global external IP addresses are always Premium Tier; regional external IP addresses can be either Standard or Premium Tier. If this field is not specified, it is assumed to be PREMIUM.
    /// </summary>
    [EnumType]
    public readonly struct AddressNetworkTier : IEquatable<AddressNetworkTier>
    {
        private readonly string _value;

        private AddressNetworkTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Public internet quality with fixed bandwidth.
        /// </summary>
        public static AddressNetworkTier FixedStandard { get; } = new AddressNetworkTier("FIXED_STANDARD");
        /// <summary>
        /// High quality, Google-grade network tier, support for all networking products.
        /// </summary>
        public static AddressNetworkTier Premium { get; } = new AddressNetworkTier("PREMIUM");
        /// <summary>
        /// Public internet quality, only limited support for other networking products.
        /// </summary>
        public static AddressNetworkTier Standard { get; } = new AddressNetworkTier("STANDARD");
        /// <summary>
        /// (Output only) Temporary tier for FIXED_STANDARD when fixed standard tier is expired or not configured.
        /// </summary>
        public static AddressNetworkTier StandardOverridesFixedStandard { get; } = new AddressNetworkTier("STANDARD_OVERRIDES_FIXED_STANDARD");

        public static bool operator ==(AddressNetworkTier left, AddressNetworkTier right) => left.Equals(right);
        public static bool operator !=(AddressNetworkTier left, AddressNetworkTier right) => !left.Equals(right);

        public static explicit operator string(AddressNetworkTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AddressNetworkTier other && Equals(other);
        public bool Equals(AddressNetworkTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The purpose of this resource, which can be one of the following values: - GCE_ENDPOINT for addresses that are used by VM instances, alias IP ranges, load balancers, and similar resources. - DNS_RESOLVER for a DNS resolver address in a subnetwork for a Cloud DNS inbound forwarder IP addresses (regional internal IP address in a subnet of a VPC network) - VPC_PEERING for global internal IP addresses used for private services access allocated ranges. - NAT_AUTO for the regional external IP addresses used by Cloud NAT when allocating addresses using automatic NAT IP address allocation. - IPSEC_INTERCONNECT for addresses created from a private IP range that are reserved for a VLAN attachment in an *IPsec-encrypted Cloud Interconnect* configuration. These addresses are regional resources. Not currently available publicly. - `SHARED_LOADBALANCER_VIP` for an internal IP address that is assigned to multiple internal forwarding rules. - `PRIVATE_SERVICE_CONNECT` for a private network address that is used to configure Private Service Connect. Only global internal addresses can use this purpose. 
    /// </summary>
    [EnumType]
    public readonly struct AddressPurpose : IEquatable<AddressPurpose>
    {
        private readonly string _value;

        private AddressPurpose(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// DNS resolver address in the subnetwork.
        /// </summary>
        public static AddressPurpose DnsResolver { get; } = new AddressPurpose("DNS_RESOLVER");
        /// <summary>
        /// VM internal/alias IP, Internal LB service IP, etc.
        /// </summary>
        public static AddressPurpose GceEndpoint { get; } = new AddressPurpose("GCE_ENDPOINT");
        /// <summary>
        /// A regional internal IP address range reserved for the VLAN attachment that is used in IPsec-encrypted Cloud Interconnect. This regional internal IP address range must not overlap with any IP address range of subnet/route in the VPC network and its peering networks. After the VLAN attachment is created with the reserved IP address range, when creating a new VPN gateway, its interface IP address is allocated from the associated VLAN attachmentâ€™s IP address range.
        /// </summary>
        public static AddressPurpose IpsecInterconnect { get; } = new AddressPurpose("IPSEC_INTERCONNECT");
        /// <summary>
        /// External IP automatically reserved for Cloud NAT.
        /// </summary>
        public static AddressPurpose NatAuto { get; } = new AddressPurpose("NAT_AUTO");
        /// <summary>
        /// A private network IP address that can be used to configure Private Service Connect. This purpose can be specified only for GLOBAL addresses of Type INTERNAL
        /// </summary>
        public static AddressPurpose PrivateServiceConnect { get; } = new AddressPurpose("PRIVATE_SERVICE_CONNECT");
        /// <summary>
        /// A private network IP address that can be shared by multiple Internal Load Balancer forwarding rules.
        /// </summary>
        public static AddressPurpose SharedLoadbalancerVip { get; } = new AddressPurpose("SHARED_LOADBALANCER_VIP");
        /// <summary>
        /// IP range for peer networks.
        /// </summary>
        public static AddressPurpose VpcPeering { get; } = new AddressPurpose("VPC_PEERING");

        public static bool operator ==(AddressPurpose left, AddressPurpose right) => left.Equals(right);
        public static bool operator !=(AddressPurpose left, AddressPurpose right) => !left.Equals(right);

        public static explicit operator string(AddressPurpose value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AddressPurpose other && Equals(other);
        public bool Equals(AddressPurpose other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME. The default is SCSI. For performance characteristics of SCSI over NVMe, see Local SSD performance.
    /// </summary>
    [EnumType]
    public readonly struct AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface : IEquatable<AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface>
    {
        private readonly string _value;

        private AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface Nvme { get; } = new AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface("NVME");
        public static AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface Scsi { get; } = new AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface("SCSI");

        public static bool operator ==(AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface left, AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface right) => left.Equals(right);
        public static bool operator !=(AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface left, AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface right) => !left.Equals(right);

        public static explicit operator string(AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface other && Equals(other);
        public bool Equals(AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// For more information about maintenance intervals, see Setting maintenance intervals.
    /// </summary>
    [EnumType]
    public readonly struct AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval : IEquatable<AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval>
    {
        private readonly string _value;

        private AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// VMs receive infrastructure and hypervisor updates on a periodic basis, minimizing the number of maintenance operations (live migrations or terminations) on an individual VM. This may mean a VM will take longer to receive an update than if it was configured for AS_NEEDED. Security updates will still be applied as soon as they are available.
        /// </summary>
        public static AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval Periodic { get; } = new AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval("PERIODIC");

        public static bool operator ==(AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval left, AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval right) => left.Equals(right);
        public static bool operator !=(AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval left, AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval right) => !left.Equals(right);

        public static explicit operator string(AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval other && Equals(other);
        public bool Equals(AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies which action to take on instance update with this disk. Default is to use the existing disk.
    /// </summary>
    [EnumType]
    public readonly struct AttachedDiskInitializeParamsOnUpdateAction : IEquatable<AttachedDiskInitializeParamsOnUpdateAction>
    {
        private readonly string _value;

        private AttachedDiskInitializeParamsOnUpdateAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Always recreate the disk.
        /// </summary>
        public static AttachedDiskInitializeParamsOnUpdateAction RecreateDisk { get; } = new AttachedDiskInitializeParamsOnUpdateAction("RECREATE_DISK");
        /// <summary>
        /// Recreate the disk if source (image, snapshot) of this disk is different from source of existing disk.
        /// </summary>
        public static AttachedDiskInitializeParamsOnUpdateAction RecreateDiskIfSourceChanged { get; } = new AttachedDiskInitializeParamsOnUpdateAction("RECREATE_DISK_IF_SOURCE_CHANGED");
        /// <summary>
        /// Use the existing disk, this is the default behaviour.
        /// </summary>
        public static AttachedDiskInitializeParamsOnUpdateAction UseExistingDisk { get; } = new AttachedDiskInitializeParamsOnUpdateAction("USE_EXISTING_DISK");

        public static bool operator ==(AttachedDiskInitializeParamsOnUpdateAction left, AttachedDiskInitializeParamsOnUpdateAction right) => left.Equals(right);
        public static bool operator !=(AttachedDiskInitializeParamsOnUpdateAction left, AttachedDiskInitializeParamsOnUpdateAction right) => !left.Equals(right);

        public static explicit operator string(AttachedDiskInitializeParamsOnUpdateAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AttachedDiskInitializeParamsOnUpdateAction other && Equals(other);
        public bool Equals(AttachedDiskInitializeParamsOnUpdateAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME. The default is SCSI. Persistent disks must always use SCSI and the request will fail if you attempt to attach a persistent disk in any other format than SCSI. Local SSDs can use either NVME or SCSI. For performance characteristics of SCSI over NVMe, see Local SSD performance.
    /// </summary>
    [EnumType]
    public readonly struct AttachedDiskInterface : IEquatable<AttachedDiskInterface>
    {
        private readonly string _value;

        private AttachedDiskInterface(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AttachedDiskInterface Nvme { get; } = new AttachedDiskInterface("NVME");
        public static AttachedDiskInterface Scsi { get; } = new AttachedDiskInterface("SCSI");

        public static bool operator ==(AttachedDiskInterface left, AttachedDiskInterface right) => left.Equals(right);
        public static bool operator !=(AttachedDiskInterface left, AttachedDiskInterface right) => !left.Equals(right);

        public static explicit operator string(AttachedDiskInterface value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AttachedDiskInterface other && Equals(other);
        public bool Equals(AttachedDiskInterface other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If not specified, the default is to attach the disk in READ_WRITE mode.
    /// </summary>
    [EnumType]
    public readonly struct AttachedDiskMode : IEquatable<AttachedDiskMode>
    {
        private readonly string _value;

        private AttachedDiskMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Attaches this disk in read-only mode. Multiple virtual machines can use a disk in read-only mode at a time.
        /// </summary>
        public static AttachedDiskMode ReadOnly { get; } = new AttachedDiskMode("READ_ONLY");
        /// <summary>
        /// *[Default]* Attaches this disk in read-write mode. Only one virtual machine at a time can be attached to a disk in read-write mode.
        /// </summary>
        public static AttachedDiskMode ReadWrite { get; } = new AttachedDiskMode("READ_WRITE");

        public static bool operator ==(AttachedDiskMode left, AttachedDiskMode right) => left.Equals(right);
        public static bool operator !=(AttachedDiskMode left, AttachedDiskMode right) => !left.Equals(right);

        public static explicit operator string(AttachedDiskMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AttachedDiskMode other && Equals(other);
        public bool Equals(AttachedDiskMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of the disk, either SCRATCH or PERSISTENT. If not specified, the default is PERSISTENT.
    /// </summary>
    [EnumType]
    public readonly struct AttachedDiskType : IEquatable<AttachedDiskType>
    {
        private readonly string _value;

        private AttachedDiskType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AttachedDiskType Persistent { get; } = new AttachedDiskType("PERSISTENT");
        public static AttachedDiskType Scratch { get; } = new AttachedDiskType("SCRATCH");

        public static bool operator ==(AttachedDiskType left, AttachedDiskType right) => left.Equals(right);
        public static bool operator !=(AttachedDiskType left, AttachedDiskType right) => !left.Equals(right);

        public static explicit operator string(AttachedDiskType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AttachedDiskType other && Equals(other);
        public bool Equals(AttachedDiskType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The log type that this config enables.
    /// </summary>
    [EnumType]
    public readonly struct AuditLogConfigLogType : IEquatable<AuditLogConfigLogType>
    {
        private readonly string _value;

        private AuditLogConfigLogType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Admin reads. Example: CloudIAM getIamPolicy
        /// </summary>
        public static AuditLogConfigLogType AdminRead { get; } = new AuditLogConfigLogType("ADMIN_READ");
        /// <summary>
        /// Data reads. Example: CloudSQL Users list
        /// </summary>
        public static AuditLogConfigLogType DataRead { get; } = new AuditLogConfigLogType("DATA_READ");
        /// <summary>
        /// Data writes. Example: CloudSQL Users create
        /// </summary>
        public static AuditLogConfigLogType DataWrite { get; } = new AuditLogConfigLogType("DATA_WRITE");
        /// <summary>
        /// Default case. Should never be this.
        /// </summary>
        public static AuditLogConfigLogType LogTypeUnspecified { get; } = new AuditLogConfigLogType("LOG_TYPE_UNSPECIFIED");

        public static bool operator ==(AuditLogConfigLogType left, AuditLogConfigLogType right) => left.Equals(right);
        public static bool operator !=(AuditLogConfigLogType left, AuditLogConfigLogType right) => !left.Equals(right);

        public static explicit operator string(AuditLogConfigLogType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AuditLogConfigLogType other && Equals(other);
        public bool Equals(AuditLogConfigLogType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This is deprecated and has no effect. Do not use.
    /// </summary>
    [EnumType]
    public readonly struct AuthorizationLoggingOptionsPermissionType : IEquatable<AuthorizationLoggingOptionsPermissionType>
    {
        private readonly string _value;

        private AuthorizationLoggingOptionsPermissionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static AuthorizationLoggingOptionsPermissionType AdminRead { get; } = new AuthorizationLoggingOptionsPermissionType("ADMIN_READ");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static AuthorizationLoggingOptionsPermissionType AdminWrite { get; } = new AuthorizationLoggingOptionsPermissionType("ADMIN_WRITE");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static AuthorizationLoggingOptionsPermissionType DataRead { get; } = new AuthorizationLoggingOptionsPermissionType("DATA_READ");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static AuthorizationLoggingOptionsPermissionType DataWrite { get; } = new AuthorizationLoggingOptionsPermissionType("DATA_WRITE");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static AuthorizationLoggingOptionsPermissionType PermissionTypeUnspecified { get; } = new AuthorizationLoggingOptionsPermissionType("PERMISSION_TYPE_UNSPECIFIED");

        public static bool operator ==(AuthorizationLoggingOptionsPermissionType left, AuthorizationLoggingOptionsPermissionType right) => left.Equals(right);
        public static bool operator !=(AuthorizationLoggingOptionsPermissionType left, AuthorizationLoggingOptionsPermissionType right) => !left.Equals(right);

        public static explicit operator string(AuthorizationLoggingOptionsPermissionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AuthorizationLoggingOptionsPermissionType other && Equals(other);
        public bool Equals(AuthorizationLoggingOptionsPermissionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether predictive autoscaling based on CPU metric is enabled. Valid values are: * NONE (default). No predictive method is used. The autoscaler scales the group to meet current demand based on real-time metrics. * OPTIMIZE_AVAILABILITY. Predictive autoscaling improves availability by monitoring daily and weekly load patterns and scaling out ahead of anticipated demand.
    /// </summary>
    [EnumType]
    public readonly struct AutoscalingPolicyCpuUtilizationPredictiveMethod : IEquatable<AutoscalingPolicyCpuUtilizationPredictiveMethod>
    {
        private readonly string _value;

        private AutoscalingPolicyCpuUtilizationPredictiveMethod(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No predictive method is used. The autoscaler scales the group to meet current demand based on real-time metrics
        /// </summary>
        public static AutoscalingPolicyCpuUtilizationPredictiveMethod None { get; } = new AutoscalingPolicyCpuUtilizationPredictiveMethod("NONE");
        /// <summary>
        /// Predictive autoscaling improves availability by monitoring daily and weekly load patterns and scaling out ahead of anticipated demand.
        /// </summary>
        public static AutoscalingPolicyCpuUtilizationPredictiveMethod OptimizeAvailability { get; } = new AutoscalingPolicyCpuUtilizationPredictiveMethod("OPTIMIZE_AVAILABILITY");
        public static AutoscalingPolicyCpuUtilizationPredictiveMethod PredictiveMethodUnspecified { get; } = new AutoscalingPolicyCpuUtilizationPredictiveMethod("PREDICTIVE_METHOD_UNSPECIFIED");

        public static bool operator ==(AutoscalingPolicyCpuUtilizationPredictiveMethod left, AutoscalingPolicyCpuUtilizationPredictiveMethod right) => left.Equals(right);
        public static bool operator !=(AutoscalingPolicyCpuUtilizationPredictiveMethod left, AutoscalingPolicyCpuUtilizationPredictiveMethod right) => !left.Equals(right);

        public static explicit operator string(AutoscalingPolicyCpuUtilizationPredictiveMethod value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AutoscalingPolicyCpuUtilizationPredictiveMethod other && Equals(other);
        public bool Equals(AutoscalingPolicyCpuUtilizationPredictiveMethod other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines how target utilization value is expressed for a Stackdriver Monitoring metric. Either GAUGE, DELTA_PER_SECOND, or DELTA_PER_MINUTE.
    /// </summary>
    [EnumType]
    public readonly struct AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType : IEquatable<AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType>
    {
        private readonly string _value;

        private AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Sets the utilization target value for a cumulative or delta metric, expressed as the rate of growth per minute.
        /// </summary>
        public static AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType DeltaPerMinute { get; } = new AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType("DELTA_PER_MINUTE");
        /// <summary>
        /// Sets the utilization target value for a cumulative or delta metric, expressed as the rate of growth per second.
        /// </summary>
        public static AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType DeltaPerSecond { get; } = new AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType("DELTA_PER_SECOND");
        /// <summary>
        /// Sets the utilization target value for a gauge metric. The autoscaler will collect the average utilization of the virtual machines from the last couple of minutes, and compare the value to the utilization target value to perform autoscaling.
        /// </summary>
        public static AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType Gauge { get; } = new AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType("GAUGE");

        public static bool operator ==(AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType left, AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType right) => left.Equals(right);
        public static bool operator !=(AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType left, AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType right) => !left.Equals(right);

        public static explicit operator string(AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType other && Equals(other);
        public bool Equals(AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines operating mode for this policy.
    /// </summary>
    [EnumType]
    public readonly struct AutoscalingPolicyMode : IEquatable<AutoscalingPolicyMode>
    {
        private readonly string _value;

        private AutoscalingPolicyMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Do not automatically scale the MIG in or out. The recommended_size field contains the size of MIG that would be set if the actuation mode was enabled.
        /// </summary>
        public static AutoscalingPolicyMode Off { get; } = new AutoscalingPolicyMode("OFF");
        /// <summary>
        /// Automatically scale the MIG in and out according to the policy.
        /// </summary>
        public static AutoscalingPolicyMode On { get; } = new AutoscalingPolicyMode("ON");
        /// <summary>
        /// Automatically create VMs according to the policy, but do not scale the MIG in.
        /// </summary>
        public static AutoscalingPolicyMode OnlyScaleOut { get; } = new AutoscalingPolicyMode("ONLY_SCALE_OUT");
        /// <summary>
        /// Automatically create VMs according to the policy, but do not scale the MIG in.
        /// </summary>
        public static AutoscalingPolicyMode OnlyUp { get; } = new AutoscalingPolicyMode("ONLY_UP");

        public static bool operator ==(AutoscalingPolicyMode left, AutoscalingPolicyMode right) => left.Equals(right);
        public static bool operator !=(AutoscalingPolicyMode left, AutoscalingPolicyMode right) => !left.Equals(right);

        public static explicit operator string(AutoscalingPolicyMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AutoscalingPolicyMode other && Equals(other);
        public bool Equals(AutoscalingPolicyMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how to determine whether the backend of a load balancer can handle additional traffic or is fully loaded. For usage guidelines, see Connection balancing mode. Backends must use compatible balancing modes. For more information, see Supported balancing modes and target capacity settings and Restrictions and guidance for instance groups. Note: Currently, if you use the API to configure incompatible balancing modes, the configuration might be accepted even though it has no impact and is ignored. Specifically, Backend.maxUtilization is ignored when Backend.balancingMode is RATE. In the future, this incompatible combination will be rejected.
    /// </summary>
    [EnumType]
    public readonly struct BackendBalancingMode : IEquatable<BackendBalancingMode>
    {
        private readonly string _value;

        private BackendBalancingMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Balance based on the number of simultaneous connections.
        /// </summary>
        public static BackendBalancingMode Connection { get; } = new BackendBalancingMode("CONNECTION");
        /// <summary>
        /// Balance based on requests per second (RPS).
        /// </summary>
        public static BackendBalancingMode Rate { get; } = new BackendBalancingMode("RATE");
        /// <summary>
        /// Balance based on the backend utilization.
        /// </summary>
        public static BackendBalancingMode Utilization { get; } = new BackendBalancingMode("UTILIZATION");

        public static bool operator ==(BackendBalancingMode left, BackendBalancingMode right) => left.Equals(right);
        public static bool operator !=(BackendBalancingMode left, BackendBalancingMode right) => !left.Equals(right);

        public static explicit operator string(BackendBalancingMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackendBalancingMode other && Equals(other);
        public bool Equals(BackendBalancingMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the cache setting for all responses from this backend. The possible values are: USE_ORIGIN_HEADERS Requires the origin to set valid caching headers to cache content. Responses without these headers will not be cached at Google's edge, and will require a full trip to the origin on every request, potentially impacting performance and increasing load on the origin server. FORCE_CACHE_ALL Cache all content, ignoring any "private", "no-store" or "no-cache" directives in Cache-Control response headers. Warning: this may result in Cloud CDN caching private, per-user (user identifiable) content. CACHE_ALL_STATIC Automatically cache static content, including common image formats, media (video and audio), and web assets (JavaScript and CSS). Requests and responses that are marked as uncacheable, as well as dynamic content (including HTML), will not be cached.
    /// </summary>
    [EnumType]
    public readonly struct BackendBucketCdnPolicyCacheMode : IEquatable<BackendBucketCdnPolicyCacheMode>
    {
        private readonly string _value;

        private BackendBucketCdnPolicyCacheMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Automatically cache static content, including common image formats, media (video and audio), and web assets (JavaScript and CSS). Requests and responses that are marked as uncacheable, as well as dynamic content (including HTML), will not be cached.
        /// </summary>
        public static BackendBucketCdnPolicyCacheMode CacheAllStatic { get; } = new BackendBucketCdnPolicyCacheMode("CACHE_ALL_STATIC");
        /// <summary>
        /// Cache all content, ignoring any "private", "no-store" or "no-cache" directives in Cache-Control response headers. Warning: this may result in Cloud CDN caching private, per-user (user identifiable) content.
        /// </summary>
        public static BackendBucketCdnPolicyCacheMode ForceCacheAll { get; } = new BackendBucketCdnPolicyCacheMode("FORCE_CACHE_ALL");
        public static BackendBucketCdnPolicyCacheMode InvalidCacheMode { get; } = new BackendBucketCdnPolicyCacheMode("INVALID_CACHE_MODE");
        /// <summary>
        /// Requires the origin to set valid caching headers to cache content. Responses without these headers will not be cached at Google's edge, and will require a full trip to the origin on every request, potentially impacting performance and increasing load on the origin server.
        /// </summary>
        public static BackendBucketCdnPolicyCacheMode UseOriginHeaders { get; } = new BackendBucketCdnPolicyCacheMode("USE_ORIGIN_HEADERS");

        public static bool operator ==(BackendBucketCdnPolicyCacheMode left, BackendBucketCdnPolicyCacheMode right) => left.Equals(right);
        public static bool operator !=(BackendBucketCdnPolicyCacheMode left, BackendBucketCdnPolicyCacheMode right) => !left.Equals(right);

        public static explicit operator string(BackendBucketCdnPolicyCacheMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackendBucketCdnPolicyCacheMode other && Equals(other);
        public bool Equals(BackendBucketCdnPolicyCacheMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Compress text responses using Brotli or gzip compression, based on the client's Accept-Encoding header.
    /// </summary>
    [EnumType]
    public readonly struct BackendBucketCompressionMode : IEquatable<BackendBucketCompressionMode>
    {
        private readonly string _value;

        private BackendBucketCompressionMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Automatically uses the best compression based on the Accept-Encoding header sent by the client.
        /// </summary>
        public static BackendBucketCompressionMode Automatic { get; } = new BackendBucketCompressionMode("AUTOMATIC");
        /// <summary>
        /// Disables compression. Existing compressed responses cached by Cloud CDN will not be served to clients.
        /// </summary>
        public static BackendBucketCompressionMode Disabled { get; } = new BackendBucketCompressionMode("DISABLED");

        public static bool operator ==(BackendBucketCompressionMode left, BackendBucketCompressionMode right) => left.Equals(right);
        public static bool operator !=(BackendBucketCompressionMode left, BackendBucketCompressionMode right) => !left.Equals(right);

        public static explicit operator string(BackendBucketCompressionMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackendBucketCompressionMode other && Equals(other);
        public bool Equals(BackendBucketCompressionMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the cache setting for all responses from this backend. The possible values are: USE_ORIGIN_HEADERS Requires the origin to set valid caching headers to cache content. Responses without these headers will not be cached at Google's edge, and will require a full trip to the origin on every request, potentially impacting performance and increasing load on the origin server. FORCE_CACHE_ALL Cache all content, ignoring any "private", "no-store" or "no-cache" directives in Cache-Control response headers. Warning: this may result in Cloud CDN caching private, per-user (user identifiable) content. CACHE_ALL_STATIC Automatically cache static content, including common image formats, media (video and audio), and web assets (JavaScript and CSS). Requests and responses that are marked as uncacheable, as well as dynamic content (including HTML), will not be cached.
    /// </summary>
    [EnumType]
    public readonly struct BackendServiceCdnPolicyCacheMode : IEquatable<BackendServiceCdnPolicyCacheMode>
    {
        private readonly string _value;

        private BackendServiceCdnPolicyCacheMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Automatically cache static content, including common image formats, media (video and audio), and web assets (JavaScript and CSS). Requests and responses that are marked as uncacheable, as well as dynamic content (including HTML), will not be cached.
        /// </summary>
        public static BackendServiceCdnPolicyCacheMode CacheAllStatic { get; } = new BackendServiceCdnPolicyCacheMode("CACHE_ALL_STATIC");
        /// <summary>
        /// Cache all content, ignoring any "private", "no-store" or "no-cache" directives in Cache-Control response headers. Warning: this may result in Cloud CDN caching private, per-user (user identifiable) content.
        /// </summary>
        public static BackendServiceCdnPolicyCacheMode ForceCacheAll { get; } = new BackendServiceCdnPolicyCacheMode("FORCE_CACHE_ALL");
        public static BackendServiceCdnPolicyCacheMode InvalidCacheMode { get; } = new BackendServiceCdnPolicyCacheMode("INVALID_CACHE_MODE");
        /// <summary>
        /// Requires the origin to set valid caching headers to cache content. Responses without these headers will not be cached at Google's edge, and will require a full trip to the origin on every request, potentially impacting performance and increasing load on the origin server.
        /// </summary>
        public static BackendServiceCdnPolicyCacheMode UseOriginHeaders { get; } = new BackendServiceCdnPolicyCacheMode("USE_ORIGIN_HEADERS");

        public static bool operator ==(BackendServiceCdnPolicyCacheMode left, BackendServiceCdnPolicyCacheMode right) => left.Equals(right);
        public static bool operator !=(BackendServiceCdnPolicyCacheMode left, BackendServiceCdnPolicyCacheMode right) => !left.Equals(right);

        public static explicit operator string(BackendServiceCdnPolicyCacheMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackendServiceCdnPolicyCacheMode other && Equals(other);
        public bool Equals(BackendServiceCdnPolicyCacheMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Compress text responses using Brotli or gzip compression, based on the client's Accept-Encoding header.
    /// </summary>
    [EnumType]
    public readonly struct BackendServiceCompressionMode : IEquatable<BackendServiceCompressionMode>
    {
        private readonly string _value;

        private BackendServiceCompressionMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Automatically uses the best compression based on the Accept-Encoding header sent by the client.
        /// </summary>
        public static BackendServiceCompressionMode Automatic { get; } = new BackendServiceCompressionMode("AUTOMATIC");
        /// <summary>
        /// Disables compression. Existing compressed responses cached by Cloud CDN will not be served to clients.
        /// </summary>
        public static BackendServiceCompressionMode Disabled { get; } = new BackendServiceCompressionMode("DISABLED");

        public static bool operator ==(BackendServiceCompressionMode left, BackendServiceCompressionMode right) => left.Equals(right);
        public static bool operator !=(BackendServiceCompressionMode left, BackendServiceCompressionMode right) => !left.Equals(right);

        public static explicit operator string(BackendServiceCompressionMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackendServiceCompressionMode other && Equals(other);
        public bool Equals(BackendServiceCompressionMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies connection persistence when backends are unhealthy. The default value is DEFAULT_FOR_PROTOCOL. If set to DEFAULT_FOR_PROTOCOL, the existing connections persist on unhealthy backends only for connection-oriented protocols (TCP and SCTP) and only if the Tracking Mode is PER_CONNECTION (default tracking mode) or the Session Affinity is configured for 5-tuple. They do not persist for UDP. If set to NEVER_PERSIST, after a backend becomes unhealthy, the existing connections on the unhealthy backend are never persisted on the unhealthy backend. They are always diverted to newly selected healthy backends (unless all backends are unhealthy). If set to ALWAYS_PERSIST, existing connections always persist on unhealthy backends regardless of protocol and session affinity. It is generally not recommended to use this mode overriding the default. For more details, see [Connection Persistence for Network Load Balancing](https://cloud.google.com/load-balancing/docs/network/networklb-backend-service#connection-persistence) and [Connection Persistence for Internal TCP/UDP Load Balancing](https://cloud.google.com/load-balancing/docs/internal#connection-persistence).
    /// </summary>
    [EnumType]
    public readonly struct BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends : IEquatable<BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends>
    {
        private readonly string _value;

        private BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends AlwaysPersist { get; } = new BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends("ALWAYS_PERSIST");
        public static BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends DefaultForProtocol { get; } = new BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends("DEFAULT_FOR_PROTOCOL");
        public static BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends NeverPersist { get; } = new BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends("NEVER_PERSIST");

        public static bool operator ==(BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends left, BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends right) => left.Equals(right);
        public static bool operator !=(BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends left, BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends right) => !left.Equals(right);

        public static explicit operator string(BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends other && Equals(other);
        public bool Equals(BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the key used for connection tracking. There are two options: - PER_CONNECTION: This is the default mode. The Connection Tracking is performed as per the Connection Key (default Hash Method) for the specific protocol. - PER_SESSION: The Connection Tracking is performed as per the configured Session Affinity. It matches the configured Session Affinity. For more details, see [Tracking Mode for Network Load Balancing](https://cloud.google.com/load-balancing/docs/network/networklb-backend-service#tracking-mode) and [Tracking Mode for Internal TCP/UDP Load Balancing](https://cloud.google.com/load-balancing/docs/internal#tracking-mode).
    /// </summary>
    [EnumType]
    public readonly struct BackendServiceConnectionTrackingPolicyTrackingMode : IEquatable<BackendServiceConnectionTrackingPolicyTrackingMode>
    {
        private readonly string _value;

        private BackendServiceConnectionTrackingPolicyTrackingMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BackendServiceConnectionTrackingPolicyTrackingMode InvalidTrackingMode { get; } = new BackendServiceConnectionTrackingPolicyTrackingMode("INVALID_TRACKING_MODE");
        public static BackendServiceConnectionTrackingPolicyTrackingMode PerConnection { get; } = new BackendServiceConnectionTrackingPolicyTrackingMode("PER_CONNECTION");
        public static BackendServiceConnectionTrackingPolicyTrackingMode PerSession { get; } = new BackendServiceConnectionTrackingPolicyTrackingMode("PER_SESSION");

        public static bool operator ==(BackendServiceConnectionTrackingPolicyTrackingMode left, BackendServiceConnectionTrackingPolicyTrackingMode right) => left.Equals(right);
        public static bool operator !=(BackendServiceConnectionTrackingPolicyTrackingMode left, BackendServiceConnectionTrackingPolicyTrackingMode right) => !left.Equals(right);

        public static explicit operator string(BackendServiceConnectionTrackingPolicyTrackingMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackendServiceConnectionTrackingPolicyTrackingMode other && Equals(other);
        public bool Equals(BackendServiceConnectionTrackingPolicyTrackingMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the load balancer type. A backend service created for one type of load balancer cannot be used with another. For more information, refer to Choosing a load balancer.
    /// </summary>
    [EnumType]
    public readonly struct BackendServiceLoadBalancingScheme : IEquatable<BackendServiceLoadBalancingScheme>
    {
        private readonly string _value;

        private BackendServiceLoadBalancingScheme(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Signifies that this will be used for external HTTP(S), SSL Proxy, TCP Proxy, or Network Load Balancing
        /// </summary>
        public static BackendServiceLoadBalancingScheme External { get; } = new BackendServiceLoadBalancingScheme("EXTERNAL");
        /// <summary>
        /// Signifies that this will be used for External Managed HTTP(S) Load Balancing.
        /// </summary>
        public static BackendServiceLoadBalancingScheme ExternalManaged { get; } = new BackendServiceLoadBalancingScheme("EXTERNAL_MANAGED");
        /// <summary>
        /// Signifies that this will be used for Internal TCP/UDP Load Balancing.
        /// </summary>
        public static BackendServiceLoadBalancingScheme Internal { get; } = new BackendServiceLoadBalancingScheme("INTERNAL");
        /// <summary>
        /// Signifies that this will be used for Internal HTTP(S) Load Balancing.
        /// </summary>
        public static BackendServiceLoadBalancingScheme InternalManaged { get; } = new BackendServiceLoadBalancingScheme("INTERNAL_MANAGED");
        /// <summary>
        /// Signifies that this will be used by Traffic Director.
        /// </summary>
        public static BackendServiceLoadBalancingScheme InternalSelfManaged { get; } = new BackendServiceLoadBalancingScheme("INTERNAL_SELF_MANAGED");
        public static BackendServiceLoadBalancingScheme InvalidLoadBalancingScheme { get; } = new BackendServiceLoadBalancingScheme("INVALID_LOAD_BALANCING_SCHEME");

        public static bool operator ==(BackendServiceLoadBalancingScheme left, BackendServiceLoadBalancingScheme right) => left.Equals(right);
        public static bool operator !=(BackendServiceLoadBalancingScheme left, BackendServiceLoadBalancingScheme right) => !left.Equals(right);

        public static explicit operator string(BackendServiceLoadBalancingScheme value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackendServiceLoadBalancingScheme other && Equals(other);
        public bool Equals(BackendServiceLoadBalancingScheme other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The load balancing algorithm used within the scope of the locality. The possible values are: - ROUND_ROBIN: This is a simple policy in which each healthy backend is selected in round robin order. This is the default. - LEAST_REQUEST: An O(1) algorithm which selects two random healthy hosts and picks the host which has fewer active requests. - RING_HASH: The ring/modulo hash load balancer implements consistent hashing to backends. The algorithm has the property that the addition/removal of a host from a set of N hosts only affects 1/N of the requests. - RANDOM: The load balancer selects a random healthy host. - ORIGINAL_DESTINATION: Backend host is selected based on the client connection metadata, i.e., connections are opened to the same address as the destination address of the incoming connection before the connection was redirected to the load balancer. - MAGLEV: used as a drop in replacement for the ring hash load balancer. Maglev is not as stable as ring hash but has faster table lookup build times and host selection times. For more information about Maglev, see https://ai.google/research/pubs/pub44824 This field is applicable to either: - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED. - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED. If sessionAffinity is not NONE, and this field is not set to MAGLEV or RING_HASH, session affinity settings will not take effect. Only ROUND_ROBIN and RING_HASH are supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
    /// </summary>
    [EnumType]
    public readonly struct BackendServiceLocalityLbPolicy : IEquatable<BackendServiceLocalityLbPolicy>
    {
        private readonly string _value;

        private BackendServiceLocalityLbPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BackendServiceLocalityLbPolicy InvalidLbPolicy { get; } = new BackendServiceLocalityLbPolicy("INVALID_LB_POLICY");
        /// <summary>
        /// An O(1) algorithm which selects two random healthy hosts and picks the host which has fewer active requests.
        /// </summary>
        public static BackendServiceLocalityLbPolicy LeastRequest { get; } = new BackendServiceLocalityLbPolicy("LEAST_REQUEST");
        /// <summary>
        /// This algorithm implements consistent hashing to backends. Maglev can be used as a drop in replacement for the ring hash load balancer. Maglev is not as stable as ring hash but has faster table lookup build times and host selection times. For more information about Maglev, see https://ai.google/research/pubs/pub44824
        /// </summary>
        public static BackendServiceLocalityLbPolicy Maglev { get; } = new BackendServiceLocalityLbPolicy("MAGLEV");
        /// <summary>
        /// Backend host is selected based on the client connection metadata, i.e., connections are opened to the same address as the destination address of the incoming connection before the connection was redirected to the load balancer.
        /// </summary>
        public static BackendServiceLocalityLbPolicy OriginalDestination { get; } = new BackendServiceLocalityLbPolicy("ORIGINAL_DESTINATION");
        /// <summary>
        /// The load balancer selects a random healthy host.
        /// </summary>
        public static BackendServiceLocalityLbPolicy Random { get; } = new BackendServiceLocalityLbPolicy("RANDOM");
        /// <summary>
        /// The ring/modulo hash load balancer implements consistent hashing to backends. The algorithm has the property that the addition/removal of a host from a set of N hosts only affects 1/N of the requests.
        /// </summary>
        public static BackendServiceLocalityLbPolicy RingHash { get; } = new BackendServiceLocalityLbPolicy("RING_HASH");
        /// <summary>
        /// This is a simple policy in which each healthy backend is selected in round robin order. This is the default.
        /// </summary>
        public static BackendServiceLocalityLbPolicy RoundRobin { get; } = new BackendServiceLocalityLbPolicy("ROUND_ROBIN");

        public static bool operator ==(BackendServiceLocalityLbPolicy left, BackendServiceLocalityLbPolicy right) => left.Equals(right);
        public static bool operator !=(BackendServiceLocalityLbPolicy left, BackendServiceLocalityLbPolicy right) => !left.Equals(right);

        public static explicit operator string(BackendServiceLocalityLbPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackendServiceLocalityLbPolicy other && Equals(other);
        public bool Equals(BackendServiceLocalityLbPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The protocol this BackendService uses to communicate with backends. Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, UDP or GRPC. depending on the chosen load balancer or Traffic Director configuration. Refer to the documentation for the load balancers or for Traffic Director for more information. Must be set to GRPC when the backend service is referenced by a URL map that is bound to target gRPC proxy.
    /// </summary>
    [EnumType]
    public readonly struct BackendServiceProtocol : IEquatable<BackendServiceProtocol>
    {
        private readonly string _value;

        private BackendServiceProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// gRPC (available for Traffic Director).
        /// </summary>
        public static BackendServiceProtocol Grpc { get; } = new BackendServiceProtocol("GRPC");
        public static BackendServiceProtocol Http { get; } = new BackendServiceProtocol("HTTP");
        /// <summary>
        /// HTTP/2 with SSL.
        /// </summary>
        public static BackendServiceProtocol Http2 { get; } = new BackendServiceProtocol("HTTP2");
        public static BackendServiceProtocol Https { get; } = new BackendServiceProtocol("HTTPS");
        /// <summary>
        /// TCP proxying with SSL.
        /// </summary>
        public static BackendServiceProtocol Ssl { get; } = new BackendServiceProtocol("SSL");
        /// <summary>
        /// TCP proxying or TCP pass-through.
        /// </summary>
        public static BackendServiceProtocol Tcp { get; } = new BackendServiceProtocol("TCP");
        /// <summary>
        /// UDP.
        /// </summary>
        public static BackendServiceProtocol Udp { get; } = new BackendServiceProtocol("UDP");
        /// <summary>
        /// If a Backend Service has UNSPECIFIED as its protocol, it can be used with any L3/L4 Forwarding Rules.
        /// </summary>
        public static BackendServiceProtocol Unspecified { get; } = new BackendServiceProtocol("UNSPECIFIED");

        public static bool operator ==(BackendServiceProtocol left, BackendServiceProtocol right) => left.Equals(right);
        public static bool operator !=(BackendServiceProtocol left, BackendServiceProtocol right) => !left.Equals(right);

        public static explicit operator string(BackendServiceProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackendServiceProtocol other && Equals(other);
        public bool Equals(BackendServiceProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of session affinity to use. The default is NONE. Only NONE and HEADER_FIELD are supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true. For more details, see: [Session Affinity](https://cloud.google.com/load-balancing/docs/backend-service#session_affinity).
    /// </summary>
    [EnumType]
    public readonly struct BackendServiceSessionAffinity : IEquatable<BackendServiceSessionAffinity>
    {
        private readonly string _value;

        private BackendServiceSessionAffinity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// 2-tuple hash on packet's source and destination IP addresses. Connections from the same source IP address to the same destination IP address will be served by the same backend VM while that VM remains healthy.
        /// </summary>
        public static BackendServiceSessionAffinity ClientIp { get; } = new BackendServiceSessionAffinity("CLIENT_IP");
        /// <summary>
        /// 1-tuple hash only on packet's source IP address. Connections from the same source IP address will be served by the same backend VM while that VM remains healthy. This option can only be used for Internal TCP/UDP Load Balancing.
        /// </summary>
        public static BackendServiceSessionAffinity ClientIpNoDestination { get; } = new BackendServiceSessionAffinity("CLIENT_IP_NO_DESTINATION");
        /// <summary>
        /// 5-tuple hash on packet's source and destination IP addresses, IP protocol, and source and destination ports. Connections for the same IP protocol from the same source IP address and port to the same destination IP address and port will be served by the same backend VM while that VM remains healthy. This option cannot be used for HTTP(S) load balancing.
        /// </summary>
        public static BackendServiceSessionAffinity ClientIpPortProto { get; } = new BackendServiceSessionAffinity("CLIENT_IP_PORT_PROTO");
        /// <summary>
        /// 3-tuple hash on packet's source and destination IP addresses, and IP protocol. Connections for the same IP protocol from the same source IP address to the same destination IP address will be served by the same backend VM while that VM remains healthy. This option cannot be used for HTTP(S) load balancing.
        /// </summary>
        public static BackendServiceSessionAffinity ClientIpProto { get; } = new BackendServiceSessionAffinity("CLIENT_IP_PROTO");
        /// <summary>
        /// Hash based on a cookie generated by the L7 loadbalancer. Only valid for HTTP(S) load balancing.
        /// </summary>
        public static BackendServiceSessionAffinity GeneratedCookie { get; } = new BackendServiceSessionAffinity("GENERATED_COOKIE");
        /// <summary>
        /// The hash is based on a user specified header field.
        /// </summary>
        public static BackendServiceSessionAffinity HeaderField { get; } = new BackendServiceSessionAffinity("HEADER_FIELD");
        /// <summary>
        /// The hash is based on a user provided cookie.
        /// </summary>
        public static BackendServiceSessionAffinity HttpCookie { get; } = new BackendServiceSessionAffinity("HTTP_COOKIE");
        /// <summary>
        /// No session affinity. Connections from the same client IP may go to any instance in the pool.
        /// </summary>
        public static BackendServiceSessionAffinity None { get; } = new BackendServiceSessionAffinity("NONE");

        public static bool operator ==(BackendServiceSessionAffinity left, BackendServiceSessionAffinity right) => left.Equals(right);
        public static bool operator !=(BackendServiceSessionAffinity left, BackendServiceSessionAffinity right) => !left.Equals(right);

        public static explicit operator string(BackendServiceSessionAffinity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackendServiceSessionAffinity other && Equals(other);
        public bool Equals(BackendServiceSessionAffinity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This is deprecated and has no effect. Do not use.
    /// </summary>
    [EnumType]
    public readonly struct ConditionIam : IEquatable<ConditionIam>
    {
        private readonly string _value;

        private ConditionIam(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static ConditionIam Approver { get; } = new ConditionIam("APPROVER");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static ConditionIam Attribution { get; } = new ConditionIam("ATTRIBUTION");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static ConditionIam Authority { get; } = new ConditionIam("AUTHORITY");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static ConditionIam CredentialsType { get; } = new ConditionIam("CREDENTIALS_TYPE");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static ConditionIam CredsAssertion { get; } = new ConditionIam("CREDS_ASSERTION");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static ConditionIam JustificationType { get; } = new ConditionIam("JUSTIFICATION_TYPE");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static ConditionIam NoAttr { get; } = new ConditionIam("NO_ATTR");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static ConditionIam SecurityRealm { get; } = new ConditionIam("SECURITY_REALM");

        public static bool operator ==(ConditionIam left, ConditionIam right) => left.Equals(right);
        public static bool operator !=(ConditionIam left, ConditionIam right) => !left.Equals(right);

        public static explicit operator string(ConditionIam value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ConditionIam other && Equals(other);
        public bool Equals(ConditionIam other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This is deprecated and has no effect. Do not use.
    /// </summary>
    [EnumType]
    public readonly struct ConditionOp : IEquatable<ConditionOp>
    {
        private readonly string _value;

        private ConditionOp(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static ConditionOp Discharged { get; } = new ConditionOp("DISCHARGED");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static ConditionOp EqualsValue { get; } = new ConditionOp("EQUALS");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static ConditionOp In { get; } = new ConditionOp("IN");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static ConditionOp NotEquals { get; } = new ConditionOp("NOT_EQUALS");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static ConditionOp NotIn { get; } = new ConditionOp("NOT_IN");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static ConditionOp NoOp { get; } = new ConditionOp("NO_OP");

        public static bool operator ==(ConditionOp left, ConditionOp right) => left.Equals(right);
        public static bool operator !=(ConditionOp left, ConditionOp right) => !left.Equals(right);

        public static explicit operator string(ConditionOp value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ConditionOp other && Equals(other);
        public bool Equals(ConditionOp other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This is deprecated and has no effect. Do not use.
    /// </summary>
    [EnumType]
    public readonly struct ConditionSys : IEquatable<ConditionSys>
    {
        private readonly string _value;

        private ConditionSys(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static ConditionSys Ip { get; } = new ConditionSys("IP");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static ConditionSys Name { get; } = new ConditionSys("NAME");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static ConditionSys NoAttr { get; } = new ConditionSys("NO_ATTR");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static ConditionSys Region { get; } = new ConditionSys("REGION");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static ConditionSys Service { get; } = new ConditionSys("SERVICE");

        public static bool operator ==(ConditionSys left, ConditionSys right) => left.Equals(right);
        public static bool operator !=(ConditionSys left, ConditionSys right) => !left.Equals(right);

        public static explicit operator string(ConditionSys value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ConditionSys other && Equals(other);
        public bool Equals(ConditionSys other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The deprecation state of this resource. This can be ACTIVE, DEPRECATED, OBSOLETE, or DELETED. Operations which communicate the end of life date for an image, can use ACTIVE. Operations which create a new resource using a DEPRECATED resource will return successfully, but with a warning indicating the deprecated resource and recommending its replacement. Operations which use OBSOLETE or DELETED resources will be rejected and result in an error.
    /// </summary>
    [EnumType]
    public readonly struct DeprecationStatusState : IEquatable<DeprecationStatusState>
    {
        private readonly string _value;

        private DeprecationStatusState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DeprecationStatusState Active { get; } = new DeprecationStatusState("ACTIVE");
        public static DeprecationStatusState Deleted { get; } = new DeprecationStatusState("DELETED");
        public static DeprecationStatusState Deprecated { get; } = new DeprecationStatusState("DEPRECATED");
        public static DeprecationStatusState Obsolete { get; } = new DeprecationStatusState("OBSOLETE");

        public static bool operator ==(DeprecationStatusState left, DeprecationStatusState right) => left.Equals(right);
        public static bool operator !=(DeprecationStatusState left, DeprecationStatusState right) => !left.Equals(right);

        public static explicit operator string(DeprecationStatusState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DeprecationStatusState other && Equals(other);
        public bool Equals(DeprecationStatusState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether to include the disk and what image to use. Possible values are: - source-image: to use the same image that was used to create the source instance's corresponding disk. Applicable to the boot disk and additional read-write disks. - source-image-family: to use the same image family that was used to create the source instance's corresponding disk. Applicable to the boot disk and additional read-write disks. - custom-image: to use a user-provided image url for disk creation. Applicable to the boot disk and additional read-write disks. - attach-read-only: to attach a read-only disk. Applicable to read-only disks. - do-not-include: to exclude a disk from the template. Applicable to additional read-write disks, local SSDs, and read-only disks. 
    /// </summary>
    [EnumType]
    public readonly struct DiskInstantiationConfigInstantiateFrom : IEquatable<DiskInstantiationConfigInstantiateFrom>
    {
        private readonly string _value;

        private DiskInstantiationConfigInstantiateFrom(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Attach the existing disk in read-only mode. The request will fail if the disk was attached in read-write mode on the source instance. Applicable to: read-only disks.
        /// </summary>
        public static DiskInstantiationConfigInstantiateFrom AttachReadOnly { get; } = new DiskInstantiationConfigInstantiateFrom("ATTACH_READ_ONLY");
        /// <summary>
        /// Create a blank disk. The disk will be created unformatted. Applicable to: additional read-write disks, local SSDs.
        /// </summary>
        public static DiskInstantiationConfigInstantiateFrom Blank { get; } = new DiskInstantiationConfigInstantiateFrom("BLANK");
        /// <summary>
        /// Use the custom image specified in the custom_image field. Applicable to: boot disk, additional read-write disks.
        /// </summary>
        public static DiskInstantiationConfigInstantiateFrom CustomImage { get; } = new DiskInstantiationConfigInstantiateFrom("CUSTOM_IMAGE");
        /// <summary>
        /// Use the default instantiation option for the corresponding type of disk. For boot disk and any other R/W disks, new custom images will be created from each disk. For read-only disks, they will be attached in read-only mode. Local SSD disks will be created as blank volumes.
        /// </summary>
        public static DiskInstantiationConfigInstantiateFrom Default { get; } = new DiskInstantiationConfigInstantiateFrom("DEFAULT");
        /// <summary>
        /// Do not include the disk in the instance template. Applicable to: additional read-write disks, local SSDs, read-only disks.
        /// </summary>
        public static DiskInstantiationConfigInstantiateFrom DoNotInclude { get; } = new DiskInstantiationConfigInstantiateFrom("DO_NOT_INCLUDE");
        /// <summary>
        /// Use the same source image used for creation of the source instance's corresponding disk. The request will fail if the source VM's disk was created from a snapshot. Applicable to: boot disk, additional read-write disks.
        /// </summary>
        public static DiskInstantiationConfigInstantiateFrom SourceImage { get; } = new DiskInstantiationConfigInstantiateFrom("SOURCE_IMAGE");
        /// <summary>
        /// Use the same source image family used for creation of the source instance's corresponding disk. The request will fail if the source image of the source disk does not belong to any image family. Applicable to: boot disk, additional read-write disks.
        /// </summary>
        public static DiskInstantiationConfigInstantiateFrom SourceImageFamily { get; } = new DiskInstantiationConfigInstantiateFrom("SOURCE_IMAGE_FAMILY");

        public static bool operator ==(DiskInstantiationConfigInstantiateFrom left, DiskInstantiationConfigInstantiateFrom right) => left.Equals(right);
        public static bool operator !=(DiskInstantiationConfigInstantiateFrom left, DiskInstantiationConfigInstantiateFrom right) => !left.Equals(right);

        public static explicit operator string(DiskInstantiationConfigInstantiateFrom value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiskInstantiationConfigInstantiateFrom other && Equals(other);
        public bool Equals(DiskInstantiationConfigInstantiateFrom other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The distribution shape to which the group converges either proactively or on resize events (depending on the value set in updatePolicy.instanceRedistributionType).
    /// </summary>
    [EnumType]
    public readonly struct DistributionPolicyTargetShape : IEquatable<DistributionPolicyTargetShape>
    {
        private readonly string _value;

        private DistributionPolicyTargetShape(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The group picks zones for creating VM instances to fulfill the requested number of VMs within present resource constraints and to maximize utilization of unused zonal reservations. Recommended for batch workloads that do not require high availability.
        /// </summary>
        public static DistributionPolicyTargetShape Any { get; } = new DistributionPolicyTargetShape("ANY");
        /// <summary>
        /// The group prioritizes acquisition of resources, scheduling VMs in zones where resources are available while distributing VMs as evenly as possible across selected zones to minimize the impact of zonal failure. Recommended for highly available serving workloads.
        /// </summary>
        public static DistributionPolicyTargetShape Balanced { get; } = new DistributionPolicyTargetShape("BALANCED");
        /// <summary>
        /// The group schedules VM instance creation and deletion to achieve and maintain an even number of managed instances across the selected zones. The distribution is even when the number of managed instances does not differ by more than 1 between any two zones. Recommended for highly available serving workloads.
        /// </summary>
        public static DistributionPolicyTargetShape Even { get; } = new DistributionPolicyTargetShape("EVEN");

        public static bool operator ==(DistributionPolicyTargetShape left, DistributionPolicyTargetShape right) => left.Equals(right);
        public static bool operator !=(DistributionPolicyTargetShape left, DistributionPolicyTargetShape right) => !left.Equals(right);

        public static explicit operator string(DistributionPolicyTargetShape value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DistributionPolicyTargetShape other && Equals(other);
        public bool Equals(DistributionPolicyTargetShape other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates the user-supplied redundancy type of this external VPN gateway.
    /// </summary>
    [EnumType]
    public readonly struct ExternalVpnGatewayRedundancyType : IEquatable<ExternalVpnGatewayRedundancyType>
    {
        private readonly string _value;

        private ExternalVpnGatewayRedundancyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The external VPN gateway has four public IP addresses; at the time of writing this API, the AWS virtual private gateway is an example which has four public IP addresses for high availability connections; there should be two VPN connections in the AWS virtual private gateway , each AWS VPN connection has two public IP addresses; please make sure to put two public IP addresses from one AWS VPN connection into interfaces 0 and 1 of this external VPN gateway, and put the other two public IP addresses from another AWS VPN connection into interfaces 2 and 3 of this external VPN gateway. When displaying highly available configuration status for the VPN tunnels connected to FOUR_IPS_REDUNDANCY external VPN gateway, Google will always detect whether interfaces 0 and 1 are connected on one interface of HA Cloud VPN gateway, and detect whether interfaces 2 and 3 are connected to another interface of the HA Cloud VPN gateway.
        /// </summary>
        public static ExternalVpnGatewayRedundancyType FourIpsRedundancy { get; } = new ExternalVpnGatewayRedundancyType("FOUR_IPS_REDUNDANCY");
        /// <summary>
        /// The external VPN gateway has only one public IP address which internally provide redundancy or failover.
        /// </summary>
        public static ExternalVpnGatewayRedundancyType SingleIpInternallyRedundant { get; } = new ExternalVpnGatewayRedundancyType("SINGLE_IP_INTERNALLY_REDUNDANT");
        /// <summary>
        /// The external VPN gateway has two public IP addresses which are redundant with each other, the following two types of setup on your on-premises side would have this type of redundancy: (1) Two separate on-premises gateways, each with one public IP address, the two on-premises gateways are redundant with each other. (2) A single on-premise gateway with two public IP addresses that are redundant with eatch other.
        /// </summary>
        public static ExternalVpnGatewayRedundancyType TwoIpsRedundancy { get; } = new ExternalVpnGatewayRedundancyType("TWO_IPS_REDUNDANCY");

        public static bool operator ==(ExternalVpnGatewayRedundancyType left, ExternalVpnGatewayRedundancyType right) => left.Equals(right);
        public static bool operator !=(ExternalVpnGatewayRedundancyType left, ExternalVpnGatewayRedundancyType right) => !left.Equals(right);

        public static explicit operator string(ExternalVpnGatewayRedundancyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExternalVpnGatewayRedundancyType other && Equals(other);
        public bool Equals(ExternalVpnGatewayRedundancyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The file type of source file.
    /// </summary>
    [EnumType]
    public readonly struct FileContentBufferFileType : IEquatable<FileContentBufferFileType>
    {
        private readonly string _value;

        private FileContentBufferFileType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FileContentBufferFileType Bin { get; } = new FileContentBufferFileType("BIN");
        public static FileContentBufferFileType Undefined { get; } = new FileContentBufferFileType("UNDEFINED");
        public static FileContentBufferFileType X509 { get; } = new FileContentBufferFileType("X509");

        public static bool operator ==(FileContentBufferFileType left, FileContentBufferFileType right) => left.Equals(right);
        public static bool operator !=(FileContentBufferFileType left, FileContentBufferFileType right) => !left.Equals(right);

        public static explicit operator string(FileContentBufferFileType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FileContentBufferFileType other && Equals(other);
        public bool Equals(FileContentBufferFileType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Direction of traffic to which this firewall applies, either `INGRESS` or `EGRESS`. The default is `INGRESS`. For `INGRESS` traffic, you cannot specify the destinationRanges field, and for `EGRESS` traffic, you cannot specify the sourceRanges or sourceTags fields.
    /// </summary>
    [EnumType]
    public readonly struct FirewallDirection : IEquatable<FirewallDirection>
    {
        private readonly string _value;

        private FirewallDirection(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Indicates that firewall should apply to outgoing traffic.
        /// </summary>
        public static FirewallDirection Egress { get; } = new FirewallDirection("EGRESS");
        /// <summary>
        /// Indicates that firewall should apply to incoming traffic.
        /// </summary>
        public static FirewallDirection Ingress { get; } = new FirewallDirection("INGRESS");

        public static bool operator ==(FirewallDirection left, FirewallDirection right) => left.Equals(right);
        public static bool operator !=(FirewallDirection left, FirewallDirection right) => !left.Equals(right);

        public static explicit operator string(FirewallDirection value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FirewallDirection other && Equals(other);
        public bool Equals(FirewallDirection other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This field can only be specified for a particular firewall rule if logging is enabled for that rule. This field denotes whether to include or exclude metadata for firewall logs.
    /// </summary>
    [EnumType]
    public readonly struct FirewallLogConfigMetadata : IEquatable<FirewallLogConfigMetadata>
    {
        private readonly string _value;

        private FirewallLogConfigMetadata(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FirewallLogConfigMetadata ExcludeAllMetadata { get; } = new FirewallLogConfigMetadata("EXCLUDE_ALL_METADATA");
        public static FirewallLogConfigMetadata IncludeAllMetadata { get; } = new FirewallLogConfigMetadata("INCLUDE_ALL_METADATA");

        public static bool operator ==(FirewallLogConfigMetadata left, FirewallLogConfigMetadata right) => left.Equals(right);
        public static bool operator !=(FirewallLogConfigMetadata left, FirewallLogConfigMetadata right) => !left.Equals(right);

        public static explicit operator string(FirewallLogConfigMetadata value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FirewallLogConfigMetadata other && Equals(other);
        public bool Equals(FirewallLogConfigMetadata other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The direction in which this rule applies.
    /// </summary>
    [EnumType]
    public readonly struct FirewallPolicyRuleDirection : IEquatable<FirewallPolicyRuleDirection>
    {
        private readonly string _value;

        private FirewallPolicyRuleDirection(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FirewallPolicyRuleDirection Egress { get; } = new FirewallPolicyRuleDirection("EGRESS");
        public static FirewallPolicyRuleDirection Ingress { get; } = new FirewallPolicyRuleDirection("INGRESS");

        public static bool operator ==(FirewallPolicyRuleDirection left, FirewallPolicyRuleDirection right) => left.Equals(right);
        public static bool operator !=(FirewallPolicyRuleDirection left, FirewallPolicyRuleDirection right) => !left.Equals(right);

        public static explicit operator string(FirewallPolicyRuleDirection value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FirewallPolicyRuleDirection other && Equals(other);
        public bool Equals(FirewallPolicyRuleDirection other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The IP protocol to which this rule applies. For protocol forwarding, valid options are TCP, UDP, ESP, AH, SCTP, ICMP and L3_DEFAULT. The valid IP protocols are different for different load balancing products as described in [Load balancing features](https://cloud.google.com/load-balancing/docs/features#protocols_from_the_load_balancer_to_the_backends).
    /// </summary>
    [EnumType]
    public readonly struct ForwardingRuleIpProtocol : IEquatable<ForwardingRuleIpProtocol>
    {
        private readonly string _value;

        private ForwardingRuleIpProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ForwardingRuleIpProtocol Ah { get; } = new ForwardingRuleIpProtocol("AH");
        public static ForwardingRuleIpProtocol Esp { get; } = new ForwardingRuleIpProtocol("ESP");
        public static ForwardingRuleIpProtocol Icmp { get; } = new ForwardingRuleIpProtocol("ICMP");
        public static ForwardingRuleIpProtocol L3Default { get; } = new ForwardingRuleIpProtocol("L3_DEFAULT");
        public static ForwardingRuleIpProtocol Sctp { get; } = new ForwardingRuleIpProtocol("SCTP");
        public static ForwardingRuleIpProtocol Tcp { get; } = new ForwardingRuleIpProtocol("TCP");
        public static ForwardingRuleIpProtocol Udp { get; } = new ForwardingRuleIpProtocol("UDP");

        public static bool operator ==(ForwardingRuleIpProtocol left, ForwardingRuleIpProtocol right) => left.Equals(right);
        public static bool operator !=(ForwardingRuleIpProtocol left, ForwardingRuleIpProtocol right) => !left.Equals(right);

        public static explicit operator string(ForwardingRuleIpProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ForwardingRuleIpProtocol other && Equals(other);
        public bool Equals(ForwardingRuleIpProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The IP Version that will be used by this forwarding rule. Valid options are IPV4 or IPV6. This can only be specified for an external global forwarding rule.
    /// </summary>
    [EnumType]
    public readonly struct ForwardingRuleIpVersion : IEquatable<ForwardingRuleIpVersion>
    {
        private readonly string _value;

        private ForwardingRuleIpVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ForwardingRuleIpVersion Ipv4 { get; } = new ForwardingRuleIpVersion("IPV4");
        public static ForwardingRuleIpVersion Ipv6 { get; } = new ForwardingRuleIpVersion("IPV6");
        public static ForwardingRuleIpVersion UnspecifiedVersion { get; } = new ForwardingRuleIpVersion("UNSPECIFIED_VERSION");

        public static bool operator ==(ForwardingRuleIpVersion left, ForwardingRuleIpVersion right) => left.Equals(right);
        public static bool operator !=(ForwardingRuleIpVersion left, ForwardingRuleIpVersion right) => !left.Equals(right);

        public static explicit operator string(ForwardingRuleIpVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ForwardingRuleIpVersion other && Equals(other);
        public bool Equals(ForwardingRuleIpVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the forwarding rule type. For more information about forwarding rules, refer to Forwarding rule concepts.
    /// </summary>
    [EnumType]
    public readonly struct ForwardingRuleLoadBalancingScheme : IEquatable<ForwardingRuleLoadBalancingScheme>
    {
        private readonly string _value;

        private ForwardingRuleLoadBalancingScheme(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ForwardingRuleLoadBalancingScheme External { get; } = new ForwardingRuleLoadBalancingScheme("EXTERNAL");
        public static ForwardingRuleLoadBalancingScheme ExternalManaged { get; } = new ForwardingRuleLoadBalancingScheme("EXTERNAL_MANAGED");
        public static ForwardingRuleLoadBalancingScheme Internal { get; } = new ForwardingRuleLoadBalancingScheme("INTERNAL");
        public static ForwardingRuleLoadBalancingScheme InternalManaged { get; } = new ForwardingRuleLoadBalancingScheme("INTERNAL_MANAGED");
        public static ForwardingRuleLoadBalancingScheme InternalSelfManaged { get; } = new ForwardingRuleLoadBalancingScheme("INTERNAL_SELF_MANAGED");
        public static ForwardingRuleLoadBalancingScheme Invalid { get; } = new ForwardingRuleLoadBalancingScheme("INVALID");

        public static bool operator ==(ForwardingRuleLoadBalancingScheme left, ForwardingRuleLoadBalancingScheme right) => left.Equals(right);
        public static bool operator !=(ForwardingRuleLoadBalancingScheme left, ForwardingRuleLoadBalancingScheme right) => !left.Equals(right);

        public static explicit operator string(ForwardingRuleLoadBalancingScheme value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ForwardingRuleLoadBalancingScheme other && Equals(other);
        public bool Equals(ForwardingRuleLoadBalancingScheme other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This signifies the networking tier used for configuring this load balancer and can only take the following values: PREMIUM, STANDARD. For regional ForwardingRule, the valid values are PREMIUM and STANDARD. For GlobalForwardingRule, the valid value is PREMIUM. If this field is not specified, it is assumed to be PREMIUM. If IPAddress is specified, this value must be equal to the networkTier of the Address.
    /// </summary>
    [EnumType]
    public readonly struct ForwardingRuleNetworkTier : IEquatable<ForwardingRuleNetworkTier>
    {
        private readonly string _value;

        private ForwardingRuleNetworkTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Public internet quality with fixed bandwidth.
        /// </summary>
        public static ForwardingRuleNetworkTier FixedStandard { get; } = new ForwardingRuleNetworkTier("FIXED_STANDARD");
        /// <summary>
        /// High quality, Google-grade network tier, support for all networking products.
        /// </summary>
        public static ForwardingRuleNetworkTier Premium { get; } = new ForwardingRuleNetworkTier("PREMIUM");
        /// <summary>
        /// Public internet quality, only limited support for other networking products.
        /// </summary>
        public static ForwardingRuleNetworkTier Standard { get; } = new ForwardingRuleNetworkTier("STANDARD");
        /// <summary>
        /// (Output only) Temporary tier for FIXED_STANDARD when fixed standard tier is expired or not configured.
        /// </summary>
        public static ForwardingRuleNetworkTier StandardOverridesFixedStandard { get; } = new ForwardingRuleNetworkTier("STANDARD_OVERRIDES_FIXED_STANDARD");

        public static bool operator ==(ForwardingRuleNetworkTier left, ForwardingRuleNetworkTier right) => left.Equals(right);
        public static bool operator !=(ForwardingRuleNetworkTier left, ForwardingRuleNetworkTier right) => !left.Equals(right);

        public static explicit operator string(ForwardingRuleNetworkTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ForwardingRuleNetworkTier other && Equals(other);
        public bool Equals(ForwardingRuleNetworkTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct ForwardingRulePscConnectionStatus : IEquatable<ForwardingRulePscConnectionStatus>
    {
        private readonly string _value;

        private ForwardingRulePscConnectionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The connection has been accepted by the producer.
        /// </summary>
        public static ForwardingRulePscConnectionStatus Accepted { get; } = new ForwardingRulePscConnectionStatus("ACCEPTED");
        /// <summary>
        /// The connection has been closed by the producer and will not serve traffic going forward.
        /// </summary>
        public static ForwardingRulePscConnectionStatus Closed { get; } = new ForwardingRulePscConnectionStatus("CLOSED");
        /// <summary>
        /// The connection is pending acceptance by the producer.
        /// </summary>
        public static ForwardingRulePscConnectionStatus Pending { get; } = new ForwardingRulePscConnectionStatus("PENDING");
        /// <summary>
        /// The connection has been rejected by the producer.
        /// </summary>
        public static ForwardingRulePscConnectionStatus Rejected { get; } = new ForwardingRulePscConnectionStatus("REJECTED");
        public static ForwardingRulePscConnectionStatus StatusUnspecified { get; } = new ForwardingRulePscConnectionStatus("STATUS_UNSPECIFIED");

        public static bool operator ==(ForwardingRulePscConnectionStatus left, ForwardingRulePscConnectionStatus right) => left.Equals(right);
        public static bool operator !=(ForwardingRulePscConnectionStatus left, ForwardingRulePscConnectionStatus right) => !left.Equals(right);

        public static explicit operator string(ForwardingRulePscConnectionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ForwardingRulePscConnectionStatus other && Equals(other);
        public bool Equals(ForwardingRulePscConnectionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how port is selected for health checking, can be one of following values: USE_FIXED_PORT: The port number in port is used for health checking. USE_NAMED_PORT: The portName is used for health checking. USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking. If not specified, gRPC health check follows behavior specified in port and portName fields.
    /// </summary>
    [EnumType]
    public readonly struct GRPCHealthCheckPortSpecification : IEquatable<GRPCHealthCheckPortSpecification>
    {
        private readonly string _value;

        private GRPCHealthCheckPortSpecification(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The port number in port is used for health checking.
        /// </summary>
        public static GRPCHealthCheckPortSpecification UseFixedPort { get; } = new GRPCHealthCheckPortSpecification("USE_FIXED_PORT");
        /// <summary>
        /// The portName is used for health checking.
        /// </summary>
        public static GRPCHealthCheckPortSpecification UseNamedPort { get; } = new GRPCHealthCheckPortSpecification("USE_NAMED_PORT");
        /// <summary>
        /// For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking.
        /// </summary>
        public static GRPCHealthCheckPortSpecification UseServingPort { get; } = new GRPCHealthCheckPortSpecification("USE_SERVING_PORT");

        public static bool operator ==(GRPCHealthCheckPortSpecification left, GRPCHealthCheckPortSpecification right) => left.Equals(right);
        public static bool operator !=(GRPCHealthCheckPortSpecification left, GRPCHealthCheckPortSpecification right) => !left.Equals(right);

        public static explicit operator string(GRPCHealthCheckPortSpecification value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GRPCHealthCheckPortSpecification other && Equals(other);
        public bool Equals(GRPCHealthCheckPortSpecification other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of address to reserve, either INTERNAL or EXTERNAL. If unspecified, defaults to EXTERNAL.
    /// </summary>
    [EnumType]
    public readonly struct GlobalAddressAddressType : IEquatable<GlobalAddressAddressType>
    {
        private readonly string _value;

        private GlobalAddressAddressType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// A publicly visible external IP address.
        /// </summary>
        public static GlobalAddressAddressType External { get; } = new GlobalAddressAddressType("EXTERNAL");
        /// <summary>
        /// A private network IP address, for use with an Instance or Internal Load Balancer forwarding rule.
        /// </summary>
        public static GlobalAddressAddressType Internal { get; } = new GlobalAddressAddressType("INTERNAL");
        public static GlobalAddressAddressType UnspecifiedType { get; } = new GlobalAddressAddressType("UNSPECIFIED_TYPE");

        public static bool operator ==(GlobalAddressAddressType left, GlobalAddressAddressType right) => left.Equals(right);
        public static bool operator !=(GlobalAddressAddressType left, GlobalAddressAddressType right) => !left.Equals(right);

        public static explicit operator string(GlobalAddressAddressType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GlobalAddressAddressType other && Equals(other);
        public bool Equals(GlobalAddressAddressType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The IP version that will be used by this address. Valid options are IPV4 or IPV6. This can only be specified for a global address.
    /// </summary>
    [EnumType]
    public readonly struct GlobalAddressIpVersion : IEquatable<GlobalAddressIpVersion>
    {
        private readonly string _value;

        private GlobalAddressIpVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GlobalAddressIpVersion Ipv4 { get; } = new GlobalAddressIpVersion("IPV4");
        public static GlobalAddressIpVersion Ipv6 { get; } = new GlobalAddressIpVersion("IPV6");
        public static GlobalAddressIpVersion UnspecifiedVersion { get; } = new GlobalAddressIpVersion("UNSPECIFIED_VERSION");

        public static bool operator ==(GlobalAddressIpVersion left, GlobalAddressIpVersion right) => left.Equals(right);
        public static bool operator !=(GlobalAddressIpVersion left, GlobalAddressIpVersion right) => !left.Equals(right);

        public static explicit operator string(GlobalAddressIpVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GlobalAddressIpVersion other && Equals(other);
        public bool Equals(GlobalAddressIpVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This signifies the networking tier used for configuring this address and can only take the following values: PREMIUM or STANDARD. Internal IP addresses are always Premium Tier; global external IP addresses are always Premium Tier; regional external IP addresses can be either Standard or Premium Tier. If this field is not specified, it is assumed to be PREMIUM.
    /// </summary>
    [EnumType]
    public readonly struct GlobalAddressNetworkTier : IEquatable<GlobalAddressNetworkTier>
    {
        private readonly string _value;

        private GlobalAddressNetworkTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Public internet quality with fixed bandwidth.
        /// </summary>
        public static GlobalAddressNetworkTier FixedStandard { get; } = new GlobalAddressNetworkTier("FIXED_STANDARD");
        /// <summary>
        /// High quality, Google-grade network tier, support for all networking products.
        /// </summary>
        public static GlobalAddressNetworkTier Premium { get; } = new GlobalAddressNetworkTier("PREMIUM");
        /// <summary>
        /// Public internet quality, only limited support for other networking products.
        /// </summary>
        public static GlobalAddressNetworkTier Standard { get; } = new GlobalAddressNetworkTier("STANDARD");
        /// <summary>
        /// (Output only) Temporary tier for FIXED_STANDARD when fixed standard tier is expired or not configured.
        /// </summary>
        public static GlobalAddressNetworkTier StandardOverridesFixedStandard { get; } = new GlobalAddressNetworkTier("STANDARD_OVERRIDES_FIXED_STANDARD");

        public static bool operator ==(GlobalAddressNetworkTier left, GlobalAddressNetworkTier right) => left.Equals(right);
        public static bool operator !=(GlobalAddressNetworkTier left, GlobalAddressNetworkTier right) => !left.Equals(right);

        public static explicit operator string(GlobalAddressNetworkTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GlobalAddressNetworkTier other && Equals(other);
        public bool Equals(GlobalAddressNetworkTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The purpose of this resource, which can be one of the following values: - GCE_ENDPOINT for addresses that are used by VM instances, alias IP ranges, load balancers, and similar resources. - DNS_RESOLVER for a DNS resolver address in a subnetwork for a Cloud DNS inbound forwarder IP addresses (regional internal IP address in a subnet of a VPC network) - VPC_PEERING for global internal IP addresses used for private services access allocated ranges. - NAT_AUTO for the regional external IP addresses used by Cloud NAT when allocating addresses using automatic NAT IP address allocation. - IPSEC_INTERCONNECT for addresses created from a private IP range that are reserved for a VLAN attachment in an *IPsec-encrypted Cloud Interconnect* configuration. These addresses are regional resources. Not currently available publicly. - `SHARED_LOADBALANCER_VIP` for an internal IP address that is assigned to multiple internal forwarding rules. - `PRIVATE_SERVICE_CONNECT` for a private network address that is used to configure Private Service Connect. Only global internal addresses can use this purpose. 
    /// </summary>
    [EnumType]
    public readonly struct GlobalAddressPurpose : IEquatable<GlobalAddressPurpose>
    {
        private readonly string _value;

        private GlobalAddressPurpose(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// DNS resolver address in the subnetwork.
        /// </summary>
        public static GlobalAddressPurpose DnsResolver { get; } = new GlobalAddressPurpose("DNS_RESOLVER");
        /// <summary>
        /// VM internal/alias IP, Internal LB service IP, etc.
        /// </summary>
        public static GlobalAddressPurpose GceEndpoint { get; } = new GlobalAddressPurpose("GCE_ENDPOINT");
        /// <summary>
        /// A regional internal IP address range reserved for the VLAN attachment that is used in IPsec-encrypted Cloud Interconnect. This regional internal IP address range must not overlap with any IP address range of subnet/route in the VPC network and its peering networks. After the VLAN attachment is created with the reserved IP address range, when creating a new VPN gateway, its interface IP address is allocated from the associated VLAN attachmentâ€™s IP address range.
        /// </summary>
        public static GlobalAddressPurpose IpsecInterconnect { get; } = new GlobalAddressPurpose("IPSEC_INTERCONNECT");
        /// <summary>
        /// External IP automatically reserved for Cloud NAT.
        /// </summary>
        public static GlobalAddressPurpose NatAuto { get; } = new GlobalAddressPurpose("NAT_AUTO");
        /// <summary>
        /// A private network IP address that can be used to configure Private Service Connect. This purpose can be specified only for GLOBAL addresses of Type INTERNAL
        /// </summary>
        public static GlobalAddressPurpose PrivateServiceConnect { get; } = new GlobalAddressPurpose("PRIVATE_SERVICE_CONNECT");
        /// <summary>
        /// A private network IP address that can be shared by multiple Internal Load Balancer forwarding rules.
        /// </summary>
        public static GlobalAddressPurpose SharedLoadbalancerVip { get; } = new GlobalAddressPurpose("SHARED_LOADBALANCER_VIP");
        /// <summary>
        /// IP range for peer networks.
        /// </summary>
        public static GlobalAddressPurpose VpcPeering { get; } = new GlobalAddressPurpose("VPC_PEERING");

        public static bool operator ==(GlobalAddressPurpose left, GlobalAddressPurpose right) => left.Equals(right);
        public static bool operator !=(GlobalAddressPurpose left, GlobalAddressPurpose right) => !left.Equals(right);

        public static explicit operator string(GlobalAddressPurpose value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GlobalAddressPurpose other && Equals(other);
        public bool Equals(GlobalAddressPurpose other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The IP protocol to which this rule applies. For protocol forwarding, valid options are TCP, UDP, ESP, AH, SCTP, ICMP and L3_DEFAULT. The valid IP protocols are different for different load balancing products as described in [Load balancing features](https://cloud.google.com/load-balancing/docs/features#protocols_from_the_load_balancer_to_the_backends).
    /// </summary>
    [EnumType]
    public readonly struct GlobalForwardingRuleIpProtocol : IEquatable<GlobalForwardingRuleIpProtocol>
    {
        private readonly string _value;

        private GlobalForwardingRuleIpProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GlobalForwardingRuleIpProtocol Ah { get; } = new GlobalForwardingRuleIpProtocol("AH");
        public static GlobalForwardingRuleIpProtocol Esp { get; } = new GlobalForwardingRuleIpProtocol("ESP");
        public static GlobalForwardingRuleIpProtocol Icmp { get; } = new GlobalForwardingRuleIpProtocol("ICMP");
        public static GlobalForwardingRuleIpProtocol L3Default { get; } = new GlobalForwardingRuleIpProtocol("L3_DEFAULT");
        public static GlobalForwardingRuleIpProtocol Sctp { get; } = new GlobalForwardingRuleIpProtocol("SCTP");
        public static GlobalForwardingRuleIpProtocol Tcp { get; } = new GlobalForwardingRuleIpProtocol("TCP");
        public static GlobalForwardingRuleIpProtocol Udp { get; } = new GlobalForwardingRuleIpProtocol("UDP");

        public static bool operator ==(GlobalForwardingRuleIpProtocol left, GlobalForwardingRuleIpProtocol right) => left.Equals(right);
        public static bool operator !=(GlobalForwardingRuleIpProtocol left, GlobalForwardingRuleIpProtocol right) => !left.Equals(right);

        public static explicit operator string(GlobalForwardingRuleIpProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GlobalForwardingRuleIpProtocol other && Equals(other);
        public bool Equals(GlobalForwardingRuleIpProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The IP Version that will be used by this forwarding rule. Valid options are IPV4 or IPV6. This can only be specified for an external global forwarding rule.
    /// </summary>
    [EnumType]
    public readonly struct GlobalForwardingRuleIpVersion : IEquatable<GlobalForwardingRuleIpVersion>
    {
        private readonly string _value;

        private GlobalForwardingRuleIpVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GlobalForwardingRuleIpVersion Ipv4 { get; } = new GlobalForwardingRuleIpVersion("IPV4");
        public static GlobalForwardingRuleIpVersion Ipv6 { get; } = new GlobalForwardingRuleIpVersion("IPV6");
        public static GlobalForwardingRuleIpVersion UnspecifiedVersion { get; } = new GlobalForwardingRuleIpVersion("UNSPECIFIED_VERSION");

        public static bool operator ==(GlobalForwardingRuleIpVersion left, GlobalForwardingRuleIpVersion right) => left.Equals(right);
        public static bool operator !=(GlobalForwardingRuleIpVersion left, GlobalForwardingRuleIpVersion right) => !left.Equals(right);

        public static explicit operator string(GlobalForwardingRuleIpVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GlobalForwardingRuleIpVersion other && Equals(other);
        public bool Equals(GlobalForwardingRuleIpVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the forwarding rule type. For more information about forwarding rules, refer to Forwarding rule concepts.
    /// </summary>
    [EnumType]
    public readonly struct GlobalForwardingRuleLoadBalancingScheme : IEquatable<GlobalForwardingRuleLoadBalancingScheme>
    {
        private readonly string _value;

        private GlobalForwardingRuleLoadBalancingScheme(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GlobalForwardingRuleLoadBalancingScheme External { get; } = new GlobalForwardingRuleLoadBalancingScheme("EXTERNAL");
        public static GlobalForwardingRuleLoadBalancingScheme ExternalManaged { get; } = new GlobalForwardingRuleLoadBalancingScheme("EXTERNAL_MANAGED");
        public static GlobalForwardingRuleLoadBalancingScheme Internal { get; } = new GlobalForwardingRuleLoadBalancingScheme("INTERNAL");
        public static GlobalForwardingRuleLoadBalancingScheme InternalManaged { get; } = new GlobalForwardingRuleLoadBalancingScheme("INTERNAL_MANAGED");
        public static GlobalForwardingRuleLoadBalancingScheme InternalSelfManaged { get; } = new GlobalForwardingRuleLoadBalancingScheme("INTERNAL_SELF_MANAGED");
        public static GlobalForwardingRuleLoadBalancingScheme Invalid { get; } = new GlobalForwardingRuleLoadBalancingScheme("INVALID");

        public static bool operator ==(GlobalForwardingRuleLoadBalancingScheme left, GlobalForwardingRuleLoadBalancingScheme right) => left.Equals(right);
        public static bool operator !=(GlobalForwardingRuleLoadBalancingScheme left, GlobalForwardingRuleLoadBalancingScheme right) => !left.Equals(right);

        public static explicit operator string(GlobalForwardingRuleLoadBalancingScheme value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GlobalForwardingRuleLoadBalancingScheme other && Equals(other);
        public bool Equals(GlobalForwardingRuleLoadBalancingScheme other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This signifies the networking tier used for configuring this load balancer and can only take the following values: PREMIUM, STANDARD. For regional ForwardingRule, the valid values are PREMIUM and STANDARD. For GlobalForwardingRule, the valid value is PREMIUM. If this field is not specified, it is assumed to be PREMIUM. If IPAddress is specified, this value must be equal to the networkTier of the Address.
    /// </summary>
    [EnumType]
    public readonly struct GlobalForwardingRuleNetworkTier : IEquatable<GlobalForwardingRuleNetworkTier>
    {
        private readonly string _value;

        private GlobalForwardingRuleNetworkTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Public internet quality with fixed bandwidth.
        /// </summary>
        public static GlobalForwardingRuleNetworkTier FixedStandard { get; } = new GlobalForwardingRuleNetworkTier("FIXED_STANDARD");
        /// <summary>
        /// High quality, Google-grade network tier, support for all networking products.
        /// </summary>
        public static GlobalForwardingRuleNetworkTier Premium { get; } = new GlobalForwardingRuleNetworkTier("PREMIUM");
        /// <summary>
        /// Public internet quality, only limited support for other networking products.
        /// </summary>
        public static GlobalForwardingRuleNetworkTier Standard { get; } = new GlobalForwardingRuleNetworkTier("STANDARD");
        /// <summary>
        /// (Output only) Temporary tier for FIXED_STANDARD when fixed standard tier is expired or not configured.
        /// </summary>
        public static GlobalForwardingRuleNetworkTier StandardOverridesFixedStandard { get; } = new GlobalForwardingRuleNetworkTier("STANDARD_OVERRIDES_FIXED_STANDARD");

        public static bool operator ==(GlobalForwardingRuleNetworkTier left, GlobalForwardingRuleNetworkTier right) => left.Equals(right);
        public static bool operator !=(GlobalForwardingRuleNetworkTier left, GlobalForwardingRuleNetworkTier right) => !left.Equals(right);

        public static explicit operator string(GlobalForwardingRuleNetworkTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GlobalForwardingRuleNetworkTier other && Equals(other);
        public bool Equals(GlobalForwardingRuleNetworkTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct GlobalForwardingRulePscConnectionStatus : IEquatable<GlobalForwardingRulePscConnectionStatus>
    {
        private readonly string _value;

        private GlobalForwardingRulePscConnectionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The connection has been accepted by the producer.
        /// </summary>
        public static GlobalForwardingRulePscConnectionStatus Accepted { get; } = new GlobalForwardingRulePscConnectionStatus("ACCEPTED");
        /// <summary>
        /// The connection has been closed by the producer and will not serve traffic going forward.
        /// </summary>
        public static GlobalForwardingRulePscConnectionStatus Closed { get; } = new GlobalForwardingRulePscConnectionStatus("CLOSED");
        /// <summary>
        /// The connection is pending acceptance by the producer.
        /// </summary>
        public static GlobalForwardingRulePscConnectionStatus Pending { get; } = new GlobalForwardingRulePscConnectionStatus("PENDING");
        /// <summary>
        /// The connection has been rejected by the producer.
        /// </summary>
        public static GlobalForwardingRulePscConnectionStatus Rejected { get; } = new GlobalForwardingRulePscConnectionStatus("REJECTED");
        public static GlobalForwardingRulePscConnectionStatus StatusUnspecified { get; } = new GlobalForwardingRulePscConnectionStatus("STATUS_UNSPECIFIED");

        public static bool operator ==(GlobalForwardingRulePscConnectionStatus left, GlobalForwardingRulePscConnectionStatus right) => left.Equals(right);
        public static bool operator !=(GlobalForwardingRulePscConnectionStatus left, GlobalForwardingRulePscConnectionStatus right) => !left.Equals(right);

        public static explicit operator string(GlobalForwardingRulePscConnectionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GlobalForwardingRulePscConnectionStatus other && Equals(other);
        public bool Equals(GlobalForwardingRulePscConnectionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of network endpoints in this network endpoint group. Can be one of GCE_VM_IP_PORT, NON_GCP_PRIVATE_IP_PORT, INTERNET_FQDN_PORT, INTERNET_IP_PORT, SERVERLESS, PRIVATE_SERVICE_CONNECT.
    /// </summary>
    [EnumType]
    public readonly struct GlobalNetworkEndpointGroupNetworkEndpointType : IEquatable<GlobalNetworkEndpointGroupNetworkEndpointType>
    {
        private readonly string _value;

        private GlobalNetworkEndpointGroupNetworkEndpointType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The network endpoint is represented by an IP address.
        /// </summary>
        public static GlobalNetworkEndpointGroupNetworkEndpointType GceVmIp { get; } = new GlobalNetworkEndpointGroupNetworkEndpointType("GCE_VM_IP");
        /// <summary>
        /// The network endpoint is represented by IP address and port pair.
        /// </summary>
        public static GlobalNetworkEndpointGroupNetworkEndpointType GceVmIpPort { get; } = new GlobalNetworkEndpointGroupNetworkEndpointType("GCE_VM_IP_PORT");
        /// <summary>
        /// The network endpoint is represented by fully qualified domain name and port.
        /// </summary>
        public static GlobalNetworkEndpointGroupNetworkEndpointType InternetFqdnPort { get; } = new GlobalNetworkEndpointGroupNetworkEndpointType("INTERNET_FQDN_PORT");
        /// <summary>
        /// The network endpoint is represented by an internet IP address and port.
        /// </summary>
        public static GlobalNetworkEndpointGroupNetworkEndpointType InternetIpPort { get; } = new GlobalNetworkEndpointGroupNetworkEndpointType("INTERNET_IP_PORT");
        /// <summary>
        /// The network endpoint is represented by an IP address and port. The endpoint belongs to a VM or pod running in a customer's on-premises.
        /// </summary>
        public static GlobalNetworkEndpointGroupNetworkEndpointType NonGcpPrivateIpPort { get; } = new GlobalNetworkEndpointGroupNetworkEndpointType("NON_GCP_PRIVATE_IP_PORT");
        /// <summary>
        /// The network endpoint is either public Google APIs or services exposed by other GCP Project with a Service Attachment. The connection is set up by private service connect
        /// </summary>
        public static GlobalNetworkEndpointGroupNetworkEndpointType PrivateServiceConnect { get; } = new GlobalNetworkEndpointGroupNetworkEndpointType("PRIVATE_SERVICE_CONNECT");
        /// <summary>
        /// The network endpoint is handled by specified serverless infrastructure.
        /// </summary>
        public static GlobalNetworkEndpointGroupNetworkEndpointType Serverless { get; } = new GlobalNetworkEndpointGroupNetworkEndpointType("SERVERLESS");

        public static bool operator ==(GlobalNetworkEndpointGroupNetworkEndpointType left, GlobalNetworkEndpointGroupNetworkEndpointType right) => left.Equals(right);
        public static bool operator !=(GlobalNetworkEndpointGroupNetworkEndpointType left, GlobalNetworkEndpointGroupNetworkEndpointType right) => !left.Equals(right);

        public static explicit operator string(GlobalNetworkEndpointGroupNetworkEndpointType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GlobalNetworkEndpointGroupNetworkEndpointType other && Equals(other);
        public bool Equals(GlobalNetworkEndpointGroupNetworkEndpointType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The ID of a supported feature. To add multiple values, use commas to separate values. Set to one or more of the following values: - VIRTIO_SCSI_MULTIQUEUE - WINDOWS - MULTI_IP_SUBNET - UEFI_COMPATIBLE - SECURE_BOOT - GVNIC - SEV_CAPABLE - SUSPEND_RESUME_COMPATIBLE For more information, see Enabling guest operating system features.
    /// </summary>
    [EnumType]
    public readonly struct GuestOsFeatureType : IEquatable<GuestOsFeatureType>
    {
        private readonly string _value;

        private GuestOsFeatureType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GuestOsFeatureType FeatureTypeUnspecified { get; } = new GuestOsFeatureType("FEATURE_TYPE_UNSPECIFIED");
        public static GuestOsFeatureType Gvnic { get; } = new GuestOsFeatureType("GVNIC");
        public static GuestOsFeatureType MultiIpSubnet { get; } = new GuestOsFeatureType("MULTI_IP_SUBNET");
        public static GuestOsFeatureType SecureBoot { get; } = new GuestOsFeatureType("SECURE_BOOT");
        public static GuestOsFeatureType SevCapable { get; } = new GuestOsFeatureType("SEV_CAPABLE");
        public static GuestOsFeatureType UefiCompatible { get; } = new GuestOsFeatureType("UEFI_COMPATIBLE");
        public static GuestOsFeatureType VirtioScsiMultiqueue { get; } = new GuestOsFeatureType("VIRTIO_SCSI_MULTIQUEUE");
        public static GuestOsFeatureType Windows { get; } = new GuestOsFeatureType("WINDOWS");

        public static bool operator ==(GuestOsFeatureType left, GuestOsFeatureType right) => left.Equals(right);
        public static bool operator !=(GuestOsFeatureType left, GuestOsFeatureType right) => !left.Equals(right);

        public static explicit operator string(GuestOsFeatureType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GuestOsFeatureType other && Equals(other);
        public bool Equals(GuestOsFeatureType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how port is selected for health checking, can be one of following values: USE_FIXED_PORT: The port number in port is used for health checking. USE_NAMED_PORT: The portName is used for health checking. USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking. If not specified, HTTP2 health check follows behavior specified in port and portName fields.
    /// </summary>
    [EnumType]
    public readonly struct HTTP2HealthCheckPortSpecification : IEquatable<HTTP2HealthCheckPortSpecification>
    {
        private readonly string _value;

        private HTTP2HealthCheckPortSpecification(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The port number in port is used for health checking.
        /// </summary>
        public static HTTP2HealthCheckPortSpecification UseFixedPort { get; } = new HTTP2HealthCheckPortSpecification("USE_FIXED_PORT");
        /// <summary>
        /// The portName is used for health checking.
        /// </summary>
        public static HTTP2HealthCheckPortSpecification UseNamedPort { get; } = new HTTP2HealthCheckPortSpecification("USE_NAMED_PORT");
        /// <summary>
        /// For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking.
        /// </summary>
        public static HTTP2HealthCheckPortSpecification UseServingPort { get; } = new HTTP2HealthCheckPortSpecification("USE_SERVING_PORT");

        public static bool operator ==(HTTP2HealthCheckPortSpecification left, HTTP2HealthCheckPortSpecification right) => left.Equals(right);
        public static bool operator !=(HTTP2HealthCheckPortSpecification left, HTTP2HealthCheckPortSpecification right) => !left.Equals(right);

        public static explicit operator string(HTTP2HealthCheckPortSpecification value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HTTP2HealthCheckPortSpecification other && Equals(other);
        public bool Equals(HTTP2HealthCheckPortSpecification other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
    /// </summary>
    [EnumType]
    public readonly struct HTTP2HealthCheckProxyHeader : IEquatable<HTTP2HealthCheckProxyHeader>
    {
        private readonly string _value;

        private HTTP2HealthCheckProxyHeader(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HTTP2HealthCheckProxyHeader None { get; } = new HTTP2HealthCheckProxyHeader("NONE");
        public static HTTP2HealthCheckProxyHeader ProxyV1 { get; } = new HTTP2HealthCheckProxyHeader("PROXY_V1");

        public static bool operator ==(HTTP2HealthCheckProxyHeader left, HTTP2HealthCheckProxyHeader right) => left.Equals(right);
        public static bool operator !=(HTTP2HealthCheckProxyHeader left, HTTP2HealthCheckProxyHeader right) => !left.Equals(right);

        public static explicit operator string(HTTP2HealthCheckProxyHeader value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HTTP2HealthCheckProxyHeader other && Equals(other);
        public bool Equals(HTTP2HealthCheckProxyHeader other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how port is selected for health checking, can be one of following values: USE_FIXED_PORT: The port number in port is used for health checking. USE_NAMED_PORT: The portName is used for health checking. USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking. If not specified, HTTP health check follows behavior specified in port and portName fields.
    /// </summary>
    [EnumType]
    public readonly struct HTTPHealthCheckPortSpecification : IEquatable<HTTPHealthCheckPortSpecification>
    {
        private readonly string _value;

        private HTTPHealthCheckPortSpecification(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The port number in port is used for health checking.
        /// </summary>
        public static HTTPHealthCheckPortSpecification UseFixedPort { get; } = new HTTPHealthCheckPortSpecification("USE_FIXED_PORT");
        /// <summary>
        /// The portName is used for health checking.
        /// </summary>
        public static HTTPHealthCheckPortSpecification UseNamedPort { get; } = new HTTPHealthCheckPortSpecification("USE_NAMED_PORT");
        /// <summary>
        /// For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking.
        /// </summary>
        public static HTTPHealthCheckPortSpecification UseServingPort { get; } = new HTTPHealthCheckPortSpecification("USE_SERVING_PORT");

        public static bool operator ==(HTTPHealthCheckPortSpecification left, HTTPHealthCheckPortSpecification right) => left.Equals(right);
        public static bool operator !=(HTTPHealthCheckPortSpecification left, HTTPHealthCheckPortSpecification right) => !left.Equals(right);

        public static explicit operator string(HTTPHealthCheckPortSpecification value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HTTPHealthCheckPortSpecification other && Equals(other);
        public bool Equals(HTTPHealthCheckPortSpecification other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
    /// </summary>
    [EnumType]
    public readonly struct HTTPHealthCheckProxyHeader : IEquatable<HTTPHealthCheckProxyHeader>
    {
        private readonly string _value;

        private HTTPHealthCheckProxyHeader(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HTTPHealthCheckProxyHeader None { get; } = new HTTPHealthCheckProxyHeader("NONE");
        public static HTTPHealthCheckProxyHeader ProxyV1 { get; } = new HTTPHealthCheckProxyHeader("PROXY_V1");

        public static bool operator ==(HTTPHealthCheckProxyHeader left, HTTPHealthCheckProxyHeader right) => left.Equals(right);
        public static bool operator !=(HTTPHealthCheckProxyHeader left, HTTPHealthCheckProxyHeader right) => !left.Equals(right);

        public static explicit operator string(HTTPHealthCheckProxyHeader value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HTTPHealthCheckProxyHeader other && Equals(other);
        public bool Equals(HTTPHealthCheckProxyHeader other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how port is selected for health checking, can be one of following values: USE_FIXED_PORT: The port number in port is used for health checking. USE_NAMED_PORT: The portName is used for health checking. USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking. If not specified, HTTPS health check follows behavior specified in port and portName fields.
    /// </summary>
    [EnumType]
    public readonly struct HTTPSHealthCheckPortSpecification : IEquatable<HTTPSHealthCheckPortSpecification>
    {
        private readonly string _value;

        private HTTPSHealthCheckPortSpecification(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The port number in port is used for health checking.
        /// </summary>
        public static HTTPSHealthCheckPortSpecification UseFixedPort { get; } = new HTTPSHealthCheckPortSpecification("USE_FIXED_PORT");
        /// <summary>
        /// The portName is used for health checking.
        /// </summary>
        public static HTTPSHealthCheckPortSpecification UseNamedPort { get; } = new HTTPSHealthCheckPortSpecification("USE_NAMED_PORT");
        /// <summary>
        /// For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking.
        /// </summary>
        public static HTTPSHealthCheckPortSpecification UseServingPort { get; } = new HTTPSHealthCheckPortSpecification("USE_SERVING_PORT");

        public static bool operator ==(HTTPSHealthCheckPortSpecification left, HTTPSHealthCheckPortSpecification right) => left.Equals(right);
        public static bool operator !=(HTTPSHealthCheckPortSpecification left, HTTPSHealthCheckPortSpecification right) => !left.Equals(right);

        public static explicit operator string(HTTPSHealthCheckPortSpecification value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HTTPSHealthCheckPortSpecification other && Equals(other);
        public bool Equals(HTTPSHealthCheckPortSpecification other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
    /// </summary>
    [EnumType]
    public readonly struct HTTPSHealthCheckProxyHeader : IEquatable<HTTPSHealthCheckProxyHeader>
    {
        private readonly string _value;

        private HTTPSHealthCheckProxyHeader(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HTTPSHealthCheckProxyHeader None { get; } = new HTTPSHealthCheckProxyHeader("NONE");
        public static HTTPSHealthCheckProxyHeader ProxyV1 { get; } = new HTTPSHealthCheckProxyHeader("PROXY_V1");

        public static bool operator ==(HTTPSHealthCheckProxyHeader left, HTTPSHealthCheckProxyHeader right) => left.Equals(right);
        public static bool operator !=(HTTPSHealthCheckProxyHeader left, HTTPSHealthCheckProxyHeader right) => !left.Equals(right);

        public static explicit operator string(HTTPSHealthCheckProxyHeader value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HTTPSHealthCheckProxyHeader other && Equals(other);
        public bool Equals(HTTPSHealthCheckProxyHeader other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of the healthCheck, either TCP, SSL, HTTP, HTTPS or HTTP2. Exactly one of the protocol-specific health check field must be specified, which must match type field.
    /// </summary>
    [EnumType]
    public readonly struct HealthCheckType : IEquatable<HealthCheckType>
    {
        private readonly string _value;

        private HealthCheckType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HealthCheckType Grpc { get; } = new HealthCheckType("GRPC");
        public static HealthCheckType Http { get; } = new HealthCheckType("HTTP");
        public static HealthCheckType Http2 { get; } = new HealthCheckType("HTTP2");
        public static HealthCheckType Https { get; } = new HealthCheckType("HTTPS");
        public static HealthCheckType Invalid { get; } = new HealthCheckType("INVALID");
        public static HealthCheckType Ssl { get; } = new HealthCheckType("SSL");
        public static HealthCheckType Tcp { get; } = new HealthCheckType("TCP");

        public static bool operator ==(HealthCheckType left, HealthCheckType right) => left.Equals(right);
        public static bool operator !=(HealthCheckType left, HealthCheckType right) => !left.Equals(right);

        public static explicit operator string(HealthCheckType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HealthCheckType other && Equals(other);
        public bool Equals(HealthCheckType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The HTTP Status code to use for this RedirectAction. Supported values are: - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301. - FOUND, which corresponds to 302. - SEE_OTHER which corresponds to 303. - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method is retained. - PERMANENT_REDIRECT, which corresponds to 308. In this case, the request method is retained. 
    /// </summary>
    [EnumType]
    public readonly struct HttpRedirectActionRedirectResponseCode : IEquatable<HttpRedirectActionRedirectResponseCode>
    {
        private readonly string _value;

        private HttpRedirectActionRedirectResponseCode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Http Status Code 302 - Found.
        /// </summary>
        public static HttpRedirectActionRedirectResponseCode Found { get; } = new HttpRedirectActionRedirectResponseCode("FOUND");
        /// <summary>
        /// Http Status Code 301 - Moved Permanently.
        /// </summary>
        public static HttpRedirectActionRedirectResponseCode MovedPermanentlyDefault { get; } = new HttpRedirectActionRedirectResponseCode("MOVED_PERMANENTLY_DEFAULT");
        /// <summary>
        /// Http Status Code 308 - Permanent Redirect maintaining HTTP method.
        /// </summary>
        public static HttpRedirectActionRedirectResponseCode PermanentRedirect { get; } = new HttpRedirectActionRedirectResponseCode("PERMANENT_REDIRECT");
        /// <summary>
        /// Http Status Code 303 - See Other.
        /// </summary>
        public static HttpRedirectActionRedirectResponseCode SeeOther { get; } = new HttpRedirectActionRedirectResponseCode("SEE_OTHER");
        /// <summary>
        /// Http Status Code 307 - Temporary Redirect maintaining HTTP method.
        /// </summary>
        public static HttpRedirectActionRedirectResponseCode TemporaryRedirect { get; } = new HttpRedirectActionRedirectResponseCode("TEMPORARY_REDIRECT");

        public static bool operator ==(HttpRedirectActionRedirectResponseCode left, HttpRedirectActionRedirectResponseCode right) => left.Equals(right);
        public static bool operator !=(HttpRedirectActionRedirectResponseCode left, HttpRedirectActionRedirectResponseCode right) => !left.Equals(right);

        public static explicit operator string(HttpRedirectActionRedirectResponseCode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HttpRedirectActionRedirectResponseCode other && Equals(other);
        public bool Equals(HttpRedirectActionRedirectResponseCode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The format used to encode and transmit the block device, which should be TAR. This is just a container and transmission format and not a runtime format. Provided by the client when the disk image is created.
    /// </summary>
    [EnumType]
    public readonly struct ImageRawDiskContainerType : IEquatable<ImageRawDiskContainerType>
    {
        private readonly string _value;

        private ImageRawDiskContainerType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ImageRawDiskContainerType Tar { get; } = new ImageRawDiskContainerType("TAR");

        public static bool operator ==(ImageRawDiskContainerType left, ImageRawDiskContainerType right) => left.Equals(right);
        public static bool operator !=(ImageRawDiskContainerType left, ImageRawDiskContainerType right) => !left.Equals(right);

        public static explicit operator string(ImageRawDiskContainerType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ImageRawDiskContainerType other && Equals(other);
        public bool Equals(ImageRawDiskContainerType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the image used to create this disk. The default and only value is RAW
    /// </summary>
    [EnumType]
    public readonly struct ImageSourceType : IEquatable<ImageSourceType>
    {
        private readonly string _value;

        private ImageSourceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ImageSourceType Raw { get; } = new ImageSourceType("RAW");

        public static bool operator ==(ImageSourceType left, ImageSourceType right) => left.Equals(right);
        public static bool operator !=(ImageSourceType left, ImageSourceType right) => !left.Equals(right);

        public static explicit operator string(ImageSourceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ImageSourceType other && Equals(other);
        public bool Equals(ImageSourceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The action to perform in case of zone failure. Only one value is supported, NO_FAILOVER. The default is NO_FAILOVER.
    /// </summary>
    [EnumType]
    public readonly struct InstanceGroupManagerFailoverAction : IEquatable<InstanceGroupManagerFailoverAction>
    {
        private readonly string _value;

        private InstanceGroupManagerFailoverAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InstanceGroupManagerFailoverAction NoFailover { get; } = new InstanceGroupManagerFailoverAction("NO_FAILOVER");
        public static InstanceGroupManagerFailoverAction Unknown { get; } = new InstanceGroupManagerFailoverAction("UNKNOWN");

        public static bool operator ==(InstanceGroupManagerFailoverAction left, InstanceGroupManagerFailoverAction right) => left.Equals(right);
        public static bool operator !=(InstanceGroupManagerFailoverAction left, InstanceGroupManagerFailoverAction right) => !left.Equals(right);

        public static explicit operator string(InstanceGroupManagerFailoverAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceGroupManagerFailoverAction other && Equals(other);
        public bool Equals(InstanceGroupManagerFailoverAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The instance redistribution policy for regional managed instance groups. Valid values are: - PROACTIVE (default): The group attempts to maintain an even distribution of VM instances across zones in the region. - NONE: For non-autoscaled groups, proactive redistribution is disabled. 
    /// </summary>
    [EnumType]
    public readonly struct InstanceGroupManagerUpdatePolicyInstanceRedistributionType : IEquatable<InstanceGroupManagerUpdatePolicyInstanceRedistributionType>
    {
        private readonly string _value;

        private InstanceGroupManagerUpdatePolicyInstanceRedistributionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No action is being proactively performed in order to bring this IGM to its target instance distribution.
        /// </summary>
        public static InstanceGroupManagerUpdatePolicyInstanceRedistributionType None { get; } = new InstanceGroupManagerUpdatePolicyInstanceRedistributionType("NONE");
        /// <summary>
        /// This IGM will actively converge to its target instance distribution.
        /// </summary>
        public static InstanceGroupManagerUpdatePolicyInstanceRedistributionType Proactive { get; } = new InstanceGroupManagerUpdatePolicyInstanceRedistributionType("PROACTIVE");

        public static bool operator ==(InstanceGroupManagerUpdatePolicyInstanceRedistributionType left, InstanceGroupManagerUpdatePolicyInstanceRedistributionType right) => left.Equals(right);
        public static bool operator !=(InstanceGroupManagerUpdatePolicyInstanceRedistributionType left, InstanceGroupManagerUpdatePolicyInstanceRedistributionType right) => !left.Equals(right);

        public static explicit operator string(InstanceGroupManagerUpdatePolicyInstanceRedistributionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceGroupManagerUpdatePolicyInstanceRedistributionType other && Equals(other);
        public bool Equals(InstanceGroupManagerUpdatePolicyInstanceRedistributionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Minimal action to be taken on an instance. You can specify either RESTART to restart existing instances or REPLACE to delete and create new instances from the target template. If you specify a RESTART, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
    /// </summary>
    [EnumType]
    public readonly struct InstanceGroupManagerUpdatePolicyMinimalAction : IEquatable<InstanceGroupManagerUpdatePolicyMinimalAction>
    {
        private readonly string _value;

        private InstanceGroupManagerUpdatePolicyMinimalAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Do not perform any action.
        /// </summary>
        public static InstanceGroupManagerUpdatePolicyMinimalAction None { get; } = new InstanceGroupManagerUpdatePolicyMinimalAction("NONE");
        /// <summary>
        /// Updates applied in runtime, instances will not be disrupted.
        /// </summary>
        public static InstanceGroupManagerUpdatePolicyMinimalAction Refresh { get; } = new InstanceGroupManagerUpdatePolicyMinimalAction("REFRESH");
        /// <summary>
        /// Old instances will be deleted. New instances will be created from the target template.
        /// </summary>
        public static InstanceGroupManagerUpdatePolicyMinimalAction Replace { get; } = new InstanceGroupManagerUpdatePolicyMinimalAction("REPLACE");
        /// <summary>
        /// Every instance will be restarted.
        /// </summary>
        public static InstanceGroupManagerUpdatePolicyMinimalAction Restart { get; } = new InstanceGroupManagerUpdatePolicyMinimalAction("RESTART");

        public static bool operator ==(InstanceGroupManagerUpdatePolicyMinimalAction left, InstanceGroupManagerUpdatePolicyMinimalAction right) => left.Equals(right);
        public static bool operator !=(InstanceGroupManagerUpdatePolicyMinimalAction left, InstanceGroupManagerUpdatePolicyMinimalAction right) => !left.Equals(right);

        public static explicit operator string(InstanceGroupManagerUpdatePolicyMinimalAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceGroupManagerUpdatePolicyMinimalAction other && Equals(other);
        public bool Equals(InstanceGroupManagerUpdatePolicyMinimalAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Most disruptive action that is allowed to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to allow actions that do not need instance restart, RESTART to allow actions that can be applied without instance replacing or REPLACE to allow all possible actions. If the Updater determines that the minimal update action needed is more disruptive than most disruptive allowed action you specify it will not perform the update at all.
    /// </summary>
    [EnumType]
    public readonly struct InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction : IEquatable<InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction>
    {
        private readonly string _value;

        private InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Do not perform any action.
        /// </summary>
        public static InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction None { get; } = new InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction("NONE");
        /// <summary>
        /// Updates applied in runtime, instances will not be disrupted.
        /// </summary>
        public static InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction Refresh { get; } = new InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction("REFRESH");
        /// <summary>
        /// Old instances will be deleted. New instances will be created from the target template.
        /// </summary>
        public static InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction Replace { get; } = new InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction("REPLACE");
        /// <summary>
        /// Every instance will be restarted.
        /// </summary>
        public static InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction Restart { get; } = new InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction("RESTART");

        public static bool operator ==(InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction left, InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction right) => left.Equals(right);
        public static bool operator !=(InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction left, InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction right) => !left.Equals(right);

        public static explicit operator string(InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction other && Equals(other);
        public bool Equals(InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// What action should be used to replace instances. See minimal_action.REPLACE
    /// </summary>
    [EnumType]
    public readonly struct InstanceGroupManagerUpdatePolicyReplacementMethod : IEquatable<InstanceGroupManagerUpdatePolicyReplacementMethod>
    {
        private readonly string _value;

        private InstanceGroupManagerUpdatePolicyReplacementMethod(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Instances will be recreated (with the same name)
        /// </summary>
        public static InstanceGroupManagerUpdatePolicyReplacementMethod Recreate { get; } = new InstanceGroupManagerUpdatePolicyReplacementMethod("RECREATE");
        /// <summary>
        /// Default option: instances will be deleted and created (with a new name)
        /// </summary>
        public static InstanceGroupManagerUpdatePolicyReplacementMethod Substitute { get; } = new InstanceGroupManagerUpdatePolicyReplacementMethod("SUBSTITUTE");

        public static bool operator ==(InstanceGroupManagerUpdatePolicyReplacementMethod left, InstanceGroupManagerUpdatePolicyReplacementMethod right) => left.Equals(right);
        public static bool operator !=(InstanceGroupManagerUpdatePolicyReplacementMethod left, InstanceGroupManagerUpdatePolicyReplacementMethod right) => !left.Equals(right);

        public static explicit operator string(InstanceGroupManagerUpdatePolicyReplacementMethod value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceGroupManagerUpdatePolicyReplacementMethod other && Equals(other);
        public bool Equals(InstanceGroupManagerUpdatePolicyReplacementMethod other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of update process. You can specify either PROACTIVE so that the instance group manager proactively executes actions in order to bring instances to their target versions or OPPORTUNISTIC so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
    /// </summary>
    [EnumType]
    public readonly struct InstanceGroupManagerUpdatePolicyType : IEquatable<InstanceGroupManagerUpdatePolicyType>
    {
        private readonly string _value;

        private InstanceGroupManagerUpdatePolicyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No action is being proactively performed in order to bring this IGM to its target version distribution (regardless of whether this distribution is expressed using instanceTemplate or versions field).
        /// </summary>
        public static InstanceGroupManagerUpdatePolicyType Opportunistic { get; } = new InstanceGroupManagerUpdatePolicyType("OPPORTUNISTIC");
        /// <summary>
        /// This IGM will actively converge to its target version distribution (regardless of whether this distribution is expressed using instanceTemplate or versions field).
        /// </summary>
        public static InstanceGroupManagerUpdatePolicyType Proactive { get; } = new InstanceGroupManagerUpdatePolicyType("PROACTIVE");

        public static bool operator ==(InstanceGroupManagerUpdatePolicyType left, InstanceGroupManagerUpdatePolicyType right) => left.Equals(right);
        public static bool operator !=(InstanceGroupManagerUpdatePolicyType left, InstanceGroupManagerUpdatePolicyType right) => !left.Equals(right);

        public static explicit operator string(InstanceGroupManagerUpdatePolicyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceGroupManagerUpdatePolicyType other && Equals(other);
        public bool Equals(InstanceGroupManagerUpdatePolicyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// PostKeyRevocationActionType of the instance.
    /// </summary>
    [EnumType]
    public readonly struct InstancePostKeyRevocationActionType : IEquatable<InstancePostKeyRevocationActionType>
    {
        private readonly string _value;

        private InstancePostKeyRevocationActionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Indicates user chose no operation.
        /// </summary>
        public static InstancePostKeyRevocationActionType Noop { get; } = new InstancePostKeyRevocationActionType("NOOP");
        /// <summary>
        /// Default value. This value is unused.
        /// </summary>
        public static InstancePostKeyRevocationActionType PostKeyRevocationActionTypeUnspecified { get; } = new InstancePostKeyRevocationActionType("POST_KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED");
        /// <summary>
        /// Indicates user chose to opt for VM shutdown on key revocation.
        /// </summary>
        public static InstancePostKeyRevocationActionType Shutdown { get; } = new InstancePostKeyRevocationActionType("SHUTDOWN");

        public static bool operator ==(InstancePostKeyRevocationActionType left, InstancePostKeyRevocationActionType right) => left.Equals(right);
        public static bool operator !=(InstancePostKeyRevocationActionType left, InstancePostKeyRevocationActionType right) => !left.Equals(right);

        public static explicit operator string(InstancePostKeyRevocationActionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstancePostKeyRevocationActionType other && Equals(other);
        public bool Equals(InstancePostKeyRevocationActionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The private IPv6 google access type for the VM. If not specified, use INHERIT_FROM_SUBNETWORK as default.
    /// </summary>
    [EnumType]
    public readonly struct InstancePrivateIpv6GoogleAccess : IEquatable<InstancePrivateIpv6GoogleAccess>
    {
        private readonly string _value;

        private InstancePrivateIpv6GoogleAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Bidirectional private IPv6 access to/from Google services. If specified, the subnetwork who is attached to the instance's default network interface will be assigned an internal IPv6 prefix if it doesn't have before.
        /// </summary>
        public static InstancePrivateIpv6GoogleAccess EnableBidirectionalAccessToGoogle { get; } = new InstancePrivateIpv6GoogleAccess("ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE");
        /// <summary>
        /// Outbound private IPv6 access from VMs in this subnet to Google services. If specified, the subnetwork who is attached to the instance's default network interface will be assigned an internal IPv6 prefix if it doesn't have before.
        /// </summary>
        public static InstancePrivateIpv6GoogleAccess EnableOutboundVmAccessToGoogle { get; } = new InstancePrivateIpv6GoogleAccess("ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE");
        /// <summary>
        /// Each network interface inherits PrivateIpv6GoogleAccess from its subnetwork.
        /// </summary>
        public static InstancePrivateIpv6GoogleAccess InheritFromSubnetwork { get; } = new InstancePrivateIpv6GoogleAccess("INHERIT_FROM_SUBNETWORK");

        public static bool operator ==(InstancePrivateIpv6GoogleAccess left, InstancePrivateIpv6GoogleAccess right) => left.Equals(right);
        public static bool operator !=(InstancePrivateIpv6GoogleAccess left, InstancePrivateIpv6GoogleAccess right) => !left.Equals(right);

        public static explicit operator string(InstancePrivateIpv6GoogleAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstancePrivateIpv6GoogleAccess other && Equals(other);
        public bool Equals(InstancePrivateIpv6GoogleAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// PostKeyRevocationActionType of the instance.
    /// </summary>
    [EnumType]
    public readonly struct InstancePropertiesPostKeyRevocationActionType : IEquatable<InstancePropertiesPostKeyRevocationActionType>
    {
        private readonly string _value;

        private InstancePropertiesPostKeyRevocationActionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Indicates user chose no operation.
        /// </summary>
        public static InstancePropertiesPostKeyRevocationActionType Noop { get; } = new InstancePropertiesPostKeyRevocationActionType("NOOP");
        /// <summary>
        /// Default value. This value is unused.
        /// </summary>
        public static InstancePropertiesPostKeyRevocationActionType PostKeyRevocationActionTypeUnspecified { get; } = new InstancePropertiesPostKeyRevocationActionType("POST_KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED");
        /// <summary>
        /// Indicates user chose to opt for VM shutdown on key revocation.
        /// </summary>
        public static InstancePropertiesPostKeyRevocationActionType Shutdown { get; } = new InstancePropertiesPostKeyRevocationActionType("SHUTDOWN");

        public static bool operator ==(InstancePropertiesPostKeyRevocationActionType left, InstancePropertiesPostKeyRevocationActionType right) => left.Equals(right);
        public static bool operator !=(InstancePropertiesPostKeyRevocationActionType left, InstancePropertiesPostKeyRevocationActionType right) => !left.Equals(right);

        public static explicit operator string(InstancePropertiesPostKeyRevocationActionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstancePropertiesPostKeyRevocationActionType other && Equals(other);
        public bool Equals(InstancePropertiesPostKeyRevocationActionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The private IPv6 google access type for VMs. If not specified, use INHERIT_FROM_SUBNETWORK as default. Note that for MachineImage, this is not supported yet.
    /// </summary>
    [EnumType]
    public readonly struct InstancePropertiesPrivateIpv6GoogleAccess : IEquatable<InstancePropertiesPrivateIpv6GoogleAccess>
    {
        private readonly string _value;

        private InstancePropertiesPrivateIpv6GoogleAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Bidirectional private IPv6 access to/from Google services. If specified, the subnetwork who is attached to the instance's default network interface will be assigned an internal IPv6 prefix if it doesn't have before.
        /// </summary>
        public static InstancePropertiesPrivateIpv6GoogleAccess EnableBidirectionalAccessToGoogle { get; } = new InstancePropertiesPrivateIpv6GoogleAccess("ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE");
        /// <summary>
        /// Outbound private IPv6 access from VMs in this subnet to Google services. If specified, the subnetwork who is attached to the instance's default network interface will be assigned an internal IPv6 prefix if it doesn't have before.
        /// </summary>
        public static InstancePropertiesPrivateIpv6GoogleAccess EnableOutboundVmAccessToGoogle { get; } = new InstancePropertiesPrivateIpv6GoogleAccess("ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE");
        /// <summary>
        /// Each network interface inherits PrivateIpv6GoogleAccess from its subnetwork.
        /// </summary>
        public static InstancePropertiesPrivateIpv6GoogleAccess InheritFromSubnetwork { get; } = new InstancePropertiesPrivateIpv6GoogleAccess("INHERIT_FROM_SUBNETWORK");

        public static bool operator ==(InstancePropertiesPrivateIpv6GoogleAccess left, InstancePropertiesPrivateIpv6GoogleAccess right) => left.Equals(right);
        public static bool operator !=(InstancePropertiesPrivateIpv6GoogleAccess left, InstancePropertiesPrivateIpv6GoogleAccess right) => !left.Equals(right);

        public static explicit operator string(InstancePropertiesPrivateIpv6GoogleAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstancePropertiesPrivateIpv6GoogleAccess other && Equals(other);
        public bool Equals(InstancePropertiesPrivateIpv6GoogleAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Provisioned bandwidth capacity for the interconnect attachment. For attachments of type DEDICATED, the user can set the bandwidth. For attachments of type PARTNER, the Google Partner that is operating the interconnect must set the bandwidth. Output only for PARTNER type, mutable for PARTNER_PROVIDER and DEDICATED, and can take one of the following values: - BPS_50M: 50 Mbit/s - BPS_100M: 100 Mbit/s - BPS_200M: 200 Mbit/s - BPS_300M: 300 Mbit/s - BPS_400M: 400 Mbit/s - BPS_500M: 500 Mbit/s - BPS_1G: 1 Gbit/s - BPS_2G: 2 Gbit/s - BPS_5G: 5 Gbit/s - BPS_10G: 10 Gbit/s - BPS_20G: 20 Gbit/s - BPS_50G: 50 Gbit/s 
    /// </summary>
    [EnumType]
    public readonly struct InterconnectAttachmentBandwidth : IEquatable<InterconnectAttachmentBandwidth>
    {
        private readonly string _value;

        private InterconnectAttachmentBandwidth(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// 100 Mbit/s
        /// </summary>
        public static InterconnectAttachmentBandwidth Bps100m { get; } = new InterconnectAttachmentBandwidth("BPS_100M");
        /// <summary>
        /// 10 Gbit/s
        /// </summary>
        public static InterconnectAttachmentBandwidth Bps10g { get; } = new InterconnectAttachmentBandwidth("BPS_10G");
        /// <summary>
        /// 1 Gbit/s
        /// </summary>
        public static InterconnectAttachmentBandwidth Bps1g { get; } = new InterconnectAttachmentBandwidth("BPS_1G");
        /// <summary>
        /// 200 Mbit/s
        /// </summary>
        public static InterconnectAttachmentBandwidth Bps200m { get; } = new InterconnectAttachmentBandwidth("BPS_200M");
        /// <summary>
        /// 20 Gbit/s
        /// </summary>
        public static InterconnectAttachmentBandwidth Bps20g { get; } = new InterconnectAttachmentBandwidth("BPS_20G");
        /// <summary>
        /// 2 Gbit/s
        /// </summary>
        public static InterconnectAttachmentBandwidth Bps2g { get; } = new InterconnectAttachmentBandwidth("BPS_2G");
        /// <summary>
        /// 300 Mbit/s
        /// </summary>
        public static InterconnectAttachmentBandwidth Bps300m { get; } = new InterconnectAttachmentBandwidth("BPS_300M");
        /// <summary>
        /// 400 Mbit/s
        /// </summary>
        public static InterconnectAttachmentBandwidth Bps400m { get; } = new InterconnectAttachmentBandwidth("BPS_400M");
        /// <summary>
        /// 500 Mbit/s
        /// </summary>
        public static InterconnectAttachmentBandwidth Bps500m { get; } = new InterconnectAttachmentBandwidth("BPS_500M");
        /// <summary>
        /// 50 Gbit/s
        /// </summary>
        public static InterconnectAttachmentBandwidth Bps50g { get; } = new InterconnectAttachmentBandwidth("BPS_50G");
        /// <summary>
        /// 50 Mbit/s
        /// </summary>
        public static InterconnectAttachmentBandwidth Bps50m { get; } = new InterconnectAttachmentBandwidth("BPS_50M");
        /// <summary>
        /// 5 Gbit/s
        /// </summary>
        public static InterconnectAttachmentBandwidth Bps5g { get; } = new InterconnectAttachmentBandwidth("BPS_5G");

        public static bool operator ==(InterconnectAttachmentBandwidth left, InterconnectAttachmentBandwidth right) => left.Equals(right);
        public static bool operator !=(InterconnectAttachmentBandwidth left, InterconnectAttachmentBandwidth right) => !left.Equals(right);

        public static explicit operator string(InterconnectAttachmentBandwidth value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InterconnectAttachmentBandwidth other && Equals(other);
        public bool Equals(InterconnectAttachmentBandwidth other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Desired availability domain for the attachment. Only available for type PARTNER, at creation time, and can take one of the following values: - AVAILABILITY_DOMAIN_ANY - AVAILABILITY_DOMAIN_1 - AVAILABILITY_DOMAIN_2 For improved reliability, customers should configure a pair of attachments, one per availability domain. The selected availability domain will be provided to the Partner via the pairing key, so that the provisioned circuit will lie in the specified domain. If not specified, the value will default to AVAILABILITY_DOMAIN_ANY.
    /// </summary>
    [EnumType]
    public readonly struct InterconnectAttachmentEdgeAvailabilityDomain : IEquatable<InterconnectAttachmentEdgeAvailabilityDomain>
    {
        private readonly string _value;

        private InterconnectAttachmentEdgeAvailabilityDomain(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InterconnectAttachmentEdgeAvailabilityDomain AvailabilityDomain1 { get; } = new InterconnectAttachmentEdgeAvailabilityDomain("AVAILABILITY_DOMAIN_1");
        public static InterconnectAttachmentEdgeAvailabilityDomain AvailabilityDomain2 { get; } = new InterconnectAttachmentEdgeAvailabilityDomain("AVAILABILITY_DOMAIN_2");
        public static InterconnectAttachmentEdgeAvailabilityDomain AvailabilityDomainAny { get; } = new InterconnectAttachmentEdgeAvailabilityDomain("AVAILABILITY_DOMAIN_ANY");

        public static bool operator ==(InterconnectAttachmentEdgeAvailabilityDomain left, InterconnectAttachmentEdgeAvailabilityDomain right) => left.Equals(right);
        public static bool operator !=(InterconnectAttachmentEdgeAvailabilityDomain left, InterconnectAttachmentEdgeAvailabilityDomain right) => !left.Equals(right);

        public static explicit operator string(InterconnectAttachmentEdgeAvailabilityDomain value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InterconnectAttachmentEdgeAvailabilityDomain other && Equals(other);
        public bool Equals(InterconnectAttachmentEdgeAvailabilityDomain other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates the user-supplied encryption option of this VLAN attachment (interconnectAttachment). Can only be specified at attachment creation for PARTNER or DEDICATED attachments. Possible values are: - NONE - This is the default value, which means that the VLAN attachment carries unencrypted traffic. VMs are able to send traffic to, or receive traffic from, such a VLAN attachment. - IPSEC - The VLAN attachment carries only encrypted traffic that is encrypted by an IPsec device, such as an HA VPN gateway or third-party IPsec VPN. VMs cannot directly send traffic to, or receive traffic from, such a VLAN attachment. To use *IPsec-encrypted Cloud Interconnect*, the VLAN attachment must be created with this option. Not currently available publicly. 
    /// </summary>
    [EnumType]
    public readonly struct InterconnectAttachmentEncryption : IEquatable<InterconnectAttachmentEncryption>
    {
        private readonly string _value;

        private InterconnectAttachmentEncryption(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The interconnect attachment will carry only encrypted traffic that is encrypted by an IPsec device such as HA VPN gateway; VMs cannot directly send traffic to or receive traffic from such an interconnect attachment. To use IPsec-encrypted Cloud Interconnect, the interconnect attachment must be created with this option.
        /// </summary>
        public static InterconnectAttachmentEncryption Ipsec { get; } = new InterconnectAttachmentEncryption("IPSEC");
        /// <summary>
        /// This is the default value, which means the Interconnect Attachment will carry unencrypted traffic. VMs will be able to send traffic to or receive traffic from such interconnect attachment.
        /// </summary>
        public static InterconnectAttachmentEncryption None { get; } = new InterconnectAttachmentEncryption("NONE");

        public static bool operator ==(InterconnectAttachmentEncryption left, InterconnectAttachmentEncryption right) => left.Equals(right);
        public static bool operator !=(InterconnectAttachmentEncryption left, InterconnectAttachmentEncryption right) => !left.Equals(right);

        public static explicit operator string(InterconnectAttachmentEncryption value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InterconnectAttachmentEncryption other && Equals(other);
        public bool Equals(InterconnectAttachmentEncryption other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The stack type for this interconnect attachment to identify whether the IPv6 feature is enabled or not. If not specified, IPV4_ONLY will be used. This field can be both set at interconnect attachments creation and update interconnect attachment operations.
    /// </summary>
    [EnumType]
    public readonly struct InterconnectAttachmentStackType : IEquatable<InterconnectAttachmentStackType>
    {
        private readonly string _value;

        private InterconnectAttachmentStackType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The interconnect attachment can have both IPv4 and IPv6 addresses.
        /// </summary>
        public static InterconnectAttachmentStackType Ipv4Ipv6 { get; } = new InterconnectAttachmentStackType("IPV4_IPV6");
        /// <summary>
        /// The interconnect attachment will only be assigned IPv4 addresses.
        /// </summary>
        public static InterconnectAttachmentStackType Ipv4Only { get; } = new InterconnectAttachmentStackType("IPV4_ONLY");

        public static bool operator ==(InterconnectAttachmentStackType left, InterconnectAttachmentStackType right) => left.Equals(right);
        public static bool operator !=(InterconnectAttachmentStackType left, InterconnectAttachmentStackType right) => !left.Equals(right);

        public static explicit operator string(InterconnectAttachmentStackType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InterconnectAttachmentStackType other && Equals(other);
        public bool Equals(InterconnectAttachmentStackType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of interconnect attachment this is, which can take one of the following values: - DEDICATED: an attachment to a Dedicated Interconnect. - PARTNER: an attachment to a Partner Interconnect, created by the customer. - PARTNER_PROVIDER: an attachment to a Partner Interconnect, created by the partner. 
    /// </summary>
    [EnumType]
    public readonly struct InterconnectAttachmentType : IEquatable<InterconnectAttachmentType>
    {
        private readonly string _value;

        private InterconnectAttachmentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Attachment to a dedicated interconnect.
        /// </summary>
        public static InterconnectAttachmentType Dedicated { get; } = new InterconnectAttachmentType("DEDICATED");
        /// <summary>
        /// Attachment to a partner interconnect, created by the customer.
        /// </summary>
        public static InterconnectAttachmentType Partner { get; } = new InterconnectAttachmentType("PARTNER");
        /// <summary>
        /// Attachment to a partner interconnect, created by the partner.
        /// </summary>
        public static InterconnectAttachmentType PartnerProvider { get; } = new InterconnectAttachmentType("PARTNER_PROVIDER");

        public static bool operator ==(InterconnectAttachmentType left, InterconnectAttachmentType right) => left.Equals(right);
        public static bool operator !=(InterconnectAttachmentType left, InterconnectAttachmentType right) => !left.Equals(right);

        public static explicit operator string(InterconnectAttachmentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InterconnectAttachmentType other && Equals(other);
        public bool Equals(InterconnectAttachmentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of interconnect, which can take one of the following values: - PARTNER: A partner-managed interconnection shared between customers though a partner. - DEDICATED: A dedicated physical interconnection with the customer. Note that a value IT_PRIVATE has been deprecated in favor of DEDICATED.
    /// </summary>
    [EnumType]
    public readonly struct InterconnectInterconnectType : IEquatable<InterconnectInterconnectType>
    {
        private readonly string _value;

        private InterconnectInterconnectType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// A dedicated physical interconnection with the customer.
        /// </summary>
        public static InterconnectInterconnectType Dedicated { get; } = new InterconnectInterconnectType("DEDICATED");
        /// <summary>
        /// [Deprecated] A private, physical interconnection with the customer.
        /// </summary>
        public static InterconnectInterconnectType ItPrivate { get; } = new InterconnectInterconnectType("IT_PRIVATE");
        /// <summary>
        /// A partner-managed interconnection shared between customers via partner.
        /// </summary>
        public static InterconnectInterconnectType Partner { get; } = new InterconnectInterconnectType("PARTNER");

        public static bool operator ==(InterconnectInterconnectType left, InterconnectInterconnectType right) => left.Equals(right);
        public static bool operator !=(InterconnectInterconnectType left, InterconnectInterconnectType right) => !left.Equals(right);

        public static explicit operator string(InterconnectInterconnectType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InterconnectInterconnectType other && Equals(other);
        public bool Equals(InterconnectInterconnectType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of link requested, which can take one of the following values: - LINK_TYPE_ETHERNET_10G_LR: A 10G Ethernet with LR optics - LINK_TYPE_ETHERNET_100G_LR: A 100G Ethernet with LR optics. Note that this field indicates the speed of each of the links in the bundle, not the speed of the entire bundle.
    /// </summary>
    [EnumType]
    public readonly struct InterconnectLinkType : IEquatable<InterconnectLinkType>
    {
        private readonly string _value;

        private InterconnectLinkType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// 100G Ethernet, LR Optics.
        /// </summary>
        public static InterconnectLinkType LinkTypeEthernet100gLr { get; } = new InterconnectLinkType("LINK_TYPE_ETHERNET_100G_LR");
        /// <summary>
        /// 10G Ethernet, LR Optics. [(rate_bps) = 10000000000];
        /// </summary>
        public static InterconnectLinkType LinkTypeEthernet10gLr { get; } = new InterconnectLinkType("LINK_TYPE_ETHERNET_10G_LR");

        public static bool operator ==(InterconnectLinkType left, InterconnectLinkType right) => left.Equals(right);
        public static bool operator !=(InterconnectLinkType left, InterconnectLinkType right) => !left.Equals(right);

        public static explicit operator string(InterconnectLinkType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InterconnectLinkType other && Equals(other);
        public bool Equals(InterconnectLinkType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This is deprecated and has no effect. Do not use.
    /// </summary>
    [EnumType]
    public readonly struct LogConfigCloudAuditOptionsLogName : IEquatable<LogConfigCloudAuditOptionsLogName>
    {
        private readonly string _value;

        private LogConfigCloudAuditOptionsLogName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static LogConfigCloudAuditOptionsLogName AdminActivity { get; } = new LogConfigCloudAuditOptionsLogName("ADMIN_ACTIVITY");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static LogConfigCloudAuditOptionsLogName DataAccess { get; } = new LogConfigCloudAuditOptionsLogName("DATA_ACCESS");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static LogConfigCloudAuditOptionsLogName UnspecifiedLogName { get; } = new LogConfigCloudAuditOptionsLogName("UNSPECIFIED_LOG_NAME");

        public static bool operator ==(LogConfigCloudAuditOptionsLogName left, LogConfigCloudAuditOptionsLogName right) => left.Equals(right);
        public static bool operator !=(LogConfigCloudAuditOptionsLogName left, LogConfigCloudAuditOptionsLogName right) => !left.Equals(right);

        public static explicit operator string(LogConfigCloudAuditOptionsLogName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LogConfigCloudAuditOptionsLogName other && Equals(other);
        public bool Equals(LogConfigCloudAuditOptionsLogName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This is deprecated and has no effect. Do not use.
    /// </summary>
    [EnumType]
    public readonly struct LogConfigDataAccessOptionsLogMode : IEquatable<LogConfigDataAccessOptionsLogMode>
    {
        private readonly string _value;

        private LogConfigDataAccessOptionsLogMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static LogConfigDataAccessOptionsLogMode LogFailClosed { get; } = new LogConfigDataAccessOptionsLogMode("LOG_FAIL_CLOSED");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static LogConfigDataAccessOptionsLogMode LogModeUnspecified { get; } = new LogConfigDataAccessOptionsLogMode("LOG_MODE_UNSPECIFIED");

        public static bool operator ==(LogConfigDataAccessOptionsLogMode left, LogConfigDataAccessOptionsLogMode right) => left.Equals(right);
        public static bool operator !=(LogConfigDataAccessOptionsLogMode left, LogConfigDataAccessOptionsLogMode right) => !left.Equals(right);

        public static explicit operator string(LogConfigDataAccessOptionsLogMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LogConfigDataAccessOptionsLogMode other && Equals(other);
        public bool Equals(LogConfigDataAccessOptionsLogMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how individual filter label matches within the list of filterLabels and contributes toward the overall metadataFilter match. Supported values are: - MATCH_ANY: at least one of the filterLabels must have a matching label in the provided metadata. - MATCH_ALL: all filterLabels must have matching labels in the provided metadata. 
    /// </summary>
    [EnumType]
    public readonly struct MetadataFilterFilterMatchCriteria : IEquatable<MetadataFilterFilterMatchCriteria>
    {
        private readonly string _value;

        private MetadataFilterFilterMatchCriteria(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Specifies that all filterLabels must match for the metadataFilter to be considered a match.
        /// </summary>
        public static MetadataFilterFilterMatchCriteria MatchAll { get; } = new MetadataFilterFilterMatchCriteria("MATCH_ALL");
        /// <summary>
        /// Specifies that any filterLabel must match for the metadataFilter to be considered a match.
        /// </summary>
        public static MetadataFilterFilterMatchCriteria MatchAny { get; } = new MetadataFilterFilterMatchCriteria("MATCH_ANY");
        /// <summary>
        /// Indicates that the match criteria was not set. A metadataFilter must never be created with this value.
        /// </summary>
        public static MetadataFilterFilterMatchCriteria NotSet { get; } = new MetadataFilterFilterMatchCriteria("NOT_SET");

        public static bool operator ==(MetadataFilterFilterMatchCriteria left, MetadataFilterFilterMatchCriteria right) => left.Equals(right);
        public static bool operator !=(MetadataFilterFilterMatchCriteria left, MetadataFilterFilterMatchCriteria right) => !left.Equals(right);

        public static explicit operator string(MetadataFilterFilterMatchCriteria value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MetadataFilterFilterMatchCriteria other && Equals(other);
        public bool Equals(MetadataFilterFilterMatchCriteria other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of network endpoints in this network endpoint group. Can be one of GCE_VM_IP_PORT, NON_GCP_PRIVATE_IP_PORT, INTERNET_FQDN_PORT, INTERNET_IP_PORT, SERVERLESS, PRIVATE_SERVICE_CONNECT.
    /// </summary>
    [EnumType]
    public readonly struct NetworkEndpointGroupNetworkEndpointType : IEquatable<NetworkEndpointGroupNetworkEndpointType>
    {
        private readonly string _value;

        private NetworkEndpointGroupNetworkEndpointType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The network endpoint is represented by an IP address.
        /// </summary>
        public static NetworkEndpointGroupNetworkEndpointType GceVmIp { get; } = new NetworkEndpointGroupNetworkEndpointType("GCE_VM_IP");
        /// <summary>
        /// The network endpoint is represented by IP address and port pair.
        /// </summary>
        public static NetworkEndpointGroupNetworkEndpointType GceVmIpPort { get; } = new NetworkEndpointGroupNetworkEndpointType("GCE_VM_IP_PORT");
        /// <summary>
        /// The network endpoint is represented by fully qualified domain name and port.
        /// </summary>
        public static NetworkEndpointGroupNetworkEndpointType InternetFqdnPort { get; } = new NetworkEndpointGroupNetworkEndpointType("INTERNET_FQDN_PORT");
        /// <summary>
        /// The network endpoint is represented by an internet IP address and port.
        /// </summary>
        public static NetworkEndpointGroupNetworkEndpointType InternetIpPort { get; } = new NetworkEndpointGroupNetworkEndpointType("INTERNET_IP_PORT");
        /// <summary>
        /// The network endpoint is represented by an IP address and port. The endpoint belongs to a VM or pod running in a customer's on-premises.
        /// </summary>
        public static NetworkEndpointGroupNetworkEndpointType NonGcpPrivateIpPort { get; } = new NetworkEndpointGroupNetworkEndpointType("NON_GCP_PRIVATE_IP_PORT");
        /// <summary>
        /// The network endpoint is either public Google APIs or services exposed by other GCP Project with a Service Attachment. The connection is set up by private service connect
        /// </summary>
        public static NetworkEndpointGroupNetworkEndpointType PrivateServiceConnect { get; } = new NetworkEndpointGroupNetworkEndpointType("PRIVATE_SERVICE_CONNECT");
        /// <summary>
        /// The network endpoint is handled by specified serverless infrastructure.
        /// </summary>
        public static NetworkEndpointGroupNetworkEndpointType Serverless { get; } = new NetworkEndpointGroupNetworkEndpointType("SERVERLESS");

        public static bool operator ==(NetworkEndpointGroupNetworkEndpointType left, NetworkEndpointGroupNetworkEndpointType right) => left.Equals(right);
        public static bool operator !=(NetworkEndpointGroupNetworkEndpointType left, NetworkEndpointGroupNetworkEndpointType right) => !left.Equals(right);

        public static explicit operator string(NetworkEndpointGroupNetworkEndpointType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkEndpointGroupNetworkEndpointType other && Equals(other);
        public bool Equals(NetworkEndpointGroupNetworkEndpointType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of vNIC to be used on this interface. This may be gVNIC or VirtioNet.
    /// </summary>
    [EnumType]
    public readonly struct NetworkInterfaceNicType : IEquatable<NetworkInterfaceNicType>
    {
        private readonly string _value;

        private NetworkInterfaceNicType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// GVNIC
        /// </summary>
        public static NetworkInterfaceNicType Gvnic { get; } = new NetworkInterfaceNicType("GVNIC");
        /// <summary>
        /// No type specified.
        /// </summary>
        public static NetworkInterfaceNicType UnspecifiedNicType { get; } = new NetworkInterfaceNicType("UNSPECIFIED_NIC_TYPE");
        /// <summary>
        /// VIRTIO
        /// </summary>
        public static NetworkInterfaceNicType VirtioNet { get; } = new NetworkInterfaceNicType("VIRTIO_NET");

        public static bool operator ==(NetworkInterfaceNicType left, NetworkInterfaceNicType right) => left.Equals(right);
        public static bool operator !=(NetworkInterfaceNicType left, NetworkInterfaceNicType right) => !left.Equals(right);

        public static explicit operator string(NetworkInterfaceNicType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkInterfaceNicType other && Equals(other);
        public bool Equals(NetworkInterfaceNicType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The stack type for this network interface to identify whether the IPv6 feature is enabled or not. If not specified, IPV4_ONLY will be used. This field can be both set at instance creation and update network interface operations.
    /// </summary>
    [EnumType]
    public readonly struct NetworkInterfaceStackType : IEquatable<NetworkInterfaceStackType>
    {
        private readonly string _value;

        private NetworkInterfaceStackType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The network interface can have both IPv4 and IPv6 addresses.
        /// </summary>
        public static NetworkInterfaceStackType Ipv4Ipv6 { get; } = new NetworkInterfaceStackType("IPV4_IPV6");
        /// <summary>
        /// The network interface will be assigned IPv4 address.
        /// </summary>
        public static NetworkInterfaceStackType Ipv4Only { get; } = new NetworkInterfaceStackType("IPV4_ONLY");
        public static NetworkInterfaceStackType UnspecifiedStackType { get; } = new NetworkInterfaceStackType("UNSPECIFIED_STACK_TYPE");

        public static bool operator ==(NetworkInterfaceStackType left, NetworkInterfaceStackType right) => left.Equals(right);
        public static bool operator !=(NetworkInterfaceStackType left, NetworkInterfaceStackType right) => !left.Equals(right);

        public static explicit operator string(NetworkInterfaceStackType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkInterfaceStackType other && Equals(other);
        public bool Equals(NetworkInterfaceStackType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct NetworkPerformanceConfigTotalEgressBandwidthTier : IEquatable<NetworkPerformanceConfigTotalEgressBandwidthTier>
    {
        private readonly string _value;

        private NetworkPerformanceConfigTotalEgressBandwidthTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NetworkPerformanceConfigTotalEgressBandwidthTier Default { get; } = new NetworkPerformanceConfigTotalEgressBandwidthTier("DEFAULT");
        public static NetworkPerformanceConfigTotalEgressBandwidthTier Tier1 { get; } = new NetworkPerformanceConfigTotalEgressBandwidthTier("TIER_1");

        public static bool operator ==(NetworkPerformanceConfigTotalEgressBandwidthTier left, NetworkPerformanceConfigTotalEgressBandwidthTier right) => left.Equals(right);
        public static bool operator !=(NetworkPerformanceConfigTotalEgressBandwidthTier left, NetworkPerformanceConfigTotalEgressBandwidthTier right) => !left.Equals(right);

        public static explicit operator string(NetworkPerformanceConfigTotalEgressBandwidthTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkPerformanceConfigTotalEgressBandwidthTier other && Equals(other);
        public bool Equals(NetworkPerformanceConfigTotalEgressBandwidthTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The network-wide routing mode to use. If set to REGIONAL, this network's Cloud Routers will only advertise routes with subnets of this network in the same region as the router. If set to GLOBAL, this network's Cloud Routers will advertise routes with all subnets of this network, across regions.
    /// </summary>
    [EnumType]
    public readonly struct NetworkRoutingConfigRoutingMode : IEquatable<NetworkRoutingConfigRoutingMode>
    {
        private readonly string _value;

        private NetworkRoutingConfigRoutingMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NetworkRoutingConfigRoutingMode Global { get; } = new NetworkRoutingConfigRoutingMode("GLOBAL");
        public static NetworkRoutingConfigRoutingMode Regional { get; } = new NetworkRoutingConfigRoutingMode("REGIONAL");

        public static bool operator ==(NetworkRoutingConfigRoutingMode left, NetworkRoutingConfigRoutingMode right) => left.Equals(right);
        public static bool operator !=(NetworkRoutingConfigRoutingMode left, NetworkRoutingConfigRoutingMode right) => !left.Equals(right);

        public static explicit operator string(NetworkRoutingConfigRoutingMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkRoutingConfigRoutingMode other && Equals(other);
        public bool Equals(NetworkRoutingConfigRoutingMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The autoscaling mode. Set to one of: ON, OFF, or ONLY_SCALE_OUT. For more information, see Autoscaler modes.
    /// </summary>
    [EnumType]
    public readonly struct NodeGroupAutoscalingPolicyMode : IEquatable<NodeGroupAutoscalingPolicyMode>
    {
        private readonly string _value;

        private NodeGroupAutoscalingPolicyMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NodeGroupAutoscalingPolicyMode ModeUnspecified { get; } = new NodeGroupAutoscalingPolicyMode("MODE_UNSPECIFIED");
        /// <summary>
        /// Autoscaling is disabled.
        /// </summary>
        public static NodeGroupAutoscalingPolicyMode Off { get; } = new NodeGroupAutoscalingPolicyMode("OFF");
        /// <summary>
        /// Autocaling is fully enabled.
        /// </summary>
        public static NodeGroupAutoscalingPolicyMode On { get; } = new NodeGroupAutoscalingPolicyMode("ON");
        /// <summary>
        /// Autoscaling will only scale out and will not remove nodes.
        /// </summary>
        public static NodeGroupAutoscalingPolicyMode OnlyScaleOut { get; } = new NodeGroupAutoscalingPolicyMode("ONLY_SCALE_OUT");

        public static bool operator ==(NodeGroupAutoscalingPolicyMode left, NodeGroupAutoscalingPolicyMode right) => left.Equals(right);
        public static bool operator !=(NodeGroupAutoscalingPolicyMode left, NodeGroupAutoscalingPolicyMode right) => !left.Equals(right);

        public static explicit operator string(NodeGroupAutoscalingPolicyMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NodeGroupAutoscalingPolicyMode other && Equals(other);
        public bool Equals(NodeGroupAutoscalingPolicyMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how to handle instances when a node in the group undergoes maintenance. Set to one of: DEFAULT, RESTART_IN_PLACE, or MIGRATE_WITHIN_NODE_GROUP. The default value is DEFAULT. For more information, see Maintenance policies.
    /// </summary>
    [EnumType]
    public readonly struct NodeGroupMaintenancePolicy : IEquatable<NodeGroupMaintenancePolicy>
    {
        private readonly string _value;

        private NodeGroupMaintenancePolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Allow the node and corresponding instances to retain default maintenance behavior.
        /// </summary>
        public static NodeGroupMaintenancePolicy Default { get; } = new NodeGroupMaintenancePolicy("DEFAULT");
        public static NodeGroupMaintenancePolicy MaintenancePolicyUnspecified { get; } = new NodeGroupMaintenancePolicy("MAINTENANCE_POLICY_UNSPECIFIED");
        /// <summary>
        /// When maintenance must be done on a node, the instances on that node will be moved to other nodes in the group. Instances with onHostMaintenance = MIGRATE will live migrate to their destinations while instances with onHostMaintenance = TERMINATE will terminate and then restart on their destination nodes if automaticRestart = true.
        /// </summary>
        public static NodeGroupMaintenancePolicy MigrateWithinNodeGroup { get; } = new NodeGroupMaintenancePolicy("MIGRATE_WITHIN_NODE_GROUP");
        /// <summary>
        /// Instances in this group will restart on the same node when maintenance has completed. Instances must have onHostMaintenance = TERMINATE, and they will only restart if automaticRestart = true.
        /// </summary>
        public static NodeGroupMaintenancePolicy RestartInPlace { get; } = new NodeGroupMaintenancePolicy("RESTART_IN_PLACE");

        public static bool operator ==(NodeGroupMaintenancePolicy left, NodeGroupMaintenancePolicy right) => left.Equals(right);
        public static bool operator !=(NodeGroupMaintenancePolicy left, NodeGroupMaintenancePolicy right) => !left.Equals(right);

        public static explicit operator string(NodeGroupMaintenancePolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NodeGroupMaintenancePolicy other && Equals(other);
        public bool Equals(NodeGroupMaintenancePolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct NodeGroupStatus : IEquatable<NodeGroupStatus>
    {
        private readonly string _value;

        private NodeGroupStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NodeGroupStatus Creating { get; } = new NodeGroupStatus("CREATING");
        public static NodeGroupStatus Deleting { get; } = new NodeGroupStatus("DELETING");
        public static NodeGroupStatus Invalid { get; } = new NodeGroupStatus("INVALID");
        public static NodeGroupStatus Ready { get; } = new NodeGroupStatus("READY");

        public static bool operator ==(NodeGroupStatus left, NodeGroupStatus right) => left.Equals(right);
        public static bool operator !=(NodeGroupStatus left, NodeGroupStatus right) => !left.Equals(right);

        public static explicit operator string(NodeGroupStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NodeGroupStatus other && Equals(other);
        public bool Equals(NodeGroupStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// CPU overcommit.
    /// </summary>
    [EnumType]
    public readonly struct NodeTemplateCpuOvercommitType : IEquatable<NodeTemplateCpuOvercommitType>
    {
        private readonly string _value;

        private NodeTemplateCpuOvercommitType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NodeTemplateCpuOvercommitType CpuOvercommitTypeUnspecified { get; } = new NodeTemplateCpuOvercommitType("CPU_OVERCOMMIT_TYPE_UNSPECIFIED");
        public static NodeTemplateCpuOvercommitType Enabled { get; } = new NodeTemplateCpuOvercommitType("ENABLED");
        public static NodeTemplateCpuOvercommitType None { get; } = new NodeTemplateCpuOvercommitType("NONE");

        public static bool operator ==(NodeTemplateCpuOvercommitType left, NodeTemplateCpuOvercommitType right) => left.Equals(right);
        public static bool operator !=(NodeTemplateCpuOvercommitType left, NodeTemplateCpuOvercommitType right) => !left.Equals(right);

        public static explicit operator string(NodeTemplateCpuOvercommitType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NodeTemplateCpuOvercommitType other && Equals(other);
        public bool Equals(NodeTemplateCpuOvercommitType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type indicates the intended use of the security policy. CLOUD_ARMOR - Cloud Armor backend security policies can be configured to filter incoming HTTP requests targeting backend services. They filter requests before they hit the origin servers. CLOUD_ARMOR_EDGE - Cloud Armor edge security policies can be configured to filter incoming HTTP requests targeting backend services (including Cloud CDN-enabled) as well as backend buckets (Cloud Storage). They filter requests before the request is served from Google's cache.
    /// </summary>
    [EnumType]
    public readonly struct OrganizationSecurityPolicyType : IEquatable<OrganizationSecurityPolicyType>
    {
        private readonly string _value;

        private OrganizationSecurityPolicyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static OrganizationSecurityPolicyType CloudArmor { get; } = new OrganizationSecurityPolicyType("CLOUD_ARMOR");
        public static OrganizationSecurityPolicyType CloudArmorEdge { get; } = new OrganizationSecurityPolicyType("CLOUD_ARMOR_EDGE");
        public static OrganizationSecurityPolicyType Firewall { get; } = new OrganizationSecurityPolicyType("FIREWALL");

        public static bool operator ==(OrganizationSecurityPolicyType left, OrganizationSecurityPolicyType right) => left.Equals(right);
        public static bool operator !=(OrganizationSecurityPolicyType left, OrganizationSecurityPolicyType right) => !left.Equals(right);

        public static explicit operator string(OrganizationSecurityPolicyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OrganizationSecurityPolicyType other && Equals(other);
        public bool Equals(OrganizationSecurityPolicyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether or not this packet mirroring takes effect. If set to FALSE, this packet mirroring policy will not be enforced on the network. The default is TRUE.
    /// </summary>
    [EnumType]
    public readonly struct PacketMirroringEnable : IEquatable<PacketMirroringEnable>
    {
        private readonly string _value;

        private PacketMirroringEnable(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PacketMirroringEnable False { get; } = new PacketMirroringEnable("FALSE");
        public static PacketMirroringEnable True { get; } = new PacketMirroringEnable("TRUE");

        public static bool operator ==(PacketMirroringEnable left, PacketMirroringEnable right) => left.Equals(right);
        public static bool operator !=(PacketMirroringEnable left, PacketMirroringEnable right) => !left.Equals(right);

        public static explicit operator string(PacketMirroringEnable value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PacketMirroringEnable other && Equals(other);
        public bool Equals(PacketMirroringEnable other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Direction of traffic to mirror, either INGRESS, EGRESS, or BOTH. The default is BOTH.
    /// </summary>
    [EnumType]
    public readonly struct PacketMirroringFilterDirection : IEquatable<PacketMirroringFilterDirection>
    {
        private readonly string _value;

        private PacketMirroringFilterDirection(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default, both directions are mirrored.
        /// </summary>
        public static PacketMirroringFilterDirection Both { get; } = new PacketMirroringFilterDirection("BOTH");
        /// <summary>
        /// Only egress traffic is mirrored.
        /// </summary>
        public static PacketMirroringFilterDirection Egress { get; } = new PacketMirroringFilterDirection("EGRESS");
        /// <summary>
        /// Only ingress traffic is mirrored.
        /// </summary>
        public static PacketMirroringFilterDirection Ingress { get; } = new PacketMirroringFilterDirection("INGRESS");

        public static bool operator ==(PacketMirroringFilterDirection left, PacketMirroringFilterDirection right) => left.Equals(right);
        public static bool operator !=(PacketMirroringFilterDirection left, PacketMirroringFilterDirection right) => !left.Equals(right);

        public static explicit operator string(PacketMirroringFilterDirection value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PacketMirroringFilterDirection other && Equals(other);
        public bool Equals(PacketMirroringFilterDirection other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The status of the public advertised prefix. Possible values include: - `INITIAL`: RPKI validation is complete. - `PTR_CONFIGURED`: User has configured the PTR. - `VALIDATED`: Reverse DNS lookup is successful. - `REVERSE_DNS_LOOKUP_FAILED`: Reverse DNS lookup failed. - `PREFIX_CONFIGURATION_IN_PROGRESS`: The prefix is being configured. - `PREFIX_CONFIGURATION_COMPLETE`: The prefix is fully configured. - `PREFIX_REMOVAL_IN_PROGRESS`: The prefix is being removed. 
    /// </summary>
    [EnumType]
    public readonly struct PublicAdvertisedPrefixStatus : IEquatable<PublicAdvertisedPrefixStatus>
    {
        private readonly string _value;

        private PublicAdvertisedPrefixStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// RPKI validation is complete.
        /// </summary>
        public static PublicAdvertisedPrefixStatus Initial { get; } = new PublicAdvertisedPrefixStatus("INITIAL");
        /// <summary>
        /// The prefix is fully configured.
        /// </summary>
        public static PublicAdvertisedPrefixStatus PrefixConfigurationComplete { get; } = new PublicAdvertisedPrefixStatus("PREFIX_CONFIGURATION_COMPLETE");
        /// <summary>
        /// The prefix is being configured.
        /// </summary>
        public static PublicAdvertisedPrefixStatus PrefixConfigurationInProgress { get; } = new PublicAdvertisedPrefixStatus("PREFIX_CONFIGURATION_IN_PROGRESS");
        /// <summary>
        /// The prefix is being removed.
        /// </summary>
        public static PublicAdvertisedPrefixStatus PrefixRemovalInProgress { get; } = new PublicAdvertisedPrefixStatus("PREFIX_REMOVAL_IN_PROGRESS");
        /// <summary>
        /// User has configured the PTR.
        /// </summary>
        public static PublicAdvertisedPrefixStatus PtrConfigured { get; } = new PublicAdvertisedPrefixStatus("PTR_CONFIGURED");
        /// <summary>
        /// Reverse DNS lookup failed.
        /// </summary>
        public static PublicAdvertisedPrefixStatus ReverseDnsLookupFailed { get; } = new PublicAdvertisedPrefixStatus("REVERSE_DNS_LOOKUP_FAILED");
        /// <summary>
        /// Reverse DNS lookup is successful.
        /// </summary>
        public static PublicAdvertisedPrefixStatus Validated { get; } = new PublicAdvertisedPrefixStatus("VALIDATED");

        public static bool operator ==(PublicAdvertisedPrefixStatus left, PublicAdvertisedPrefixStatus right) => left.Equals(right);
        public static bool operator !=(PublicAdvertisedPrefixStatus left, PublicAdvertisedPrefixStatus right) => !left.Equals(right);

        public static explicit operator string(PublicAdvertisedPrefixStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicAdvertisedPrefixStatus other && Equals(other);
        public bool Equals(PublicAdvertisedPrefixStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Compress text responses using Brotli or gzip compression, based on the client's Accept-Encoding header.
    /// </summary>
    [EnumType]
    public readonly struct RegionBackendServiceCompressionMode : IEquatable<RegionBackendServiceCompressionMode>
    {
        private readonly string _value;

        private RegionBackendServiceCompressionMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Automatically uses the best compression based on the Accept-Encoding header sent by the client.
        /// </summary>
        public static RegionBackendServiceCompressionMode Automatic { get; } = new RegionBackendServiceCompressionMode("AUTOMATIC");
        /// <summary>
        /// Disables compression. Existing compressed responses cached by Cloud CDN will not be served to clients.
        /// </summary>
        public static RegionBackendServiceCompressionMode Disabled { get; } = new RegionBackendServiceCompressionMode("DISABLED");

        public static bool operator ==(RegionBackendServiceCompressionMode left, RegionBackendServiceCompressionMode right) => left.Equals(right);
        public static bool operator !=(RegionBackendServiceCompressionMode left, RegionBackendServiceCompressionMode right) => !left.Equals(right);

        public static explicit operator string(RegionBackendServiceCompressionMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionBackendServiceCompressionMode other && Equals(other);
        public bool Equals(RegionBackendServiceCompressionMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the load balancer type. A backend service created for one type of load balancer cannot be used with another. For more information, refer to Choosing a load balancer.
    /// </summary>
    [EnumType]
    public readonly struct RegionBackendServiceLoadBalancingScheme : IEquatable<RegionBackendServiceLoadBalancingScheme>
    {
        private readonly string _value;

        private RegionBackendServiceLoadBalancingScheme(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Signifies that this will be used for external HTTP(S), SSL Proxy, TCP Proxy, or Network Load Balancing
        /// </summary>
        public static RegionBackendServiceLoadBalancingScheme External { get; } = new RegionBackendServiceLoadBalancingScheme("EXTERNAL");
        /// <summary>
        /// Signifies that this will be used for External Managed HTTP(S) Load Balancing.
        /// </summary>
        public static RegionBackendServiceLoadBalancingScheme ExternalManaged { get; } = new RegionBackendServiceLoadBalancingScheme("EXTERNAL_MANAGED");
        /// <summary>
        /// Signifies that this will be used for Internal TCP/UDP Load Balancing.
        /// </summary>
        public static RegionBackendServiceLoadBalancingScheme Internal { get; } = new RegionBackendServiceLoadBalancingScheme("INTERNAL");
        /// <summary>
        /// Signifies that this will be used for Internal HTTP(S) Load Balancing.
        /// </summary>
        public static RegionBackendServiceLoadBalancingScheme InternalManaged { get; } = new RegionBackendServiceLoadBalancingScheme("INTERNAL_MANAGED");
        /// <summary>
        /// Signifies that this will be used by Traffic Director.
        /// </summary>
        public static RegionBackendServiceLoadBalancingScheme InternalSelfManaged { get; } = new RegionBackendServiceLoadBalancingScheme("INTERNAL_SELF_MANAGED");
        public static RegionBackendServiceLoadBalancingScheme InvalidLoadBalancingScheme { get; } = new RegionBackendServiceLoadBalancingScheme("INVALID_LOAD_BALANCING_SCHEME");

        public static bool operator ==(RegionBackendServiceLoadBalancingScheme left, RegionBackendServiceLoadBalancingScheme right) => left.Equals(right);
        public static bool operator !=(RegionBackendServiceLoadBalancingScheme left, RegionBackendServiceLoadBalancingScheme right) => !left.Equals(right);

        public static explicit operator string(RegionBackendServiceLoadBalancingScheme value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionBackendServiceLoadBalancingScheme other && Equals(other);
        public bool Equals(RegionBackendServiceLoadBalancingScheme other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The load balancing algorithm used within the scope of the locality. The possible values are: - ROUND_ROBIN: This is a simple policy in which each healthy backend is selected in round robin order. This is the default. - LEAST_REQUEST: An O(1) algorithm which selects two random healthy hosts and picks the host which has fewer active requests. - RING_HASH: The ring/modulo hash load balancer implements consistent hashing to backends. The algorithm has the property that the addition/removal of a host from a set of N hosts only affects 1/N of the requests. - RANDOM: The load balancer selects a random healthy host. - ORIGINAL_DESTINATION: Backend host is selected based on the client connection metadata, i.e., connections are opened to the same address as the destination address of the incoming connection before the connection was redirected to the load balancer. - MAGLEV: used as a drop in replacement for the ring hash load balancer. Maglev is not as stable as ring hash but has faster table lookup build times and host selection times. For more information about Maglev, see https://ai.google/research/pubs/pub44824 This field is applicable to either: - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED. - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED. If sessionAffinity is not NONE, and this field is not set to MAGLEV or RING_HASH, session affinity settings will not take effect. Only ROUND_ROBIN and RING_HASH are supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
    /// </summary>
    [EnumType]
    public readonly struct RegionBackendServiceLocalityLbPolicy : IEquatable<RegionBackendServiceLocalityLbPolicy>
    {
        private readonly string _value;

        private RegionBackendServiceLocalityLbPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegionBackendServiceLocalityLbPolicy InvalidLbPolicy { get; } = new RegionBackendServiceLocalityLbPolicy("INVALID_LB_POLICY");
        /// <summary>
        /// An O(1) algorithm which selects two random healthy hosts and picks the host which has fewer active requests.
        /// </summary>
        public static RegionBackendServiceLocalityLbPolicy LeastRequest { get; } = new RegionBackendServiceLocalityLbPolicy("LEAST_REQUEST");
        /// <summary>
        /// This algorithm implements consistent hashing to backends. Maglev can be used as a drop in replacement for the ring hash load balancer. Maglev is not as stable as ring hash but has faster table lookup build times and host selection times. For more information about Maglev, see https://ai.google/research/pubs/pub44824
        /// </summary>
        public static RegionBackendServiceLocalityLbPolicy Maglev { get; } = new RegionBackendServiceLocalityLbPolicy("MAGLEV");
        /// <summary>
        /// Backend host is selected based on the client connection metadata, i.e., connections are opened to the same address as the destination address of the incoming connection before the connection was redirected to the load balancer.
        /// </summary>
        public static RegionBackendServiceLocalityLbPolicy OriginalDestination { get; } = new RegionBackendServiceLocalityLbPolicy("ORIGINAL_DESTINATION");
        /// <summary>
        /// The load balancer selects a random healthy host.
        /// </summary>
        public static RegionBackendServiceLocalityLbPolicy Random { get; } = new RegionBackendServiceLocalityLbPolicy("RANDOM");
        /// <summary>
        /// The ring/modulo hash load balancer implements consistent hashing to backends. The algorithm has the property that the addition/removal of a host from a set of N hosts only affects 1/N of the requests.
        /// </summary>
        public static RegionBackendServiceLocalityLbPolicy RingHash { get; } = new RegionBackendServiceLocalityLbPolicy("RING_HASH");
        /// <summary>
        /// This is a simple policy in which each healthy backend is selected in round robin order. This is the default.
        /// </summary>
        public static RegionBackendServiceLocalityLbPolicy RoundRobin { get; } = new RegionBackendServiceLocalityLbPolicy("ROUND_ROBIN");

        public static bool operator ==(RegionBackendServiceLocalityLbPolicy left, RegionBackendServiceLocalityLbPolicy right) => left.Equals(right);
        public static bool operator !=(RegionBackendServiceLocalityLbPolicy left, RegionBackendServiceLocalityLbPolicy right) => !left.Equals(right);

        public static explicit operator string(RegionBackendServiceLocalityLbPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionBackendServiceLocalityLbPolicy other && Equals(other);
        public bool Equals(RegionBackendServiceLocalityLbPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The protocol this BackendService uses to communicate with backends. Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, UDP or GRPC. depending on the chosen load balancer or Traffic Director configuration. Refer to the documentation for the load balancers or for Traffic Director for more information. Must be set to GRPC when the backend service is referenced by a URL map that is bound to target gRPC proxy.
    /// </summary>
    [EnumType]
    public readonly struct RegionBackendServiceProtocol : IEquatable<RegionBackendServiceProtocol>
    {
        private readonly string _value;

        private RegionBackendServiceProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// gRPC (available for Traffic Director).
        /// </summary>
        public static RegionBackendServiceProtocol Grpc { get; } = new RegionBackendServiceProtocol("GRPC");
        public static RegionBackendServiceProtocol Http { get; } = new RegionBackendServiceProtocol("HTTP");
        /// <summary>
        /// HTTP/2 with SSL.
        /// </summary>
        public static RegionBackendServiceProtocol Http2 { get; } = new RegionBackendServiceProtocol("HTTP2");
        public static RegionBackendServiceProtocol Https { get; } = new RegionBackendServiceProtocol("HTTPS");
        /// <summary>
        /// TCP proxying with SSL.
        /// </summary>
        public static RegionBackendServiceProtocol Ssl { get; } = new RegionBackendServiceProtocol("SSL");
        /// <summary>
        /// TCP proxying or TCP pass-through.
        /// </summary>
        public static RegionBackendServiceProtocol Tcp { get; } = new RegionBackendServiceProtocol("TCP");
        /// <summary>
        /// UDP.
        /// </summary>
        public static RegionBackendServiceProtocol Udp { get; } = new RegionBackendServiceProtocol("UDP");
        /// <summary>
        /// If a Backend Service has UNSPECIFIED as its protocol, it can be used with any L3/L4 Forwarding Rules.
        /// </summary>
        public static RegionBackendServiceProtocol Unspecified { get; } = new RegionBackendServiceProtocol("UNSPECIFIED");

        public static bool operator ==(RegionBackendServiceProtocol left, RegionBackendServiceProtocol right) => left.Equals(right);
        public static bool operator !=(RegionBackendServiceProtocol left, RegionBackendServiceProtocol right) => !left.Equals(right);

        public static explicit operator string(RegionBackendServiceProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionBackendServiceProtocol other && Equals(other);
        public bool Equals(RegionBackendServiceProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of session affinity to use. The default is NONE. Only NONE and HEADER_FIELD are supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true. For more details, see: [Session Affinity](https://cloud.google.com/load-balancing/docs/backend-service#session_affinity).
    /// </summary>
    [EnumType]
    public readonly struct RegionBackendServiceSessionAffinity : IEquatable<RegionBackendServiceSessionAffinity>
    {
        private readonly string _value;

        private RegionBackendServiceSessionAffinity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// 2-tuple hash on packet's source and destination IP addresses. Connections from the same source IP address to the same destination IP address will be served by the same backend VM while that VM remains healthy.
        /// </summary>
        public static RegionBackendServiceSessionAffinity ClientIp { get; } = new RegionBackendServiceSessionAffinity("CLIENT_IP");
        /// <summary>
        /// 1-tuple hash only on packet's source IP address. Connections from the same source IP address will be served by the same backend VM while that VM remains healthy. This option can only be used for Internal TCP/UDP Load Balancing.
        /// </summary>
        public static RegionBackendServiceSessionAffinity ClientIpNoDestination { get; } = new RegionBackendServiceSessionAffinity("CLIENT_IP_NO_DESTINATION");
        /// <summary>
        /// 5-tuple hash on packet's source and destination IP addresses, IP protocol, and source and destination ports. Connections for the same IP protocol from the same source IP address and port to the same destination IP address and port will be served by the same backend VM while that VM remains healthy. This option cannot be used for HTTP(S) load balancing.
        /// </summary>
        public static RegionBackendServiceSessionAffinity ClientIpPortProto { get; } = new RegionBackendServiceSessionAffinity("CLIENT_IP_PORT_PROTO");
        /// <summary>
        /// 3-tuple hash on packet's source and destination IP addresses, and IP protocol. Connections for the same IP protocol from the same source IP address to the same destination IP address will be served by the same backend VM while that VM remains healthy. This option cannot be used for HTTP(S) load balancing.
        /// </summary>
        public static RegionBackendServiceSessionAffinity ClientIpProto { get; } = new RegionBackendServiceSessionAffinity("CLIENT_IP_PROTO");
        /// <summary>
        /// Hash based on a cookie generated by the L7 loadbalancer. Only valid for HTTP(S) load balancing.
        /// </summary>
        public static RegionBackendServiceSessionAffinity GeneratedCookie { get; } = new RegionBackendServiceSessionAffinity("GENERATED_COOKIE");
        /// <summary>
        /// The hash is based on a user specified header field.
        /// </summary>
        public static RegionBackendServiceSessionAffinity HeaderField { get; } = new RegionBackendServiceSessionAffinity("HEADER_FIELD");
        /// <summary>
        /// The hash is based on a user provided cookie.
        /// </summary>
        public static RegionBackendServiceSessionAffinity HttpCookie { get; } = new RegionBackendServiceSessionAffinity("HTTP_COOKIE");
        /// <summary>
        /// No session affinity. Connections from the same client IP may go to any instance in the pool.
        /// </summary>
        public static RegionBackendServiceSessionAffinity None { get; } = new RegionBackendServiceSessionAffinity("NONE");

        public static bool operator ==(RegionBackendServiceSessionAffinity left, RegionBackendServiceSessionAffinity right) => left.Equals(right);
        public static bool operator !=(RegionBackendServiceSessionAffinity left, RegionBackendServiceSessionAffinity right) => !left.Equals(right);

        public static explicit operator string(RegionBackendServiceSessionAffinity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionBackendServiceSessionAffinity other && Equals(other);
        public bool Equals(RegionBackendServiceSessionAffinity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The category of the commitment. Category MACHINE specifies commitments composed of machine resources such as VCPU or MEMORY, listed in resources. Category LICENSE specifies commitments composed of software licenses, listed in licenseResources. Note that only MACHINE commitments should have a Type specified.
    /// </summary>
    [EnumType]
    public readonly struct RegionCommitmentCategory : IEquatable<RegionCommitmentCategory>
    {
        private readonly string _value;

        private RegionCommitmentCategory(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegionCommitmentCategory CategoryUnspecified { get; } = new RegionCommitmentCategory("CATEGORY_UNSPECIFIED");
        public static RegionCommitmentCategory License { get; } = new RegionCommitmentCategory("LICENSE");
        public static RegionCommitmentCategory Machine { get; } = new RegionCommitmentCategory("MACHINE");

        public static bool operator ==(RegionCommitmentCategory left, RegionCommitmentCategory right) => left.Equals(right);
        public static bool operator !=(RegionCommitmentCategory left, RegionCommitmentCategory right) => !left.Equals(right);

        public static explicit operator string(RegionCommitmentCategory value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionCommitmentCategory other && Equals(other);
        public bool Equals(RegionCommitmentCategory other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The plan for this commitment, which determines duration and discount rate. The currently supported plans are TWELVE_MONTH (1 year), and THIRTY_SIX_MONTH (3 years).
    /// </summary>
    [EnumType]
    public readonly struct RegionCommitmentPlan : IEquatable<RegionCommitmentPlan>
    {
        private readonly string _value;

        private RegionCommitmentPlan(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegionCommitmentPlan Invalid { get; } = new RegionCommitmentPlan("INVALID");
        public static RegionCommitmentPlan ThirtySixMonth { get; } = new RegionCommitmentPlan("THIRTY_SIX_MONTH");
        public static RegionCommitmentPlan TwelveMonth { get; } = new RegionCommitmentPlan("TWELVE_MONTH");

        public static bool operator ==(RegionCommitmentPlan left, RegionCommitmentPlan right) => left.Equals(right);
        public static bool operator !=(RegionCommitmentPlan left, RegionCommitmentPlan right) => !left.Equals(right);

        public static explicit operator string(RegionCommitmentPlan value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionCommitmentPlan other && Equals(other);
        public bool Equals(RegionCommitmentPlan other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of commitment, which affects the discount rate and the eligible resources. Type MEMORY_OPTIMIZED specifies a commitment that will only apply to memory optimized machines. Type ACCELERATOR_OPTIMIZED specifies a commitment that will only apply to accelerator optimized machines.
    /// </summary>
    [EnumType]
    public readonly struct RegionCommitmentType : IEquatable<RegionCommitmentType>
    {
        private readonly string _value;

        private RegionCommitmentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegionCommitmentType AcceleratorOptimized { get; } = new RegionCommitmentType("ACCELERATOR_OPTIMIZED");
        public static RegionCommitmentType ComputeOptimized { get; } = new RegionCommitmentType("COMPUTE_OPTIMIZED");
        public static RegionCommitmentType ComputeOptimizedC2d { get; } = new RegionCommitmentType("COMPUTE_OPTIMIZED_C2D");
        public static RegionCommitmentType GeneralPurpose { get; } = new RegionCommitmentType("GENERAL_PURPOSE");
        public static RegionCommitmentType GeneralPurposeE2 { get; } = new RegionCommitmentType("GENERAL_PURPOSE_E2");
        public static RegionCommitmentType GeneralPurposeN2 { get; } = new RegionCommitmentType("GENERAL_PURPOSE_N2");
        public static RegionCommitmentType GeneralPurposeN2d { get; } = new RegionCommitmentType("GENERAL_PURPOSE_N2D");
        public static RegionCommitmentType GeneralPurposeT2d { get; } = new RegionCommitmentType("GENERAL_PURPOSE_T2D");
        public static RegionCommitmentType MemoryOptimized { get; } = new RegionCommitmentType("MEMORY_OPTIMIZED");
        public static RegionCommitmentType TypeUnspecified { get; } = new RegionCommitmentType("TYPE_UNSPECIFIED");

        public static bool operator ==(RegionCommitmentType left, RegionCommitmentType right) => left.Equals(right);
        public static bool operator !=(RegionCommitmentType left, RegionCommitmentType right) => !left.Equals(right);

        public static explicit operator string(RegionCommitmentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionCommitmentType other && Equals(other);
        public bool Equals(RegionCommitmentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. Policy for how the results from multiple health checks for the same endpoint are aggregated. Defaults to NO_AGGREGATION if unspecified. - NO_AGGREGATION. An EndpointHealth message is returned for each pair in the health check service. - AND. If any health check of an endpoint reports UNHEALTHY, then UNHEALTHY is the HealthState of the endpoint. If all health checks report HEALTHY, the HealthState of the endpoint is HEALTHY. .
    /// </summary>
    [EnumType]
    public readonly struct RegionHealthCheckServiceHealthStatusAggregationPolicy : IEquatable<RegionHealthCheckServiceHealthStatusAggregationPolicy>
    {
        private readonly string _value;

        private RegionHealthCheckServiceHealthStatusAggregationPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// If any backend's health check reports UNHEALTHY, then UNHEALTHY is the HealthState of the entire health check service. If all backend's are healthy, the HealthState of the health check service is HEALTHY.
        /// </summary>
        public static RegionHealthCheckServiceHealthStatusAggregationPolicy And { get; } = new RegionHealthCheckServiceHealthStatusAggregationPolicy("AND");
        /// <summary>
        /// An EndpointHealth message is returned for each backend in the health check service.
        /// </summary>
        public static RegionHealthCheckServiceHealthStatusAggregationPolicy NoAggregation { get; } = new RegionHealthCheckServiceHealthStatusAggregationPolicy("NO_AGGREGATION");

        public static bool operator ==(RegionHealthCheckServiceHealthStatusAggregationPolicy left, RegionHealthCheckServiceHealthStatusAggregationPolicy right) => left.Equals(right);
        public static bool operator !=(RegionHealthCheckServiceHealthStatusAggregationPolicy left, RegionHealthCheckServiceHealthStatusAggregationPolicy right) => !left.Equals(right);

        public static explicit operator string(RegionHealthCheckServiceHealthStatusAggregationPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionHealthCheckServiceHealthStatusAggregationPolicy other && Equals(other);
        public bool Equals(RegionHealthCheckServiceHealthStatusAggregationPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of the healthCheck, either TCP, SSL, HTTP, HTTPS or HTTP2. Exactly one of the protocol-specific health check field must be specified, which must match type field.
    /// </summary>
    [EnumType]
    public readonly struct RegionHealthCheckType : IEquatable<RegionHealthCheckType>
    {
        private readonly string _value;

        private RegionHealthCheckType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegionHealthCheckType Grpc { get; } = new RegionHealthCheckType("GRPC");
        public static RegionHealthCheckType Http { get; } = new RegionHealthCheckType("HTTP");
        public static RegionHealthCheckType Http2 { get; } = new RegionHealthCheckType("HTTP2");
        public static RegionHealthCheckType Https { get; } = new RegionHealthCheckType("HTTPS");
        public static RegionHealthCheckType Invalid { get; } = new RegionHealthCheckType("INVALID");
        public static RegionHealthCheckType Ssl { get; } = new RegionHealthCheckType("SSL");
        public static RegionHealthCheckType Tcp { get; } = new RegionHealthCheckType("TCP");

        public static bool operator ==(RegionHealthCheckType left, RegionHealthCheckType right) => left.Equals(right);
        public static bool operator !=(RegionHealthCheckType left, RegionHealthCheckType right) => !left.Equals(right);

        public static explicit operator string(RegionHealthCheckType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionHealthCheckType other && Equals(other);
        public bool Equals(RegionHealthCheckType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The action to perform in case of zone failure. Only one value is supported, NO_FAILOVER. The default is NO_FAILOVER.
    /// </summary>
    [EnumType]
    public readonly struct RegionInstanceGroupManagerFailoverAction : IEquatable<RegionInstanceGroupManagerFailoverAction>
    {
        private readonly string _value;

        private RegionInstanceGroupManagerFailoverAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegionInstanceGroupManagerFailoverAction NoFailover { get; } = new RegionInstanceGroupManagerFailoverAction("NO_FAILOVER");
        public static RegionInstanceGroupManagerFailoverAction Unknown { get; } = new RegionInstanceGroupManagerFailoverAction("UNKNOWN");

        public static bool operator ==(RegionInstanceGroupManagerFailoverAction left, RegionInstanceGroupManagerFailoverAction right) => left.Equals(right);
        public static bool operator !=(RegionInstanceGroupManagerFailoverAction left, RegionInstanceGroupManagerFailoverAction right) => !left.Equals(right);

        public static explicit operator string(RegionInstanceGroupManagerFailoverAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionInstanceGroupManagerFailoverAction other && Equals(other);
        public bool Equals(RegionInstanceGroupManagerFailoverAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of network endpoints in this network endpoint group. Can be one of GCE_VM_IP_PORT, NON_GCP_PRIVATE_IP_PORT, INTERNET_FQDN_PORT, INTERNET_IP_PORT, SERVERLESS, PRIVATE_SERVICE_CONNECT.
    /// </summary>
    [EnumType]
    public readonly struct RegionNetworkEndpointGroupNetworkEndpointType : IEquatable<RegionNetworkEndpointGroupNetworkEndpointType>
    {
        private readonly string _value;

        private RegionNetworkEndpointGroupNetworkEndpointType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The network endpoint is represented by an IP address.
        /// </summary>
        public static RegionNetworkEndpointGroupNetworkEndpointType GceVmIp { get; } = new RegionNetworkEndpointGroupNetworkEndpointType("GCE_VM_IP");
        /// <summary>
        /// The network endpoint is represented by IP address and port pair.
        /// </summary>
        public static RegionNetworkEndpointGroupNetworkEndpointType GceVmIpPort { get; } = new RegionNetworkEndpointGroupNetworkEndpointType("GCE_VM_IP_PORT");
        /// <summary>
        /// The network endpoint is represented by fully qualified domain name and port.
        /// </summary>
        public static RegionNetworkEndpointGroupNetworkEndpointType InternetFqdnPort { get; } = new RegionNetworkEndpointGroupNetworkEndpointType("INTERNET_FQDN_PORT");
        /// <summary>
        /// The network endpoint is represented by an internet IP address and port.
        /// </summary>
        public static RegionNetworkEndpointGroupNetworkEndpointType InternetIpPort { get; } = new RegionNetworkEndpointGroupNetworkEndpointType("INTERNET_IP_PORT");
        /// <summary>
        /// The network endpoint is represented by an IP address and port. The endpoint belongs to a VM or pod running in a customer's on-premises.
        /// </summary>
        public static RegionNetworkEndpointGroupNetworkEndpointType NonGcpPrivateIpPort { get; } = new RegionNetworkEndpointGroupNetworkEndpointType("NON_GCP_PRIVATE_IP_PORT");
        /// <summary>
        /// The network endpoint is either public Google APIs or services exposed by other GCP Project with a Service Attachment. The connection is set up by private service connect
        /// </summary>
        public static RegionNetworkEndpointGroupNetworkEndpointType PrivateServiceConnect { get; } = new RegionNetworkEndpointGroupNetworkEndpointType("PRIVATE_SERVICE_CONNECT");
        /// <summary>
        /// The network endpoint is handled by specified serverless infrastructure.
        /// </summary>
        public static RegionNetworkEndpointGroupNetworkEndpointType Serverless { get; } = new RegionNetworkEndpointGroupNetworkEndpointType("SERVERLESS");

        public static bool operator ==(RegionNetworkEndpointGroupNetworkEndpointType left, RegionNetworkEndpointGroupNetworkEndpointType right) => left.Equals(right);
        public static bool operator !=(RegionNetworkEndpointGroupNetworkEndpointType left, RegionNetworkEndpointGroupNetworkEndpointType right) => !left.Equals(right);

        public static explicit operator string(RegionNetworkEndpointGroupNetworkEndpointType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionNetworkEndpointGroupNetworkEndpointType other && Equals(other);
        public bool Equals(RegionNetworkEndpointGroupNetworkEndpointType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// (Optional) Specifies the type of SSL certificate, either "SELF_MANAGED" or "MANAGED". If not specified, the certificate is self-managed and the fields certificate and private_key are used.
    /// </summary>
    [EnumType]
    public readonly struct RegionSslCertificateType : IEquatable<RegionSslCertificateType>
    {
        private readonly string _value;

        private RegionSslCertificateType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Google-managed SSLCertificate.
        /// </summary>
        public static RegionSslCertificateType Managed { get; } = new RegionSslCertificateType("MANAGED");
        /// <summary>
        /// Certificate uploaded by user.
        /// </summary>
        public static RegionSslCertificateType SelfManaged { get; } = new RegionSslCertificateType("SELF_MANAGED");
        public static RegionSslCertificateType TypeUnspecified { get; } = new RegionSslCertificateType("TYPE_UNSPECIFIED");

        public static bool operator ==(RegionSslCertificateType left, RegionSslCertificateType right) => left.Equals(right);
        public static bool operator !=(RegionSslCertificateType left, RegionSslCertificateType right) => !left.Equals(right);

        public static explicit operator string(RegionSslCertificateType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionSslCertificateType other && Equals(other);
        public bool Equals(RegionSslCertificateType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the QUIC override policy for this TargetHttpsProxy resource. This setting determines whether the load balancer attempts to negotiate QUIC with clients. You can specify NONE, ENABLE, or DISABLE. - When quic-override is set to NONE, Google manages whether QUIC is used. - When quic-override is set to ENABLE, the load balancer uses QUIC when possible. - When quic-override is set to DISABLE, the load balancer doesn't use QUIC. - If the quic-override flag is not specified, NONE is implied. 
    /// </summary>
    [EnumType]
    public readonly struct RegionTargetHttpsProxyQuicOverride : IEquatable<RegionTargetHttpsProxyQuicOverride>
    {
        private readonly string _value;

        private RegionTargetHttpsProxyQuicOverride(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The load balancer will not attempt to negotiate QUIC with clients.
        /// </summary>
        public static RegionTargetHttpsProxyQuicOverride Disable { get; } = new RegionTargetHttpsProxyQuicOverride("DISABLE");
        /// <summary>
        /// The load balancer will attempt to negotiate QUIC with clients.
        /// </summary>
        public static RegionTargetHttpsProxyQuicOverride Enable { get; } = new RegionTargetHttpsProxyQuicOverride("ENABLE");
        /// <summary>
        /// No overrides to the default QUIC policy. This option is implicit if no QUIC override has been specified in the request.
        /// </summary>
        public static RegionTargetHttpsProxyQuicOverride None { get; } = new RegionTargetHttpsProxyQuicOverride("NONE");

        public static bool operator ==(RegionTargetHttpsProxyQuicOverride left, RegionTargetHttpsProxyQuicOverride right) => left.Equals(right);
        public static bool operator !=(RegionTargetHttpsProxyQuicOverride left, RegionTargetHttpsProxyQuicOverride right) => !left.Equals(right);

        public static explicit operator string(RegionTargetHttpsProxyQuicOverride value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegionTargetHttpsProxyQuicOverride other && Equals(other);
        public bool Equals(RegionTargetHttpsProxyQuicOverride other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of reservation from which this instance can consume resources: ANY_RESERVATION (default), SPECIFIC_RESERVATION, or NO_RESERVATION. See Consuming reserved instances for examples.
    /// </summary>
    [EnumType]
    public readonly struct ReservationAffinityConsumeReservationType : IEquatable<ReservationAffinityConsumeReservationType>
    {
        private readonly string _value;

        private ReservationAffinityConsumeReservationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Consume any allocation available.
        /// </summary>
        public static ReservationAffinityConsumeReservationType AnyReservation { get; } = new ReservationAffinityConsumeReservationType("ANY_RESERVATION");
        /// <summary>
        /// Do not consume from any allocated capacity.
        /// </summary>
        public static ReservationAffinityConsumeReservationType NoReservation { get; } = new ReservationAffinityConsumeReservationType("NO_RESERVATION");
        /// <summary>
        /// Must consume from a specific reservation. Must specify key value fields for specifying the reservations.
        /// </summary>
        public static ReservationAffinityConsumeReservationType SpecificReservation { get; } = new ReservationAffinityConsumeReservationType("SPECIFIC_RESERVATION");
        /// <summary>
        /// Prefer to consume from a specific reservation, but still consume any reservation available if the specified reservation is not available or exhausted. Must specify key value fields for specifying the reservations.
        /// </summary>
        public static ReservationAffinityConsumeReservationType SpecificThenAnyReservation { get; } = new ReservationAffinityConsumeReservationType("SPECIFIC_THEN_ANY_RESERVATION");
        public static ReservationAffinityConsumeReservationType Unspecified { get; } = new ReservationAffinityConsumeReservationType("UNSPECIFIED");

        public static bool operator ==(ReservationAffinityConsumeReservationType left, ReservationAffinityConsumeReservationType right) => left.Equals(right);
        public static bool operator !=(ReservationAffinityConsumeReservationType left, ReservationAffinityConsumeReservationType right) => !left.Equals(right);

        public static explicit operator string(ReservationAffinityConsumeReservationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReservationAffinityConsumeReservationType other && Equals(other);
        public bool Equals(ReservationAffinityConsumeReservationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of resource for which this commitment applies. Possible values are VCPU and MEMORY
    /// </summary>
    [EnumType]
    public readonly struct ResourceCommitmentType : IEquatable<ResourceCommitmentType>
    {
        private readonly string _value;

        private ResourceCommitmentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourceCommitmentType Accelerator { get; } = new ResourceCommitmentType("ACCELERATOR");
        public static ResourceCommitmentType LocalSsd { get; } = new ResourceCommitmentType("LOCAL_SSD");
        public static ResourceCommitmentType Memory { get; } = new ResourceCommitmentType("MEMORY");
        public static ResourceCommitmentType Unspecified { get; } = new ResourceCommitmentType("UNSPECIFIED");
        public static ResourceCommitmentType Vcpu { get; } = new ResourceCommitmentType("VCPU");

        public static bool operator ==(ResourceCommitmentType left, ResourceCommitmentType right) => left.Equals(right);
        public static bool operator !=(ResourceCommitmentType left, ResourceCommitmentType right) => !left.Equals(right);

        public static explicit operator string(ResourceCommitmentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourceCommitmentType other && Equals(other);
        public bool Equals(ResourceCommitmentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies network collocation
    /// </summary>
    [EnumType]
    public readonly struct ResourcePolicyGroupPlacementPolicyCollocation : IEquatable<ResourcePolicyGroupPlacementPolicyCollocation>
    {
        private readonly string _value;

        private ResourcePolicyGroupPlacementPolicyCollocation(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourcePolicyGroupPlacementPolicyCollocation Collocated { get; } = new ResourcePolicyGroupPlacementPolicyCollocation("COLLOCATED");
        public static ResourcePolicyGroupPlacementPolicyCollocation UnspecifiedCollocation { get; } = new ResourcePolicyGroupPlacementPolicyCollocation("UNSPECIFIED_COLLOCATION");

        public static bool operator ==(ResourcePolicyGroupPlacementPolicyCollocation left, ResourcePolicyGroupPlacementPolicyCollocation right) => left.Equals(right);
        public static bool operator !=(ResourcePolicyGroupPlacementPolicyCollocation left, ResourcePolicyGroupPlacementPolicyCollocation right) => !left.Equals(right);

        public static explicit operator string(ResourcePolicyGroupPlacementPolicyCollocation value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourcePolicyGroupPlacementPolicyCollocation other && Equals(other);
        public bool Equals(ResourcePolicyGroupPlacementPolicyCollocation other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the behavior to apply to scheduled snapshots when the source disk is deleted.
    /// </summary>
    [EnumType]
    public readonly struct ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete : IEquatable<ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete>
    {
        private readonly string _value;

        private ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete ApplyRetentionPolicy { get; } = new ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete("APPLY_RETENTION_POLICY");
        public static ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete KeepAutoSnapshots { get; } = new ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete("KEEP_AUTO_SNAPSHOTS");
        public static ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete UnspecifiedOnSourceDiskDelete { get; } = new ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete("UNSPECIFIED_ON_SOURCE_DISK_DELETE");

        public static bool operator ==(ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete left, ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete right) => left.Equals(right);
        public static bool operator !=(ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete left, ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete right) => !left.Equals(right);

        public static explicit operator string(ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete other && Equals(other);
        public bool Equals(ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines a schedule that runs on specific days of the week. Specify one or more days. The following options are available: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
    /// </summary>
    [EnumType]
    public readonly struct ResourcePolicyWeeklyCycleDayOfWeekDay : IEquatable<ResourcePolicyWeeklyCycleDayOfWeekDay>
    {
        private readonly string _value;

        private ResourcePolicyWeeklyCycleDayOfWeekDay(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourcePolicyWeeklyCycleDayOfWeekDay Friday { get; } = new ResourcePolicyWeeklyCycleDayOfWeekDay("FRIDAY");
        public static ResourcePolicyWeeklyCycleDayOfWeekDay Invalid { get; } = new ResourcePolicyWeeklyCycleDayOfWeekDay("INVALID");
        public static ResourcePolicyWeeklyCycleDayOfWeekDay Monday { get; } = new ResourcePolicyWeeklyCycleDayOfWeekDay("MONDAY");
        public static ResourcePolicyWeeklyCycleDayOfWeekDay Saturday { get; } = new ResourcePolicyWeeklyCycleDayOfWeekDay("SATURDAY");
        public static ResourcePolicyWeeklyCycleDayOfWeekDay Sunday { get; } = new ResourcePolicyWeeklyCycleDayOfWeekDay("SUNDAY");
        public static ResourcePolicyWeeklyCycleDayOfWeekDay Thursday { get; } = new ResourcePolicyWeeklyCycleDayOfWeekDay("THURSDAY");
        public static ResourcePolicyWeeklyCycleDayOfWeekDay Tuesday { get; } = new ResourcePolicyWeeklyCycleDayOfWeekDay("TUESDAY");
        public static ResourcePolicyWeeklyCycleDayOfWeekDay Wednesday { get; } = new ResourcePolicyWeeklyCycleDayOfWeekDay("WEDNESDAY");

        public static bool operator ==(ResourcePolicyWeeklyCycleDayOfWeekDay left, ResourcePolicyWeeklyCycleDayOfWeekDay right) => left.Equals(right);
        public static bool operator !=(ResourcePolicyWeeklyCycleDayOfWeekDay left, ResourcePolicyWeeklyCycleDayOfWeekDay right) => !left.Equals(right);

        public static explicit operator string(ResourcePolicyWeeklyCycleDayOfWeekDay value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourcePolicyWeeklyCycleDayOfWeekDay other && Equals(other);
        public bool Equals(ResourcePolicyWeeklyCycleDayOfWeekDay other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// User-specified flag to indicate which mode to use for advertisement. The options are DEFAULT or CUSTOM.
    /// </summary>
    [EnumType]
    public readonly struct RouterBgpAdvertiseMode : IEquatable<RouterBgpAdvertiseMode>
    {
        private readonly string _value;

        private RouterBgpAdvertiseMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterBgpAdvertiseMode Custom { get; } = new RouterBgpAdvertiseMode("CUSTOM");
        public static RouterBgpAdvertiseMode Default { get; } = new RouterBgpAdvertiseMode("DEFAULT");

        public static bool operator ==(RouterBgpAdvertiseMode left, RouterBgpAdvertiseMode right) => left.Equals(right);
        public static bool operator !=(RouterBgpAdvertiseMode left, RouterBgpAdvertiseMode right) => !left.Equals(right);

        public static explicit operator string(RouterBgpAdvertiseMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterBgpAdvertiseMode other && Equals(other);
        public bool Equals(RouterBgpAdvertiseMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterBgpAdvertisedGroupsItem : IEquatable<RouterBgpAdvertisedGroupsItem>
    {
        private readonly string _value;

        private RouterBgpAdvertisedGroupsItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Advertise all available subnets (including peer VPC subnets).
        /// </summary>
        public static RouterBgpAdvertisedGroupsItem AllSubnets { get; } = new RouterBgpAdvertisedGroupsItem("ALL_SUBNETS");

        public static bool operator ==(RouterBgpAdvertisedGroupsItem left, RouterBgpAdvertisedGroupsItem right) => left.Equals(right);
        public static bool operator !=(RouterBgpAdvertisedGroupsItem left, RouterBgpAdvertisedGroupsItem right) => !left.Equals(right);

        public static explicit operator string(RouterBgpAdvertisedGroupsItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterBgpAdvertisedGroupsItem other && Equals(other);
        public bool Equals(RouterBgpAdvertisedGroupsItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// User-specified flag to indicate which mode to use for advertisement.
    /// </summary>
    [EnumType]
    public readonly struct RouterBgpPeerAdvertiseMode : IEquatable<RouterBgpPeerAdvertiseMode>
    {
        private readonly string _value;

        private RouterBgpPeerAdvertiseMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterBgpPeerAdvertiseMode Custom { get; } = new RouterBgpPeerAdvertiseMode("CUSTOM");
        public static RouterBgpPeerAdvertiseMode Default { get; } = new RouterBgpPeerAdvertiseMode("DEFAULT");

        public static bool operator ==(RouterBgpPeerAdvertiseMode left, RouterBgpPeerAdvertiseMode right) => left.Equals(right);
        public static bool operator !=(RouterBgpPeerAdvertiseMode left, RouterBgpPeerAdvertiseMode right) => !left.Equals(right);

        public static explicit operator string(RouterBgpPeerAdvertiseMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterBgpPeerAdvertiseMode other && Equals(other);
        public bool Equals(RouterBgpPeerAdvertiseMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterBgpPeerAdvertisedGroupsItem : IEquatable<RouterBgpPeerAdvertisedGroupsItem>
    {
        private readonly string _value;

        private RouterBgpPeerAdvertisedGroupsItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Advertise all available subnets (including peer VPC subnets).
        /// </summary>
        public static RouterBgpPeerAdvertisedGroupsItem AllSubnets { get; } = new RouterBgpPeerAdvertisedGroupsItem("ALL_SUBNETS");

        public static bool operator ==(RouterBgpPeerAdvertisedGroupsItem left, RouterBgpPeerAdvertisedGroupsItem right) => left.Equals(right);
        public static bool operator !=(RouterBgpPeerAdvertisedGroupsItem left, RouterBgpPeerAdvertisedGroupsItem right) => !left.Equals(right);

        public static explicit operator string(RouterBgpPeerAdvertisedGroupsItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterBgpPeerAdvertisedGroupsItem other && Equals(other);
        public bool Equals(RouterBgpPeerAdvertisedGroupsItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The BFD session initialization mode for this BGP peer. If set to ACTIVE, the Cloud Router will initiate the BFD session for this BGP peer. If set to PASSIVE, the Cloud Router will wait for the peer router to initiate the BFD session for this BGP peer. If set to DISABLED, BFD is disabled for this BGP peer. The default is PASSIVE.
    /// </summary>
    [EnumType]
    public readonly struct RouterBgpPeerBfdSessionInitializationMode : IEquatable<RouterBgpPeerBfdSessionInitializationMode>
    {
        private readonly string _value;

        private RouterBgpPeerBfdSessionInitializationMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterBgpPeerBfdSessionInitializationMode Active { get; } = new RouterBgpPeerBfdSessionInitializationMode("ACTIVE");
        public static RouterBgpPeerBfdSessionInitializationMode Disabled { get; } = new RouterBgpPeerBfdSessionInitializationMode("DISABLED");
        public static RouterBgpPeerBfdSessionInitializationMode Passive { get; } = new RouterBgpPeerBfdSessionInitializationMode("PASSIVE");

        public static bool operator ==(RouterBgpPeerBfdSessionInitializationMode left, RouterBgpPeerBfdSessionInitializationMode right) => left.Equals(right);
        public static bool operator !=(RouterBgpPeerBfdSessionInitializationMode left, RouterBgpPeerBfdSessionInitializationMode right) => !left.Equals(right);

        public static explicit operator string(RouterBgpPeerBfdSessionInitializationMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterBgpPeerBfdSessionInitializationMode other && Equals(other);
        public bool Equals(RouterBgpPeerBfdSessionInitializationMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The status of the BGP peer connection. If set to FALSE, any active session with the peer is terminated and all associated routing information is removed. If set to TRUE, the peer connection can be established with routing information. The default is TRUE.
    /// </summary>
    [EnumType]
    public readonly struct RouterBgpPeerEnable : IEquatable<RouterBgpPeerEnable>
    {
        private readonly string _value;

        private RouterBgpPeerEnable(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterBgpPeerEnable False { get; } = new RouterBgpPeerEnable("FALSE");
        public static RouterBgpPeerEnable True { get; } = new RouterBgpPeerEnable("TRUE");

        public static bool operator ==(RouterBgpPeerEnable left, RouterBgpPeerEnable right) => left.Equals(right);
        public static bool operator !=(RouterBgpPeerEnable left, RouterBgpPeerEnable right) => !left.Equals(right);

        public static explicit operator string(RouterBgpPeerEnable value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterBgpPeerEnable other && Equals(other);
        public bool Equals(RouterBgpPeerEnable other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specify the desired filtering of logs on this NAT. If unspecified, logs are exported for all connections handled by this NAT. This option can take one of the following values: - ERRORS_ONLY: Export logs only for connection failures. - TRANSLATIONS_ONLY: Export logs only for successful connections. - ALL: Export logs for all connections, successful and unsuccessful. 
    /// </summary>
    [EnumType]
    public readonly struct RouterNatLogConfigFilter : IEquatable<RouterNatLogConfigFilter>
    {
        private readonly string _value;

        private RouterNatLogConfigFilter(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Export logs for all (successful and unsuccessful) connections.
        /// </summary>
        public static RouterNatLogConfigFilter All { get; } = new RouterNatLogConfigFilter("ALL");
        /// <summary>
        /// Export logs for connection failures only.
        /// </summary>
        public static RouterNatLogConfigFilter ErrorsOnly { get; } = new RouterNatLogConfigFilter("ERRORS_ONLY");
        /// <summary>
        /// Export logs for successful connections only.
        /// </summary>
        public static RouterNatLogConfigFilter TranslationsOnly { get; } = new RouterNatLogConfigFilter("TRANSLATIONS_ONLY");

        public static bool operator ==(RouterNatLogConfigFilter left, RouterNatLogConfigFilter right) => left.Equals(right);
        public static bool operator !=(RouterNatLogConfigFilter left, RouterNatLogConfigFilter right) => !left.Equals(right);

        public static explicit operator string(RouterNatLogConfigFilter value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterNatLogConfigFilter other && Equals(other);
        public bool Equals(RouterNatLogConfigFilter other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specify the NatIpAllocateOption, which can take one of the following values: - MANUAL_ONLY: Uses only Nat IP addresses provided by customers. When there are not enough specified Nat IPs, the Nat service fails for new VMs. - AUTO_ONLY: Nat IPs are allocated by Google Cloud Platform; customers can't specify any Nat IPs. When choosing AUTO_ONLY, then nat_ip should be empty. 
    /// </summary>
    [EnumType]
    public readonly struct RouterNatNatIpAllocateOption : IEquatable<RouterNatNatIpAllocateOption>
    {
        private readonly string _value;

        private RouterNatNatIpAllocateOption(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Nat IPs are allocated by GCP; customers can not specify any Nat IPs.
        /// </summary>
        public static RouterNatNatIpAllocateOption AutoOnly { get; } = new RouterNatNatIpAllocateOption("AUTO_ONLY");
        /// <summary>
        /// Only use Nat IPs provided by customers. When specified Nat IPs are not enough then the Nat service fails for new VMs.
        /// </summary>
        public static RouterNatNatIpAllocateOption ManualOnly { get; } = new RouterNatNatIpAllocateOption("MANUAL_ONLY");

        public static bool operator ==(RouterNatNatIpAllocateOption left, RouterNatNatIpAllocateOption right) => left.Equals(right);
        public static bool operator !=(RouterNatNatIpAllocateOption left, RouterNatNatIpAllocateOption right) => !left.Equals(right);

        public static explicit operator string(RouterNatNatIpAllocateOption value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterNatNatIpAllocateOption other && Equals(other);
        public bool Equals(RouterNatNatIpAllocateOption other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specify the Nat option, which can take one of the following values: - ALL_SUBNETWORKS_ALL_IP_RANGES: All of the IP ranges in every Subnetwork are allowed to Nat. - ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES: All of the primary IP ranges in every Subnetwork are allowed to Nat. - LIST_OF_SUBNETWORKS: A list of Subnetworks are allowed to Nat (specified in the field subnetwork below) The default is SUBNETWORK_IP_RANGE_TO_NAT_OPTION_UNSPECIFIED. Note that if this field contains ALL_SUBNETWORKS_ALL_IP_RANGES or ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES, then there should not be any other Router.Nat section in any Router for this network in this region.
    /// </summary>
    [EnumType]
    public readonly struct RouterNatSourceSubnetworkIpRangesToNat : IEquatable<RouterNatSourceSubnetworkIpRangesToNat>
    {
        private readonly string _value;

        private RouterNatSourceSubnetworkIpRangesToNat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// All the IP ranges in every Subnetwork are allowed to Nat.
        /// </summary>
        public static RouterNatSourceSubnetworkIpRangesToNat AllSubnetworksAllIpRanges { get; } = new RouterNatSourceSubnetworkIpRangesToNat("ALL_SUBNETWORKS_ALL_IP_RANGES");
        /// <summary>
        /// All the primary IP ranges in every Subnetwork are allowed to Nat.
        /// </summary>
        public static RouterNatSourceSubnetworkIpRangesToNat AllSubnetworksAllPrimaryIpRanges { get; } = new RouterNatSourceSubnetworkIpRangesToNat("ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES");
        /// <summary>
        /// A list of Subnetworks are allowed to Nat (specified in the field subnetwork below)
        /// </summary>
        public static RouterNatSourceSubnetworkIpRangesToNat ListOfSubnetworks { get; } = new RouterNatSourceSubnetworkIpRangesToNat("LIST_OF_SUBNETWORKS");

        public static bool operator ==(RouterNatSourceSubnetworkIpRangesToNat left, RouterNatSourceSubnetworkIpRangesToNat right) => left.Equals(right);
        public static bool operator !=(RouterNatSourceSubnetworkIpRangesToNat left, RouterNatSourceSubnetworkIpRangesToNat right) => !left.Equals(right);

        public static explicit operator string(RouterNatSourceSubnetworkIpRangesToNat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterNatSourceSubnetworkIpRangesToNat other && Equals(other);
        public bool Equals(RouterNatSourceSubnetworkIpRangesToNat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterNatSubnetworkToNatSourceIpRangesToNatItem : IEquatable<RouterNatSubnetworkToNatSourceIpRangesToNatItem>
    {
        private readonly string _value;

        private RouterNatSubnetworkToNatSourceIpRangesToNatItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The primary and all the secondary ranges are allowed to Nat.
        /// </summary>
        public static RouterNatSubnetworkToNatSourceIpRangesToNatItem AllIpRanges { get; } = new RouterNatSubnetworkToNatSourceIpRangesToNatItem("ALL_IP_RANGES");
        /// <summary>
        /// A list of secondary ranges are allowed to Nat.
        /// </summary>
        public static RouterNatSubnetworkToNatSourceIpRangesToNatItem ListOfSecondaryIpRanges { get; } = new RouterNatSubnetworkToNatSourceIpRangesToNatItem("LIST_OF_SECONDARY_IP_RANGES");
        /// <summary>
        /// The primary range is allowed to Nat.
        /// </summary>
        public static RouterNatSubnetworkToNatSourceIpRangesToNatItem PrimaryIpRange { get; } = new RouterNatSubnetworkToNatSourceIpRangesToNatItem("PRIMARY_IP_RANGE");

        public static bool operator ==(RouterNatSubnetworkToNatSourceIpRangesToNatItem left, RouterNatSubnetworkToNatSourceIpRangesToNatItem right) => left.Equals(right);
        public static bool operator !=(RouterNatSubnetworkToNatSourceIpRangesToNatItem left, RouterNatSubnetworkToNatSourceIpRangesToNatItem right) => !left.Equals(right);

        public static explicit operator string(RouterNatSubnetworkToNatSourceIpRangesToNatItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterNatSubnetworkToNatSourceIpRangesToNatItem other && Equals(other);
        public bool Equals(RouterNatSubnetworkToNatSourceIpRangesToNatItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This is deprecated and has no effect. Do not use.
    /// </summary>
    [EnumType]
    public readonly struct RuleAction : IEquatable<RuleAction>
    {
        private readonly string _value;

        private RuleAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static RuleAction Allow { get; } = new RuleAction("ALLOW");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static RuleAction AllowWithLog { get; } = new RuleAction("ALLOW_WITH_LOG");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static RuleAction Deny { get; } = new RuleAction("DENY");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static RuleAction DenyWithLog { get; } = new RuleAction("DENY_WITH_LOG");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static RuleAction Log { get; } = new RuleAction("LOG");
        /// <summary>
        /// This is deprecated and has no effect. Do not use.
        /// </summary>
        public static RuleAction NoAction { get; } = new RuleAction("NO_ACTION");

        public static bool operator ==(RuleAction left, RuleAction right) => left.Equals(right);
        public static bool operator !=(RuleAction left, RuleAction right) => !left.Equals(right);

        public static explicit operator string(RuleAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleAction other && Equals(other);
        public bool Equals(RuleAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how port is selected for health checking, can be one of following values: USE_FIXED_PORT: The port number in port is used for health checking. USE_NAMED_PORT: The portName is used for health checking. USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking. If not specified, SSL health check follows behavior specified in port and portName fields.
    /// </summary>
    [EnumType]
    public readonly struct SSLHealthCheckPortSpecification : IEquatable<SSLHealthCheckPortSpecification>
    {
        private readonly string _value;

        private SSLHealthCheckPortSpecification(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The port number in port is used for health checking.
        /// </summary>
        public static SSLHealthCheckPortSpecification UseFixedPort { get; } = new SSLHealthCheckPortSpecification("USE_FIXED_PORT");
        /// <summary>
        /// The portName is used for health checking.
        /// </summary>
        public static SSLHealthCheckPortSpecification UseNamedPort { get; } = new SSLHealthCheckPortSpecification("USE_NAMED_PORT");
        /// <summary>
        /// For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking.
        /// </summary>
        public static SSLHealthCheckPortSpecification UseServingPort { get; } = new SSLHealthCheckPortSpecification("USE_SERVING_PORT");

        public static bool operator ==(SSLHealthCheckPortSpecification left, SSLHealthCheckPortSpecification right) => left.Equals(right);
        public static bool operator !=(SSLHealthCheckPortSpecification left, SSLHealthCheckPortSpecification right) => !left.Equals(right);

        public static explicit operator string(SSLHealthCheckPortSpecification value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SSLHealthCheckPortSpecification other && Equals(other);
        public bool Equals(SSLHealthCheckPortSpecification other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
    /// </summary>
    [EnumType]
    public readonly struct SSLHealthCheckProxyHeader : IEquatable<SSLHealthCheckProxyHeader>
    {
        private readonly string _value;

        private SSLHealthCheckProxyHeader(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SSLHealthCheckProxyHeader None { get; } = new SSLHealthCheckProxyHeader("NONE");
        public static SSLHealthCheckProxyHeader ProxyV1 { get; } = new SSLHealthCheckProxyHeader("PROXY_V1");

        public static bool operator ==(SSLHealthCheckProxyHeader left, SSLHealthCheckProxyHeader right) => left.Equals(right);
        public static bool operator !=(SSLHealthCheckProxyHeader left, SSLHealthCheckProxyHeader right) => !left.Equals(right);

        public static explicit operator string(SSLHealthCheckProxyHeader value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SSLHealthCheckProxyHeader other && Equals(other);
        public bool Equals(SSLHealthCheckProxyHeader other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the termination action for the instance.
    /// </summary>
    [EnumType]
    public readonly struct SchedulingInstanceTerminationAction : IEquatable<SchedulingInstanceTerminationAction>
    {
        private readonly string _value;

        private SchedulingInstanceTerminationAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Delete the VM.
        /// </summary>
        public static SchedulingInstanceTerminationAction Delete { get; } = new SchedulingInstanceTerminationAction("DELETE");
        /// <summary>
        /// Default value. This value is unused.
        /// </summary>
        public static SchedulingInstanceTerminationAction InstanceTerminationActionUnspecified { get; } = new SchedulingInstanceTerminationAction("INSTANCE_TERMINATION_ACTION_UNSPECIFIED");
        /// <summary>
        /// Stop the VM without storing in-memory content. default action.
        /// </summary>
        public static SchedulingInstanceTerminationAction Stop { get; } = new SchedulingInstanceTerminationAction("STOP");

        public static bool operator ==(SchedulingInstanceTerminationAction left, SchedulingInstanceTerminationAction right) => left.Equals(right);
        public static bool operator !=(SchedulingInstanceTerminationAction left, SchedulingInstanceTerminationAction right) => !left.Equals(right);

        public static explicit operator string(SchedulingInstanceTerminationAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SchedulingInstanceTerminationAction other && Equals(other);
        public bool Equals(SchedulingInstanceTerminationAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// For more information about maintenance intervals, see Setting maintenance intervals.
    /// </summary>
    [EnumType]
    public readonly struct SchedulingMaintenanceInterval : IEquatable<SchedulingMaintenanceInterval>
    {
        private readonly string _value;

        private SchedulingMaintenanceInterval(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// VMs receive infrastructure and hypervisor updates on a periodic basis, minimizing the number of maintenance operations (live migrations or terminations) on an individual VM. This may mean a VM will take longer to receive an update than if it was configured for AS_NEEDED. Security updates will still be applied as soon as they are available.
        /// </summary>
        public static SchedulingMaintenanceInterval Periodic { get; } = new SchedulingMaintenanceInterval("PERIODIC");

        public static bool operator ==(SchedulingMaintenanceInterval left, SchedulingMaintenanceInterval right) => left.Equals(right);
        public static bool operator !=(SchedulingMaintenanceInterval left, SchedulingMaintenanceInterval right) => !left.Equals(right);

        public static explicit operator string(SchedulingMaintenanceInterval value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SchedulingMaintenanceInterval other && Equals(other);
        public bool Equals(SchedulingMaintenanceInterval other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines the operation of node selection. Valid operators are IN for affinity and NOT_IN for anti-affinity.
    /// </summary>
    [EnumType]
    public readonly struct SchedulingNodeAffinityOperator : IEquatable<SchedulingNodeAffinityOperator>
    {
        private readonly string _value;

        private SchedulingNodeAffinityOperator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Requires Compute Engine to seek for matched nodes.
        /// </summary>
        public static SchedulingNodeAffinityOperator In { get; } = new SchedulingNodeAffinityOperator("IN");
        /// <summary>
        /// Requires Compute Engine to avoid certain nodes.
        /// </summary>
        public static SchedulingNodeAffinityOperator NotIn { get; } = new SchedulingNodeAffinityOperator("NOT_IN");
        public static SchedulingNodeAffinityOperator OperatorUnspecified { get; } = new SchedulingNodeAffinityOperator("OPERATOR_UNSPECIFIED");

        public static bool operator ==(SchedulingNodeAffinityOperator left, SchedulingNodeAffinityOperator right) => left.Equals(right);
        public static bool operator !=(SchedulingNodeAffinityOperator left, SchedulingNodeAffinityOperator right) => !left.Equals(right);

        public static explicit operator string(SchedulingNodeAffinityOperator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SchedulingNodeAffinityOperator other && Equals(other);
        public bool Equals(SchedulingNodeAffinityOperator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines the maintenance behavior for this instance. For standard instances, the default behavior is MIGRATE. For preemptible instances, the default and only possible behavior is TERMINATE. For more information, see Setting Instance Scheduling Options.
    /// </summary>
    [EnumType]
    public readonly struct SchedulingOnHostMaintenance : IEquatable<SchedulingOnHostMaintenance>
    {
        private readonly string _value;

        private SchedulingOnHostMaintenance(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// *[Default]* Allows Compute Engine to automatically migrate instances out of the way of maintenance events.
        /// </summary>
        public static SchedulingOnHostMaintenance Migrate { get; } = new SchedulingOnHostMaintenance("MIGRATE");
        /// <summary>
        /// Tells Compute Engine to terminate and (optionally) restart the instance away from the maintenance activity. If you would like your instance to be restarted, set the automaticRestart flag to true. Your instance may be restarted more than once, and it may be restarted outside the window of maintenance events.
        /// </summary>
        public static SchedulingOnHostMaintenance Terminate { get; } = new SchedulingOnHostMaintenance("TERMINATE");

        public static bool operator ==(SchedulingOnHostMaintenance left, SchedulingOnHostMaintenance right) => left.Equals(right);
        public static bool operator !=(SchedulingOnHostMaintenance left, SchedulingOnHostMaintenance right) => !left.Equals(right);

        public static explicit operator string(SchedulingOnHostMaintenance value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SchedulingOnHostMaintenance other && Equals(other);
        public bool Equals(SchedulingOnHostMaintenance other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the provisioning model of the instance.
    /// </summary>
    [EnumType]
    public readonly struct SchedulingProvisioningModel : IEquatable<SchedulingProvisioningModel>
    {
        private readonly string _value;

        private SchedulingProvisioningModel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Heavily discounted, no guaranteed runtime.
        /// </summary>
        public static SchedulingProvisioningModel Spot { get; } = new SchedulingProvisioningModel("SPOT");
        /// <summary>
        /// Standard provisioning with user controlled runtime, no discounts.
        /// </summary>
        public static SchedulingProvisioningModel Standard { get; } = new SchedulingProvisioningModel("STANDARD");

        public static bool operator ==(SchedulingProvisioningModel left, SchedulingProvisioningModel right) => left.Equals(right);
        public static bool operator !=(SchedulingProvisioningModel left, SchedulingProvisioningModel right) => !left.Equals(right);

        public static explicit operator string(SchedulingProvisioningModel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SchedulingProvisioningModel other && Equals(other);
        public bool Equals(SchedulingProvisioningModel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Rule visibility can be one of the following: STANDARD - opaque rules. (default) PREMIUM - transparent rules.
    /// </summary>
    [EnumType]
    public readonly struct SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility : IEquatable<SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility>
    {
        private readonly string _value;

        private SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility Premium { get; } = new SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility("PREMIUM");
        public static SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility Standard { get; } = new SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility("STANDARD");

        public static bool operator ==(SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility left, SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility right) => left.Equals(right);
        public static bool operator !=(SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility left, SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility right) => !left.Equals(right);

        public static explicit operator string(SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility other && Equals(other);
        public bool Equals(SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct SecurityPolicyAdvancedOptionsConfigJsonParsing : IEquatable<SecurityPolicyAdvancedOptionsConfigJsonParsing>
    {
        private readonly string _value;

        private SecurityPolicyAdvancedOptionsConfigJsonParsing(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecurityPolicyAdvancedOptionsConfigJsonParsing Disabled { get; } = new SecurityPolicyAdvancedOptionsConfigJsonParsing("DISABLED");
        public static SecurityPolicyAdvancedOptionsConfigJsonParsing Standard { get; } = new SecurityPolicyAdvancedOptionsConfigJsonParsing("STANDARD");

        public static bool operator ==(SecurityPolicyAdvancedOptionsConfigJsonParsing left, SecurityPolicyAdvancedOptionsConfigJsonParsing right) => left.Equals(right);
        public static bool operator !=(SecurityPolicyAdvancedOptionsConfigJsonParsing left, SecurityPolicyAdvancedOptionsConfigJsonParsing right) => !left.Equals(right);

        public static explicit operator string(SecurityPolicyAdvancedOptionsConfigJsonParsing value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityPolicyAdvancedOptionsConfigJsonParsing other && Equals(other);
        public bool Equals(SecurityPolicyAdvancedOptionsConfigJsonParsing other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct SecurityPolicyAdvancedOptionsConfigLogLevel : IEquatable<SecurityPolicyAdvancedOptionsConfigLogLevel>
    {
        private readonly string _value;

        private SecurityPolicyAdvancedOptionsConfigLogLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecurityPolicyAdvancedOptionsConfigLogLevel Normal { get; } = new SecurityPolicyAdvancedOptionsConfigLogLevel("NORMAL");
        public static SecurityPolicyAdvancedOptionsConfigLogLevel Verbose { get; } = new SecurityPolicyAdvancedOptionsConfigLogLevel("VERBOSE");

        public static bool operator ==(SecurityPolicyAdvancedOptionsConfigLogLevel left, SecurityPolicyAdvancedOptionsConfigLogLevel right) => left.Equals(right);
        public static bool operator !=(SecurityPolicyAdvancedOptionsConfigLogLevel left, SecurityPolicyAdvancedOptionsConfigLogLevel right) => !left.Equals(right);

        public static explicit operator string(SecurityPolicyAdvancedOptionsConfigLogLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityPolicyAdvancedOptionsConfigLogLevel other && Equals(other);
        public bool Equals(SecurityPolicyAdvancedOptionsConfigLogLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The direction in which this rule applies. This field may only be specified when versioned_expr is set to FIREWALL.
    /// </summary>
    [EnumType]
    public readonly struct SecurityPolicyRuleDirection : IEquatable<SecurityPolicyRuleDirection>
    {
        private readonly string _value;

        private SecurityPolicyRuleDirection(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecurityPolicyRuleDirection Egress { get; } = new SecurityPolicyRuleDirection("EGRESS");
        public static SecurityPolicyRuleDirection Ingress { get; } = new SecurityPolicyRuleDirection("INGRESS");

        public static bool operator ==(SecurityPolicyRuleDirection left, SecurityPolicyRuleDirection right) => left.Equals(right);
        public static bool operator !=(SecurityPolicyRuleDirection left, SecurityPolicyRuleDirection right) => !left.Equals(right);

        public static explicit operator string(SecurityPolicyRuleDirection value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityPolicyRuleDirection other && Equals(other);
        public bool Equals(SecurityPolicyRuleDirection other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Preconfigured versioned expression. If this field is specified, config must also be specified. Available preconfigured expressions along with their requirements are: SRC_IPS_V1 - must specify the corresponding src_ip_range field in config.
    /// </summary>
    [EnumType]
    public readonly struct SecurityPolicyRuleMatcherVersionedExpr : IEquatable<SecurityPolicyRuleMatcherVersionedExpr>
    {
        private readonly string _value;

        private SecurityPolicyRuleMatcherVersionedExpr(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecurityPolicyRuleMatcherVersionedExpr Firewall { get; } = new SecurityPolicyRuleMatcherVersionedExpr("FIREWALL");
        /// <summary>
        /// Matches the source IP address of a request to the IP ranges supplied in config.
        /// </summary>
        public static SecurityPolicyRuleMatcherVersionedExpr SrcIpsV1 { get; } = new SecurityPolicyRuleMatcherVersionedExpr("SRC_IPS_V1");

        public static bool operator ==(SecurityPolicyRuleMatcherVersionedExpr left, SecurityPolicyRuleMatcherVersionedExpr right) => left.Equals(right);
        public static bool operator !=(SecurityPolicyRuleMatcherVersionedExpr left, SecurityPolicyRuleMatcherVersionedExpr right) => !left.Equals(right);

        public static explicit operator string(SecurityPolicyRuleMatcherVersionedExpr value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityPolicyRuleMatcherVersionedExpr other && Equals(other);
        public bool Equals(SecurityPolicyRuleMatcherVersionedExpr other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines the key to enforce the rate_limit_threshold on. Possible values are: - ALL: A single rate limit threshold is applied to all the requests matching this rule. This is the default value if this field 'enforce_on_key' is not configured. - IP: The source IP address of the request is the key. Each IP has this limit enforced separately. - HTTP_HEADER: The value of the HTTP header whose name is configured under "enforce_on_key_name". The key value is truncated to the first 128 bytes of the header value. If no such header is present in the request, the key type defaults to ALL. - XFF_IP: The first IP address (i.e. the originating client IP address) specified in the list of IPs under X-Forwarded-For HTTP header. If no such header is present or the value is not a valid IP, the key type defaults to ALL. - HTTP_COOKIE: The value of the HTTP cookie whose name is configured under "enforce_on_key_name". The key value is truncated to the first 128 bytes of the cookie value. If no such cookie is present in the request, the key type defaults to ALL. 
    /// </summary>
    [EnumType]
    public readonly struct SecurityPolicyRuleRateLimitOptionsEnforceOnKey : IEquatable<SecurityPolicyRuleRateLimitOptionsEnforceOnKey>
    {
        private readonly string _value;

        private SecurityPolicyRuleRateLimitOptionsEnforceOnKey(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecurityPolicyRuleRateLimitOptionsEnforceOnKey All { get; } = new SecurityPolicyRuleRateLimitOptionsEnforceOnKey("ALL");
        public static SecurityPolicyRuleRateLimitOptionsEnforceOnKey AllIps { get; } = new SecurityPolicyRuleRateLimitOptionsEnforceOnKey("ALL_IPS");
        public static SecurityPolicyRuleRateLimitOptionsEnforceOnKey HttpCookie { get; } = new SecurityPolicyRuleRateLimitOptionsEnforceOnKey("HTTP_COOKIE");
        public static SecurityPolicyRuleRateLimitOptionsEnforceOnKey HttpHeader { get; } = new SecurityPolicyRuleRateLimitOptionsEnforceOnKey("HTTP_HEADER");
        public static SecurityPolicyRuleRateLimitOptionsEnforceOnKey Ip { get; } = new SecurityPolicyRuleRateLimitOptionsEnforceOnKey("IP");
        public static SecurityPolicyRuleRateLimitOptionsEnforceOnKey XffIp { get; } = new SecurityPolicyRuleRateLimitOptionsEnforceOnKey("XFF_IP");

        public static bool operator ==(SecurityPolicyRuleRateLimitOptionsEnforceOnKey left, SecurityPolicyRuleRateLimitOptionsEnforceOnKey right) => left.Equals(right);
        public static bool operator !=(SecurityPolicyRuleRateLimitOptionsEnforceOnKey left, SecurityPolicyRuleRateLimitOptionsEnforceOnKey right) => !left.Equals(right);

        public static explicit operator string(SecurityPolicyRuleRateLimitOptionsEnforceOnKey value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityPolicyRuleRateLimitOptionsEnforceOnKey other && Equals(other);
        public bool Equals(SecurityPolicyRuleRateLimitOptionsEnforceOnKey other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of the redirect action.
    /// </summary>
    [EnumType]
    public readonly struct SecurityPolicyRuleRedirectOptionsType : IEquatable<SecurityPolicyRuleRedirectOptionsType>
    {
        private readonly string _value;

        private SecurityPolicyRuleRedirectOptionsType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecurityPolicyRuleRedirectOptionsType External302 { get; } = new SecurityPolicyRuleRedirectOptionsType("EXTERNAL_302");
        public static SecurityPolicyRuleRedirectOptionsType GoogleRecaptcha { get; } = new SecurityPolicyRuleRedirectOptionsType("GOOGLE_RECAPTCHA");

        public static bool operator ==(SecurityPolicyRuleRedirectOptionsType left, SecurityPolicyRuleRedirectOptionsType right) => left.Equals(right);
        public static bool operator !=(SecurityPolicyRuleRedirectOptionsType left, SecurityPolicyRuleRedirectOptionsType right) => !left.Equals(right);

        public static explicit operator string(SecurityPolicyRuleRedirectOptionsType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityPolicyRuleRedirectOptionsType other && Equals(other);
        public bool Equals(SecurityPolicyRuleRedirectOptionsType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type indicates the intended use of the security policy. CLOUD_ARMOR - Cloud Armor backend security policies can be configured to filter incoming HTTP requests targeting backend services. They filter requests before they hit the origin servers. CLOUD_ARMOR_EDGE - Cloud Armor edge security policies can be configured to filter incoming HTTP requests targeting backend services (including Cloud CDN-enabled) as well as backend buckets (Cloud Storage). They filter requests before the request is served from Google's cache.
    /// </summary>
    [EnumType]
    public readonly struct SecurityPolicyType : IEquatable<SecurityPolicyType>
    {
        private readonly string _value;

        private SecurityPolicyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecurityPolicyType CloudArmor { get; } = new SecurityPolicyType("CLOUD_ARMOR");
        public static SecurityPolicyType CloudArmorEdge { get; } = new SecurityPolicyType("CLOUD_ARMOR_EDGE");
        public static SecurityPolicyType Firewall { get; } = new SecurityPolicyType("FIREWALL");

        public static bool operator ==(SecurityPolicyType left, SecurityPolicyType right) => left.Equals(right);
        public static bool operator !=(SecurityPolicyType left, SecurityPolicyType right) => !left.Equals(right);

        public static explicit operator string(SecurityPolicyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityPolicyType other && Equals(other);
        public bool Equals(SecurityPolicyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct ServerBindingType : IEquatable<ServerBindingType>
    {
        private readonly string _value;

        private ServerBindingType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Node may associate with any physical server over its lifetime.
        /// </summary>
        public static ServerBindingType RestartNodeOnAnyServer { get; } = new ServerBindingType("RESTART_NODE_ON_ANY_SERVER");
        /// <summary>
        /// Node may associate with minimal physical servers over its lifetime.
        /// </summary>
        public static ServerBindingType RestartNodeOnMinimalServers { get; } = new ServerBindingType("RESTART_NODE_ON_MINIMAL_SERVERS");
        public static ServerBindingType ServerBindingTypeUnspecified { get; } = new ServerBindingType("SERVER_BINDING_TYPE_UNSPECIFIED");

        public static bool operator ==(ServerBindingType left, ServerBindingType right) => left.Equals(right);
        public static bool operator !=(ServerBindingType left, ServerBindingType right) => !left.Equals(right);

        public static explicit operator string(ServerBindingType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServerBindingType other && Equals(other);
        public bool Equals(ServerBindingType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The connection preference of service attachment. The value can be set to ACCEPT_AUTOMATIC. An ACCEPT_AUTOMATIC service attachment is one that always accepts the connection from consumer forwarding rules.
    /// </summary>
    [EnumType]
    public readonly struct ServiceAttachmentConnectionPreference : IEquatable<ServiceAttachmentConnectionPreference>
    {
        private readonly string _value;

        private ServiceAttachmentConnectionPreference(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServiceAttachmentConnectionPreference AcceptAutomatic { get; } = new ServiceAttachmentConnectionPreference("ACCEPT_AUTOMATIC");
        public static ServiceAttachmentConnectionPreference AcceptManual { get; } = new ServiceAttachmentConnectionPreference("ACCEPT_MANUAL");
        public static ServiceAttachmentConnectionPreference ConnectionPreferenceUnspecified { get; } = new ServiceAttachmentConnectionPreference("CONNECTION_PREFERENCE_UNSPECIFIED");

        public static bool operator ==(ServiceAttachmentConnectionPreference left, ServiceAttachmentConnectionPreference right) => left.Equals(right);
        public static bool operator !=(ServiceAttachmentConnectionPreference left, ServiceAttachmentConnectionPreference right) => !left.Equals(right);

        public static explicit operator string(ServiceAttachmentConnectionPreference value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceAttachmentConnectionPreference other && Equals(other);
        public bool Equals(ServiceAttachmentConnectionPreference other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of sharing for this shared-reservation
    /// </summary>
    [EnumType]
    public readonly struct ShareSettingsShareType : IEquatable<ShareSettingsShareType>
    {
        private readonly string _value;

        private ShareSettingsShareType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value.
        /// </summary>
        public static ShareSettingsShareType Local { get; } = new ShareSettingsShareType("LOCAL");
        /// <summary>
        /// Default value. This value is unused.
        /// </summary>
        public static ShareSettingsShareType ShareTypeUnspecified { get; } = new ShareSettingsShareType("SHARE_TYPE_UNSPECIFIED");
        /// <summary>
        /// Shared-reservation is open to specific projects
        /// </summary>
        public static ShareSettingsShareType SpecificProjects { get; } = new ShareSettingsShareType("SPECIFIC_PROJECTS");

        public static bool operator ==(ShareSettingsShareType left, ShareSettingsShareType right) => left.Equals(right);
        public static bool operator !=(ShareSettingsShareType left, ShareSettingsShareType right) => !left.Equals(right);

        public static explicit operator string(ShareSettingsShareType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ShareSettingsShareType other && Equals(other);
        public bool Equals(ShareSettingsShareType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// (Optional) Specifies the type of SSL certificate, either "SELF_MANAGED" or "MANAGED". If not specified, the certificate is self-managed and the fields certificate and private_key are used.
    /// </summary>
    [EnumType]
    public readonly struct SslCertificateType : IEquatable<SslCertificateType>
    {
        private readonly string _value;

        private SslCertificateType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Google-managed SSLCertificate.
        /// </summary>
        public static SslCertificateType Managed { get; } = new SslCertificateType("MANAGED");
        /// <summary>
        /// Certificate uploaded by user.
        /// </summary>
        public static SslCertificateType SelfManaged { get; } = new SslCertificateType("SELF_MANAGED");
        public static SslCertificateType TypeUnspecified { get; } = new SslCertificateType("TYPE_UNSPECIFIED");

        public static bool operator ==(SslCertificateType left, SslCertificateType right) => left.Equals(right);
        public static bool operator !=(SslCertificateType left, SslCertificateType right) => !left.Equals(right);

        public static explicit operator string(SslCertificateType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SslCertificateType other && Equals(other);
        public bool Equals(SslCertificateType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The minimum version of SSL protocol that can be used by the clients to establish a connection with the load balancer. This can be one of TLS_1_0, TLS_1_1, TLS_1_2.
    /// </summary>
    [EnumType]
    public readonly struct SslPolicyMinTlsVersion : IEquatable<SslPolicyMinTlsVersion>
    {
        private readonly string _value;

        private SslPolicyMinTlsVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// TLS 1.0
        /// </summary>
        public static SslPolicyMinTlsVersion Tls10 { get; } = new SslPolicyMinTlsVersion("TLS_1_0");
        /// <summary>
        /// TLS 1.1
        /// </summary>
        public static SslPolicyMinTlsVersion Tls11 { get; } = new SslPolicyMinTlsVersion("TLS_1_1");
        /// <summary>
        /// TLS 1.2
        /// </summary>
        public static SslPolicyMinTlsVersion Tls12 { get; } = new SslPolicyMinTlsVersion("TLS_1_2");

        public static bool operator ==(SslPolicyMinTlsVersion left, SslPolicyMinTlsVersion right) => left.Equals(right);
        public static bool operator !=(SslPolicyMinTlsVersion left, SslPolicyMinTlsVersion right) => !left.Equals(right);

        public static explicit operator string(SslPolicyMinTlsVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SslPolicyMinTlsVersion other && Equals(other);
        public bool Equals(SslPolicyMinTlsVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Profile specifies the set of SSL features that can be used by the load balancer when negotiating SSL with clients. This can be one of COMPATIBLE, MODERN, RESTRICTED, or CUSTOM. If using CUSTOM, the set of SSL features to enable must be specified in the customFeatures field.
    /// </summary>
    [EnumType]
    public readonly struct SslPolicyProfile : IEquatable<SslPolicyProfile>
    {
        private readonly string _value;

        private SslPolicyProfile(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Compatible profile. Allows the broadset set of clients, even those which support only out-of-date SSL features to negotiate with the load balancer.
        /// </summary>
        public static SslPolicyProfile Compatible { get; } = new SslPolicyProfile("COMPATIBLE");
        /// <summary>
        /// Custom profile. Allow only the set of allowed SSL features specified in the customFeatures field.
        /// </summary>
        public static SslPolicyProfile Custom { get; } = new SslPolicyProfile("CUSTOM");
        /// <summary>
        /// Modern profile. Supports a wide set of SSL features, allowing modern clients to negotiate SSL with the load balancer.
        /// </summary>
        public static SslPolicyProfile Modern { get; } = new SslPolicyProfile("MODERN");
        /// <summary>
        /// Restricted profile. Supports a reduced set of SSL features, intended to meet stricter compliance requirements.
        /// </summary>
        public static SslPolicyProfile Restricted { get; } = new SslPolicyProfile("RESTRICTED");

        public static bool operator ==(SslPolicyProfile left, SslPolicyProfile right) => left.Equals(right);
        public static bool operator !=(SslPolicyProfile left, SslPolicyProfile right) => !left.Equals(right);

        public static explicit operator string(SslPolicyProfile value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SslPolicyProfile other && Equals(other);
        public bool Equals(SslPolicyProfile other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The access type of IPv6 address this subnet holds. It's immutable and can only be specified during creation or the first time the subnet is updated into IPV4_IPV6 dual stack. If the ipv6_type is EXTERNAL then this subnet cannot enable direct path.
    /// </summary>
    [EnumType]
    public readonly struct SubnetworkIpv6AccessType : IEquatable<SubnetworkIpv6AccessType>
    {
        private readonly string _value;

        private SubnetworkIpv6AccessType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// VMs on this subnet will be assigned IPv6 addresses that are accesible via the Internet, as well as the VPC network.
        /// </summary>
        public static SubnetworkIpv6AccessType External { get; } = new SubnetworkIpv6AccessType("EXTERNAL");
        /// <summary>
        /// IPv6 access type not set. Means this subnet hasn't been turned on IPv6 yet.
        /// </summary>
        public static SubnetworkIpv6AccessType UnspecifiedIpv6AccessType { get; } = new SubnetworkIpv6AccessType("UNSPECIFIED_IPV6_ACCESS_TYPE");

        public static bool operator ==(SubnetworkIpv6AccessType left, SubnetworkIpv6AccessType right) => left.Equals(right);
        public static bool operator !=(SubnetworkIpv6AccessType left, SubnetworkIpv6AccessType right) => !left.Equals(right);

        public static explicit operator string(SubnetworkIpv6AccessType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SubnetworkIpv6AccessType other && Equals(other);
        public bool Equals(SubnetworkIpv6AccessType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Can only be specified if VPC flow logging for this subnetwork is enabled. Toggles the aggregation interval for collecting flow logs. Increasing the interval time will reduce the amount of generated flow logs for long lasting connections. Default is an interval of 5 seconds per connection.
    /// </summary>
    [EnumType]
    public readonly struct SubnetworkLogConfigAggregationInterval : IEquatable<SubnetworkLogConfigAggregationInterval>
    {
        private readonly string _value;

        private SubnetworkLogConfigAggregationInterval(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SubnetworkLogConfigAggregationInterval Interval10Min { get; } = new SubnetworkLogConfigAggregationInterval("INTERVAL_10_MIN");
        public static SubnetworkLogConfigAggregationInterval Interval15Min { get; } = new SubnetworkLogConfigAggregationInterval("INTERVAL_15_MIN");
        public static SubnetworkLogConfigAggregationInterval Interval1Min { get; } = new SubnetworkLogConfigAggregationInterval("INTERVAL_1_MIN");
        public static SubnetworkLogConfigAggregationInterval Interval30Sec { get; } = new SubnetworkLogConfigAggregationInterval("INTERVAL_30_SEC");
        public static SubnetworkLogConfigAggregationInterval Interval5Min { get; } = new SubnetworkLogConfigAggregationInterval("INTERVAL_5_MIN");
        public static SubnetworkLogConfigAggregationInterval Interval5Sec { get; } = new SubnetworkLogConfigAggregationInterval("INTERVAL_5_SEC");

        public static bool operator ==(SubnetworkLogConfigAggregationInterval left, SubnetworkLogConfigAggregationInterval right) => left.Equals(right);
        public static bool operator !=(SubnetworkLogConfigAggregationInterval left, SubnetworkLogConfigAggregationInterval right) => !left.Equals(right);

        public static explicit operator string(SubnetworkLogConfigAggregationInterval value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SubnetworkLogConfigAggregationInterval other && Equals(other);
        public bool Equals(SubnetworkLogConfigAggregationInterval other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Can only be specified if VPC flow logs for this subnetwork is enabled. Configures whether all, none or a subset of metadata fields should be added to the reported VPC flow logs. Default is EXCLUDE_ALL_METADATA.
    /// </summary>
    [EnumType]
    public readonly struct SubnetworkLogConfigMetadata : IEquatable<SubnetworkLogConfigMetadata>
    {
        private readonly string _value;

        private SubnetworkLogConfigMetadata(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SubnetworkLogConfigMetadata CustomMetadata { get; } = new SubnetworkLogConfigMetadata("CUSTOM_METADATA");
        public static SubnetworkLogConfigMetadata ExcludeAllMetadata { get; } = new SubnetworkLogConfigMetadata("EXCLUDE_ALL_METADATA");
        public static SubnetworkLogConfigMetadata IncludeAllMetadata { get; } = new SubnetworkLogConfigMetadata("INCLUDE_ALL_METADATA");

        public static bool operator ==(SubnetworkLogConfigMetadata left, SubnetworkLogConfigMetadata right) => left.Equals(right);
        public static bool operator !=(SubnetworkLogConfigMetadata left, SubnetworkLogConfigMetadata right) => !left.Equals(right);

        public static explicit operator string(SubnetworkLogConfigMetadata value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SubnetworkLogConfigMetadata other && Equals(other);
        public bool Equals(SubnetworkLogConfigMetadata other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The private IPv6 google access type for the VMs in this subnet. This is an expanded field of enablePrivateV6Access. If both fields are set, privateIpv6GoogleAccess will take priority. This field can be both set at resource creation time and updated using patch.
    /// </summary>
    [EnumType]
    public readonly struct SubnetworkPrivateIpv6GoogleAccess : IEquatable<SubnetworkPrivateIpv6GoogleAccess>
    {
        private readonly string _value;

        private SubnetworkPrivateIpv6GoogleAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Disable private IPv6 access to/from Google services.
        /// </summary>
        public static SubnetworkPrivateIpv6GoogleAccess DisableGoogleAccess { get; } = new SubnetworkPrivateIpv6GoogleAccess("DISABLE_GOOGLE_ACCESS");
        /// <summary>
        /// Bidirectional private IPv6 access to/from Google services.
        /// </summary>
        public static SubnetworkPrivateIpv6GoogleAccess EnableBidirectionalAccessToGoogle { get; } = new SubnetworkPrivateIpv6GoogleAccess("ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE");
        /// <summary>
        /// Outbound private IPv6 access from VMs in this subnet to Google services.
        /// </summary>
        public static SubnetworkPrivateIpv6GoogleAccess EnableOutboundVmAccessToGoogle { get; } = new SubnetworkPrivateIpv6GoogleAccess("ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE");

        public static bool operator ==(SubnetworkPrivateIpv6GoogleAccess left, SubnetworkPrivateIpv6GoogleAccess right) => left.Equals(right);
        public static bool operator !=(SubnetworkPrivateIpv6GoogleAccess left, SubnetworkPrivateIpv6GoogleAccess right) => !left.Equals(right);

        public static explicit operator string(SubnetworkPrivateIpv6GoogleAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SubnetworkPrivateIpv6GoogleAccess other && Equals(other);
        public bool Equals(SubnetworkPrivateIpv6GoogleAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The purpose of the resource. This field can be either PRIVATE_RFC_1918 or INTERNAL_HTTPS_LOAD_BALANCER. A subnetwork with purpose set to INTERNAL_HTTPS_LOAD_BALANCER is a user-created subnetwork that is reserved for Internal HTTP(S) Load Balancing. If unspecified, the purpose defaults to PRIVATE_RFC_1918. The enableFlowLogs field isn't supported with the purpose field set to INTERNAL_HTTPS_LOAD_BALANCER.
    /// </summary>
    [EnumType]
    public readonly struct SubnetworkPurpose : IEquatable<SubnetworkPurpose>
    {
        private readonly string _value;

        private SubnetworkPurpose(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Subnet reserved for Internal HTTP(S) Load Balancing.
        /// </summary>
        public static SubnetworkPurpose InternalHttpsLoadBalancer { get; } = new SubnetworkPurpose("INTERNAL_HTTPS_LOAD_BALANCER");
        /// <summary>
        /// Regular user created or automatically created subnet.
        /// </summary>
        public static SubnetworkPurpose Private { get; } = new SubnetworkPurpose("PRIVATE");
        /// <summary>
        /// Regular user created or automatically created subnet.
        /// </summary>
        public static SubnetworkPurpose PrivateRfc1918 { get; } = new SubnetworkPurpose("PRIVATE_RFC_1918");
        /// <summary>
        /// Subnetworks created for Private Service Connect in the producer network.
        /// </summary>
        public static SubnetworkPurpose PrivateServiceConnect { get; } = new SubnetworkPurpose("PRIVATE_SERVICE_CONNECT");
        /// <summary>
        /// Subnetwork used for Regional Internal/External HTTP(S) Load Balancing.
        /// </summary>
        public static SubnetworkPurpose RegionalManagedProxy { get; } = new SubnetworkPurpose("REGIONAL_MANAGED_PROXY");

        public static bool operator ==(SubnetworkPurpose left, SubnetworkPurpose right) => left.Equals(right);
        public static bool operator !=(SubnetworkPurpose left, SubnetworkPurpose right) => !left.Equals(right);

        public static explicit operator string(SubnetworkPurpose value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SubnetworkPurpose other && Equals(other);
        public bool Equals(SubnetworkPurpose other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The role of subnetwork. Currently, this field is only used when purpose = INTERNAL_HTTPS_LOAD_BALANCER. The value can be set to ACTIVE or BACKUP. An ACTIVE subnetwork is one that is currently being used for Internal HTTP(S) Load Balancing. A BACKUP subnetwork is one that is ready to be promoted to ACTIVE or is currently draining. This field can be updated with a patch request.
    /// </summary>
    [EnumType]
    public readonly struct SubnetworkRole : IEquatable<SubnetworkRole>
    {
        private readonly string _value;

        private SubnetworkRole(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The ACTIVE subnet that is currently used.
        /// </summary>
        public static SubnetworkRole Active { get; } = new SubnetworkRole("ACTIVE");
        /// <summary>
        /// The BACKUP subnet that could be promoted to ACTIVE.
        /// </summary>
        public static SubnetworkRole Backup { get; } = new SubnetworkRole("BACKUP");

        public static bool operator ==(SubnetworkRole left, SubnetworkRole right) => left.Equals(right);
        public static bool operator !=(SubnetworkRole left, SubnetworkRole right) => !left.Equals(right);

        public static explicit operator string(SubnetworkRole value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SubnetworkRole other && Equals(other);
        public bool Equals(SubnetworkRole other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The stack type for this subnet to identify whether the IPv6 feature is enabled or not. If not specified IPV4_ONLY will be used. This field can be both set at resource creation time and updated using patch.
    /// </summary>
    [EnumType]
    public readonly struct SubnetworkStackType : IEquatable<SubnetworkStackType>
    {
        private readonly string _value;

        private SubnetworkStackType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// New VMs in this subnet can have both IPv4 and IPv6 addresses.
        /// </summary>
        public static SubnetworkStackType Ipv4Ipv6 { get; } = new SubnetworkStackType("IPV4_IPV6");
        /// <summary>
        /// New VMs in this subnet will only be assigned IPv4 addresses.
        /// </summary>
        public static SubnetworkStackType Ipv4Only { get; } = new SubnetworkStackType("IPV4_ONLY");
        public static SubnetworkStackType UnspecifiedStackType { get; } = new SubnetworkStackType("UNSPECIFIED_STACK_TYPE");

        public static bool operator ==(SubnetworkStackType left, SubnetworkStackType right) => left.Equals(right);
        public static bool operator !=(SubnetworkStackType left, SubnetworkStackType right) => !left.Equals(right);

        public static explicit operator string(SubnetworkStackType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SubnetworkStackType other && Equals(other);
        public bool Equals(SubnetworkStackType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct SubsettingPolicy : IEquatable<SubsettingPolicy>
    {
        private readonly string _value;

        private SubsettingPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Subsetting based on consistent hashing. For Traffic Director, the number of backends per backend group (the subset size) is based on the `subset_size` parameter. For Internal HTTP(S) load balancing, the number of backends per backend group (the subset size) is dynamically adjusted in two cases: - As the number of proxy instances participating in Internal HTTP(S) load balancing increases, the subset size decreases. - When the total number of backends in a network exceeds the capacity of a single proxy instance, subset sizes are reduced automatically for each service that has backend subsetting enabled.
        /// </summary>
        public static SubsettingPolicy ConsistentHashSubsetting { get; } = new SubsettingPolicy("CONSISTENT_HASH_SUBSETTING");
        /// <summary>
        /// No Subsetting. Clients may open connections and send traffic to all backends of this backend service. This can lead to performance issues if there is substantial imbalance in the count of clients and backends.
        /// </summary>
        public static SubsettingPolicy None { get; } = new SubsettingPolicy("NONE");

        public static bool operator ==(SubsettingPolicy left, SubsettingPolicy right) => left.Equals(right);
        public static bool operator !=(SubsettingPolicy left, SubsettingPolicy right) => !left.Equals(right);

        public static explicit operator string(SubsettingPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SubsettingPolicy other && Equals(other);
        public bool Equals(SubsettingPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how port is selected for health checking, can be one of following values: USE_FIXED_PORT: The port number in port is used for health checking. USE_NAMED_PORT: The portName is used for health checking. USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking. If not specified, TCP health check follows behavior specified in port and portName fields.
    /// </summary>
    [EnumType]
    public readonly struct TCPHealthCheckPortSpecification : IEquatable<TCPHealthCheckPortSpecification>
    {
        private readonly string _value;

        private TCPHealthCheckPortSpecification(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The port number in port is used for health checking.
        /// </summary>
        public static TCPHealthCheckPortSpecification UseFixedPort { get; } = new TCPHealthCheckPortSpecification("USE_FIXED_PORT");
        /// <summary>
        /// The portName is used for health checking.
        /// </summary>
        public static TCPHealthCheckPortSpecification UseNamedPort { get; } = new TCPHealthCheckPortSpecification("USE_NAMED_PORT");
        /// <summary>
        /// For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking.
        /// </summary>
        public static TCPHealthCheckPortSpecification UseServingPort { get; } = new TCPHealthCheckPortSpecification("USE_SERVING_PORT");

        public static bool operator ==(TCPHealthCheckPortSpecification left, TCPHealthCheckPortSpecification right) => left.Equals(right);
        public static bool operator !=(TCPHealthCheckPortSpecification left, TCPHealthCheckPortSpecification right) => !left.Equals(right);

        public static explicit operator string(TCPHealthCheckPortSpecification value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TCPHealthCheckPortSpecification other && Equals(other);
        public bool Equals(TCPHealthCheckPortSpecification other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
    /// </summary>
    [EnumType]
    public readonly struct TCPHealthCheckProxyHeader : IEquatable<TCPHealthCheckProxyHeader>
    {
        private readonly string _value;

        private TCPHealthCheckProxyHeader(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TCPHealthCheckProxyHeader None { get; } = new TCPHealthCheckProxyHeader("NONE");
        public static TCPHealthCheckProxyHeader ProxyV1 { get; } = new TCPHealthCheckProxyHeader("PROXY_V1");

        public static bool operator ==(TCPHealthCheckProxyHeader left, TCPHealthCheckProxyHeader right) => left.Equals(right);
        public static bool operator !=(TCPHealthCheckProxyHeader left, TCPHealthCheckProxyHeader right) => !left.Equals(right);

        public static explicit operator string(TCPHealthCheckProxyHeader value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TCPHealthCheckProxyHeader other && Equals(other);
        public bool Equals(TCPHealthCheckProxyHeader other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the QUIC override policy for this TargetHttpsProxy resource. This setting determines whether the load balancer attempts to negotiate QUIC with clients. You can specify NONE, ENABLE, or DISABLE. - When quic-override is set to NONE, Google manages whether QUIC is used. - When quic-override is set to ENABLE, the load balancer uses QUIC when possible. - When quic-override is set to DISABLE, the load balancer doesn't use QUIC. - If the quic-override flag is not specified, NONE is implied. 
    /// </summary>
    [EnumType]
    public readonly struct TargetHttpsProxyQuicOverride : IEquatable<TargetHttpsProxyQuicOverride>
    {
        private readonly string _value;

        private TargetHttpsProxyQuicOverride(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The load balancer will not attempt to negotiate QUIC with clients.
        /// </summary>
        public static TargetHttpsProxyQuicOverride Disable { get; } = new TargetHttpsProxyQuicOverride("DISABLE");
        /// <summary>
        /// The load balancer will attempt to negotiate QUIC with clients.
        /// </summary>
        public static TargetHttpsProxyQuicOverride Enable { get; } = new TargetHttpsProxyQuicOverride("ENABLE");
        /// <summary>
        /// No overrides to the default QUIC policy. This option is implicit if no QUIC override has been specified in the request.
        /// </summary>
        public static TargetHttpsProxyQuicOverride None { get; } = new TargetHttpsProxyQuicOverride("NONE");

        public static bool operator ==(TargetHttpsProxyQuicOverride left, TargetHttpsProxyQuicOverride right) => left.Equals(right);
        public static bool operator !=(TargetHttpsProxyQuicOverride left, TargetHttpsProxyQuicOverride right) => !left.Equals(right);

        public static explicit operator string(TargetHttpsProxyQuicOverride value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TargetHttpsProxyQuicOverride other && Equals(other);
        public bool Equals(TargetHttpsProxyQuicOverride other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// NAT option controlling how IPs are NAT'ed to the instance. Currently only NO_NAT (default value) is supported.
    /// </summary>
    [EnumType]
    public readonly struct TargetInstanceNatPolicy : IEquatable<TargetInstanceNatPolicy>
    {
        private readonly string _value;

        private TargetInstanceNatPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No NAT performed.
        /// </summary>
        public static TargetInstanceNatPolicy NoNat { get; } = new TargetInstanceNatPolicy("NO_NAT");

        public static bool operator ==(TargetInstanceNatPolicy left, TargetInstanceNatPolicy right) => left.Equals(right);
        public static bool operator !=(TargetInstanceNatPolicy left, TargetInstanceNatPolicy right) => !left.Equals(right);

        public static explicit operator string(TargetInstanceNatPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TargetInstanceNatPolicy other && Equals(other);
        public bool Equals(TargetInstanceNatPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Session affinity option, must be one of the following values: NONE: Connections from the same client IP may go to any instance in the pool. CLIENT_IP: Connections from the same client IP will go to the same instance in the pool while that instance remains healthy. CLIENT_IP_PROTO: Connections from the same client IP with the same IP protocol will go to the same instance in the pool while that instance remains healthy.
    /// </summary>
    [EnumType]
    public readonly struct TargetPoolSessionAffinity : IEquatable<TargetPoolSessionAffinity>
    {
        private readonly string _value;

        private TargetPoolSessionAffinity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// 2-tuple hash on packet's source and destination IP addresses. Connections from the same source IP address to the same destination IP address will be served by the same backend VM while that VM remains healthy.
        /// </summary>
        public static TargetPoolSessionAffinity ClientIp { get; } = new TargetPoolSessionAffinity("CLIENT_IP");
        /// <summary>
        /// 1-tuple hash only on packet's source IP address. Connections from the same source IP address will be served by the same backend VM while that VM remains healthy. This option can only be used for Internal TCP/UDP Load Balancing.
        /// </summary>
        public static TargetPoolSessionAffinity ClientIpNoDestination { get; } = new TargetPoolSessionAffinity("CLIENT_IP_NO_DESTINATION");
        /// <summary>
        /// 5-tuple hash on packet's source and destination IP addresses, IP protocol, and source and destination ports. Connections for the same IP protocol from the same source IP address and port to the same destination IP address and port will be served by the same backend VM while that VM remains healthy. This option cannot be used for HTTP(S) load balancing.
        /// </summary>
        public static TargetPoolSessionAffinity ClientIpPortProto { get; } = new TargetPoolSessionAffinity("CLIENT_IP_PORT_PROTO");
        /// <summary>
        /// 3-tuple hash on packet's source and destination IP addresses, and IP protocol. Connections for the same IP protocol from the same source IP address to the same destination IP address will be served by the same backend VM while that VM remains healthy. This option cannot be used for HTTP(S) load balancing.
        /// </summary>
        public static TargetPoolSessionAffinity ClientIpProto { get; } = new TargetPoolSessionAffinity("CLIENT_IP_PROTO");
        /// <summary>
        /// Hash based on a cookie generated by the L7 loadbalancer. Only valid for HTTP(S) load balancing.
        /// </summary>
        public static TargetPoolSessionAffinity GeneratedCookie { get; } = new TargetPoolSessionAffinity("GENERATED_COOKIE");
        /// <summary>
        /// The hash is based on a user specified header field.
        /// </summary>
        public static TargetPoolSessionAffinity HeaderField { get; } = new TargetPoolSessionAffinity("HEADER_FIELD");
        /// <summary>
        /// The hash is based on a user provided cookie.
        /// </summary>
        public static TargetPoolSessionAffinity HttpCookie { get; } = new TargetPoolSessionAffinity("HTTP_COOKIE");
        /// <summary>
        /// No session affinity. Connections from the same client IP may go to any instance in the pool.
        /// </summary>
        public static TargetPoolSessionAffinity None { get; } = new TargetPoolSessionAffinity("NONE");

        public static bool operator ==(TargetPoolSessionAffinity left, TargetPoolSessionAffinity right) => left.Equals(right);
        public static bool operator !=(TargetPoolSessionAffinity left, TargetPoolSessionAffinity right) => !left.Equals(right);

        public static explicit operator string(TargetPoolSessionAffinity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TargetPoolSessionAffinity other && Equals(other);
        public bool Equals(TargetPoolSessionAffinity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
    /// </summary>
    [EnumType]
    public readonly struct TargetSslProxyProxyHeader : IEquatable<TargetSslProxyProxyHeader>
    {
        private readonly string _value;

        private TargetSslProxyProxyHeader(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TargetSslProxyProxyHeader None { get; } = new TargetSslProxyProxyHeader("NONE");
        public static TargetSslProxyProxyHeader ProxyV1 { get; } = new TargetSslProxyProxyHeader("PROXY_V1");

        public static bool operator ==(TargetSslProxyProxyHeader left, TargetSslProxyProxyHeader right) => left.Equals(right);
        public static bool operator !=(TargetSslProxyProxyHeader left, TargetSslProxyProxyHeader right) => !left.Equals(right);

        public static explicit operator string(TargetSslProxyProxyHeader value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TargetSslProxyProxyHeader other && Equals(other);
        public bool Equals(TargetSslProxyProxyHeader other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
    /// </summary>
    [EnumType]
    public readonly struct TargetTcpProxyProxyHeader : IEquatable<TargetTcpProxyProxyHeader>
    {
        private readonly string _value;

        private TargetTcpProxyProxyHeader(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TargetTcpProxyProxyHeader None { get; } = new TargetTcpProxyProxyHeader("NONE");
        public static TargetTcpProxyProxyHeader ProxyV1 { get; } = new TargetTcpProxyProxyHeader("PROXY_V1");

        public static bool operator ==(TargetTcpProxyProxyHeader left, TargetTcpProxyProxyHeader right) => left.Equals(right);
        public static bool operator !=(TargetTcpProxyProxyHeader left, TargetTcpProxyProxyHeader right) => !left.Equals(right);

        public static explicit operator string(TargetTcpProxyProxyHeader value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TargetTcpProxyProxyHeader other && Equals(other);
        public bool Equals(TargetTcpProxyProxyHeader other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The stack type for this VPN gateway to identify the IP protocols that are enabled. If not specified, IPV4_ONLY will be used.
    /// </summary>
    [EnumType]
    public readonly struct VpnGatewayStackType : IEquatable<VpnGatewayStackType>
    {
        private readonly string _value;

        private VpnGatewayStackType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Enable VPN gateway with both IPv4 and IPv6 protocols.
        /// </summary>
        public static VpnGatewayStackType Ipv4Ipv6 { get; } = new VpnGatewayStackType("IPV4_IPV6");
        /// <summary>
        /// Enable VPN gateway with only IPv4 protocol.
        /// </summary>
        public static VpnGatewayStackType Ipv4Only { get; } = new VpnGatewayStackType("IPV4_ONLY");

        public static bool operator ==(VpnGatewayStackType left, VpnGatewayStackType right) => left.Equals(right);
        public static bool operator !=(VpnGatewayStackType left, VpnGatewayStackType right) => !left.Equals(right);

        public static explicit operator string(VpnGatewayStackType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VpnGatewayStackType other && Equals(other);
        public bool Equals(VpnGatewayStackType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
