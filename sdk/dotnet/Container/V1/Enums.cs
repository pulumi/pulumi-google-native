// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.Container.V1
{
    /// <summary>
    /// Which load balancer type is installed for Cloud Run.
    /// </summary>
    [EnumType]
    public readonly struct CloudRunConfigLoadBalancerType : IEquatable<CloudRunConfigLoadBalancerType>
    {
        private readonly string _value;

        private CloudRunConfigLoadBalancerType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Load balancer type for Cloud Run is unspecified.
        /// </summary>
        public static CloudRunConfigLoadBalancerType LoadBalancerTypeUnspecified { get; } = new CloudRunConfigLoadBalancerType("LOAD_BALANCER_TYPE_UNSPECIFIED");
        /// <summary>
        /// Install external load balancer for Cloud Run.
        /// </summary>
        public static CloudRunConfigLoadBalancerType LoadBalancerTypeExternal { get; } = new CloudRunConfigLoadBalancerType("LOAD_BALANCER_TYPE_EXTERNAL");
        /// <summary>
        /// Install internal load balancer for Cloud Run.
        /// </summary>
        public static CloudRunConfigLoadBalancerType LoadBalancerTypeInternal { get; } = new CloudRunConfigLoadBalancerType("LOAD_BALANCER_TYPE_INTERNAL");

        public static bool operator ==(CloudRunConfigLoadBalancerType left, CloudRunConfigLoadBalancerType right) => left.Equals(right);
        public static bool operator !=(CloudRunConfigLoadBalancerType left, CloudRunConfigLoadBalancerType right) => !left.Equals(right);

        public static explicit operator string(CloudRunConfigLoadBalancerType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CloudRunConfigLoadBalancerType other && Equals(other);
        public bool Equals(CloudRunConfigLoadBalancerType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines autoscaling behaviour.
    /// </summary>
    [EnumType]
    public readonly struct ClusterAutoscalingAutoscalingProfile : IEquatable<ClusterAutoscalingAutoscalingProfile>
    {
        private readonly string _value;

        private ClusterAutoscalingAutoscalingProfile(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No change to autoscaling configuration.
        /// </summary>
        public static ClusterAutoscalingAutoscalingProfile ProfileUnspecified { get; } = new ClusterAutoscalingAutoscalingProfile("PROFILE_UNSPECIFIED");
        /// <summary>
        /// Prioritize optimizing utilization of resources.
        /// </summary>
        public static ClusterAutoscalingAutoscalingProfile OptimizeUtilization { get; } = new ClusterAutoscalingAutoscalingProfile("OPTIMIZE_UTILIZATION");
        /// <summary>
        /// Use default (balanced) autoscaling configuration.
        /// </summary>
        public static ClusterAutoscalingAutoscalingProfile Balanced { get; } = new ClusterAutoscalingAutoscalingProfile("BALANCED");

        public static bool operator ==(ClusterAutoscalingAutoscalingProfile left, ClusterAutoscalingAutoscalingProfile right) => left.Equals(right);
        public static bool operator !=(ClusterAutoscalingAutoscalingProfile left, ClusterAutoscalingAutoscalingProfile right) => !left.Equals(right);

        public static explicit operator string(ClusterAutoscalingAutoscalingProfile value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterAutoscalingAutoscalingProfile other && Equals(other);
        public bool Equals(ClusterAutoscalingAutoscalingProfile other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The desired datapath provider for the cluster.
    /// </summary>
    [EnumType]
    public readonly struct ClusterUpdateDesiredDatapathProvider : IEquatable<ClusterUpdateDesiredDatapathProvider>
    {
        private readonly string _value;

        private ClusterUpdateDesiredDatapathProvider(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value.
        /// </summary>
        public static ClusterUpdateDesiredDatapathProvider DatapathProviderUnspecified { get; } = new ClusterUpdateDesiredDatapathProvider("DATAPATH_PROVIDER_UNSPECIFIED");
        /// <summary>
        /// Use the IPTables implementation based on kube-proxy.
        /// </summary>
        public static ClusterUpdateDesiredDatapathProvider LegacyDatapath { get; } = new ClusterUpdateDesiredDatapathProvider("LEGACY_DATAPATH");
        /// <summary>
        /// Use the eBPF based GKE Dataplane V2 with additional features. See the [GKE Dataplane V2 documentation](https://cloud.google.com/kubernetes-engine/docs/how-to/dataplane-v2) for more.
        /// </summary>
        public static ClusterUpdateDesiredDatapathProvider AdvancedDatapath { get; } = new ClusterUpdateDesiredDatapathProvider("ADVANCED_DATAPATH");

        public static bool operator ==(ClusterUpdateDesiredDatapathProvider left, ClusterUpdateDesiredDatapathProvider right) => left.Equals(right);
        public static bool operator !=(ClusterUpdateDesiredDatapathProvider left, ClusterUpdateDesiredDatapathProvider right) => !left.Equals(right);

        public static explicit operator string(ClusterUpdateDesiredDatapathProvider value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterUpdateDesiredDatapathProvider other && Equals(other);
        public bool Equals(ClusterUpdateDesiredDatapathProvider other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The desired state of IPv6 connectivity to Google Services.
    /// </summary>
    [EnumType]
    public readonly struct ClusterUpdateDesiredPrivateIpv6GoogleAccess : IEquatable<ClusterUpdateDesiredPrivateIpv6GoogleAccess>
    {
        private readonly string _value;

        private ClusterUpdateDesiredPrivateIpv6GoogleAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value. Same as DISABLED
        /// </summary>
        public static ClusterUpdateDesiredPrivateIpv6GoogleAccess PrivateIpv6GoogleAccessUnspecified { get; } = new ClusterUpdateDesiredPrivateIpv6GoogleAccess("PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED");
        /// <summary>
        /// No private access to or from Google Services
        /// </summary>
        public static ClusterUpdateDesiredPrivateIpv6GoogleAccess PrivateIpv6GoogleAccessDisabled { get; } = new ClusterUpdateDesiredPrivateIpv6GoogleAccess("PRIVATE_IPV6_GOOGLE_ACCESS_DISABLED");
        /// <summary>
        /// Enables private IPv6 access to Google Services from GKE
        /// </summary>
        public static ClusterUpdateDesiredPrivateIpv6GoogleAccess PrivateIpv6GoogleAccessToGoogle { get; } = new ClusterUpdateDesiredPrivateIpv6GoogleAccess("PRIVATE_IPV6_GOOGLE_ACCESS_TO_GOOGLE");
        /// <summary>
        /// Enables priate IPv6 access to and from Google Services
        /// </summary>
        public static ClusterUpdateDesiredPrivateIpv6GoogleAccess PrivateIpv6GoogleAccessBidirectional { get; } = new ClusterUpdateDesiredPrivateIpv6GoogleAccess("PRIVATE_IPV6_GOOGLE_ACCESS_BIDIRECTIONAL");

        public static bool operator ==(ClusterUpdateDesiredPrivateIpv6GoogleAccess left, ClusterUpdateDesiredPrivateIpv6GoogleAccess right) => left.Equals(right);
        public static bool operator !=(ClusterUpdateDesiredPrivateIpv6GoogleAccess left, ClusterUpdateDesiredPrivateIpv6GoogleAccess right) => !left.Equals(right);

        public static explicit operator string(ClusterUpdateDesiredPrivateIpv6GoogleAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterUpdateDesiredPrivateIpv6GoogleAccess other && Equals(other);
        public bool Equals(ClusterUpdateDesiredPrivateIpv6GoogleAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// cluster_dns indicates which in-cluster DNS provider should be used.
    /// </summary>
    [EnumType]
    public readonly struct DNSConfigClusterDns : IEquatable<DNSConfigClusterDns>
    {
        private readonly string _value;

        private DNSConfigClusterDns(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value
        /// </summary>
        public static DNSConfigClusterDns ProviderUnspecified { get; } = new DNSConfigClusterDns("PROVIDER_UNSPECIFIED");
        /// <summary>
        /// Use GKE default DNS provider(kube-dns) for DNS resolution.
        /// </summary>
        public static DNSConfigClusterDns PlatformDefault { get; } = new DNSConfigClusterDns("PLATFORM_DEFAULT");
        /// <summary>
        /// Use CloudDNS for DNS resolution.
        /// </summary>
        public static DNSConfigClusterDns CloudDns { get; } = new DNSConfigClusterDns("CLOUD_DNS");

        public static bool operator ==(DNSConfigClusterDns left, DNSConfigClusterDns right) => left.Equals(right);
        public static bool operator !=(DNSConfigClusterDns left, DNSConfigClusterDns right) => !left.Equals(right);

        public static explicit operator string(DNSConfigClusterDns value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DNSConfigClusterDns other && Equals(other);
        public bool Equals(DNSConfigClusterDns other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// cluster_dns_scope indicates the scope of access to cluster DNS records.
    /// </summary>
    [EnumType]
    public readonly struct DNSConfigClusterDnsScope : IEquatable<DNSConfigClusterDnsScope>
    {
        private readonly string _value;

        private DNSConfigClusterDnsScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value, will be inferred as cluster scope.
        /// </summary>
        public static DNSConfigClusterDnsScope DnsScopeUnspecified { get; } = new DNSConfigClusterDnsScope("DNS_SCOPE_UNSPECIFIED");
        /// <summary>
        /// DNS records are accessible from within the VPC.
        /// </summary>
        public static DNSConfigClusterDnsScope VpcScope { get; } = new DNSConfigClusterDnsScope("VPC_SCOPE");

        public static bool operator ==(DNSConfigClusterDnsScope left, DNSConfigClusterDnsScope right) => left.Equals(right);
        public static bool operator !=(DNSConfigClusterDnsScope left, DNSConfigClusterDnsScope right) => !left.Equals(right);

        public static explicit operator string(DNSConfigClusterDnsScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DNSConfigClusterDnsScope other && Equals(other);
        public bool Equals(DNSConfigClusterDnsScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Denotes the state of etcd encryption.
    /// </summary>
    [EnumType]
    public readonly struct DatabaseEncryptionState : IEquatable<DatabaseEncryptionState>
    {
        private readonly string _value;

        private DatabaseEncryptionState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Should never be set
        /// </summary>
        public static DatabaseEncryptionState Unknown { get; } = new DatabaseEncryptionState("UNKNOWN");
        /// <summary>
        /// Secrets in etcd are encrypted.
        /// </summary>
        public static DatabaseEncryptionState Encrypted { get; } = new DatabaseEncryptionState("ENCRYPTED");
        /// <summary>
        /// Secrets in etcd are stored in plain text (at etcd level) - this is unrelated to Compute Engine level full disk encryption.
        /// </summary>
        public static DatabaseEncryptionState Decrypted { get; } = new DatabaseEncryptionState("DECRYPTED");

        public static bool operator ==(DatabaseEncryptionState left, DatabaseEncryptionState right) => left.Equals(right);
        public static bool operator !=(DatabaseEncryptionState left, DatabaseEncryptionState right) => !left.Equals(right);

        public static explicit operator string(DatabaseEncryptionState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseEncryptionState other && Equals(other);
        public bool Equals(DatabaseEncryptionState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct FilterEventTypeItem : IEquatable<FilterEventTypeItem>
    {
        private readonly string _value;

        private FilterEventTypeItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not set, will be ignored.
        /// </summary>
        public static FilterEventTypeItem EventTypeUnspecified { get; } = new FilterEventTypeItem("EVENT_TYPE_UNSPECIFIED");
        /// <summary>
        /// Corresponds with UpgradeAvailableEvent.
        /// </summary>
        public static FilterEventTypeItem UpgradeAvailableEvent { get; } = new FilterEventTypeItem("UPGRADE_AVAILABLE_EVENT");
        /// <summary>
        /// Corresponds with UpgradeEvent.
        /// </summary>
        public static FilterEventTypeItem UpgradeEvent { get; } = new FilterEventTypeItem("UPGRADE_EVENT");
        /// <summary>
        /// Corresponds with SecurityBulletinEvent.
        /// </summary>
        public static FilterEventTypeItem SecurityBulletinEvent { get; } = new FilterEventTypeItem("SECURITY_BULLETIN_EVENT");

        public static bool operator ==(FilterEventTypeItem left, FilterEventTypeItem right) => left.Equals(right);
        public static bool operator !=(FilterEventTypeItem left, FilterEventTypeItem right) => !left.Equals(right);

        public static explicit operator string(FilterEventTypeItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FilterEventTypeItem other && Equals(other);
        public bool Equals(FilterEventTypeItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct LoggingComponentConfigEnableComponentsItem : IEquatable<LoggingComponentConfigEnableComponentsItem>
    {
        private readonly string _value;

        private LoggingComponentConfigEnableComponentsItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value. This shouldn't be used.
        /// </summary>
        public static LoggingComponentConfigEnableComponentsItem ComponentUnspecified { get; } = new LoggingComponentConfigEnableComponentsItem("COMPONENT_UNSPECIFIED");
        /// <summary>
        /// system components
        /// </summary>
        public static LoggingComponentConfigEnableComponentsItem SystemComponents { get; } = new LoggingComponentConfigEnableComponentsItem("SYSTEM_COMPONENTS");
        /// <summary>
        /// workloads
        /// </summary>
        public static LoggingComponentConfigEnableComponentsItem Workloads { get; } = new LoggingComponentConfigEnableComponentsItem("WORKLOADS");

        public static bool operator ==(LoggingComponentConfigEnableComponentsItem left, LoggingComponentConfigEnableComponentsItem right) => left.Equals(right);
        public static bool operator !=(LoggingComponentConfigEnableComponentsItem left, LoggingComponentConfigEnableComponentsItem right) => !left.Equals(right);

        public static explicit operator string(LoggingComponentConfigEnableComponentsItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoggingComponentConfigEnableComponentsItem other && Equals(other);
        public bool Equals(LoggingComponentConfigEnableComponentsItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Scope specifies the upgrade scope which upgrades are blocked by the exclusion.
    /// </summary>
    [EnumType]
    public readonly struct MaintenanceExclusionOptionsScope : IEquatable<MaintenanceExclusionOptionsScope>
    {
        private readonly string _value;

        private MaintenanceExclusionOptionsScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// NO_UPGRADES excludes all upgrades, including patch upgrades and minor upgrades across control planes and nodes. This is the default exclusion behavior.
        /// </summary>
        public static MaintenanceExclusionOptionsScope NoUpgrades { get; } = new MaintenanceExclusionOptionsScope("NO_UPGRADES");
        /// <summary>
        /// NO_MINOR_UPGRADES excludes all minor upgrades for the cluster, only patches are allowed.
        /// </summary>
        public static MaintenanceExclusionOptionsScope NoMinorUpgrades { get; } = new MaintenanceExclusionOptionsScope("NO_MINOR_UPGRADES");
        /// <summary>
        /// NO_MINOR_OR_NODE_UPGRADES excludes all minor upgrades for the cluster, and also exclude all node pool upgrades. Only control plane patches are allowed.
        /// </summary>
        public static MaintenanceExclusionOptionsScope NoMinorOrNodeUpgrades { get; } = new MaintenanceExclusionOptionsScope("NO_MINOR_OR_NODE_UPGRADES");

        public static bool operator ==(MaintenanceExclusionOptionsScope left, MaintenanceExclusionOptionsScope right) => left.Equals(right);
        public static bool operator !=(MaintenanceExclusionOptionsScope left, MaintenanceExclusionOptionsScope right) => !left.Equals(right);

        public static explicit operator string(MaintenanceExclusionOptionsScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MaintenanceExclusionOptionsScope other && Equals(other);
        public bool Equals(MaintenanceExclusionOptionsScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct MonitoringComponentConfigEnableComponentsItem : IEquatable<MonitoringComponentConfigEnableComponentsItem>
    {
        private readonly string _value;

        private MonitoringComponentConfigEnableComponentsItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value. This shouldn't be used.
        /// </summary>
        public static MonitoringComponentConfigEnableComponentsItem ComponentUnspecified { get; } = new MonitoringComponentConfigEnableComponentsItem("COMPONENT_UNSPECIFIED");
        /// <summary>
        /// system components
        /// </summary>
        public static MonitoringComponentConfigEnableComponentsItem SystemComponents { get; } = new MonitoringComponentConfigEnableComponentsItem("SYSTEM_COMPONENTS");

        public static bool operator ==(MonitoringComponentConfigEnableComponentsItem left, MonitoringComponentConfigEnableComponentsItem right) => left.Equals(right);
        public static bool operator !=(MonitoringComponentConfigEnableComponentsItem left, MonitoringComponentConfigEnableComponentsItem right) => !left.Equals(right);

        public static explicit operator string(MonitoringComponentConfigEnableComponentsItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MonitoringComponentConfigEnableComponentsItem other && Equals(other);
        public bool Equals(MonitoringComponentConfigEnableComponentsItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The desired datapath provider for this cluster. By default, uses the IPTables-based kube-proxy implementation.
    /// </summary>
    [EnumType]
    public readonly struct NetworkConfigDatapathProvider : IEquatable<NetworkConfigDatapathProvider>
    {
        private readonly string _value;

        private NetworkConfigDatapathProvider(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value.
        /// </summary>
        public static NetworkConfigDatapathProvider DatapathProviderUnspecified { get; } = new NetworkConfigDatapathProvider("DATAPATH_PROVIDER_UNSPECIFIED");
        /// <summary>
        /// Use the IPTables implementation based on kube-proxy.
        /// </summary>
        public static NetworkConfigDatapathProvider LegacyDatapath { get; } = new NetworkConfigDatapathProvider("LEGACY_DATAPATH");
        /// <summary>
        /// Use the eBPF based GKE Dataplane V2 with additional features. See the [GKE Dataplane V2 documentation](https://cloud.google.com/kubernetes-engine/docs/how-to/dataplane-v2) for more.
        /// </summary>
        public static NetworkConfigDatapathProvider AdvancedDatapath { get; } = new NetworkConfigDatapathProvider("ADVANCED_DATAPATH");

        public static bool operator ==(NetworkConfigDatapathProvider left, NetworkConfigDatapathProvider right) => left.Equals(right);
        public static bool operator !=(NetworkConfigDatapathProvider left, NetworkConfigDatapathProvider right) => !left.Equals(right);

        public static explicit operator string(NetworkConfigDatapathProvider value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkConfigDatapathProvider other && Equals(other);
        public bool Equals(NetworkConfigDatapathProvider other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The desired state of IPv6 connectivity to Google Services. By default, no private IPv6 access to or from Google Services (all access will be via IPv4)
    /// </summary>
    [EnumType]
    public readonly struct NetworkConfigPrivateIpv6GoogleAccess : IEquatable<NetworkConfigPrivateIpv6GoogleAccess>
    {
        private readonly string _value;

        private NetworkConfigPrivateIpv6GoogleAccess(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value. Same as DISABLED
        /// </summary>
        public static NetworkConfigPrivateIpv6GoogleAccess PrivateIpv6GoogleAccessUnspecified { get; } = new NetworkConfigPrivateIpv6GoogleAccess("PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED");
        /// <summary>
        /// No private access to or from Google Services
        /// </summary>
        public static NetworkConfigPrivateIpv6GoogleAccess PrivateIpv6GoogleAccessDisabled { get; } = new NetworkConfigPrivateIpv6GoogleAccess("PRIVATE_IPV6_GOOGLE_ACCESS_DISABLED");
        /// <summary>
        /// Enables private IPv6 access to Google Services from GKE
        /// </summary>
        public static NetworkConfigPrivateIpv6GoogleAccess PrivateIpv6GoogleAccessToGoogle { get; } = new NetworkConfigPrivateIpv6GoogleAccess("PRIVATE_IPV6_GOOGLE_ACCESS_TO_GOOGLE");
        /// <summary>
        /// Enables priate IPv6 access to and from Google Services
        /// </summary>
        public static NetworkConfigPrivateIpv6GoogleAccess PrivateIpv6GoogleAccessBidirectional { get; } = new NetworkConfigPrivateIpv6GoogleAccess("PRIVATE_IPV6_GOOGLE_ACCESS_BIDIRECTIONAL");

        public static bool operator ==(NetworkConfigPrivateIpv6GoogleAccess left, NetworkConfigPrivateIpv6GoogleAccess right) => left.Equals(right);
        public static bool operator !=(NetworkConfigPrivateIpv6GoogleAccess left, NetworkConfigPrivateIpv6GoogleAccess right) => !left.Equals(right);

        public static explicit operator string(NetworkConfigPrivateIpv6GoogleAccess value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkConfigPrivateIpv6GoogleAccess other && Equals(other);
        public bool Equals(NetworkConfigPrivateIpv6GoogleAccess other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The selected network policy provider.
    /// </summary>
    [EnumType]
    public readonly struct NetworkPolicyProvider : IEquatable<NetworkPolicyProvider>
    {
        private readonly string _value;

        private NetworkPolicyProvider(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not set
        /// </summary>
        public static NetworkPolicyProvider ProviderUnspecified { get; } = new NetworkPolicyProvider("PROVIDER_UNSPECIFIED");
        /// <summary>
        /// Tigera (Calico Felix).
        /// </summary>
        public static NetworkPolicyProvider Calico { get; } = new NetworkPolicyProvider("CALICO");

        public static bool operator ==(NetworkPolicyProvider left, NetworkPolicyProvider right) => left.Equals(right);
        public static bool operator !=(NetworkPolicyProvider left, NetworkPolicyProvider right) => !left.Equals(right);

        public static explicit operator string(NetworkPolicyProvider value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkPolicyProvider other && Equals(other);
        public bool Equals(NetworkPolicyProvider other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Effect for taint.
    /// </summary>
    [EnumType]
    public readonly struct NodeTaintEffect : IEquatable<NodeTaintEffect>
    {
        private readonly string _value;

        private NodeTaintEffect(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not set
        /// </summary>
        public static NodeTaintEffect EffectUnspecified { get; } = new NodeTaintEffect("EFFECT_UNSPECIFIED");
        /// <summary>
        /// NoSchedule
        /// </summary>
        public static NodeTaintEffect NoSchedule { get; } = new NodeTaintEffect("NO_SCHEDULE");
        /// <summary>
        /// PreferNoSchedule
        /// </summary>
        public static NodeTaintEffect PreferNoSchedule { get; } = new NodeTaintEffect("PREFER_NO_SCHEDULE");
        /// <summary>
        /// NoExecute
        /// </summary>
        public static NodeTaintEffect NoExecute { get; } = new NodeTaintEffect("NO_EXECUTE");

        public static bool operator ==(NodeTaintEffect left, NodeTaintEffect right) => left.Equals(right);
        public static bool operator !=(NodeTaintEffect left, NodeTaintEffect right) => !left.Equals(right);

        public static explicit operator string(NodeTaintEffect value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NodeTaintEffect other && Equals(other);
        public bool Equals(NodeTaintEffect other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// channel specifies which release channel the cluster is subscribed to.
    /// </summary>
    [EnumType]
    public readonly struct ReleaseChannelChannel : IEquatable<ReleaseChannelChannel>
    {
        private readonly string _value;

        private ReleaseChannelChannel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No channel specified.
        /// </summary>
        public static ReleaseChannelChannel Unspecified { get; } = new ReleaseChannelChannel("UNSPECIFIED");
        /// <summary>
        /// RAPID channel is offered on an early access basis for customers who want to test new releases. WARNING: Versions available in the RAPID Channel may be subject to unresolved issues with no known workaround and are not subject to any SLAs.
        /// </summary>
        public static ReleaseChannelChannel Rapid { get; } = new ReleaseChannelChannel("RAPID");
        /// <summary>
        /// Clusters subscribed to REGULAR receive versions that are considered GA quality. REGULAR is intended for production users who want to take advantage of new features.
        /// </summary>
        public static ReleaseChannelChannel Regular { get; } = new ReleaseChannelChannel("REGULAR");
        /// <summary>
        /// Clusters subscribed to STABLE receive versions that are known to be stable and reliable in production.
        /// </summary>
        public static ReleaseChannelChannel Stable { get; } = new ReleaseChannelChannel("STABLE");

        public static bool operator ==(ReleaseChannelChannel left, ReleaseChannelChannel right) => left.Equals(right);
        public static bool operator !=(ReleaseChannelChannel left, ReleaseChannelChannel right) => !left.Equals(right);

        public static explicit operator string(ReleaseChannelChannel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReleaseChannelChannel other && Equals(other);
        public bool Equals(ReleaseChannelChannel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Corresponds to the type of reservation consumption.
    /// </summary>
    [EnumType]
    public readonly struct ReservationAffinityConsumeReservationType : IEquatable<ReservationAffinityConsumeReservationType>
    {
        private readonly string _value;

        private ReservationAffinityConsumeReservationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value. This should not be used.
        /// </summary>
        public static ReservationAffinityConsumeReservationType Unspecified { get; } = new ReservationAffinityConsumeReservationType("UNSPECIFIED");
        /// <summary>
        /// Do not consume from any reserved capacity.
        /// </summary>
        public static ReservationAffinityConsumeReservationType NoReservation { get; } = new ReservationAffinityConsumeReservationType("NO_RESERVATION");
        /// <summary>
        /// Consume any reservation available.
        /// </summary>
        public static ReservationAffinityConsumeReservationType AnyReservation { get; } = new ReservationAffinityConsumeReservationType("ANY_RESERVATION");
        /// <summary>
        /// Must consume from a specific reservation. Must specify key value fields for specifying the reservations.
        /// </summary>
        public static ReservationAffinityConsumeReservationType SpecificReservation { get; } = new ReservationAffinityConsumeReservationType("SPECIFIC_RESERVATION");

        public static bool operator ==(ReservationAffinityConsumeReservationType left, ReservationAffinityConsumeReservationType right) => left.Equals(right);
        public static bool operator !=(ReservationAffinityConsumeReservationType left, ReservationAffinityConsumeReservationType right) => !left.Equals(right);

        public static explicit operator string(ReservationAffinityConsumeReservationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReservationAffinityConsumeReservationType other && Equals(other);
        public bool Equals(ReservationAffinityConsumeReservationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of the sandbox to use for the node.
    /// </summary>
    [EnumType]
    public readonly struct SandboxConfigType : IEquatable<SandboxConfigType>
    {
        private readonly string _value;

        private SandboxConfigType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value. This should not be used.
        /// </summary>
        public static SandboxConfigType Unspecified { get; } = new SandboxConfigType("UNSPECIFIED");
        /// <summary>
        /// Run sandbox using gvisor.
        /// </summary>
        public static SandboxConfigType Gvisor { get; } = new SandboxConfigType("GVISOR");

        public static bool operator ==(SandboxConfigType left, SandboxConfigType right) => left.Equals(right);
        public static bool operator !=(SandboxConfigType left, SandboxConfigType right) => !left.Equals(right);

        public static explicit operator string(SandboxConfigType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SandboxConfigType other && Equals(other);
        public bool Equals(SandboxConfigType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Canonical code of the condition.
    /// </summary>
    [EnumType]
    public readonly struct StatusConditionCanonicalCode : IEquatable<StatusConditionCanonicalCode>
    {
        private readonly string _value;

        private StatusConditionCanonicalCode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not an error; returned on success HTTP Mapping: 200 OK
        /// </summary>
        public static StatusConditionCanonicalCode Ok { get; } = new StatusConditionCanonicalCode("OK");
        /// <summary>
        /// The operation was cancelled, typically by the caller. HTTP Mapping: 499 Client Closed Request
        /// </summary>
        public static StatusConditionCanonicalCode Cancelled { get; } = new StatusConditionCanonicalCode("CANCELLED");
        /// <summary>
        /// Unknown error. For example, this error may be returned when a `Status` value received from another address space belongs to an error space that is not known in this address space. Also errors raised by APIs that do not return enough error information may be converted to this error. HTTP Mapping: 500 Internal Server Error
        /// </summary>
        public static StatusConditionCanonicalCode Unknown { get; } = new StatusConditionCanonicalCode("UNKNOWN");
        /// <summary>
        /// The client specified an invalid argument. Note that this differs from `FAILED_PRECONDITION`. `INVALID_ARGUMENT` indicates arguments that are problematic regardless of the state of the system (e.g., a malformed file name). HTTP Mapping: 400 Bad Request
        /// </summary>
        public static StatusConditionCanonicalCode InvalidArgument { get; } = new StatusConditionCanonicalCode("INVALID_ARGUMENT");
        /// <summary>
        /// The deadline expired before the operation could complete. For operations that change the state of the system, this error may be returned even if the operation has completed successfully. For example, a successful response from a server could have been delayed long enough for the deadline to expire. HTTP Mapping: 504 Gateway Timeout
        /// </summary>
        public static StatusConditionCanonicalCode DeadlineExceeded { get; } = new StatusConditionCanonicalCode("DEADLINE_EXCEEDED");
        /// <summary>
        /// Some requested entity (e.g., file or directory) was not found. Note to server developers: if a request is denied for an entire class of users, such as gradual feature rollout or undocumented allowlist, `NOT_FOUND` may be used. If a request is denied for some users within a class of users, such as user-based access control, `PERMISSION_DENIED` must be used. HTTP Mapping: 404 Not Found
        /// </summary>
        public static StatusConditionCanonicalCode NotFound { get; } = new StatusConditionCanonicalCode("NOT_FOUND");
        /// <summary>
        /// The entity that a client attempted to create (e.g., file or directory) already exists. HTTP Mapping: 409 Conflict
        /// </summary>
        public static StatusConditionCanonicalCode AlreadyExists { get; } = new StatusConditionCanonicalCode("ALREADY_EXISTS");
        /// <summary>
        /// The caller does not have permission to execute the specified operation. `PERMISSION_DENIED` must not be used for rejections caused by exhausting some resource (use `RESOURCE_EXHAUSTED` instead for those errors). `PERMISSION_DENIED` must not be used if the caller can not be identified (use `UNAUTHENTICATED` instead for those errors). This error code does not imply the request is valid or the requested entity exists or satisfies other pre-conditions. HTTP Mapping: 403 Forbidden
        /// </summary>
        public static StatusConditionCanonicalCode PermissionDenied { get; } = new StatusConditionCanonicalCode("PERMISSION_DENIED");
        /// <summary>
        /// The request does not have valid authentication credentials for the operation. HTTP Mapping: 401 Unauthorized
        /// </summary>
        public static StatusConditionCanonicalCode Unauthenticated { get; } = new StatusConditionCanonicalCode("UNAUTHENTICATED");
        /// <summary>
        /// Some resource has been exhausted, perhaps a per-user quota, or perhaps the entire file system is out of space. HTTP Mapping: 429 Too Many Requests
        /// </summary>
        public static StatusConditionCanonicalCode ResourceExhausted { get; } = new StatusConditionCanonicalCode("RESOURCE_EXHAUSTED");
        /// <summary>
        /// The operation was rejected because the system is not in a state required for the operation's execution. For example, the directory to be deleted is non-empty, an rmdir operation is applied to a non-directory, etc. Service implementors can use the following guidelines to decide between `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`: (a) Use `UNAVAILABLE` if the client can retry just the failing call. (b) Use `ABORTED` if the client should retry at a higher level. For example, when a client-specified test-and-set fails, indicating the client should restart a read-modify-write sequence. (c) Use `FAILED_PRECONDITION` if the client should not retry until the system state has been explicitly fixed. For example, if an "rmdir" fails because the directory is non-empty, `FAILED_PRECONDITION` should be returned since the client should not retry unless the files are deleted from the directory. HTTP Mapping: 400 Bad Request
        /// </summary>
        public static StatusConditionCanonicalCode FailedPrecondition { get; } = new StatusConditionCanonicalCode("FAILED_PRECONDITION");
        /// <summary>
        /// The operation was aborted, typically due to a concurrency issue such as a sequencer check failure or transaction abort. See the guidelines above for deciding between `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`. HTTP Mapping: 409 Conflict
        /// </summary>
        public static StatusConditionCanonicalCode Aborted { get; } = new StatusConditionCanonicalCode("ABORTED");
        /// <summary>
        /// The operation was attempted past the valid range. E.g., seeking or reading past end-of-file. Unlike `INVALID_ARGUMENT`, this error indicates a problem that may be fixed if the system state changes. For example, a 32-bit file system will generate `INVALID_ARGUMENT` if asked to read at an offset that is not in the range [0,2^32-1], but it will generate `OUT_OF_RANGE` if asked to read from an offset past the current file size. There is a fair bit of overlap between `FAILED_PRECONDITION` and `OUT_OF_RANGE`. We recommend using `OUT_OF_RANGE` (the more specific error) when it applies so that callers who are iterating through a space can easily look for an `OUT_OF_RANGE` error to detect when they are done. HTTP Mapping: 400 Bad Request
        /// </summary>
        public static StatusConditionCanonicalCode OutOfRange { get; } = new StatusConditionCanonicalCode("OUT_OF_RANGE");
        /// <summary>
        /// The operation is not implemented or is not supported/enabled in this service. HTTP Mapping: 501 Not Implemented
        /// </summary>
        public static StatusConditionCanonicalCode Unimplemented { get; } = new StatusConditionCanonicalCode("UNIMPLEMENTED");
        /// <summary>
        /// Internal errors. This means that some invariants expected by the underlying system have been broken. This error code is reserved for serious errors. HTTP Mapping: 500 Internal Server Error
        /// </summary>
        public static StatusConditionCanonicalCode Internal { get; } = new StatusConditionCanonicalCode("INTERNAL");
        /// <summary>
        /// The service is currently unavailable. This is most likely a transient condition, which can be corrected by retrying with a backoff. Note that it is not always safe to retry non-idempotent operations. See the guidelines above for deciding between `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`. HTTP Mapping: 503 Service Unavailable
        /// </summary>
        public static StatusConditionCanonicalCode Unavailable { get; } = new StatusConditionCanonicalCode("UNAVAILABLE");
        /// <summary>
        /// Unrecoverable data loss or corruption. HTTP Mapping: 500 Internal Server Error
        /// </summary>
        public static StatusConditionCanonicalCode DataLoss { get; } = new StatusConditionCanonicalCode("DATA_LOSS");

        public static bool operator ==(StatusConditionCanonicalCode left, StatusConditionCanonicalCode right) => left.Equals(right);
        public static bool operator !=(StatusConditionCanonicalCode left, StatusConditionCanonicalCode right) => !left.Equals(right);

        public static explicit operator string(StatusConditionCanonicalCode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StatusConditionCanonicalCode other && Equals(other);
        public bool Equals(StatusConditionCanonicalCode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Mode is the configuration for how to expose metadata to workloads running on the node pool.
    /// </summary>
    [EnumType]
    public readonly struct WorkloadMetadataConfigMode : IEquatable<WorkloadMetadataConfigMode>
    {
        private readonly string _value;

        private WorkloadMetadataConfigMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not set.
        /// </summary>
        public static WorkloadMetadataConfigMode ModeUnspecified { get; } = new WorkloadMetadataConfigMode("MODE_UNSPECIFIED");
        /// <summary>
        /// Expose all Compute Engine metadata to pods.
        /// </summary>
        public static WorkloadMetadataConfigMode GceMetadata { get; } = new WorkloadMetadataConfigMode("GCE_METADATA");
        /// <summary>
        /// Run the GKE Metadata Server on this node. The GKE Metadata Server exposes a metadata API to workloads that is compatible with the V1 Compute Metadata APIs exposed by the Compute Engine and App Engine Metadata Servers. This feature can only be enabled if Workload Identity is enabled at the cluster level.
        /// </summary>
        public static WorkloadMetadataConfigMode GkeMetadata { get; } = new WorkloadMetadataConfigMode("GKE_METADATA");

        public static bool operator ==(WorkloadMetadataConfigMode left, WorkloadMetadataConfigMode right) => left.Equals(right);
        public static bool operator !=(WorkloadMetadataConfigMode left, WorkloadMetadataConfigMode right) => !left.Equals(right);

        public static explicit operator string(WorkloadMetadataConfigMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WorkloadMetadataConfigMode other && Equals(other);
        public bool Equals(WorkloadMetadataConfigMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
