// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.ContainerAnalysis.V1Beta1
{
    /// <summary>
    /// The alias kind.
    /// </summary>
    [EnumType]
    public readonly struct AliasContextKind : IEquatable<AliasContextKind>
    {
        private readonly string _value;

        private AliasContextKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown.
        /// </summary>
        public static AliasContextKind KindUnspecified { get; } = new AliasContextKind("KIND_UNSPECIFIED");
        /// <summary>
        /// Git tag.
        /// </summary>
        public static AliasContextKind Fixed { get; } = new AliasContextKind("FIXED");
        /// <summary>
        /// Git branch.
        /// </summary>
        public static AliasContextKind Movable { get; } = new AliasContextKind("MOVABLE");
        /// <summary>
        /// Used to specify non-standard aliases. For example, if a Git repo has a ref named "refs/foo/bar".
        /// </summary>
        public static AliasContextKind Other { get; } = new AliasContextKind("OTHER");

        public static bool operator ==(AliasContextKind left, AliasContextKind right) => left.Equals(right);
        public static bool operator !=(AliasContextKind left, AliasContextKind right) => !left.Equals(right);

        public static explicit operator string(AliasContextKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AliasContextKind other && Equals(other);
        public bool Equals(AliasContextKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the key, either stored in `public_key` or referenced in `key_id`.
    /// </summary>
    [EnumType]
    public readonly struct BuildSignatureKeyType : IEquatable<BuildSignatureKeyType>
    {
        private readonly string _value;

        private BuildSignatureKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// `KeyType` is not set.
        /// </summary>
        public static BuildSignatureKeyType KeyTypeUnspecified { get; } = new BuildSignatureKeyType("KEY_TYPE_UNSPECIFIED");
        /// <summary>
        /// `PGP ASCII Armored` public key.
        /// </summary>
        public static BuildSignatureKeyType PgpAsciiArmored { get; } = new BuildSignatureKeyType("PGP_ASCII_ARMORED");
        /// <summary>
        /// `PKIX PEM` public key.
        /// </summary>
        public static BuildSignatureKeyType PkixPem { get; } = new BuildSignatureKeyType("PKIX_PEM");

        public static bool operator ==(BuildSignatureKeyType left, BuildSignatureKeyType right) => left.Equals(right);
        public static bool operator !=(BuildSignatureKeyType left, BuildSignatureKeyType right) => !left.Equals(right);

        public static explicit operator string(BuildSignatureKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BuildSignatureKeyType other && Equals(other);
        public bool Equals(BuildSignatureKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CVSSv3AttackComplexity : IEquatable<CVSSv3AttackComplexity>
    {
        private readonly string _value;

        private CVSSv3AttackComplexity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CVSSv3AttackComplexity AttackComplexityUnspecified { get; } = new CVSSv3AttackComplexity("ATTACK_COMPLEXITY_UNSPECIFIED");
        public static CVSSv3AttackComplexity AttackComplexityLow { get; } = new CVSSv3AttackComplexity("ATTACK_COMPLEXITY_LOW");
        public static CVSSv3AttackComplexity AttackComplexityHigh { get; } = new CVSSv3AttackComplexity("ATTACK_COMPLEXITY_HIGH");

        public static bool operator ==(CVSSv3AttackComplexity left, CVSSv3AttackComplexity right) => left.Equals(right);
        public static bool operator !=(CVSSv3AttackComplexity left, CVSSv3AttackComplexity right) => !left.Equals(right);

        public static explicit operator string(CVSSv3AttackComplexity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSv3AttackComplexity other && Equals(other);
        public bool Equals(CVSSv3AttackComplexity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Base Metrics Represents the intrinsic characteristics of a vulnerability that are constant over time and across user environments.
    /// </summary>
    [EnumType]
    public readonly struct CVSSv3AttackVector : IEquatable<CVSSv3AttackVector>
    {
        private readonly string _value;

        private CVSSv3AttackVector(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CVSSv3AttackVector AttackVectorUnspecified { get; } = new CVSSv3AttackVector("ATTACK_VECTOR_UNSPECIFIED");
        public static CVSSv3AttackVector AttackVectorNetwork { get; } = new CVSSv3AttackVector("ATTACK_VECTOR_NETWORK");
        public static CVSSv3AttackVector AttackVectorAdjacent { get; } = new CVSSv3AttackVector("ATTACK_VECTOR_ADJACENT");
        public static CVSSv3AttackVector AttackVectorLocal { get; } = new CVSSv3AttackVector("ATTACK_VECTOR_LOCAL");
        public static CVSSv3AttackVector AttackVectorPhysical { get; } = new CVSSv3AttackVector("ATTACK_VECTOR_PHYSICAL");

        public static bool operator ==(CVSSv3AttackVector left, CVSSv3AttackVector right) => left.Equals(right);
        public static bool operator !=(CVSSv3AttackVector left, CVSSv3AttackVector right) => !left.Equals(right);

        public static explicit operator string(CVSSv3AttackVector value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSv3AttackVector other && Equals(other);
        public bool Equals(CVSSv3AttackVector other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CVSSv3AvailabilityImpact : IEquatable<CVSSv3AvailabilityImpact>
    {
        private readonly string _value;

        private CVSSv3AvailabilityImpact(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CVSSv3AvailabilityImpact ImpactUnspecified { get; } = new CVSSv3AvailabilityImpact("IMPACT_UNSPECIFIED");
        public static CVSSv3AvailabilityImpact ImpactHigh { get; } = new CVSSv3AvailabilityImpact("IMPACT_HIGH");
        public static CVSSv3AvailabilityImpact ImpactLow { get; } = new CVSSv3AvailabilityImpact("IMPACT_LOW");
        public static CVSSv3AvailabilityImpact ImpactNone { get; } = new CVSSv3AvailabilityImpact("IMPACT_NONE");

        public static bool operator ==(CVSSv3AvailabilityImpact left, CVSSv3AvailabilityImpact right) => left.Equals(right);
        public static bool operator !=(CVSSv3AvailabilityImpact left, CVSSv3AvailabilityImpact right) => !left.Equals(right);

        public static explicit operator string(CVSSv3AvailabilityImpact value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSv3AvailabilityImpact other && Equals(other);
        public bool Equals(CVSSv3AvailabilityImpact other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CVSSv3ConfidentialityImpact : IEquatable<CVSSv3ConfidentialityImpact>
    {
        private readonly string _value;

        private CVSSv3ConfidentialityImpact(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CVSSv3ConfidentialityImpact ImpactUnspecified { get; } = new CVSSv3ConfidentialityImpact("IMPACT_UNSPECIFIED");
        public static CVSSv3ConfidentialityImpact ImpactHigh { get; } = new CVSSv3ConfidentialityImpact("IMPACT_HIGH");
        public static CVSSv3ConfidentialityImpact ImpactLow { get; } = new CVSSv3ConfidentialityImpact("IMPACT_LOW");
        public static CVSSv3ConfidentialityImpact ImpactNone { get; } = new CVSSv3ConfidentialityImpact("IMPACT_NONE");

        public static bool operator ==(CVSSv3ConfidentialityImpact left, CVSSv3ConfidentialityImpact right) => left.Equals(right);
        public static bool operator !=(CVSSv3ConfidentialityImpact left, CVSSv3ConfidentialityImpact right) => !left.Equals(right);

        public static explicit operator string(CVSSv3ConfidentialityImpact value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSv3ConfidentialityImpact other && Equals(other);
        public bool Equals(CVSSv3ConfidentialityImpact other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CVSSv3IntegrityImpact : IEquatable<CVSSv3IntegrityImpact>
    {
        private readonly string _value;

        private CVSSv3IntegrityImpact(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CVSSv3IntegrityImpact ImpactUnspecified { get; } = new CVSSv3IntegrityImpact("IMPACT_UNSPECIFIED");
        public static CVSSv3IntegrityImpact ImpactHigh { get; } = new CVSSv3IntegrityImpact("IMPACT_HIGH");
        public static CVSSv3IntegrityImpact ImpactLow { get; } = new CVSSv3IntegrityImpact("IMPACT_LOW");
        public static CVSSv3IntegrityImpact ImpactNone { get; } = new CVSSv3IntegrityImpact("IMPACT_NONE");

        public static bool operator ==(CVSSv3IntegrityImpact left, CVSSv3IntegrityImpact right) => left.Equals(right);
        public static bool operator !=(CVSSv3IntegrityImpact left, CVSSv3IntegrityImpact right) => !left.Equals(right);

        public static explicit operator string(CVSSv3IntegrityImpact value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSv3IntegrityImpact other && Equals(other);
        public bool Equals(CVSSv3IntegrityImpact other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CVSSv3PrivilegesRequired : IEquatable<CVSSv3PrivilegesRequired>
    {
        private readonly string _value;

        private CVSSv3PrivilegesRequired(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CVSSv3PrivilegesRequired PrivilegesRequiredUnspecified { get; } = new CVSSv3PrivilegesRequired("PRIVILEGES_REQUIRED_UNSPECIFIED");
        public static CVSSv3PrivilegesRequired PrivilegesRequiredNone { get; } = new CVSSv3PrivilegesRequired("PRIVILEGES_REQUIRED_NONE");
        public static CVSSv3PrivilegesRequired PrivilegesRequiredLow { get; } = new CVSSv3PrivilegesRequired("PRIVILEGES_REQUIRED_LOW");
        public static CVSSv3PrivilegesRequired PrivilegesRequiredHigh { get; } = new CVSSv3PrivilegesRequired("PRIVILEGES_REQUIRED_HIGH");

        public static bool operator ==(CVSSv3PrivilegesRequired left, CVSSv3PrivilegesRequired right) => left.Equals(right);
        public static bool operator !=(CVSSv3PrivilegesRequired left, CVSSv3PrivilegesRequired right) => !left.Equals(right);

        public static explicit operator string(CVSSv3PrivilegesRequired value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSv3PrivilegesRequired other && Equals(other);
        public bool Equals(CVSSv3PrivilegesRequired other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CVSSv3Scope : IEquatable<CVSSv3Scope>
    {
        private readonly string _value;

        private CVSSv3Scope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CVSSv3Scope ScopeUnspecified { get; } = new CVSSv3Scope("SCOPE_UNSPECIFIED");
        public static CVSSv3Scope ScopeUnchanged { get; } = new CVSSv3Scope("SCOPE_UNCHANGED");
        public static CVSSv3Scope ScopeChanged { get; } = new CVSSv3Scope("SCOPE_CHANGED");

        public static bool operator ==(CVSSv3Scope left, CVSSv3Scope right) => left.Equals(right);
        public static bool operator !=(CVSSv3Scope left, CVSSv3Scope right) => !left.Equals(right);

        public static explicit operator string(CVSSv3Scope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSv3Scope other && Equals(other);
        public bool Equals(CVSSv3Scope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CVSSv3UserInteraction : IEquatable<CVSSv3UserInteraction>
    {
        private readonly string _value;

        private CVSSv3UserInteraction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CVSSv3UserInteraction UserInteractionUnspecified { get; } = new CVSSv3UserInteraction("USER_INTERACTION_UNSPECIFIED");
        public static CVSSv3UserInteraction UserInteractionNone { get; } = new CVSSv3UserInteraction("USER_INTERACTION_NONE");
        public static CVSSv3UserInteraction UserInteractionRequired { get; } = new CVSSv3UserInteraction("USER_INTERACTION_REQUIRED");

        public static bool operator ==(CVSSv3UserInteraction left, CVSSv3UserInteraction right) => left.Equals(right);
        public static bool operator !=(CVSSv3UserInteraction left, CVSSv3UserInteraction right) => !left.Equals(right);

        public static explicit operator string(CVSSv3UserInteraction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CVSSv3UserInteraction other && Equals(other);
        public bool Equals(CVSSv3UserInteraction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Platform hosting this deployment.
    /// </summary>
    [EnumType]
    public readonly struct DeploymentPlatform : IEquatable<DeploymentPlatform>
    {
        private readonly string _value;

        private DeploymentPlatform(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown.
        /// </summary>
        public static DeploymentPlatform PlatformUnspecified { get; } = new DeploymentPlatform("PLATFORM_UNSPECIFIED");
        /// <summary>
        /// Google Container Engine.
        /// </summary>
        public static DeploymentPlatform Gke { get; } = new DeploymentPlatform("GKE");
        /// <summary>
        /// Google App Engine: Flexible Environment.
        /// </summary>
        public static DeploymentPlatform Flex { get; } = new DeploymentPlatform("FLEX");
        /// <summary>
        /// Custom user-defined platform.
        /// </summary>
        public static DeploymentPlatform Custom { get; } = new DeploymentPlatform("CUSTOM");

        public static bool operator ==(DeploymentPlatform left, DeploymentPlatform right) => left.Equals(right);
        public static bool operator !=(DeploymentPlatform left, DeploymentPlatform right) => !left.Equals(right);

        public static explicit operator string(DeploymentPlatform value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DeploymentPlatform other && Equals(other);
        public bool Equals(DeploymentPlatform other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The status of discovery for the resource.
    /// </summary>
    [EnumType]
    public readonly struct DiscoveredAnalysisStatus : IEquatable<DiscoveredAnalysisStatus>
    {
        private readonly string _value;

        private DiscoveredAnalysisStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown.
        /// </summary>
        public static DiscoveredAnalysisStatus AnalysisStatusUnspecified { get; } = new DiscoveredAnalysisStatus("ANALYSIS_STATUS_UNSPECIFIED");
        /// <summary>
        /// Resource is known but no action has been taken yet.
        /// </summary>
        public static DiscoveredAnalysisStatus Pending { get; } = new DiscoveredAnalysisStatus("PENDING");
        /// <summary>
        /// Resource is being analyzed.
        /// </summary>
        public static DiscoveredAnalysisStatus Scanning { get; } = new DiscoveredAnalysisStatus("SCANNING");
        /// <summary>
        /// Analysis has finished successfully.
        /// </summary>
        public static DiscoveredAnalysisStatus FinishedSuccess { get; } = new DiscoveredAnalysisStatus("FINISHED_SUCCESS");
        /// <summary>
        /// Analysis has finished unsuccessfully, the analysis itself is in a bad state.
        /// </summary>
        public static DiscoveredAnalysisStatus FinishedFailed { get; } = new DiscoveredAnalysisStatus("FINISHED_FAILED");
        /// <summary>
        /// The resource is known not to be supported
        /// </summary>
        public static DiscoveredAnalysisStatus FinishedUnsupported { get; } = new DiscoveredAnalysisStatus("FINISHED_UNSUPPORTED");

        public static bool operator ==(DiscoveredAnalysisStatus left, DiscoveredAnalysisStatus right) => left.Equals(right);
        public static bool operator !=(DiscoveredAnalysisStatus left, DiscoveredAnalysisStatus right) => !left.Equals(right);

        public static explicit operator string(DiscoveredAnalysisStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiscoveredAnalysisStatus other && Equals(other);
        public bool Equals(DiscoveredAnalysisStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether the resource is continuously analyzed.
    /// </summary>
    [EnumType]
    public readonly struct DiscoveredContinuousAnalysis : IEquatable<DiscoveredContinuousAnalysis>
    {
        private readonly string _value;

        private DiscoveredContinuousAnalysis(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown.
        /// </summary>
        public static DiscoveredContinuousAnalysis ContinuousAnalysisUnspecified { get; } = new DiscoveredContinuousAnalysis("CONTINUOUS_ANALYSIS_UNSPECIFIED");
        /// <summary>
        /// The resource is continuously analyzed.
        /// </summary>
        public static DiscoveredContinuousAnalysis Active { get; } = new DiscoveredContinuousAnalysis("ACTIVE");
        /// <summary>
        /// The resource is ignored for continuous analysis.
        /// </summary>
        public static DiscoveredContinuousAnalysis Inactive { get; } = new DiscoveredContinuousAnalysis("INACTIVE");

        public static bool operator ==(DiscoveredContinuousAnalysis left, DiscoveredContinuousAnalysis right) => left.Equals(right);
        public static bool operator !=(DiscoveredContinuousAnalysis left, DiscoveredContinuousAnalysis right) => !left.Equals(right);

        public static explicit operator string(DiscoveredContinuousAnalysis value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiscoveredContinuousAnalysis other && Equals(other);
        public bool Equals(DiscoveredContinuousAnalysis other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. Immutable. The kind of analysis that is handled by this discovery.
    /// </summary>
    [EnumType]
    public readonly struct DiscoveryAnalysisKind : IEquatable<DiscoveryAnalysisKind>
    {
        private readonly string _value;

        private DiscoveryAnalysisKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value. This value is unused.
        /// </summary>
        public static DiscoveryAnalysisKind NoteKindUnspecified { get; } = new DiscoveryAnalysisKind("NOTE_KIND_UNSPECIFIED");
        /// <summary>
        /// The note and occurrence represent a package vulnerability.
        /// </summary>
        public static DiscoveryAnalysisKind Vulnerability { get; } = new DiscoveryAnalysisKind("VULNERABILITY");
        /// <summary>
        /// The note and occurrence assert build provenance.
        /// </summary>
        public static DiscoveryAnalysisKind Build { get; } = new DiscoveryAnalysisKind("BUILD");
        /// <summary>
        /// This represents an image basis relationship.
        /// </summary>
        public static DiscoveryAnalysisKind Image { get; } = new DiscoveryAnalysisKind("IMAGE");
        /// <summary>
        /// This represents a package installed via a package manager.
        /// </summary>
        public static DiscoveryAnalysisKind Package { get; } = new DiscoveryAnalysisKind("PACKAGE");
        /// <summary>
        /// The note and occurrence track deployment events.
        /// </summary>
        public static DiscoveryAnalysisKind Deployment { get; } = new DiscoveryAnalysisKind("DEPLOYMENT");
        /// <summary>
        /// The note and occurrence track the initial discovery status of a resource.
        /// </summary>
        public static DiscoveryAnalysisKind Discovery { get; } = new DiscoveryAnalysisKind("DISCOVERY");
        /// <summary>
        /// This represents a logical "role" that can attest to artifacts.
        /// </summary>
        public static DiscoveryAnalysisKind Attestation { get; } = new DiscoveryAnalysisKind("ATTESTATION");
        /// <summary>
        /// This represents an in-toto link.
        /// </summary>
        public static DiscoveryAnalysisKind Intoto { get; } = new DiscoveryAnalysisKind("INTOTO");
        /// <summary>
        /// This represents a software bill of materials.
        /// </summary>
        public static DiscoveryAnalysisKind Sbom { get; } = new DiscoveryAnalysisKind("SBOM");
        /// <summary>
        /// This represents an SPDX Package.
        /// </summary>
        public static DiscoveryAnalysisKind SpdxPackage { get; } = new DiscoveryAnalysisKind("SPDX_PACKAGE");
        /// <summary>
        /// This represents an SPDX File.
        /// </summary>
        public static DiscoveryAnalysisKind SpdxFile { get; } = new DiscoveryAnalysisKind("SPDX_FILE");

        public static bool operator ==(DiscoveryAnalysisKind left, DiscoveryAnalysisKind right) => left.Equals(right);
        public static bool operator !=(DiscoveryAnalysisKind left, DiscoveryAnalysisKind right) => !left.Equals(right);

        public static explicit operator string(DiscoveryAnalysisKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DiscoveryAnalysisKind other && Equals(other);
        public bool Equals(DiscoveryAnalysisKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The CPU architecture for which packages in this distribution channel were built.
    /// </summary>
    [EnumType]
    public readonly struct DistributionArchitecture : IEquatable<DistributionArchitecture>
    {
        private readonly string _value;

        private DistributionArchitecture(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown architecture.
        /// </summary>
        public static DistributionArchitecture ArchitectureUnspecified { get; } = new DistributionArchitecture("ARCHITECTURE_UNSPECIFIED");
        /// <summary>
        /// X86 architecture.
        /// </summary>
        public static DistributionArchitecture X86 { get; } = new DistributionArchitecture("X86");
        /// <summary>
        /// X64 architecture.
        /// </summary>
        public static DistributionArchitecture X64 { get; } = new DistributionArchitecture("X64");

        public static bool operator ==(DistributionArchitecture left, DistributionArchitecture right) => left.Equals(right);
        public static bool operator !=(DistributionArchitecture left, DistributionArchitecture right) => !left.Equals(right);

        public static explicit operator string(DistributionArchitecture value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DistributionArchitecture other && Equals(other);
        public bool Equals(DistributionArchitecture other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// An External Reference allows a Package to reference an external source of additional information, metadata, enumerations, asset identifiers, or downloadable content believed to be relevant to the Package
    /// </summary>
    [EnumType]
    public readonly struct ExternalRefCategory : IEquatable<ExternalRefCategory>
    {
        private readonly string _value;

        private ExternalRefCategory(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified
        /// </summary>
        public static ExternalRefCategory CategoryUnspecified { get; } = new ExternalRefCategory("CATEGORY_UNSPECIFIED");
        /// <summary>
        /// Security (e.g. cpe22Type, cpe23Type)
        /// </summary>
        public static ExternalRefCategory Security { get; } = new ExternalRefCategory("SECURITY");
        /// <summary>
        /// Package Manager (e.g. maven-central, npm, nuget, bower, purl)
        /// </summary>
        public static ExternalRefCategory PackageManager { get; } = new ExternalRefCategory("PACKAGE_MANAGER");
        /// <summary>
        /// Persistent-Id (e.g. swh)
        /// </summary>
        public static ExternalRefCategory PersistentId { get; } = new ExternalRefCategory("PERSISTENT_ID");
        /// <summary>
        /// Other
        /// </summary>
        public static ExternalRefCategory Other { get; } = new ExternalRefCategory("OTHER");

        public static bool operator ==(ExternalRefCategory left, ExternalRefCategory right) => left.Equals(right);
        public static bool operator !=(ExternalRefCategory left, ExternalRefCategory right) => !left.Equals(right);

        public static explicit operator string(ExternalRefCategory value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ExternalRefCategory other && Equals(other);
        public bool Equals(ExternalRefCategory other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// This field provides information about the type of file identified
    /// </summary>
    [EnumType]
    public readonly struct FileNoteFileType : IEquatable<FileNoteFileType>
    {
        private readonly string _value;

        private FileNoteFileType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified
        /// </summary>
        public static FileNoteFileType FileTypeUnspecified { get; } = new FileNoteFileType("FILE_TYPE_UNSPECIFIED");
        /// <summary>
        /// The file is human readable source code (.c, .html, etc.)
        /// </summary>
        public static FileNoteFileType Source { get; } = new FileNoteFileType("SOURCE");
        /// <summary>
        /// The file is a compiled object, target image or binary executable (.o, .a, etc.)
        /// </summary>
        public static FileNoteFileType Binary { get; } = new FileNoteFileType("BINARY");
        /// <summary>
        /// The file represents an archive (.tar, .jar, etc.)
        /// </summary>
        public static FileNoteFileType Archive { get; } = new FileNoteFileType("ARCHIVE");
        /// <summary>
        /// The file is associated with a specific application type (MIME type of application/*)
        /// </summary>
        public static FileNoteFileType Application { get; } = new FileNoteFileType("APPLICATION");
        /// <summary>
        /// The file is associated with an audio file (MIME type of audio/* , e.g. .mp3)
        /// </summary>
        public static FileNoteFileType Audio { get; } = new FileNoteFileType("AUDIO");
        /// <summary>
        /// The file is associated with an picture image file (MIME type of image/*, e.g., .jpg, .gif)
        /// </summary>
        public static FileNoteFileType Image { get; } = new FileNoteFileType("IMAGE");
        /// <summary>
        /// The file is human readable text file (MIME type of text/*)
        /// </summary>
        public static FileNoteFileType Text { get; } = new FileNoteFileType("TEXT");
        /// <summary>
        /// The file is associated with a video file type (MIME type of video/*)
        /// </summary>
        public static FileNoteFileType Video { get; } = new FileNoteFileType("VIDEO");
        /// <summary>
        /// The file serves as documentation
        /// </summary>
        public static FileNoteFileType Documentation { get; } = new FileNoteFileType("DOCUMENTATION");
        /// <summary>
        /// The file is an SPDX document
        /// </summary>
        public static FileNoteFileType Spdx { get; } = new FileNoteFileType("SPDX");
        /// <summary>
        /// The file doesn't fit into the above categories (generated artifacts, data files, etc.)
        /// </summary>
        public static FileNoteFileType Other { get; } = new FileNoteFileType("OTHER");

        public static bool operator ==(FileNoteFileType left, FileNoteFileType right) => left.Equals(right);
        public static bool operator !=(FileNoteFileType left, FileNoteFileType right) => !left.Equals(right);

        public static explicit operator string(FileNoteFileType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FileNoteFileType other && Equals(other);
        public bool Equals(FileNoteFileType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type (for example schema) of the attestation payload that was signed. The verifier must ensure that the provided type is one that the verifier supports, and that the attestation payload is a valid instantiation of that type (for example by validating a JSON schema).
    /// </summary>
    [EnumType]
    public readonly struct GenericSignedAttestationContentType : IEquatable<GenericSignedAttestationContentType>
    {
        private readonly string _value;

        private GenericSignedAttestationContentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// `ContentType` is not set.
        /// </summary>
        public static GenericSignedAttestationContentType ContentTypeUnspecified { get; } = new GenericSignedAttestationContentType("CONTENT_TYPE_UNSPECIFIED");
        /// <summary>
        /// Atomic format attestation signature. See https://github.com/containers/image/blob/8a5d2f82a6e3263290c8e0276c3e0f64e77723e7/docs/atomic-signature.md The payload extracted in `plaintext` is a JSON blob conforming to the linked schema.
        /// </summary>
        public static GenericSignedAttestationContentType SimpleSigningJson { get; } = new GenericSignedAttestationContentType("SIMPLE_SIGNING_JSON");

        public static bool operator ==(GenericSignedAttestationContentType left, GenericSignedAttestationContentType right) => left.Equals(right);
        public static bool operator !=(GenericSignedAttestationContentType left, GenericSignedAttestationContentType right) => !left.Equals(right);

        public static explicit operator string(GenericSignedAttestationContentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GenericSignedAttestationContentType other && Equals(other);
        public bool Equals(GenericSignedAttestationContentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The distro assigned severity for this vulnerability when it is available, and note provider assigned severity when distro has not yet assigned a severity for this vulnerability. When there are multiple PackageIssues for this vulnerability, they can have different effective severities because some might be provided by the distro while others are provided by the language ecosystem for a language pack. For this reason, it is advised to use the effective severity on the PackageIssue level. In the case where multiple PackageIssues have differing effective severities, this field should be the highest severity for any of the PackageIssues.
    /// </summary>
    [EnumType]
    public readonly struct GrafeasV1beta1VulnerabilityDetailsEffectiveSeverity : IEquatable<GrafeasV1beta1VulnerabilityDetailsEffectiveSeverity>
    {
        private readonly string _value;

        private GrafeasV1beta1VulnerabilityDetailsEffectiveSeverity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown.
        /// </summary>
        public static GrafeasV1beta1VulnerabilityDetailsEffectiveSeverity SeverityUnspecified { get; } = new GrafeasV1beta1VulnerabilityDetailsEffectiveSeverity("SEVERITY_UNSPECIFIED");
        /// <summary>
        /// Minimal severity.
        /// </summary>
        public static GrafeasV1beta1VulnerabilityDetailsEffectiveSeverity Minimal { get; } = new GrafeasV1beta1VulnerabilityDetailsEffectiveSeverity("MINIMAL");
        /// <summary>
        /// Low severity.
        /// </summary>
        public static GrafeasV1beta1VulnerabilityDetailsEffectiveSeverity Low { get; } = new GrafeasV1beta1VulnerabilityDetailsEffectiveSeverity("LOW");
        /// <summary>
        /// Medium severity.
        /// </summary>
        public static GrafeasV1beta1VulnerabilityDetailsEffectiveSeverity Medium { get; } = new GrafeasV1beta1VulnerabilityDetailsEffectiveSeverity("MEDIUM");
        /// <summary>
        /// High severity.
        /// </summary>
        public static GrafeasV1beta1VulnerabilityDetailsEffectiveSeverity High { get; } = new GrafeasV1beta1VulnerabilityDetailsEffectiveSeverity("HIGH");
        /// <summary>
        /// Critical severity.
        /// </summary>
        public static GrafeasV1beta1VulnerabilityDetailsEffectiveSeverity Critical { get; } = new GrafeasV1beta1VulnerabilityDetailsEffectiveSeverity("CRITICAL");

        public static bool operator ==(GrafeasV1beta1VulnerabilityDetailsEffectiveSeverity left, GrafeasV1beta1VulnerabilityDetailsEffectiveSeverity right) => left.Equals(right);
        public static bool operator !=(GrafeasV1beta1VulnerabilityDetailsEffectiveSeverity left, GrafeasV1beta1VulnerabilityDetailsEffectiveSeverity right) => !left.Equals(right);

        public static explicit operator string(GrafeasV1beta1VulnerabilityDetailsEffectiveSeverity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GrafeasV1beta1VulnerabilityDetailsEffectiveSeverity other && Equals(other);
        public bool Equals(GrafeasV1beta1VulnerabilityDetailsEffectiveSeverity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The recovered Dockerfile directive used to construct this layer.
    /// </summary>
    [EnumType]
    public readonly struct LayerDirective : IEquatable<LayerDirective>
    {
        private readonly string _value;

        private LayerDirective(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value for unsupported/missing directive.
        /// </summary>
        public static LayerDirective DirectiveUnspecified { get; } = new LayerDirective("DIRECTIVE_UNSPECIFIED");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Maintainer { get; } = new LayerDirective("MAINTAINER");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Run { get; } = new LayerDirective("RUN");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Cmd { get; } = new LayerDirective("CMD");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Label { get; } = new LayerDirective("LABEL");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Expose { get; } = new LayerDirective("EXPOSE");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Env { get; } = new LayerDirective("ENV");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Add { get; } = new LayerDirective("ADD");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Copy { get; } = new LayerDirective("COPY");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Entrypoint { get; } = new LayerDirective("ENTRYPOINT");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Volume { get; } = new LayerDirective("VOLUME");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective User { get; } = new LayerDirective("USER");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Workdir { get; } = new LayerDirective("WORKDIR");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Arg { get; } = new LayerDirective("ARG");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Onbuild { get; } = new LayerDirective("ONBUILD");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Stopsignal { get; } = new LayerDirective("STOPSIGNAL");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Healthcheck { get; } = new LayerDirective("HEALTHCHECK");
        /// <summary>
        /// https://docs.docker.com/engine/reference/builder/
        /// </summary>
        public static LayerDirective Shell { get; } = new LayerDirective("SHELL");

        public static bool operator ==(LayerDirective left, LayerDirective right) => left.Equals(right);
        public static bool operator !=(LayerDirective left, LayerDirective right) => !left.Equals(right);

        public static explicit operator string(LayerDirective value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LayerDirective other && Equals(other);
        public bool Equals(LayerDirective other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type (for example schema) of the attestation payload that was signed. The verifier must ensure that the provided type is one that the verifier supports, and that the attestation payload is a valid instantiation of that type (for example by validating a JSON schema).
    /// </summary>
    [EnumType]
    public readonly struct PgpSignedAttestationContentType : IEquatable<PgpSignedAttestationContentType>
    {
        private readonly string _value;

        private PgpSignedAttestationContentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// `ContentType` is not set.
        /// </summary>
        public static PgpSignedAttestationContentType ContentTypeUnspecified { get; } = new PgpSignedAttestationContentType("CONTENT_TYPE_UNSPECIFIED");
        /// <summary>
        /// Atomic format attestation signature. See https://github.com/containers/image/blob/8a5d2f82a6e3263290c8e0276c3e0f64e77723e7/docs/atomic-signature.md The payload extracted from `signature` is a JSON blob conforming to the linked schema.
        /// </summary>
        public static PgpSignedAttestationContentType SimpleSigningJson { get; } = new PgpSignedAttestationContentType("SIMPLE_SIGNING_JSON");

        public static bool operator ==(PgpSignedAttestationContentType left, PgpSignedAttestationContentType right) => left.Equals(right);
        public static bool operator !=(PgpSignedAttestationContentType left, PgpSignedAttestationContentType right) => !left.Equals(right);

        public static explicit operator string(PgpSignedAttestationContentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PgpSignedAttestationContentType other && Equals(other);
        public bool Equals(PgpSignedAttestationContentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of relationship between the source and target SPDX elements
    /// </summary>
    [EnumType]
    public readonly struct RelationshipOccurrenceType : IEquatable<RelationshipOccurrenceType>
    {
        private readonly string _value;

        private RelationshipOccurrenceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified
        /// </summary>
        public static RelationshipOccurrenceType TypeUnspecified { get; } = new RelationshipOccurrenceType("TYPE_UNSPECIFIED");
        /// <summary>
        /// Is to be used when SPDXRef-DOCUMENT describes SPDXRef-A
        /// </summary>
        public static RelationshipOccurrenceType Describes { get; } = new RelationshipOccurrenceType("DESCRIBES");
        /// <summary>
        /// Is to be used when SPDXRef-A is described by SPDXREF-Document
        /// </summary>
        public static RelationshipOccurrenceType DescribedBy { get; } = new RelationshipOccurrenceType("DESCRIBED_BY");
        /// <summary>
        /// Is to be used when SPDXRef-A contains SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType Contains { get; } = new RelationshipOccurrenceType("CONTAINS");
        /// <summary>
        /// Is to be used when SPDXRef-A is contained by SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType ContainedBy { get; } = new RelationshipOccurrenceType("CONTAINED_BY");
        /// <summary>
        /// Is to be used when SPDXRef-A depends on SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType DependsOn { get; } = new RelationshipOccurrenceType("DEPENDS_ON");
        /// <summary>
        /// Is to be used when SPDXRef-A is dependency of SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType DependencyOf { get; } = new RelationshipOccurrenceType("DEPENDENCY_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is a manifest file that lists a set of dependencies for SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType DependencyManifestOf { get; } = new RelationshipOccurrenceType("DEPENDENCY_MANIFEST_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is a build dependency of SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType BuildDependencyOf { get; } = new RelationshipOccurrenceType("BUILD_DEPENDENCY_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is a development dependency of SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType DevDependencyOf { get; } = new RelationshipOccurrenceType("DEV_DEPENDENCY_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is an optional dependency of SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType OptionalDependencyOf { get; } = new RelationshipOccurrenceType("OPTIONAL_DEPENDENCY_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is a to be provided dependency of SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType ProvidedDependencyOf { get; } = new RelationshipOccurrenceType("PROVIDED_DEPENDENCY_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is a test dependency of SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType TestDependencyOf { get; } = new RelationshipOccurrenceType("TEST_DEPENDENCY_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is a dependency required for the execution of SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType RuntimeDependencyOf { get; } = new RelationshipOccurrenceType("RUNTIME_DEPENDENCY_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is an example of SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType ExampleOf { get; } = new RelationshipOccurrenceType("EXAMPLE_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A generates SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType Generates { get; } = new RelationshipOccurrenceType("GENERATES");
        /// <summary>
        /// Is to be used when SPDXRef-A was generated from SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType GeneratedFrom { get; } = new RelationshipOccurrenceType("GENERATED_FROM");
        /// <summary>
        /// Is to be used when SPDXRef-A is an ancestor (same lineage but pre-dates) SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType AncestorOf { get; } = new RelationshipOccurrenceType("ANCESTOR_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is a descendant of (same lineage but postdates) SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType DescendantOf { get; } = new RelationshipOccurrenceType("DESCENDANT_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is a variant of (same lineage but not clear which came first) SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType VariantOf { get; } = new RelationshipOccurrenceType("VARIANT_OF");
        /// <summary>
        /// Is to be used when distributing SPDXRef-A requires that SPDXRef-B also be distributed
        /// </summary>
        public static RelationshipOccurrenceType DistributionArtifact { get; } = new RelationshipOccurrenceType("DISTRIBUTION_ARTIFACT");
        /// <summary>
        /// Is to be used when SPDXRef-A is a patch file for (to be applied to) SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType PatchFor { get; } = new RelationshipOccurrenceType("PATCH_FOR");
        /// <summary>
        /// Is to be used when SPDXRef-A is a patch file that has been applied to SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType PatchApplied { get; } = new RelationshipOccurrenceType("PATCH_APPLIED");
        /// <summary>
        /// Is to be used when SPDXRef-A is an exact copy of SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType CopyOf { get; } = new RelationshipOccurrenceType("COPY_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is a file that was added to SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType FileAdded { get; } = new RelationshipOccurrenceType("FILE_ADDED");
        /// <summary>
        /// Is to be used when SPDXRef-A is a file that was deleted from SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType FileDeleted { get; } = new RelationshipOccurrenceType("FILE_DELETED");
        /// <summary>
        /// Is to be used when SPDXRef-A is a file that was modified from SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType FileModified { get; } = new RelationshipOccurrenceType("FILE_MODIFIED");
        /// <summary>
        /// Is to be used when SPDXRef-A is expanded from the archive SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType ExpandedFromArchive { get; } = new RelationshipOccurrenceType("EXPANDED_FROM_ARCHIVE");
        /// <summary>
        /// Is to be used when SPDXRef-A dynamically links to SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType DynamicLink { get; } = new RelationshipOccurrenceType("DYNAMIC_LINK");
        /// <summary>
        /// Is to be used when SPDXRef-A statically links to SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType StaticLink { get; } = new RelationshipOccurrenceType("STATIC_LINK");
        /// <summary>
        /// Is to be used when SPDXRef-A is a data file used in SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType DataFileOf { get; } = new RelationshipOccurrenceType("DATA_FILE_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is a test case used in testing SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType TestCaseOf { get; } = new RelationshipOccurrenceType("TEST_CASE_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is used to build SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType BuildToolOf { get; } = new RelationshipOccurrenceType("BUILD_TOOL_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is used as a development tool for SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType DevToolOf { get; } = new RelationshipOccurrenceType("DEV_TOOL_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is used for testing SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType TestOf { get; } = new RelationshipOccurrenceType("TEST_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is used as a test tool for SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType TestToolOf { get; } = new RelationshipOccurrenceType("TEST_TOOL_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A provides documentation of SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType DocumentationOf { get; } = new RelationshipOccurrenceType("DOCUMENTATION_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is an optional component of SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType OptionalComponentOf { get; } = new RelationshipOccurrenceType("OPTIONAL_COMPONENT_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is a metafile of SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType MetafileOf { get; } = new RelationshipOccurrenceType("METAFILE_OF");
        /// <summary>
        /// Is to be used when SPDXRef-A is used as a package as part of SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType PackageOf { get; } = new RelationshipOccurrenceType("PACKAGE_OF");
        /// <summary>
        /// Is to be used when (current) SPDXRef-DOCUMENT amends the SPDX information in SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType Amends { get; } = new RelationshipOccurrenceType("AMENDS");
        /// <summary>
        /// Is to be used when SPDXRef-A is a prerequisite for SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType PrerequisiteFor { get; } = new RelationshipOccurrenceType("PREREQUISITE_FOR");
        /// <summary>
        /// Is to be used when SPDXRef-A has as a prerequisite SPDXRef-B
        /// </summary>
        public static RelationshipOccurrenceType HasPrerequisite { get; } = new RelationshipOccurrenceType("HAS_PREREQUISITE");
        /// <summary>
        /// Is to be used for a relationship which has not been defined in the formal SPDX specification. A description of the relationship should be included in the Relationship comments field
        /// </summary>
        public static RelationshipOccurrenceType Other { get; } = new RelationshipOccurrenceType("OTHER");

        public static bool operator ==(RelationshipOccurrenceType left, RelationshipOccurrenceType right) => left.Equals(right);
        public static bool operator !=(RelationshipOccurrenceType left, RelationshipOccurrenceType right) => !left.Equals(right);

        public static explicit operator string(RelationshipOccurrenceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RelationshipOccurrenceType other && Equals(other);
        public bool Equals(RelationshipOccurrenceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. Distinguishes between sentinel MIN/MAX versions and normal versions.
    /// </summary>
    [EnumType]
    public readonly struct VersionKind : IEquatable<VersionKind>
    {
        private readonly string _value;

        private VersionKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown.
        /// </summary>
        public static VersionKind VersionKindUnspecified { get; } = new VersionKind("VERSION_KIND_UNSPECIFIED");
        /// <summary>
        /// A standard package version.
        /// </summary>
        public static VersionKind Normal { get; } = new VersionKind("NORMAL");
        /// <summary>
        /// A special version representing negative infinity.
        /// </summary>
        public static VersionKind Minimum { get; } = new VersionKind("MINIMUM");
        /// <summary>
        /// A special version representing positive infinity.
        /// </summary>
        public static VersionKind Maximum { get; } = new VersionKind("MAXIMUM");

        public static bool operator ==(VersionKind left, VersionKind right) => left.Equals(right);
        public static bool operator !=(VersionKind left, VersionKind right) => !left.Equals(right);

        public static explicit operator string(VersionKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VersionKind other && Equals(other);
        public bool Equals(VersionKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Note provider assigned impact of the vulnerability.
    /// </summary>
    [EnumType]
    public readonly struct VulnerabilitySeverity : IEquatable<VulnerabilitySeverity>
    {
        private readonly string _value;

        private VulnerabilitySeverity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unknown.
        /// </summary>
        public static VulnerabilitySeverity SeverityUnspecified { get; } = new VulnerabilitySeverity("SEVERITY_UNSPECIFIED");
        /// <summary>
        /// Minimal severity.
        /// </summary>
        public static VulnerabilitySeverity Minimal { get; } = new VulnerabilitySeverity("MINIMAL");
        /// <summary>
        /// Low severity.
        /// </summary>
        public static VulnerabilitySeverity Low { get; } = new VulnerabilitySeverity("LOW");
        /// <summary>
        /// Medium severity.
        /// </summary>
        public static VulnerabilitySeverity Medium { get; } = new VulnerabilitySeverity("MEDIUM");
        /// <summary>
        /// High severity.
        /// </summary>
        public static VulnerabilitySeverity High { get; } = new VulnerabilitySeverity("HIGH");
        /// <summary>
        /// Critical severity.
        /// </summary>
        public static VulnerabilitySeverity Critical { get; } = new VulnerabilitySeverity("CRITICAL");

        public static bool operator ==(VulnerabilitySeverity left, VulnerabilitySeverity right) => left.Equals(right);
        public static bool operator !=(VulnerabilitySeverity left, VulnerabilitySeverity right) => !left.Equals(right);

        public static explicit operator string(VulnerabilitySeverity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VulnerabilitySeverity other && Equals(other);
        public bool Equals(VulnerabilitySeverity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
