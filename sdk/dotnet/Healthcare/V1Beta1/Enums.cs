// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.Healthcare.V1Beta1
{
    /// <summary>
    /// Optional. Controls the amount of detail to include as part of the audit logs.
    /// </summary>
    [EnumType]
    public readonly struct AccessDeterminationLogConfigLogLevel : IEquatable<AccessDeterminationLogConfigLogLevel>
    {
        private readonly string _value;

        private AccessDeterminationLogConfigLogLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No log level specified. This value is unused.
        /// </summary>
        public static AccessDeterminationLogConfigLogLevel LogLevelUnspecified { get; } = new AccessDeterminationLogConfigLogLevel("LOG_LEVEL_UNSPECIFIED");
        /// <summary>
        /// No additional consent-related logging is added to audit logs.
        /// </summary>
        public static AccessDeterminationLogConfigLogLevel Disabled { get; } = new AccessDeterminationLogConfigLogLevel("DISABLED");
        /// <summary>
        /// The following information is included: * One of the following [`consentMode`](https://cloud.google.com/healthcare-api/docs/fhir-consent#audit_logs) fields: (`off`|`emptyScope`|`enforced`|`btg`|`bypass`). * The accessor's request headers * The `log_level` of the AccessDeterminationLogConfig * The final consent evaluation (`PERMIT`, `DENY`, or `NO_CONSENT`) * A human-readable summary of the evaluation
        /// </summary>
        public static AccessDeterminationLogConfigLogLevel Minimum { get; } = new AccessDeterminationLogConfigLogLevel("MINIMUM");
        /// <summary>
        /// Includes `MINIMUM` and, for each resource owner, returns: * The resource owner's name * Most specific part of the `X-Consent-Scope` resulting in consensual determination * Timestamp of the applied enforcement leading to the decision * Enforcement version at the time the applicable consents were applied * The Consent resource name * The timestamp of the Consent resource used for enforcement * Policy type (`PATIENT` or `ADMIN`) Note that this mode adds some overhead to CRUD operations.
        /// </summary>
        public static AccessDeterminationLogConfigLogLevel Verbose { get; } = new AccessDeterminationLogConfigLogLevel("VERBOSE");

        public static bool operator ==(AccessDeterminationLogConfigLogLevel left, AccessDeterminationLogConfigLogLevel right) => left.Equals(right);
        public static bool operator !=(AccessDeterminationLogConfigLogLevel left, AccessDeterminationLogConfigLogLevel right) => !left.Equals(right);

        public static explicit operator string(AccessDeterminationLogConfigLogLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AccessDeterminationLogConfigLogLevel other && Equals(other);
        public bool Equals(AccessDeterminationLogConfigLogLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The category of the attribute. The value of this field cannot be changed after creation.
    /// </summary>
    [EnumType]
    public readonly struct AttributeDefinitionCategory : IEquatable<AttributeDefinitionCategory>
    {
        private readonly string _value;

        private AttributeDefinitionCategory(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No category specified. This option is invalid.
        /// </summary>
        public static AttributeDefinitionCategory CategoryUnspecified { get; } = new AttributeDefinitionCategory("CATEGORY_UNSPECIFIED");
        /// <summary>
        /// Specify this category when this attribute describes the properties of resources. For example, data anonymity or data type.
        /// </summary>
        public static AttributeDefinitionCategory Resource { get; } = new AttributeDefinitionCategory("RESOURCE");
        /// <summary>
        /// Specify this category when this attribute describes the properties of requests. For example, requester's role or requester's organization.
        /// </summary>
        public static AttributeDefinitionCategory Request { get; } = new AttributeDefinitionCategory("REQUEST");

        public static bool operator ==(AttributeDefinitionCategory left, AttributeDefinitionCategory right) => left.Equals(right);
        public static bool operator !=(AttributeDefinitionCategory left, AttributeDefinitionCategory right) => !left.Equals(right);

        public static explicit operator string(AttributeDefinitionCategory value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AttributeDefinitionCategory other && Equals(other);
        public bool Equals(AttributeDefinitionCategory other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The log type that this config enables.
    /// </summary>
    [EnumType]
    public readonly struct AuditLogConfigLogType : IEquatable<AuditLogConfigLogType>
    {
        private readonly string _value;

        private AuditLogConfigLogType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default case. Should never be this.
        /// </summary>
        public static AuditLogConfigLogType LogTypeUnspecified { get; } = new AuditLogConfigLogType("LOG_TYPE_UNSPECIFIED");
        /// <summary>
        /// Admin reads. Example: CloudIAM getIamPolicy
        /// </summary>
        public static AuditLogConfigLogType AdminRead { get; } = new AuditLogConfigLogType("ADMIN_READ");
        /// <summary>
        /// Data writes. Example: CloudSQL Users create
        /// </summary>
        public static AuditLogConfigLogType DataWrite { get; } = new AuditLogConfigLogType("DATA_WRITE");
        /// <summary>
        /// Data reads. Example: CloudSQL Users list
        /// </summary>
        public static AuditLogConfigLogType DataRead { get; } = new AuditLogConfigLogType("DATA_READ");

        public static bool operator ==(AuditLogConfigLogType left, AuditLogConfigLogType right) => left.Equals(right);
        public static bool operator !=(AuditLogConfigLogType left, AuditLogConfigLogType right) => !left.Equals(right);

        public static explicit operator string(AuditLogConfigLogType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AuditLogConfigLogType other && Equals(other);
        public bool Equals(AuditLogConfigLogType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. Specifies which consent enforcement version is being used for this FHIR store. This field can only be set once by either CreateFhirStore or UpdateFhirStore. After that, you must call ApplyConsents to change the version.
    /// </summary>
    [EnumType]
    public readonly struct ConsentConfigVersion : IEquatable<ConsentConfigVersion>
    {
        private readonly string _value;

        private ConsentConfigVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Users must specify an enforcement version or an error is returned.
        /// </summary>
        public static ConsentConfigVersion ConsentEnforcementVersionUnspecified { get; } = new ConsentConfigVersion("CONSENT_ENFORCEMENT_VERSION_UNSPECIFIED");
        /// <summary>
        /// Enforcement version 1. See the [FHIR Consent resources in the Cloud Healthcare API](https://cloud.google.com/healthcare-api/docs/fhir-consent) guide for more details.
        /// </summary>
        public static ConsentConfigVersion V1 { get; } = new ConsentConfigVersion("V1");

        public static bool operator ==(ConsentConfigVersion left, ConsentConfigVersion right) => left.Equals(right);
        public static bool operator !=(ConsentConfigVersion left, ConsentConfigVersion right) => !left.Equals(right);

        public static explicit operator string(ConsentConfigVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ConsentConfigVersion other && Equals(other);
        public bool Equals(ConsentConfigVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. Specifies the default server behavior when the header is empty. If not specified, the `ScopeProfile.PERMIT_EMPTY_SCOPE` option is used.
    /// </summary>
    [EnumType]
    public readonly struct ConsentHeaderHandlingProfile : IEquatable<ConsentHeaderHandlingProfile>
    {
        private readonly string _value;

        private ConsentHeaderHandlingProfile(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// If not specified, the default value `PERMIT_EMPTY_SCOPE` is used.
        /// </summary>
        public static ConsentHeaderHandlingProfile ScopeProfileUnspecified { get; } = new ConsentHeaderHandlingProfile("SCOPE_PROFILE_UNSPECIFIED");
        /// <summary>
        /// When no consent scopes are provided (for example, if there's an empty or missing header), then consent check is disabled, similar to when `access_enforced` is `false`. You can use audit logs to differentiate these two cases by looking at the value of `protopayload.metadata.consentMode`. If consents scopes are present, they must be valid and within the allowed limits, otherwise the request will be rejected with a `4xx` code.
        /// </summary>
        public static ConsentHeaderHandlingProfile PermitEmptyScope { get; } = new ConsentHeaderHandlingProfile("PERMIT_EMPTY_SCOPE");
        /// <summary>
        /// The consent header must be non-empty when performing read and search operations, otherwise the request is rejected with a `4xx` code. Additionally, invalid consent scopes or scopes exceeding the allowed limits are rejected.
        /// </summary>
        public static ConsentHeaderHandlingProfile RequiredOnRead { get; } = new ConsentHeaderHandlingProfile("REQUIRED_ON_READ");

        public static bool operator ==(ConsentHeaderHandlingProfile left, ConsentHeaderHandlingProfile right) => left.Equals(right);
        public static bool operator !=(ConsentHeaderHandlingProfile left, ConsentHeaderHandlingProfile right) => !left.Equals(right);

        public static explicit operator string(ConsentHeaderHandlingProfile value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ConsentHeaderHandlingProfile other && Equals(other);
        public bool Equals(ConsentHeaderHandlingProfile other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. Indicates the current state of this Consent.
    /// </summary>
    [EnumType]
    public readonly struct ConsentState : IEquatable<ConsentState>
    {
        private readonly string _value;

        private ConsentState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No state specified. Treated as ACTIVE only at the time of resource creation.
        /// </summary>
        public static ConsentState StateUnspecified { get; } = new ConsentState("STATE_UNSPECIFIED");
        /// <summary>
        /// The Consent is active and is considered when evaluating a user's consent on resources.
        /// </summary>
        public static ConsentState Active { get; } = new ConsentState("ACTIVE");
        /// <summary>
        /// The archived state is currently not being used.
        /// </summary>
        public static ConsentState Archived { get; } = new ConsentState("ARCHIVED");
        /// <summary>
        /// A revoked Consent is not considered when evaluating a user's consent on resources.
        /// </summary>
        public static ConsentState Revoked { get; } = new ConsentState("REVOKED");
        /// <summary>
        /// A draft Consent is not considered when evaluating a user's consent on resources unless explicitly specified.
        /// </summary>
        public static ConsentState Draft { get; } = new ConsentState("DRAFT");
        /// <summary>
        /// When a draft Consent is rejected by a user, it is set to a rejected state. A rejected Consent is not considered when evaluating a user's consent on resources.
        /// </summary>
        public static ConsentState Rejected { get; } = new ConsentState("REJECTED");

        public static bool operator ==(ConsentState left, ConsentState right) => left.Equals(right);
        public static bool operator !=(ConsentState left, ConsentState right) => !left.Equals(right);

        public static explicit operator string(ConsentState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ConsentState other && Equals(other);
        public bool Equals(ConsentState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Tag filtering profile that determines which tags to keep/remove.
    /// </summary>
    [EnumType]
    public readonly struct DicomConfigFilterProfile : IEquatable<DicomConfigFilterProfile>
    {
        private readonly string _value;

        private DicomConfigFilterProfile(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No tag filtration profile provided. Same as KEEP_ALL_PROFILE.
        /// </summary>
        public static DicomConfigFilterProfile TagFilterProfileUnspecified { get; } = new DicomConfigFilterProfile("TAG_FILTER_PROFILE_UNSPECIFIED");
        /// <summary>
        /// Keep only the tags required to produce valid DICOM objects.
        /// </summary>
        public static DicomConfigFilterProfile MinimalKeepListProfile { get; } = new DicomConfigFilterProfile("MINIMAL_KEEP_LIST_PROFILE");
        /// <summary>
        /// Remove tags based on DICOM Standard's Attribute Confidentiality Basic Profile (DICOM Standard Edition 2018e) http://dicom.nema.org/medical/dicom/2018e/output/chtml/part15/chapter_E.html.
        /// </summary>
        public static DicomConfigFilterProfile AttributeConfidentialityBasicProfile { get; } = new DicomConfigFilterProfile("ATTRIBUTE_CONFIDENTIALITY_BASIC_PROFILE");
        /// <summary>
        /// Keep all tags.
        /// </summary>
        public static DicomConfigFilterProfile KeepAllProfile { get; } = new DicomConfigFilterProfile("KEEP_ALL_PROFILE");
        /// <summary>
        /// Inspect within tag contents and replace sensitive text. The process can be configured using the TextConfig. Applies to all tags with the following Value Representation names: AE, LO, LT, PN, SH, ST, UC, UT, DA, DT, AS
        /// </summary>
        public static DicomConfigFilterProfile DeidentifyTagContents { get; } = new DicomConfigFilterProfile("DEIDENTIFY_TAG_CONTENTS");

        public static bool operator ==(DicomConfigFilterProfile left, DicomConfigFilterProfile right) => left.Equals(right);
        public static bool operator !=(DicomConfigFilterProfile left, DicomConfigFilterProfile right) => !left.Equals(right);

        public static explicit operator string(DicomConfigFilterProfile value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DicomConfigFilterProfile other && Equals(other);
        public bool Equals(DicomConfigFilterProfile other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Base profile type for handling DICOM tags.
    /// </summary>
    [EnumType]
    public readonly struct DicomTagConfigProfileType : IEquatable<DicomTagConfigProfileType>
    {
        private readonly string _value;

        private DicomTagConfigProfileType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No profile provided. Same as `ATTRIBUTE_CONFIDENTIALITY_BASIC_PROFILE`.
        /// </summary>
        public static DicomTagConfigProfileType ProfileTypeUnspecified { get; } = new DicomTagConfigProfileType("PROFILE_TYPE_UNSPECIFIED");
        /// <summary>
        /// Keep only the tags required to produce valid DICOM objects.
        /// </summary>
        public static DicomTagConfigProfileType MinimalKeepListProfile { get; } = new DicomTagConfigProfileType("MINIMAL_KEEP_LIST_PROFILE");
        /// <summary>
        /// Remove tags based on DICOM Standard's [Attribute Confidentiality Basic Profile (DICOM Standard Edition 2018e)](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part15/chapter_E.html).
        /// </summary>
        public static DicomTagConfigProfileType AttributeConfidentialityBasicProfile { get; } = new DicomTagConfigProfileType("ATTRIBUTE_CONFIDENTIALITY_BASIC_PROFILE");
        /// <summary>
        /// Keep all tags.
        /// </summary>
        public static DicomTagConfigProfileType KeepAllProfile { get; } = new DicomTagConfigProfileType("KEEP_ALL_PROFILE");
        /// <summary>
        /// Inspect tag contents and replace sensitive text. The process can be configured using the TextConfig. Applies to all tags with the following [Value Representations] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): AE, LO, LT, PN, SH, ST, UC, UT, DA, DT, AS
        /// </summary>
        public static DicomTagConfigProfileType DeidentifyTagContents { get; } = new DicomTagConfigProfileType("DEIDENTIFY_TAG_CONTENTS");

        public static bool operator ==(DicomTagConfigProfileType left, DicomTagConfigProfileType right) => left.Equals(right);
        public static bool operator !=(DicomTagConfigProfileType left, DicomTagConfigProfileType right) => !left.Equals(right);

        public static explicit operator string(DicomTagConfigProfileType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DicomTagConfigProfileType other && Equals(other);
        public bool Equals(DicomTagConfigProfileType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Base profile type for handling FHIR fields.
    /// </summary>
    [EnumType]
    public readonly struct FhirFieldConfigProfileType : IEquatable<FhirFieldConfigProfileType>
    {
        private readonly string _value;

        private FhirFieldConfigProfileType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No profile provided. Same as `BASIC`.
        /// </summary>
        public static FhirFieldConfigProfileType ProfileTypeUnspecified { get; } = new FhirFieldConfigProfileType("PROFILE_TYPE_UNSPECIFIED");
        /// <summary>
        /// Keep all fields.
        /// </summary>
        public static FhirFieldConfigProfileType KeepAll { get; } = new FhirFieldConfigProfileType("KEEP_ALL");
        /// <summary>
        /// Transforms known [HIPAA 18](https://www.hhs.gov/hipaa/for-professionals/privacy/special-topics/de-identification/index.html#standard) fields and cleans known unstructured text fields.
        /// </summary>
        public static FhirFieldConfigProfileType Basic { get; } = new FhirFieldConfigProfileType("BASIC");
        /// <summary>
        /// Cleans all supported tags. Applies to types: Code, Date, DateTime, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
        /// </summary>
        public static FhirFieldConfigProfileType CleanAll { get; } = new FhirFieldConfigProfileType("CLEAN_ALL");

        public static bool operator ==(FhirFieldConfigProfileType left, FhirFieldConfigProfileType right) => left.Equals(right);
        public static bool operator !=(FhirFieldConfigProfileType left, FhirFieldConfigProfileType right) => !left.Equals(right);

        public static explicit operator string(FhirFieldConfigProfileType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FhirFieldConfigProfileType other && Equals(other);
        public bool Equals(FhirFieldConfigProfileType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enable parsing of references within complex FHIR data types such as Extensions. If this value is set to ENABLED, then features like referential integrity and Bundle reference rewriting apply to all references. If this flag has not been specified the behavior of the FHIR store will not change, references in complex data types will not be parsed. New stores will have this value set to ENABLED after a notification period. Warning: turning on this flag causes processing existing resources to fail if they contain references to non-existent resources.
    /// </summary>
    [EnumType]
    public readonly struct FhirStoreComplexDataTypeReferenceParsing : IEquatable<FhirStoreComplexDataTypeReferenceParsing>
    {
        private readonly string _value;

        private FhirStoreComplexDataTypeReferenceParsing(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No parsing behavior specified. This is the same as DISABLED for backwards compatibility.
        /// </summary>
        public static FhirStoreComplexDataTypeReferenceParsing ComplexDataTypeReferenceParsingUnspecified { get; } = new FhirStoreComplexDataTypeReferenceParsing("COMPLEX_DATA_TYPE_REFERENCE_PARSING_UNSPECIFIED");
        /// <summary>
        /// References in complex data types are ignored.
        /// </summary>
        public static FhirStoreComplexDataTypeReferenceParsing Disabled { get; } = new FhirStoreComplexDataTypeReferenceParsing("DISABLED");
        /// <summary>
        /// References in complex data types are parsed.
        /// </summary>
        public static FhirStoreComplexDataTypeReferenceParsing Enabled { get; } = new FhirStoreComplexDataTypeReferenceParsing("ENABLED");

        public static bool operator ==(FhirStoreComplexDataTypeReferenceParsing left, FhirStoreComplexDataTypeReferenceParsing right) => left.Equals(right);
        public static bool operator !=(FhirStoreComplexDataTypeReferenceParsing left, FhirStoreComplexDataTypeReferenceParsing right) => !left.Equals(right);

        public static explicit operator string(FhirStoreComplexDataTypeReferenceParsing value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FhirStoreComplexDataTypeReferenceParsing other && Equals(other);
        public bool Equals(FhirStoreComplexDataTypeReferenceParsing other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. Immutable. The FHIR specification version that this FHIR store supports natively. This field is immutable after store creation. Requests are rejected if they contain FHIR resources of a different version. Version is required for every FHIR store.
    /// </summary>
    [EnumType]
    public readonly struct FhirStoreVersion : IEquatable<FhirStoreVersion>
    {
        private readonly string _value;

        private FhirStoreVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// VERSION_UNSPECIFIED is treated as STU3 to accommodate the existing FHIR stores.
        /// </summary>
        public static FhirStoreVersion VersionUnspecified { get; } = new FhirStoreVersion("VERSION_UNSPECIFIED");
        /// <summary>
        /// Draft Standard for Trial Use, [Release 2](https://www.hl7.org/fhir/DSTU2)
        /// </summary>
        public static FhirStoreVersion Dstu2 { get; } = new FhirStoreVersion("DSTU2");
        /// <summary>
        /// Standard for Trial Use, [Release 3](https://www.hl7.org/fhir/STU3)
        /// </summary>
        public static FhirStoreVersion Stu3 { get; } = new FhirStoreVersion("STU3");
        /// <summary>
        /// [Release 4](https://www.hl7.org/fhir/R4)
        /// </summary>
        public static FhirStoreVersion R4 { get; } = new FhirStoreVersion("R4");

        public static bool operator ==(FhirStoreVersion left, FhirStoreVersion right) => left.Equals(right);
        public static bool operator !=(FhirStoreVersion left, FhirStoreVersion right) => !left.Equals(right);

        public static explicit operator string(FhirStoreVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FhirStoreVersion other && Equals(other);
        public bool Equals(FhirStoreVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Deidentify action for one field.
    /// </summary>
    [EnumType]
    public readonly struct FieldMetadataAction : IEquatable<FieldMetadataAction>
    {
        private readonly string _value;

        private FieldMetadataAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No action specified.
        /// </summary>
        public static FieldMetadataAction ActionUnspecified { get; } = new FieldMetadataAction("ACTION_UNSPECIFIED");
        /// <summary>
        /// Transform the entire field based on transformations specified in TextConfig. When the specified transformation cannot be applied to a field, RedactConfig is used. For example, a Crypto Hash transformation can't be applied to a FHIR Date field.
        /// </summary>
        public static FieldMetadataAction Transform { get; } = new FieldMetadataAction("TRANSFORM");
        /// <summary>
        /// Inspect and transform any found PHI. When `AnnotationConfig` is provided, annotations of PHI will be generated, except for Date and Datetime.
        /// </summary>
        public static FieldMetadataAction InspectAndTransform { get; } = new FieldMetadataAction("INSPECT_AND_TRANSFORM");
        /// <summary>
        /// Do not transform.
        /// </summary>
        public static FieldMetadataAction DoNotTransform { get; } = new FieldMetadataAction("DO_NOT_TRANSFORM");

        public static bool operator ==(FieldMetadataAction left, FieldMetadataAction right) => left.Equals(right);
        public static bool operator !=(FieldMetadataAction left, FieldMetadataAction right) => !left.Equals(right);

        public static explicit operator string(FieldMetadataAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FieldMetadataAction other && Equals(other);
        public bool Equals(FieldMetadataAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines whether the existing table in the destination is to be overwritten or appended to. If a write_disposition is specified, the `force` parameter is ignored.
    /// </summary>
    [EnumType]
    public readonly struct GoogleCloudHealthcareV1beta1DicomBigQueryDestinationWriteDisposition : IEquatable<GoogleCloudHealthcareV1beta1DicomBigQueryDestinationWriteDisposition>
    {
        private readonly string _value;

        private GoogleCloudHealthcareV1beta1DicomBigQueryDestinationWriteDisposition(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default behavior is the same as WRITE_EMPTY.
        /// </summary>
        public static GoogleCloudHealthcareV1beta1DicomBigQueryDestinationWriteDisposition WriteDispositionUnspecified { get; } = new GoogleCloudHealthcareV1beta1DicomBigQueryDestinationWriteDisposition("WRITE_DISPOSITION_UNSPECIFIED");
        /// <summary>
        /// Only export data if the destination table is empty.
        /// </summary>
        public static GoogleCloudHealthcareV1beta1DicomBigQueryDestinationWriteDisposition WriteEmpty { get; } = new GoogleCloudHealthcareV1beta1DicomBigQueryDestinationWriteDisposition("WRITE_EMPTY");
        /// <summary>
        /// Erase all existing data in the destination table before writing the instances.
        /// </summary>
        public static GoogleCloudHealthcareV1beta1DicomBigQueryDestinationWriteDisposition WriteTruncate { get; } = new GoogleCloudHealthcareV1beta1DicomBigQueryDestinationWriteDisposition("WRITE_TRUNCATE");
        /// <summary>
        /// Append data to the destination table.
        /// </summary>
        public static GoogleCloudHealthcareV1beta1DicomBigQueryDestinationWriteDisposition WriteAppend { get; } = new GoogleCloudHealthcareV1beta1DicomBigQueryDestinationWriteDisposition("WRITE_APPEND");

        public static bool operator ==(GoogleCloudHealthcareV1beta1DicomBigQueryDestinationWriteDisposition left, GoogleCloudHealthcareV1beta1DicomBigQueryDestinationWriteDisposition right) => left.Equals(right);
        public static bool operator !=(GoogleCloudHealthcareV1beta1DicomBigQueryDestinationWriteDisposition left, GoogleCloudHealthcareV1beta1DicomBigQueryDestinationWriteDisposition right) => !left.Equals(right);

        public static explicit operator string(GoogleCloudHealthcareV1beta1DicomBigQueryDestinationWriteDisposition value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GoogleCloudHealthcareV1beta1DicomBigQueryDestinationWriteDisposition other && Equals(other);
        public bool Equals(GoogleCloudHealthcareV1beta1DicomBigQueryDestinationWriteDisposition other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines if existing data in the destination dataset is overwritten, appended to, or not written if the tables contain data. If a write_disposition is specified, the `force` parameter is ignored.
    /// </summary>
    [EnumType]
    public readonly struct GoogleCloudHealthcareV1beta1FhirBigQueryDestinationWriteDisposition : IEquatable<GoogleCloudHealthcareV1beta1FhirBigQueryDestinationWriteDisposition>
    {
        private readonly string _value;

        private GoogleCloudHealthcareV1beta1FhirBigQueryDestinationWriteDisposition(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default behavior is the same as WRITE_EMPTY.
        /// </summary>
        public static GoogleCloudHealthcareV1beta1FhirBigQueryDestinationWriteDisposition WriteDispositionUnspecified { get; } = new GoogleCloudHealthcareV1beta1FhirBigQueryDestinationWriteDisposition("WRITE_DISPOSITION_UNSPECIFIED");
        /// <summary>
        /// Only export data if the destination tables are empty.
        /// </summary>
        public static GoogleCloudHealthcareV1beta1FhirBigQueryDestinationWriteDisposition WriteEmpty { get; } = new GoogleCloudHealthcareV1beta1FhirBigQueryDestinationWriteDisposition("WRITE_EMPTY");
        /// <summary>
        /// Erase all existing data in the destination tables before writing the FHIR resources.
        /// </summary>
        public static GoogleCloudHealthcareV1beta1FhirBigQueryDestinationWriteDisposition WriteTruncate { get; } = new GoogleCloudHealthcareV1beta1FhirBigQueryDestinationWriteDisposition("WRITE_TRUNCATE");
        /// <summary>
        /// Append data to the destination tables.
        /// </summary>
        public static GoogleCloudHealthcareV1beta1FhirBigQueryDestinationWriteDisposition WriteAppend { get; } = new GoogleCloudHealthcareV1beta1FhirBigQueryDestinationWriteDisposition("WRITE_APPEND");

        public static bool operator ==(GoogleCloudHealthcareV1beta1FhirBigQueryDestinationWriteDisposition left, GoogleCloudHealthcareV1beta1FhirBigQueryDestinationWriteDisposition right) => left.Equals(right);
        public static bool operator !=(GoogleCloudHealthcareV1beta1FhirBigQueryDestinationWriteDisposition left, GoogleCloudHealthcareV1beta1FhirBigQueryDestinationWriteDisposition right) => !left.Equals(right);

        public static explicit operator string(GoogleCloudHealthcareV1beta1FhirBigQueryDestinationWriteDisposition value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GoogleCloudHealthcareV1beta1FhirBigQueryDestinationWriteDisposition other && Equals(other);
        public bool Equals(GoogleCloudHealthcareV1beta1FhirBigQueryDestinationWriteDisposition other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines how to redact text from image.
    /// </summary>
    [EnumType]
    public readonly struct ImageConfigTextRedactionMode : IEquatable<ImageConfigTextRedactionMode>
    {
        private readonly string _value;

        private ImageConfigTextRedactionMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No text redaction specified. Same as REDACT_NO_TEXT.
        /// </summary>
        public static ImageConfigTextRedactionMode TextRedactionModeUnspecified { get; } = new ImageConfigTextRedactionMode("TEXT_REDACTION_MODE_UNSPECIFIED");
        /// <summary>
        /// Redact all text.
        /// </summary>
        public static ImageConfigTextRedactionMode RedactAllText { get; } = new ImageConfigTextRedactionMode("REDACT_ALL_TEXT");
        /// <summary>
        /// Redact sensitive text. Uses the set of [Default DICOM InfoTypes](https://cloud.google.com/healthcare-api/docs/how-tos/dicom-deidentify#default_dicom_infotypes).
        /// </summary>
        public static ImageConfigTextRedactionMode RedactSensitiveText { get; } = new ImageConfigTextRedactionMode("REDACT_SENSITIVE_TEXT");
        /// <summary>
        /// Do not redact text.
        /// </summary>
        public static ImageConfigTextRedactionMode RedactNoText { get; } = new ImageConfigTextRedactionMode("REDACT_NO_TEXT");
        /// <summary>
        /// This mode is like `REDACT_SENSITIVE_TEXT` with the addition of the [Clean Descriptors Option] (https://dicom.nema.org/medical/dicom/2018e/output/chtml/part15/sect_E.3.5.html) enabled: When cleaning text, the process attempts to transform phrases matching any of the tags marked for removal (action codes D, Z, X, and U) in the [Basic Profile] (https://dicom.nema.org/medical/dicom/2018e/output/chtml/part15/chapter_E.html). These contextual phrases are replaced with the token "[CTX]". This mode uses an additional InfoType during inspection.
        /// </summary>
        public static ImageConfigTextRedactionMode RedactSensitiveTextCleanDescriptors { get; } = new ImageConfigTextRedactionMode("REDACT_SENSITIVE_TEXT_CLEAN_DESCRIPTORS");

        public static bool operator ==(ImageConfigTextRedactionMode left, ImageConfigTextRedactionMode right) => left.Equals(right);
        public static bool operator !=(ImageConfigTextRedactionMode left, ImageConfigTextRedactionMode right) => !left.Equals(right);

        public static explicit operator string(ImageConfigTextRedactionMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ImageConfigTextRedactionMode other && Equals(other);
        public bool Equals(ImageConfigTextRedactionMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Set `Action` for [`StudyInstanceUID`, `SeriesInstanceUID`, `SOPInstanceUID`, and `MediaStorageSOPInstanceUID`](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part06/chapter_6.html).
    /// </summary>
    [EnumType]
    public readonly struct OptionsPrimaryIds : IEquatable<OptionsPrimaryIds>
    {
        private readonly string _value;

        private OptionsPrimaryIds(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No value provided. Default to the behavior specified by the base profile.
        /// </summary>
        public static OptionsPrimaryIds PrimaryIdsOptionUnspecified { get; } = new OptionsPrimaryIds("PRIMARY_IDS_OPTION_UNSPECIFIED");
        /// <summary>
        /// Keep primary IDs.
        /// </summary>
        public static OptionsPrimaryIds Keep { get; } = new OptionsPrimaryIds("KEEP");
        /// <summary>
        /// Regenerate primary IDs.
        /// </summary>
        public static OptionsPrimaryIds Regen { get; } = new OptionsPrimaryIds("REGEN");

        public static bool operator ==(OptionsPrimaryIds left, OptionsPrimaryIds right) => left.Equals(right);
        public static bool operator !=(OptionsPrimaryIds left, OptionsPrimaryIds right) => !left.Equals(right);

        public static explicit operator string(OptionsPrimaryIds value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OptionsPrimaryIds other && Equals(other);
        public bool Equals(OptionsPrimaryIds other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Immutable. Determines the version of both the default parser to be used when `schema` is not given, as well as the schematized parser used when `schema` is specified. This field is immutable after HL7v2 store creation.
    /// </summary>
    [EnumType]
    public readonly struct ParserConfigVersion : IEquatable<ParserConfigVersion>
    {
        private readonly string _value;

        private ParserConfigVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified parser version, equivalent to V1.
        /// </summary>
        public static ParserConfigVersion ParserVersionUnspecified { get; } = new ParserConfigVersion("PARSER_VERSION_UNSPECIFIED");
        /// <summary>
        /// The `parsed_data` includes every given non-empty message field except the Field Separator (MSH-1) field. As a result, the parsed MSH segment starts with the MSH-2 field and the field numbers are off-by-one with respect to the HL7 standard.
        /// </summary>
        public static ParserConfigVersion V1 { get; } = new ParserConfigVersion("V1");
        /// <summary>
        /// The `parsed_data` includes every given non-empty message field.
        /// </summary>
        public static ParserConfigVersion V2 { get; } = new ParserConfigVersion("V2");
        /// <summary>
        /// This version is the same as V2, with the following change. The `parsed_data` contains unescaped escaped field separators, component separators, sub-component separators, repetition separators, escape characters, and truncation characters. If `schema` is specified, the schematized parser uses improved parsing heuristics compared to previous versions.
        /// </summary>
        public static ParserConfigVersion V3 { get; } = new ParserConfigVersion("V3");

        public static bool operator ==(ParserConfigVersion left, ParserConfigVersion right) => left.Equals(right);
        public static bool operator !=(ParserConfigVersion left, ParserConfigVersion right) => !left.Equals(right);

        public static explicit operator string(ParserConfigVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ParserConfigVersion other && Equals(other);
        public bool Equals(ParserConfigVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the output schema type. Schema type is required.
    /// </summary>
    [EnumType]
    public readonly struct SchemaConfigSchemaType : IEquatable<SchemaConfigSchemaType>
    {
        private readonly string _value;

        private SchemaConfigSchemaType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No schema type specified. This type is unsupported.
        /// </summary>
        public static SchemaConfigSchemaType SchemaTypeUnspecified { get; } = new SchemaConfigSchemaType("SCHEMA_TYPE_UNSPECIFIED");
        /// <summary>
        /// A data-driven schema generated from the fields present in the FHIR data being exported, with no additional simplification. This type cannot be used for streaming to BigQuery.
        /// </summary>
        public static SchemaConfigSchemaType Lossless { get; } = new SchemaConfigSchemaType("LOSSLESS");
        /// <summary>
        /// Analytics schema defined by the FHIR community. See https://github.com/FHIR/sql-on-fhir/blob/master/sql-on-fhir.md. BigQuery only allows a maximum of 10,000 columns per table. Due to this limitation, the server will not generate schemas for fields of type `Resource`, which can hold any resource type. The affected fields are `Parameters.parameter.resource`, `Bundle.entry.resource`, and `Bundle.entry.response.outcome`. Analytics schema does not gracefully handle extensions with one or more occurrences, anaytics schema also does not handle contained resource.
        /// </summary>
        public static SchemaConfigSchemaType Analytics { get; } = new SchemaConfigSchemaType("ANALYTICS");
        /// <summary>
        /// Analytics V2, similar to schema defined by the FHIR community, with added support for extensions with one or more occurrences and contained resources in stringified JSON. Analytics V2 uses more space in the destination table than Analytics V1. It is generally recommended to use Analytics V2 over Analytics.
        /// </summary>
        public static SchemaConfigSchemaType AnalyticsV2 { get; } = new SchemaConfigSchemaType("ANALYTICS_V2");

        public static bool operator ==(SchemaConfigSchemaType left, SchemaConfigSchemaType right) => left.Equals(right);
        public static bool operator !=(SchemaConfigSchemaType left, SchemaConfigSchemaType right) => !left.Equals(right);

        public static explicit operator string(SchemaConfigSchemaType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SchemaConfigSchemaType other && Equals(other);
        public bool Equals(SchemaConfigSchemaType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines how messages that fail to parse are handled.
    /// </summary>
    [EnumType]
    public readonly struct SchemaPackageSchematizedParsingType : IEquatable<SchemaPackageSchematizedParsingType>
    {
        private readonly string _value;

        private SchemaPackageSchematizedParsingType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified schematized parsing type, equivalent to `SOFT_FAIL`.
        /// </summary>
        public static SchemaPackageSchematizedParsingType SchematizedParsingTypeUnspecified { get; } = new SchemaPackageSchematizedParsingType("SCHEMATIZED_PARSING_TYPE_UNSPECIFIED");
        /// <summary>
        /// Messages that fail to parse are still stored and ACKed but a parser error is stored in place of the schematized data.
        /// </summary>
        public static SchemaPackageSchematizedParsingType SoftFail { get; } = new SchemaPackageSchematizedParsingType("SOFT_FAIL");
        /// <summary>
        /// Messages that fail to parse are rejected from ingestion/insertion and return an error code.
        /// </summary>
        public static SchemaPackageSchematizedParsingType HardFail { get; } = new SchemaPackageSchematizedParsingType("HARD_FAIL");

        public static bool operator ==(SchemaPackageSchematizedParsingType left, SchemaPackageSchematizedParsingType right) => left.Equals(right);
        public static bool operator !=(SchemaPackageSchematizedParsingType left, SchemaPackageSchematizedParsingType right) => !left.Equals(right);

        public static explicit operator string(SchemaPackageSchematizedParsingType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SchemaPackageSchematizedParsingType other && Equals(other);
        public bool Equals(SchemaPackageSchematizedParsingType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines how unexpected segments (segments not matched to the schema) are handled.
    /// </summary>
    [EnumType]
    public readonly struct SchemaPackageUnexpectedSegmentHandling : IEquatable<SchemaPackageUnexpectedSegmentHandling>
    {
        private readonly string _value;

        private SchemaPackageUnexpectedSegmentHandling(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified handling mode, equivalent to FAIL.
        /// </summary>
        public static SchemaPackageUnexpectedSegmentHandling UnexpectedSegmentHandlingModeUnspecified { get; } = new SchemaPackageUnexpectedSegmentHandling("UNEXPECTED_SEGMENT_HANDLING_MODE_UNSPECIFIED");
        /// <summary>
        /// Unexpected segments fail to parse and return an error.
        /// </summary>
        public static SchemaPackageUnexpectedSegmentHandling Fail { get; } = new SchemaPackageUnexpectedSegmentHandling("FAIL");
        /// <summary>
        /// Unexpected segments do not fail, but are omitted from the output.
        /// </summary>
        public static SchemaPackageUnexpectedSegmentHandling Skip { get; } = new SchemaPackageUnexpectedSegmentHandling("SKIP");
        /// <summary>
        /// Unexpected segments do not fail, but are parsed in place and added to the current group. If a segment has a type definition, it is used, otherwise it is parsed as VARIES.
        /// </summary>
        public static SchemaPackageUnexpectedSegmentHandling Parse { get; } = new SchemaPackageUnexpectedSegmentHandling("PARSE");

        public static bool operator ==(SchemaPackageUnexpectedSegmentHandling left, SchemaPackageUnexpectedSegmentHandling right) => left.Equals(right);
        public static bool operator !=(SchemaPackageUnexpectedSegmentHandling left, SchemaPackageUnexpectedSegmentHandling right) => !left.Equals(right);

        public static explicit operator string(SchemaPackageUnexpectedSegmentHandling value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SchemaPackageUnexpectedSegmentHandling other && Equals(other);
        public bool Equals(SchemaPackageUnexpectedSegmentHandling other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Base profile type for text transformation.
    /// </summary>
    [EnumType]
    public readonly struct TextConfigProfileType : IEquatable<TextConfigProfileType>
    {
        private readonly string _value;

        private TextConfigProfileType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No profile provided. Same as BASIC.
        /// </summary>
        public static TextConfigProfileType ProfileTypeUnspecified { get; } = new TextConfigProfileType("PROFILE_TYPE_UNSPECIFIED");
        /// <summary>
        /// Empty profile which does not perform any transformations.
        /// </summary>
        public static TextConfigProfileType Empty { get; } = new TextConfigProfileType("EMPTY");
        /// <summary>
        /// Automatically converts "DATE" infoTypes using a DateShiftConfig, and all other infoTypes using a ReplaceWithInfoTypeConfig.
        /// </summary>
        public static TextConfigProfileType Basic { get; } = new TextConfigProfileType("BASIC");

        public static bool operator ==(TextConfigProfileType left, TextConfigProfileType right) => left.Equals(right);
        public static bool operator !=(TextConfigProfileType left, TextConfigProfileType right) => !left.Equals(right);

        public static explicit operator string(TextConfigProfileType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TextConfigProfileType other && Equals(other);
        public bool Equals(TextConfigProfileType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of partitioning.
    /// </summary>
    [EnumType]
    public readonly struct TimePartitioningType : IEquatable<TimePartitioningType>
    {
        private readonly string _value;

        private TimePartitioningType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default unknown time.
        /// </summary>
        public static TimePartitioningType PartitionTypeUnspecified { get; } = new TimePartitioningType("PARTITION_TYPE_UNSPECIFIED");
        /// <summary>
        /// Data partitioned by hour.
        /// </summary>
        public static TimePartitioningType Hour { get; } = new TimePartitioningType("HOUR");
        /// <summary>
        /// Data partitioned by day.
        /// </summary>
        public static TimePartitioningType Day { get; } = new TimePartitioningType("DAY");
        /// <summary>
        /// Data partitioned by month.
        /// </summary>
        public static TimePartitioningType Month { get; } = new TimePartitioningType("MONTH");
        /// <summary>
        /// Data partitioned by year.
        /// </summary>
        public static TimePartitioningType Year { get; } = new TimePartitioningType("YEAR");

        public static bool operator ==(TimePartitioningType left, TimePartitioningType right) => left.Equals(right);
        public static bool operator !=(TimePartitioningType left, TimePartitioningType right) => !left.Equals(right);

        public static explicit operator string(TimePartitioningType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TimePartitioningType other && Equals(other);
        public bool Equals(TimePartitioningType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// If this is a primitive type then this field is the type of the primitive For example, STRING. Leave unspecified for composite types.
    /// </summary>
    [EnumType]
    public readonly struct TypePrimitive : IEquatable<TypePrimitive>
    {
        private readonly string _value;

        private TypePrimitive(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not a primitive.
        /// </summary>
        public static TypePrimitive PrimitiveUnspecified { get; } = new TypePrimitive("PRIMITIVE_UNSPECIFIED");
        /// <summary>
        /// String primitive.
        /// </summary>
        public static TypePrimitive String { get; } = new TypePrimitive("STRING");
        /// <summary>
        /// Element that can have unschematized children.
        /// </summary>
        public static TypePrimitive Varies { get; } = new TypePrimitive("VARIES");
        /// <summary>
        /// Like STRING, but all delimiters below this element are ignored.
        /// </summary>
        public static TypePrimitive UnescapedString { get; } = new TypePrimitive("UNESCAPED_STRING");

        public static bool operator ==(TypePrimitive left, TypePrimitive right) => left.Equals(right);
        public static bool operator !=(TypePrimitive left, TypePrimitive right) => !left.Equals(right);

        public static explicit operator string(TypePrimitive value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TypePrimitive other && Equals(other);
        public bool Equals(TypePrimitive other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
