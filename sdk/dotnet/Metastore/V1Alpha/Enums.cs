// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.Metastore.V1Alpha
{
    /// <summary>
    /// The log type that this config enables.
    /// </summary>
    [EnumType]
    public readonly struct AuditLogConfigLogType : IEquatable<AuditLogConfigLogType>
    {
        private readonly string _value;

        private AuditLogConfigLogType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default case. Should never be this.
        /// </summary>
        public static AuditLogConfigLogType LogTypeUnspecified { get; } = new AuditLogConfigLogType("LOG_TYPE_UNSPECIFIED");
        /// <summary>
        /// Admin reads. Example: CloudIAM getIamPolicy
        /// </summary>
        public static AuditLogConfigLogType AdminRead { get; } = new AuditLogConfigLogType("ADMIN_READ");
        /// <summary>
        /// Data writes. Example: CloudSQL Users create
        /// </summary>
        public static AuditLogConfigLogType DataWrite { get; } = new AuditLogConfigLogType("DATA_WRITE");
        /// <summary>
        /// Data reads. Example: CloudSQL Users list
        /// </summary>
        public static AuditLogConfigLogType DataRead { get; } = new AuditLogConfigLogType("DATA_READ");

        public static bool operator ==(AuditLogConfigLogType left, AuditLogConfigLogType right) => left.Equals(right);
        public static bool operator !=(AuditLogConfigLogType left, AuditLogConfigLogType right) => !left.Equals(right);

        public static explicit operator string(AuditLogConfigLogType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AuditLogConfigLogType other && Equals(other);
        public bool Equals(AuditLogConfigLogType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the database.
    /// </summary>
    [EnumType]
    public readonly struct DatabaseDumpDatabaseType : IEquatable<DatabaseDumpDatabaseType>
    {
        private readonly string _value;

        private DatabaseDumpDatabaseType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The type of the source database is unknown.
        /// </summary>
        public static DatabaseDumpDatabaseType DatabaseTypeUnspecified { get; } = new DatabaseDumpDatabaseType("DATABASE_TYPE_UNSPECIFIED");
        /// <summary>
        /// The type of the source database is MySQL.
        /// </summary>
        public static DatabaseDumpDatabaseType Mysql { get; } = new DatabaseDumpDatabaseType("MYSQL");

        public static bool operator ==(DatabaseDumpDatabaseType left, DatabaseDumpDatabaseType right) => left.Equals(right);
        public static bool operator !=(DatabaseDumpDatabaseType left, DatabaseDumpDatabaseType right) => !left.Equals(right);

        public static explicit operator string(DatabaseDumpDatabaseType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseDumpDatabaseType other && Equals(other);
        public bool Equals(DatabaseDumpDatabaseType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. The type of the database dump. If unspecified, defaults to MYSQL.
    /// </summary>
    [EnumType]
    public readonly struct DatabaseDumpType : IEquatable<DatabaseDumpType>
    {
        private readonly string _value;

        private DatabaseDumpType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The type of the database dump is unknown.
        /// </summary>
        public static DatabaseDumpType TypeUnspecified { get; } = new DatabaseDumpType("TYPE_UNSPECIFIED");
        /// <summary>
        /// Database dump is a MySQL dump file.
        /// </summary>
        public static DatabaseDumpType Mysql { get; } = new DatabaseDumpType("MYSQL");
        /// <summary>
        /// Database dump contains Avro files.
        /// </summary>
        public static DatabaseDumpType Avro { get; } = new DatabaseDumpType("AVRO");

        public static bool operator ==(DatabaseDumpType left, DatabaseDumpType right) => left.Equals(right);
        public static bool operator !=(DatabaseDumpType left, DatabaseDumpType right) => !left.Equals(right);

        public static explicit operator string(DatabaseDumpType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DatabaseDumpType other && Equals(other);
        public bool Equals(DatabaseDumpType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The day of week, when the window starts.
    /// </summary>
    [EnumType]
    public readonly struct MaintenanceWindowDayOfWeek : IEquatable<MaintenanceWindowDayOfWeek>
    {
        private readonly string _value;

        private MaintenanceWindowDayOfWeek(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The day of the week is unspecified.
        /// </summary>
        public static MaintenanceWindowDayOfWeek DayOfWeekUnspecified { get; } = new MaintenanceWindowDayOfWeek("DAY_OF_WEEK_UNSPECIFIED");
        /// <summary>
        /// Monday
        /// </summary>
        public static MaintenanceWindowDayOfWeek Monday { get; } = new MaintenanceWindowDayOfWeek("MONDAY");
        /// <summary>
        /// Tuesday
        /// </summary>
        public static MaintenanceWindowDayOfWeek Tuesday { get; } = new MaintenanceWindowDayOfWeek("TUESDAY");
        /// <summary>
        /// Wednesday
        /// </summary>
        public static MaintenanceWindowDayOfWeek Wednesday { get; } = new MaintenanceWindowDayOfWeek("WEDNESDAY");
        /// <summary>
        /// Thursday
        /// </summary>
        public static MaintenanceWindowDayOfWeek Thursday { get; } = new MaintenanceWindowDayOfWeek("THURSDAY");
        /// <summary>
        /// Friday
        /// </summary>
        public static MaintenanceWindowDayOfWeek Friday { get; } = new MaintenanceWindowDayOfWeek("FRIDAY");
        /// <summary>
        /// Saturday
        /// </summary>
        public static MaintenanceWindowDayOfWeek Saturday { get; } = new MaintenanceWindowDayOfWeek("SATURDAY");
        /// <summary>
        /// Sunday
        /// </summary>
        public static MaintenanceWindowDayOfWeek Sunday { get; } = new MaintenanceWindowDayOfWeek("SUNDAY");

        public static bool operator ==(MaintenanceWindowDayOfWeek left, MaintenanceWindowDayOfWeek right) => left.Equals(right);
        public static bool operator !=(MaintenanceWindowDayOfWeek left, MaintenanceWindowDayOfWeek right) => !left.Equals(right);

        public static explicit operator string(MaintenanceWindowDayOfWeek value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MaintenanceWindowDayOfWeek other && Equals(other);
        public bool Equals(MaintenanceWindowDayOfWeek other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Immutable. The release channel of the service. If unspecified, defaults to STABLE.
    /// </summary>
    [EnumType]
    public readonly struct ServiceReleaseChannel : IEquatable<ServiceReleaseChannel>
    {
        private readonly string _value;

        private ServiceReleaseChannel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Release channel is not specified.
        /// </summary>
        public static ServiceReleaseChannel ReleaseChannelUnspecified { get; } = new ServiceReleaseChannel("RELEASE_CHANNEL_UNSPECIFIED");
        /// <summary>
        /// The CANARY release channel contains the newest features, which may be unstable and subject to unresolved issues with no known workarounds. Services using the CANARY release channel are not subject to any SLAs.
        /// </summary>
        public static ServiceReleaseChannel Canary { get; } = new ServiceReleaseChannel("CANARY");
        /// <summary>
        /// The STABLE release channel contains features that are considered stable and have been validated for production use.
        /// </summary>
        public static ServiceReleaseChannel Stable { get; } = new ServiceReleaseChannel("STABLE");

        public static bool operator ==(ServiceReleaseChannel left, ServiceReleaseChannel right) => left.Equals(right);
        public static bool operator !=(ServiceReleaseChannel left, ServiceReleaseChannel right) => !left.Equals(right);

        public static explicit operator string(ServiceReleaseChannel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceReleaseChannel other && Equals(other);
        public bool Equals(ServiceReleaseChannel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The tier of the service.
    /// </summary>
    [EnumType]
    public readonly struct ServiceTier : IEquatable<ServiceTier>
    {
        private readonly string _value;

        private ServiceTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The tier is not set.
        /// </summary>
        public static ServiceTier TierUnspecified { get; } = new ServiceTier("TIER_UNSPECIFIED");
        /// <summary>
        /// The developer tier provides limited scalability and no fault tolerance. Good for low-cost proof-of-concept.
        /// </summary>
        public static ServiceTier Developer { get; } = new ServiceTier("DEVELOPER");
        /// <summary>
        /// The enterprise tier provides multi-zone high availability, and sufficient scalability for enterprise-level Dataproc Metastore workloads.
        /// </summary>
        public static ServiceTier Enterprise { get; } = new ServiceTier("ENTERPRISE");

        public static bool operator ==(ServiceTier left, ServiceTier right) => left.Equals(right);
        public static bool operator !=(ServiceTier left, ServiceTier right) => !left.Equals(right);

        public static explicit operator string(ServiceTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceTier other && Equals(other);
        public bool Equals(ServiceTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
