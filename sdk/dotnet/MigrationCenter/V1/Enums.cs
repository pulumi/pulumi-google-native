// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.MigrationCenter.V1
{
    /// <summary>
    /// License type to consider when calculating costs for virtual machine insights and recommendations. If unspecified, costs are calculated based on the default licensing plan.
    /// </summary>
    [EnumType]
    public readonly struct ComputeEnginePreferencesLicenseType : IEquatable<ComputeEnginePreferencesLicenseType>
    {
        private readonly string _value;

        private ComputeEnginePreferencesLicenseType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified (default value).
        /// </summary>
        public static ComputeEnginePreferencesLicenseType LicenseTypeUnspecified { get; } = new ComputeEnginePreferencesLicenseType("LICENSE_TYPE_UNSPECIFIED");
        /// <summary>
        /// Default Google Cloud licensing plan. Licensing is charged per usage. This a good value to start with.
        /// </summary>
        public static ComputeEnginePreferencesLicenseType LicenseTypeDefault { get; } = new ComputeEnginePreferencesLicenseType("LICENSE_TYPE_DEFAULT");
        /// <summary>
        /// Bring-your-own-license (BYOL) plan. User provides the OS license.
        /// </summary>
        public static ComputeEnginePreferencesLicenseType LicenseTypeBringYourOwnLicense { get; } = new ComputeEnginePreferencesLicenseType("LICENSE_TYPE_BRING_YOUR_OWN_LICENSE");

        public static bool operator ==(ComputeEnginePreferencesLicenseType left, ComputeEnginePreferencesLicenseType right) => left.Equals(right);
        public static bool operator !=(ComputeEnginePreferencesLicenseType left, ComputeEnginePreferencesLicenseType right) => !left.Equals(right);

        public static explicit operator string(ComputeEnginePreferencesLicenseType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComputeEnginePreferencesLicenseType other && Equals(other);
        public bool Equals(ComputeEnginePreferencesLicenseType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Persistent disk type to use. If unspecified (default), all types are considered, based on available usage data.
    /// </summary>
    [EnumType]
    public readonly struct ComputeEnginePreferencesPersistentDiskType : IEquatable<ComputeEnginePreferencesPersistentDiskType>
    {
        private readonly string _value;

        private ComputeEnginePreferencesPersistentDiskType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified (default value). Selecting this value allows the system to use any disk type according to reported usage. This a good value to start with.
        /// </summary>
        public static ComputeEnginePreferencesPersistentDiskType PersistentDiskTypeUnspecified { get; } = new ComputeEnginePreferencesPersistentDiskType("PERSISTENT_DISK_TYPE_UNSPECIFIED");
        /// <summary>
        /// Standard HDD Persistent Disk.
        /// </summary>
        public static ComputeEnginePreferencesPersistentDiskType PersistentDiskTypeStandard { get; } = new ComputeEnginePreferencesPersistentDiskType("PERSISTENT_DISK_TYPE_STANDARD");
        /// <summary>
        /// Balanced Persistent Disk.
        /// </summary>
        public static ComputeEnginePreferencesPersistentDiskType PersistentDiskTypeBalanced { get; } = new ComputeEnginePreferencesPersistentDiskType("PERSISTENT_DISK_TYPE_BALANCED");
        /// <summary>
        /// SSD Persistent Disk.
        /// </summary>
        public static ComputeEnginePreferencesPersistentDiskType PersistentDiskTypeSsd { get; } = new ComputeEnginePreferencesPersistentDiskType("PERSISTENT_DISK_TYPE_SSD");

        public static bool operator ==(ComputeEnginePreferencesPersistentDiskType left, ComputeEnginePreferencesPersistentDiskType right) => left.Equals(right);
        public static bool operator !=(ComputeEnginePreferencesPersistentDiskType left, ComputeEnginePreferencesPersistentDiskType right) => !left.Equals(right);

        public static explicit operator string(ComputeEnginePreferencesPersistentDiskType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComputeEnginePreferencesPersistentDiskType other && Equals(other);
        public bool Equals(ComputeEnginePreferencesPersistentDiskType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The payload format.
    /// </summary>
    [EnumType]
    public readonly struct ImportDataFileFormat : IEquatable<ImportDataFileFormat>
    {
        private readonly string _value;

        private ImportDataFileFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value.
        /// </summary>
        public static ImportDataFileFormat ImportJobFormatUnspecified { get; } = new ImportDataFileFormat("IMPORT_JOB_FORMAT_UNSPECIFIED");
        /// <summary>
        /// RVTools format (XLSX).
        /// </summary>
        public static ImportDataFileFormat ImportJobFormatRvtoolsXlsx { get; } = new ImportDataFileFormat("IMPORT_JOB_FORMAT_RVTOOLS_XLSX");
        /// <summary>
        /// RVTools format (CSV).
        /// </summary>
        public static ImportDataFileFormat ImportJobFormatRvtoolsCsv { get; } = new ImportDataFileFormat("IMPORT_JOB_FORMAT_RVTOOLS_CSV");
        /// <summary>
        /// CSV format exported from AWS using the AWS collection script.
        /// </summary>
        public static ImportDataFileFormat ImportJobFormatExportedAwsCsv { get; } = new ImportDataFileFormat("IMPORT_JOB_FORMAT_EXPORTED_AWS_CSV");
        /// <summary>
        /// CSV format exported from Azure using the Azure collection script.
        /// </summary>
        public static ImportDataFileFormat ImportJobFormatExportedAzureCsv { get; } = new ImportDataFileFormat("IMPORT_JOB_FORMAT_EXPORTED_AZURE_CSV");
        /// <summary>
        /// CSV format created manually and following the StratoZone format. For more information, see Manually create and upload data tables.
        /// </summary>
        public static ImportDataFileFormat ImportJobFormatStratozoneCsv { get; } = new ImportDataFileFormat("IMPORT_JOB_FORMAT_STRATOZONE_CSV");

        public static bool operator ==(ImportDataFileFormat left, ImportDataFileFormat right) => left.Equals(right);
        public static bool operator !=(ImportDataFileFormat left, ImportDataFileFormat right) => !left.Equals(right);

        public static explicit operator string(ImportDataFileFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ImportDataFileFormat other && Equals(other);
        public bool Equals(ImportDataFileFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Report creation state.
    /// </summary>
    [EnumType]
    public readonly struct ReportState : IEquatable<ReportState>
    {
        private readonly string _value;

        private ReportState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default Report creation state.
        /// </summary>
        public static ReportState StateUnspecified { get; } = new ReportState("STATE_UNSPECIFIED");
        /// <summary>
        /// Creating Report.
        /// </summary>
        public static ReportState Pending { get; } = new ReportState("PENDING");
        /// <summary>
        /// Successfully created Report.
        /// </summary>
        public static ReportState Succeeded { get; } = new ReportState("SUCCEEDED");
        /// <summary>
        /// Failed to create Report.
        /// </summary>
        public static ReportState Failed { get; } = new ReportState("FAILED");

        public static bool operator ==(ReportState left, ReportState right) => left.Equals(right);
        public static bool operator !=(ReportState left, ReportState right) => !left.Equals(right);

        public static explicit operator string(ReportState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReportState other && Equals(other);
        public bool Equals(ReportState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Report type.
    /// </summary>
    [EnumType]
    public readonly struct ReportType : IEquatable<ReportType>
    {
        private readonly string _value;

        private ReportType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default Report type.
        /// </summary>
        public static ReportType TypeUnspecified { get; } = new ReportType("TYPE_UNSPECIFIED");
        /// <summary>
        /// Total cost of ownership Report type.
        /// </summary>
        public static ReportType TotalCostOfOwnership { get; } = new ReportType("TOTAL_COST_OF_OWNERSHIP");

        public static bool operator ==(ReportType left, ReportType right) => left.Equals(right);
        public static bool operator !=(ReportType left, ReportType right) => !left.Equals(right);

        public static explicit operator string(ReportType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ReportType other && Equals(other);
        public bool Equals(ReportType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Commitment plan to consider when calculating costs for virtual machine insights and recommendations. If you are unsure which value to set, a 3 year commitment plan is often a good value to start with.
    /// </summary>
    [EnumType]
    public readonly struct SoleTenancyPreferencesCommitmentPlan : IEquatable<SoleTenancyPreferencesCommitmentPlan>
    {
        private readonly string _value;

        private SoleTenancyPreferencesCommitmentPlan(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified commitment plan.
        /// </summary>
        public static SoleTenancyPreferencesCommitmentPlan CommitmentPlanUnspecified { get; } = new SoleTenancyPreferencesCommitmentPlan("COMMITMENT_PLAN_UNSPECIFIED");
        /// <summary>
        /// No commitment plan (on-demand usage).
        /// </summary>
        public static SoleTenancyPreferencesCommitmentPlan OnDemand { get; } = new SoleTenancyPreferencesCommitmentPlan("ON_DEMAND");
        /// <summary>
        /// 1 year commitment.
        /// </summary>
        public static SoleTenancyPreferencesCommitmentPlan Commitment1Year { get; } = new SoleTenancyPreferencesCommitmentPlan("COMMITMENT_1_YEAR");
        /// <summary>
        /// 3 years commitment.
        /// </summary>
        public static SoleTenancyPreferencesCommitmentPlan Commitment3Year { get; } = new SoleTenancyPreferencesCommitmentPlan("COMMITMENT_3_YEAR");

        public static bool operator ==(SoleTenancyPreferencesCommitmentPlan left, SoleTenancyPreferencesCommitmentPlan right) => left.Equals(right);
        public static bool operator !=(SoleTenancyPreferencesCommitmentPlan left, SoleTenancyPreferencesCommitmentPlan right) => !left.Equals(right);

        public static explicit operator string(SoleTenancyPreferencesCommitmentPlan value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SoleTenancyPreferencesCommitmentPlan other && Equals(other);
        public bool Equals(SoleTenancyPreferencesCommitmentPlan other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Sole Tenancy nodes maintenance policy.
    /// </summary>
    [EnumType]
    public readonly struct SoleTenancyPreferencesHostMaintenancePolicy : IEquatable<SoleTenancyPreferencesHostMaintenancePolicy>
    {
        private readonly string _value;

        private SoleTenancyPreferencesHostMaintenancePolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified host maintenance policy.
        /// </summary>
        public static SoleTenancyPreferencesHostMaintenancePolicy HostMaintenancePolicyUnspecified { get; } = new SoleTenancyPreferencesHostMaintenancePolicy("HOST_MAINTENANCE_POLICY_UNSPECIFIED");
        /// <summary>
        /// Default host maintenance policy.
        /// </summary>
        public static SoleTenancyPreferencesHostMaintenancePolicy HostMaintenancePolicyDefault { get; } = new SoleTenancyPreferencesHostMaintenancePolicy("HOST_MAINTENANCE_POLICY_DEFAULT");
        /// <summary>
        /// Restart in place host maintenance policy.
        /// </summary>
        public static SoleTenancyPreferencesHostMaintenancePolicy HostMaintenancePolicyRestartInPlace { get; } = new SoleTenancyPreferencesHostMaintenancePolicy("HOST_MAINTENANCE_POLICY_RESTART_IN_PLACE");
        /// <summary>
        /// Migrate within node group host maintenance policy.
        /// </summary>
        public static SoleTenancyPreferencesHostMaintenancePolicy HostMaintenancePolicyMigrateWithinNodeGroup { get; } = new SoleTenancyPreferencesHostMaintenancePolicy("HOST_MAINTENANCE_POLICY_MIGRATE_WITHIN_NODE_GROUP");

        public static bool operator ==(SoleTenancyPreferencesHostMaintenancePolicy left, SoleTenancyPreferencesHostMaintenancePolicy right) => left.Equals(right);
        public static bool operator !=(SoleTenancyPreferencesHostMaintenancePolicy left, SoleTenancyPreferencesHostMaintenancePolicy right) => !left.Equals(right);

        public static explicit operator string(SoleTenancyPreferencesHostMaintenancePolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SoleTenancyPreferencesHostMaintenancePolicy other && Equals(other);
        public bool Equals(SoleTenancyPreferencesHostMaintenancePolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Data source type.
    /// </summary>
    [EnumType]
    public readonly struct SourceType : IEquatable<SourceType>
    {
        private readonly string _value;

        private SourceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified
        /// </summary>
        public static SourceType SourceTypeUnknown { get; } = new SourceType("SOURCE_TYPE_UNKNOWN");
        /// <summary>
        /// Manually uploaded file (e.g. CSV)
        /// </summary>
        public static SourceType SourceTypeUpload { get; } = new SourceType("SOURCE_TYPE_UPLOAD");
        /// <summary>
        /// Guest-level info
        /// </summary>
        public static SourceType SourceTypeGuestOsScan { get; } = new SourceType("SOURCE_TYPE_GUEST_OS_SCAN");
        /// <summary>
        /// Inventory-level scan
        /// </summary>
        public static SourceType SourceTypeInventoryScan { get; } = new SourceType("SOURCE_TYPE_INVENTORY_SCAN");
        /// <summary>
        /// Third-party owned sources.
        /// </summary>
        public static SourceType SourceTypeCustom { get; } = new SourceType("SOURCE_TYPE_CUSTOM");
        /// <summary>
        /// Discovery clients
        /// </summary>
        public static SourceType SourceTypeDiscoveryClient { get; } = new SourceType("SOURCE_TYPE_DISCOVERY_CLIENT");

        public static bool operator ==(SourceType left, SourceType right) => left.Equals(right);
        public static bool operator !=(SourceType left, SourceType right) => !left.Equals(right);

        public static explicit operator string(SourceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SourceType other && Equals(other);
        public bool Equals(SourceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Commitment plan to consider when calculating costs for virtual machine insights and recommendations. If you are unsure which value to set, a 3 year commitment plan is often a good value to start with.
    /// </summary>
    [EnumType]
    public readonly struct VirtualMachinePreferencesCommitmentPlan : IEquatable<VirtualMachinePreferencesCommitmentPlan>
    {
        private readonly string _value;

        private VirtualMachinePreferencesCommitmentPlan(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified commitment plan.
        /// </summary>
        public static VirtualMachinePreferencesCommitmentPlan CommitmentPlanUnspecified { get; } = new VirtualMachinePreferencesCommitmentPlan("COMMITMENT_PLAN_UNSPECIFIED");
        /// <summary>
        /// No commitment plan.
        /// </summary>
        public static VirtualMachinePreferencesCommitmentPlan CommitmentPlanNone { get; } = new VirtualMachinePreferencesCommitmentPlan("COMMITMENT_PLAN_NONE");
        /// <summary>
        /// 1 year commitment.
        /// </summary>
        public static VirtualMachinePreferencesCommitmentPlan CommitmentPlanOneYear { get; } = new VirtualMachinePreferencesCommitmentPlan("COMMITMENT_PLAN_ONE_YEAR");
        /// <summary>
        /// 3 years commitment.
        /// </summary>
        public static VirtualMachinePreferencesCommitmentPlan CommitmentPlanThreeYears { get; } = new VirtualMachinePreferencesCommitmentPlan("COMMITMENT_PLAN_THREE_YEARS");

        public static bool operator ==(VirtualMachinePreferencesCommitmentPlan left, VirtualMachinePreferencesCommitmentPlan right) => left.Equals(right);
        public static bool operator !=(VirtualMachinePreferencesCommitmentPlan left, VirtualMachinePreferencesCommitmentPlan right) => !left.Equals(right);

        public static explicit operator string(VirtualMachinePreferencesCommitmentPlan value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachinePreferencesCommitmentPlan other && Equals(other);
        public bool Equals(VirtualMachinePreferencesCommitmentPlan other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Sizing optimization strategy specifies the preferred strategy used when extrapolating usage data to calculate insights and recommendations for a virtual machine. If you are unsure which value to set, a moderate sizing optimization strategy is often a good value to start with.
    /// </summary>
    [EnumType]
    public readonly struct VirtualMachinePreferencesSizingOptimizationStrategy : IEquatable<VirtualMachinePreferencesSizingOptimizationStrategy>
    {
        private readonly string _value;

        private VirtualMachinePreferencesSizingOptimizationStrategy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified (default value).
        /// </summary>
        public static VirtualMachinePreferencesSizingOptimizationStrategy SizingOptimizationStrategyUnspecified { get; } = new VirtualMachinePreferencesSizingOptimizationStrategy("SIZING_OPTIMIZATION_STRATEGY_UNSPECIFIED");
        /// <summary>
        /// No optimization applied. Virtual machine sizing matches as closely as possible the machine shape on the source site, not considering any actual performance data.
        /// </summary>
        public static VirtualMachinePreferencesSizingOptimizationStrategy SizingOptimizationStrategySameAsSource { get; } = new VirtualMachinePreferencesSizingOptimizationStrategy("SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE");
        /// <summary>
        /// Virtual machine sizing will match the reported usage and shape, with some slack. This a good value to start with.
        /// </summary>
        public static VirtualMachinePreferencesSizingOptimizationStrategy SizingOptimizationStrategyModerate { get; } = new VirtualMachinePreferencesSizingOptimizationStrategy("SIZING_OPTIMIZATION_STRATEGY_MODERATE");
        /// <summary>
        /// Virtual machine sizing will match the reported usage, with little slack. Using this option can help reduce costs.
        /// </summary>
        public static VirtualMachinePreferencesSizingOptimizationStrategy SizingOptimizationStrategyAggressive { get; } = new VirtualMachinePreferencesSizingOptimizationStrategy("SIZING_OPTIMIZATION_STRATEGY_AGGRESSIVE");

        public static bool operator ==(VirtualMachinePreferencesSizingOptimizationStrategy left, VirtualMachinePreferencesSizingOptimizationStrategy right) => left.Equals(right);
        public static bool operator !=(VirtualMachinePreferencesSizingOptimizationStrategy left, VirtualMachinePreferencesSizingOptimizationStrategy right) => !left.Equals(right);

        public static explicit operator string(VirtualMachinePreferencesSizingOptimizationStrategy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachinePreferencesSizingOptimizationStrategy other && Equals(other);
        public bool Equals(VirtualMachinePreferencesSizingOptimizationStrategy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Target product for assets using this preference set. Specify either target product or business goal, but not both.
    /// </summary>
    [EnumType]
    public readonly struct VirtualMachinePreferencesTargetProduct : IEquatable<VirtualMachinePreferencesTargetProduct>
    {
        private readonly string _value;

        private VirtualMachinePreferencesTargetProduct(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified (default value).
        /// </summary>
        public static VirtualMachinePreferencesTargetProduct ComputeMigrationTargetProductUnspecified { get; } = new VirtualMachinePreferencesTargetProduct("COMPUTE_MIGRATION_TARGET_PRODUCT_UNSPECIFIED");
        /// <summary>
        /// Prefer to migrate to Google Cloud Compute Engine.
        /// </summary>
        public static VirtualMachinePreferencesTargetProduct ComputeMigrationTargetProductComputeEngine { get; } = new VirtualMachinePreferencesTargetProduct("COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE");
        /// <summary>
        /// Prefer to migrate to Google Cloud VMware Engine.
        /// </summary>
        public static VirtualMachinePreferencesTargetProduct ComputeMigrationTargetProductVmwareEngine { get; } = new VirtualMachinePreferencesTargetProduct("COMPUTE_MIGRATION_TARGET_PRODUCT_VMWARE_ENGINE");
        /// <summary>
        /// Prefer to migrate to Google Cloud Sole Tenant Nodes.
        /// </summary>
        public static VirtualMachinePreferencesTargetProduct ComputeMigrationTargetProductSoleTenancy { get; } = new VirtualMachinePreferencesTargetProduct("COMPUTE_MIGRATION_TARGET_PRODUCT_SOLE_TENANCY");

        public static bool operator ==(VirtualMachinePreferencesTargetProduct left, VirtualMachinePreferencesTargetProduct right) => left.Equals(right);
        public static bool operator !=(VirtualMachinePreferencesTargetProduct left, VirtualMachinePreferencesTargetProduct right) => !left.Equals(right);

        public static explicit operator string(VirtualMachinePreferencesTargetProduct value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VirtualMachinePreferencesTargetProduct other && Equals(other);
        public bool Equals(VirtualMachinePreferencesTargetProduct other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Commitment plan to consider when calculating costs for virtual machine insights and recommendations. If you are unsure which value to set, a 3 year commitment plan is often a good value to start with.
    /// </summary>
    [EnumType]
    public readonly struct VmwareEnginePreferencesCommitmentPlan : IEquatable<VmwareEnginePreferencesCommitmentPlan>
    {
        private readonly string _value;

        private VmwareEnginePreferencesCommitmentPlan(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified commitment plan.
        /// </summary>
        public static VmwareEnginePreferencesCommitmentPlan CommitmentPlanUnspecified { get; } = new VmwareEnginePreferencesCommitmentPlan("COMMITMENT_PLAN_UNSPECIFIED");
        /// <summary>
        /// No commitment plan (on-demand usage).
        /// </summary>
        public static VmwareEnginePreferencesCommitmentPlan OnDemand { get; } = new VmwareEnginePreferencesCommitmentPlan("ON_DEMAND");
        /// <summary>
        /// 1 year commitment (monthly payments).
        /// </summary>
        public static VmwareEnginePreferencesCommitmentPlan Commitment1YearMonthlyPayments { get; } = new VmwareEnginePreferencesCommitmentPlan("COMMITMENT_1_YEAR_MONTHLY_PAYMENTS");
        /// <summary>
        /// 3 year commitment (monthly payments).
        /// </summary>
        public static VmwareEnginePreferencesCommitmentPlan Commitment3YearMonthlyPayments { get; } = new VmwareEnginePreferencesCommitmentPlan("COMMITMENT_3_YEAR_MONTHLY_PAYMENTS");
        /// <summary>
        /// 1 year commitment (upfront payment).
        /// </summary>
        public static VmwareEnginePreferencesCommitmentPlan Commitment1YearUpfrontPayment { get; } = new VmwareEnginePreferencesCommitmentPlan("COMMITMENT_1_YEAR_UPFRONT_PAYMENT");
        /// <summary>
        /// 3 years commitment (upfront payment).
        /// </summary>
        public static VmwareEnginePreferencesCommitmentPlan Commitment3YearUpfrontPayment { get; } = new VmwareEnginePreferencesCommitmentPlan("COMMITMENT_3_YEAR_UPFRONT_PAYMENT");

        public static bool operator ==(VmwareEnginePreferencesCommitmentPlan left, VmwareEnginePreferencesCommitmentPlan right) => left.Equals(right);
        public static bool operator !=(VmwareEnginePreferencesCommitmentPlan left, VmwareEnginePreferencesCommitmentPlan right) => !left.Equals(right);

        public static explicit operator string(VmwareEnginePreferencesCommitmentPlan value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VmwareEnginePreferencesCommitmentPlan other && Equals(other);
        public bool Equals(VmwareEnginePreferencesCommitmentPlan other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
