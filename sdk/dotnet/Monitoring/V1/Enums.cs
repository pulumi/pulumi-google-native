// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.Monitoring.V1
{
    /// <summary>
    /// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
    /// </summary>
    [EnumType]
    public readonly struct AggregationCrossSeriesReducer : IEquatable<AggregationCrossSeriesReducer>
    {
        private readonly string _value;

        private AggregationCrossSeriesReducer(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No cross-time series reduction. The output of the Aligner is returned.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceNone { get; } = new AggregationCrossSeriesReducer("REDUCE_NONE");
        /// <summary>
        /// Reduce by computing the mean value across time series for each alignment period. This reducer is valid for DELTA and GAUGE metrics with numeric or distribution values. The value_type of the output is DOUBLE.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceMean { get; } = new AggregationCrossSeriesReducer("REDUCE_MEAN");
        /// <summary>
        /// Reduce by computing the minimum value across time series for each alignment period. This reducer is valid for DELTA and GAUGE metrics with numeric values. The value_type of the output is the same as the value_type of the input.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceMin { get; } = new AggregationCrossSeriesReducer("REDUCE_MIN");
        /// <summary>
        /// Reduce by computing the maximum value across time series for each alignment period. This reducer is valid for DELTA and GAUGE metrics with numeric values. The value_type of the output is the same as the value_type of the input.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceMax { get; } = new AggregationCrossSeriesReducer("REDUCE_MAX");
        /// <summary>
        /// Reduce by computing the sum across time series for each alignment period. This reducer is valid for DELTA and GAUGE metrics with numeric and distribution values. The value_type of the output is the same as the value_type of the input.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceSum { get; } = new AggregationCrossSeriesReducer("REDUCE_SUM");
        /// <summary>
        /// Reduce by computing the standard deviation across time series for each alignment period. This reducer is valid for DELTA and GAUGE metrics with numeric or distribution values. The value_type of the output is DOUBLE.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceStddev { get; } = new AggregationCrossSeriesReducer("REDUCE_STDDEV");
        /// <summary>
        /// Reduce by computing the number of data points across time series for each alignment period. This reducer is valid for DELTA and GAUGE metrics of numeric, Boolean, distribution, and string value_type. The value_type of the output is INT64.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceCount { get; } = new AggregationCrossSeriesReducer("REDUCE_COUNT");
        /// <summary>
        /// Reduce by computing the number of True-valued data points across time series for each alignment period. This reducer is valid for DELTA and GAUGE metrics of Boolean value_type. The value_type of the output is INT64.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceCountTrue { get; } = new AggregationCrossSeriesReducer("REDUCE_COUNT_TRUE");
        /// <summary>
        /// Reduce by computing the number of False-valued data points across time series for each alignment period. This reducer is valid for DELTA and GAUGE metrics of Boolean value_type. The value_type of the output is INT64.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceCountFalse { get; } = new AggregationCrossSeriesReducer("REDUCE_COUNT_FALSE");
        /// <summary>
        /// Reduce by computing the ratio of the number of True-valued data points to the total number of data points for each alignment period. This reducer is valid for DELTA and GAUGE metrics of Boolean value_type. The output value is in the range 0.0, 1.0 and has value_type DOUBLE.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceFractionTrue { get; } = new AggregationCrossSeriesReducer("REDUCE_FRACTION_TRUE");
        /// <summary>
        /// Reduce by computing the 99th percentile (https://en.wikipedia.org/wiki/Percentile) of data points across time series for each alignment period. This reducer is valid for GAUGE and DELTA metrics of numeric and distribution type. The value of the output is DOUBLE.
        /// </summary>
        public static AggregationCrossSeriesReducer ReducePercentile99 { get; } = new AggregationCrossSeriesReducer("REDUCE_PERCENTILE_99");
        /// <summary>
        /// Reduce by computing the 95th percentile (https://en.wikipedia.org/wiki/Percentile) of data points across time series for each alignment period. This reducer is valid for GAUGE and DELTA metrics of numeric and distribution type. The value of the output is DOUBLE.
        /// </summary>
        public static AggregationCrossSeriesReducer ReducePercentile95 { get; } = new AggregationCrossSeriesReducer("REDUCE_PERCENTILE_95");
        /// <summary>
        /// Reduce by computing the 50th percentile (https://en.wikipedia.org/wiki/Percentile) of data points across time series for each alignment period. This reducer is valid for GAUGE and DELTA metrics of numeric and distribution type. The value of the output is DOUBLE.
        /// </summary>
        public static AggregationCrossSeriesReducer ReducePercentile50 { get; } = new AggregationCrossSeriesReducer("REDUCE_PERCENTILE_50");
        /// <summary>
        /// Reduce by computing the 5th percentile (https://en.wikipedia.org/wiki/Percentile) of data points across time series for each alignment period. This reducer is valid for GAUGE and DELTA metrics of numeric and distribution type. The value of the output is DOUBLE.
        /// </summary>
        public static AggregationCrossSeriesReducer ReducePercentile05 { get; } = new AggregationCrossSeriesReducer("REDUCE_PERCENTILE_05");

        public static bool operator ==(AggregationCrossSeriesReducer left, AggregationCrossSeriesReducer right) => left.Equals(right);
        public static bool operator !=(AggregationCrossSeriesReducer left, AggregationCrossSeriesReducer right) => !left.Equals(right);

        public static explicit operator string(AggregationCrossSeriesReducer value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AggregationCrossSeriesReducer other && Equals(other);
        public bool Equals(AggregationCrossSeriesReducer other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
    /// </summary>
    [EnumType]
    public readonly struct AggregationPerSeriesAligner : IEquatable<AggregationPerSeriesAligner>
    {
        private readonly string _value;

        private AggregationPerSeriesAligner(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No alignment. Raw data is returned. Not valid if cross-series reduction is requested. The value_type of the result is the same as the value_type of the input.
        /// </summary>
        public static AggregationPerSeriesAligner AlignNone { get; } = new AggregationPerSeriesAligner("ALIGN_NONE");
        /// <summary>
        /// Align and convert to DELTA. The output is delta = y1 - y0.This alignment is valid for CUMULATIVE and DELTA metrics. If the selected alignment period results in periods with no data, then the aligned value for such a period is created by interpolation. The value_type of the aligned result is the same as the value_type of the input.
        /// </summary>
        public static AggregationPerSeriesAligner AlignDelta { get; } = new AggregationPerSeriesAligner("ALIGN_DELTA");
        /// <summary>
        /// Align and convert to a rate. The result is computed as rate = (y1 - y0)/(t1 - t0), or "delta over time". Think of this aligner as providing the slope of the line that passes through the value at the start and at the end of the alignment_period.This aligner is valid for CUMULATIVE and DELTA metrics with numeric values. If the selected alignment period results in periods with no data, then the aligned value for such a period is created by interpolation. The output is a GAUGE metric with value_type DOUBLE.If, by "rate", you mean "percentage change", see the ALIGN_PERCENT_CHANGE aligner instead.
        /// </summary>
        public static AggregationPerSeriesAligner AlignRate { get; } = new AggregationPerSeriesAligner("ALIGN_RATE");
        /// <summary>
        /// Align by interpolating between adjacent points around the alignment period boundary. This aligner is valid for GAUGE metrics with numeric values. The value_type of the aligned result is the same as the value_type of the input.
        /// </summary>
        public static AggregationPerSeriesAligner AlignInterpolate { get; } = new AggregationPerSeriesAligner("ALIGN_INTERPOLATE");
        /// <summary>
        /// Align by moving the most recent data point before the end of the alignment period to the boundary at the end of the alignment period. This aligner is valid for GAUGE metrics. The value_type of the aligned result is the same as the value_type of the input.
        /// </summary>
        public static AggregationPerSeriesAligner AlignNextOlder { get; } = new AggregationPerSeriesAligner("ALIGN_NEXT_OLDER");
        /// <summary>
        /// Align the time series by returning the minimum value in each alignment period. This aligner is valid for GAUGE and DELTA metrics with numeric values. The value_type of the aligned result is the same as the value_type of the input.
        /// </summary>
        public static AggregationPerSeriesAligner AlignMin { get; } = new AggregationPerSeriesAligner("ALIGN_MIN");
        /// <summary>
        /// Align the time series by returning the maximum value in each alignment period. This aligner is valid for GAUGE and DELTA metrics with numeric values. The value_type of the aligned result is the same as the value_type of the input.
        /// </summary>
        public static AggregationPerSeriesAligner AlignMax { get; } = new AggregationPerSeriesAligner("ALIGN_MAX");
        /// <summary>
        /// Align the time series by returning the mean value in each alignment period. This aligner is valid for GAUGE and DELTA metrics with numeric values. The value_type of the aligned result is DOUBLE.
        /// </summary>
        public static AggregationPerSeriesAligner AlignMean { get; } = new AggregationPerSeriesAligner("ALIGN_MEAN");
        /// <summary>
        /// Align the time series by returning the number of values in each alignment period. This aligner is valid for GAUGE and DELTA metrics with numeric or Boolean values. The value_type of the aligned result is INT64.
        /// </summary>
        public static AggregationPerSeriesAligner AlignCount { get; } = new AggregationPerSeriesAligner("ALIGN_COUNT");
        /// <summary>
        /// Align the time series by returning the sum of the values in each alignment period. This aligner is valid for GAUGE and DELTA metrics with numeric and distribution values. The value_type of the aligned result is the same as the value_type of the input.
        /// </summary>
        public static AggregationPerSeriesAligner AlignSum { get; } = new AggregationPerSeriesAligner("ALIGN_SUM");
        /// <summary>
        /// Align the time series by returning the standard deviation of the values in each alignment period. This aligner is valid for GAUGE and DELTA metrics with numeric values. The value_type of the output is DOUBLE.
        /// </summary>
        public static AggregationPerSeriesAligner AlignStddev { get; } = new AggregationPerSeriesAligner("ALIGN_STDDEV");
        /// <summary>
        /// Align the time series by returning the number of True values in each alignment period. This aligner is valid for GAUGE metrics with Boolean values. The value_type of the output is INT64.
        /// </summary>
        public static AggregationPerSeriesAligner AlignCountTrue { get; } = new AggregationPerSeriesAligner("ALIGN_COUNT_TRUE");
        /// <summary>
        /// Align the time series by returning the number of False values in each alignment period. This aligner is valid for GAUGE metrics with Boolean values. The value_type of the output is INT64.
        /// </summary>
        public static AggregationPerSeriesAligner AlignCountFalse { get; } = new AggregationPerSeriesAligner("ALIGN_COUNT_FALSE");
        /// <summary>
        /// Align the time series by returning the ratio of the number of True values to the total number of values in each alignment period. This aligner is valid for GAUGE metrics with Boolean values. The output value is in the range 0.0, 1.0 and has value_type DOUBLE.
        /// </summary>
        public static AggregationPerSeriesAligner AlignFractionTrue { get; } = new AggregationPerSeriesAligner("ALIGN_FRACTION_TRUE");
        /// <summary>
        /// Align the time series by using percentile aggregation (https://en.wikipedia.org/wiki/Percentile). The resulting data point in each alignment period is the 99th percentile of all data points in the period. This aligner is valid for GAUGE and DELTA metrics with distribution values. The output is a GAUGE metric with value_type DOUBLE.
        /// </summary>
        public static AggregationPerSeriesAligner AlignPercentile99 { get; } = new AggregationPerSeriesAligner("ALIGN_PERCENTILE_99");
        /// <summary>
        /// Align the time series by using percentile aggregation (https://en.wikipedia.org/wiki/Percentile). The resulting data point in each alignment period is the 95th percentile of all data points in the period. This aligner is valid for GAUGE and DELTA metrics with distribution values. The output is a GAUGE metric with value_type DOUBLE.
        /// </summary>
        public static AggregationPerSeriesAligner AlignPercentile95 { get; } = new AggregationPerSeriesAligner("ALIGN_PERCENTILE_95");
        /// <summary>
        /// Align the time series by using percentile aggregation (https://en.wikipedia.org/wiki/Percentile). The resulting data point in each alignment period is the 50th percentile of all data points in the period. This aligner is valid for GAUGE and DELTA metrics with distribution values. The output is a GAUGE metric with value_type DOUBLE.
        /// </summary>
        public static AggregationPerSeriesAligner AlignPercentile50 { get; } = new AggregationPerSeriesAligner("ALIGN_PERCENTILE_50");
        /// <summary>
        /// Align the time series by using percentile aggregation (https://en.wikipedia.org/wiki/Percentile). The resulting data point in each alignment period is the 5th percentile of all data points in the period. This aligner is valid for GAUGE and DELTA metrics with distribution values. The output is a GAUGE metric with value_type DOUBLE.
        /// </summary>
        public static AggregationPerSeriesAligner AlignPercentile05 { get; } = new AggregationPerSeriesAligner("ALIGN_PERCENTILE_05");
        /// <summary>
        /// Align and convert to a percentage change. This aligner is valid for GAUGE and DELTA metrics with numeric values. This alignment returns ((current - previous)/previous) * 100, where the value of previous is determined based on the alignment_period.If the values of current and previous are both 0, then the returned value is 0. If only previous is 0, the returned value is infinity.A 10-minute moving mean is computed at each point of the alignment period prior to the above calculation to smooth the metric and prevent false positives from very short-lived spikes. The moving mean is only applicable for data whose values are &gt;= 0. Any values &lt; 0 are treated as a missing datapoint, and are ignored. While DELTA metrics are accepted by this alignment, special care should be taken that the values for the metric will always be positive. The output is a GAUGE metric with value_type DOUBLE.
        /// </summary>
        public static AggregationPerSeriesAligner AlignPercentChange { get; } = new AggregationPerSeriesAligner("ALIGN_PERCENT_CHANGE");

        public static bool operator ==(AggregationPerSeriesAligner left, AggregationPerSeriesAligner right) => left.Equals(right);
        public static bool operator !=(AggregationPerSeriesAligner left, AggregationPerSeriesAligner right) => !left.Equals(right);

        public static explicit operator string(AggregationPerSeriesAligner value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AggregationPerSeriesAligner other && Equals(other);
        public bool Equals(AggregationPerSeriesAligner other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The axis scale. By default, a linear scale is used.
    /// </summary>
    [EnumType]
    public readonly struct AxisScale : IEquatable<AxisScale>
    {
        private readonly string _value;

        private AxisScale(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Scale is unspecified. The view will default to LINEAR.
        /// </summary>
        public static AxisScale ScaleUnspecified { get; } = new AxisScale("SCALE_UNSPECIFIED");
        /// <summary>
        /// Linear scale.
        /// </summary>
        public static AxisScale Linear { get; } = new AxisScale("LINEAR");
        /// <summary>
        /// Logarithmic scale (base 10).
        /// </summary>
        public static AxisScale Log10 { get; } = new AxisScale("LOG10");

        public static bool operator ==(AxisScale left, AxisScale right) => left.Equals(right);
        public static bool operator !=(AxisScale left, AxisScale right) => !left.Equals(right);

        public static explicit operator string(AxisScale value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AxisScale other && Equals(other);
        public bool Equals(AxisScale other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The chart mode.
    /// </summary>
    [EnumType]
    public readonly struct ChartOptionsMode : IEquatable<ChartOptionsMode>
    {
        private readonly string _value;

        private ChartOptionsMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Mode is unspecified. The view will default to COLOR.
        /// </summary>
        public static ChartOptionsMode ModeUnspecified { get; } = new ChartOptionsMode("MODE_UNSPECIFIED");
        /// <summary>
        /// The chart distinguishes data series using different color. Line colors may get reused when there are many lines in the chart.
        /// </summary>
        public static ChartOptionsMode Color { get; } = new ChartOptionsMode("COLOR");
        /// <summary>
        /// The chart uses the Stackdriver x-ray mode, in which each data set is plotted using the same semi-transparent color.
        /// </summary>
        public static ChartOptionsMode XRay { get; } = new ChartOptionsMode("X_RAY");
        /// <summary>
        /// The chart displays statistics such as average, median, 95th percentile, and more.
        /// </summary>
        public static ChartOptionsMode Stats { get; } = new ChartOptionsMode("STATS");

        public static bool operator ==(ChartOptionsMode left, ChartOptionsMode right) => left.Equals(right);
        public static bool operator !=(ChartOptionsMode left, ChartOptionsMode right) => !left.Equals(right);

        public static explicit operator string(ChartOptionsMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ChartOptionsMode other && Equals(other);
        public bool Equals(ChartOptionsMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// How this data should be plotted on the chart.
    /// </summary>
    [EnumType]
    public readonly struct DataSetPlotType : IEquatable<DataSetPlotType>
    {
        private readonly string _value;

        private DataSetPlotType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Plot type is unspecified. The view will default to LINE.
        /// </summary>
        public static DataSetPlotType PlotTypeUnspecified { get; } = new DataSetPlotType("PLOT_TYPE_UNSPECIFIED");
        /// <summary>
        /// The data is plotted as a set of lines (one line per series).
        /// </summary>
        public static DataSetPlotType Line { get; } = new DataSetPlotType("LINE");
        /// <summary>
        /// The data is plotted as a set of filled areas (one area per series), with the areas stacked vertically (the base of each area is the top of its predecessor, and the base of the first area is the X axis). Since the areas do not overlap, each is filled with a different opaque color.
        /// </summary>
        public static DataSetPlotType StackedArea { get; } = new DataSetPlotType("STACKED_AREA");
        /// <summary>
        /// The data is plotted as a set of rectangular boxes (one box per series), with the boxes stacked vertically (the base of each box is the top of its predecessor, and the base of the first box is the X axis). Since the boxes do not overlap, each is filled with a different opaque color.
        /// </summary>
        public static DataSetPlotType StackedBar { get; } = new DataSetPlotType("STACKED_BAR");
        /// <summary>
        /// The data is plotted as a heatmap. The series being plotted must have a DISTRIBUTION value type. The value of each bucket in the distribution is displayed as a color. This type is not currently available in the Stackdriver Monitoring application.
        /// </summary>
        public static DataSetPlotType Heatmap { get; } = new DataSetPlotType("HEATMAP");

        public static bool operator ==(DataSetPlotType left, DataSetPlotType right) => left.Equals(right);
        public static bool operator !=(DataSetPlotType left, DataSetPlotType right) => !left.Equals(right);

        public static explicit operator string(DataSetPlotType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DataSetPlotType other && Equals(other);
        public bool Equals(DataSetPlotType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// How to use the ranking to select time series that pass through the filter.
    /// </summary>
    [EnumType]
    public readonly struct PickTimeSeriesFilterDirection : IEquatable<PickTimeSeriesFilterDirection>
    {
        private readonly string _value;

        private PickTimeSeriesFilterDirection(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not allowed. You must specify a different Direction if you specify a PickTimeSeriesFilter.
        /// </summary>
        public static PickTimeSeriesFilterDirection DirectionUnspecified { get; } = new PickTimeSeriesFilterDirection("DIRECTION_UNSPECIFIED");
        /// <summary>
        /// Pass the highest num_time_series ranking inputs.
        /// </summary>
        public static PickTimeSeriesFilterDirection Top { get; } = new PickTimeSeriesFilterDirection("TOP");
        /// <summary>
        /// Pass the lowest num_time_series ranking inputs.
        /// </summary>
        public static PickTimeSeriesFilterDirection Bottom { get; } = new PickTimeSeriesFilterDirection("BOTTOM");

        public static bool operator ==(PickTimeSeriesFilterDirection left, PickTimeSeriesFilterDirection right) => left.Equals(right);
        public static bool operator !=(PickTimeSeriesFilterDirection left, PickTimeSeriesFilterDirection right) => !left.Equals(right);

        public static explicit operator string(PickTimeSeriesFilterDirection value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PickTimeSeriesFilterDirection other && Equals(other);
        public bool Equals(PickTimeSeriesFilterDirection other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
    /// </summary>
    [EnumType]
    public readonly struct PickTimeSeriesFilterRankingMethod : IEquatable<PickTimeSeriesFilterRankingMethod>
    {
        private readonly string _value;

        private PickTimeSeriesFilterRankingMethod(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not allowed. You must specify a different Method if you specify a PickTimeSeriesFilter.
        /// </summary>
        public static PickTimeSeriesFilterRankingMethod MethodUnspecified { get; } = new PickTimeSeriesFilterRankingMethod("METHOD_UNSPECIFIED");
        /// <summary>
        /// Select the mean of all values.
        /// </summary>
        public static PickTimeSeriesFilterRankingMethod MethodMean { get; } = new PickTimeSeriesFilterRankingMethod("METHOD_MEAN");
        /// <summary>
        /// Select the maximum value.
        /// </summary>
        public static PickTimeSeriesFilterRankingMethod MethodMax { get; } = new PickTimeSeriesFilterRankingMethod("METHOD_MAX");
        /// <summary>
        /// Select the minimum value.
        /// </summary>
        public static PickTimeSeriesFilterRankingMethod MethodMin { get; } = new PickTimeSeriesFilterRankingMethod("METHOD_MIN");
        /// <summary>
        /// Compute the sum of all values.
        /// </summary>
        public static PickTimeSeriesFilterRankingMethod MethodSum { get; } = new PickTimeSeriesFilterRankingMethod("METHOD_SUM");
        /// <summary>
        /// Select the most recent value.
        /// </summary>
        public static PickTimeSeriesFilterRankingMethod MethodLatest { get; } = new PickTimeSeriesFilterRankingMethod("METHOD_LATEST");

        public static bool operator ==(PickTimeSeriesFilterRankingMethod left, PickTimeSeriesFilterRankingMethod right) => left.Equals(right);
        public static bool operator !=(PickTimeSeriesFilterRankingMethod left, PickTimeSeriesFilterRankingMethod right) => !left.Equals(right);

        public static explicit operator string(PickTimeSeriesFilterRankingMethod value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PickTimeSeriesFilterRankingMethod other && Equals(other);
        public bool Equals(PickTimeSeriesFilterRankingMethod other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The type of sparkchart to show in this chartView.
    /// </summary>
    [EnumType]
    public readonly struct SparkChartViewSparkChartType : IEquatable<SparkChartViewSparkChartType>
    {
        private readonly string _value;

        private SparkChartViewSparkChartType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not allowed in well-formed requests.
        /// </summary>
        public static SparkChartViewSparkChartType SparkChartTypeUnspecified { get; } = new SparkChartViewSparkChartType("SPARK_CHART_TYPE_UNSPECIFIED");
        /// <summary>
        /// The sparkline will be rendered as a small line chart.
        /// </summary>
        public static SparkChartViewSparkChartType SparkLine { get; } = new SparkChartViewSparkChartType("SPARK_LINE");
        /// <summary>
        /// The sparkbar will be rendered as a small bar chart.
        /// </summary>
        public static SparkChartViewSparkChartType SparkBar { get; } = new SparkChartViewSparkChartType("SPARK_BAR");

        public static bool operator ==(SparkChartViewSparkChartType left, SparkChartViewSparkChartType right) => left.Equals(right);
        public static bool operator !=(SparkChartViewSparkChartType left, SparkChartViewSparkChartType right) => !left.Equals(right);

        public static explicit operator string(SparkChartViewSparkChartType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SparkChartViewSparkChartType other && Equals(other);
        public bool Equals(SparkChartViewSparkChartType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// How the text content is formatted.
    /// </summary>
    [EnumType]
    public readonly struct TextFormat : IEquatable<TextFormat>
    {
        private readonly string _value;

        private TextFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Format is unspecified. Defaults to MARKDOWN.
        /// </summary>
        public static TextFormat FormatUnspecified { get; } = new TextFormat("FORMAT_UNSPECIFIED");
        /// <summary>
        /// The text contains Markdown formatting.
        /// </summary>
        public static TextFormat Markdown { get; } = new TextFormat("MARKDOWN");
        /// <summary>
        /// The text contains no special formatting.
        /// </summary>
        public static TextFormat Raw { get; } = new TextFormat("RAW");

        public static bool operator ==(TextFormat left, TextFormat right) => left.Equals(right);
        public static bool operator !=(TextFormat left, TextFormat right) => !left.Equals(right);

        public static explicit operator string(TextFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TextFormat other && Equals(other);
        public bool Equals(TextFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The state color for this threshold. Color is not allowed in a XyChart.
    /// </summary>
    [EnumType]
    public readonly struct ThresholdColor : IEquatable<ThresholdColor>
    {
        private readonly string _value;

        private ThresholdColor(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Color is unspecified. Not allowed in well-formed requests.
        /// </summary>
        public static ThresholdColor ColorUnspecified { get; } = new ThresholdColor("COLOR_UNSPECIFIED");
        /// <summary>
        /// Crossing the threshold is "concerning" behavior.
        /// </summary>
        public static ThresholdColor Yellow { get; } = new ThresholdColor("YELLOW");
        /// <summary>
        /// Crossing the threshold is "emergency" behavior.
        /// </summary>
        public static ThresholdColor Red { get; } = new ThresholdColor("RED");

        public static bool operator ==(ThresholdColor left, ThresholdColor right) => left.Equals(right);
        public static bool operator !=(ThresholdColor left, ThresholdColor right) => !left.Equals(right);

        public static explicit operator string(ThresholdColor value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ThresholdColor other && Equals(other);
        public bool Equals(ThresholdColor other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The direction for the current threshold. Direction is not allowed in a XyChart.
    /// </summary>
    [EnumType]
    public readonly struct ThresholdDirection : IEquatable<ThresholdDirection>
    {
        private readonly string _value;

        private ThresholdDirection(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Not allowed in well-formed requests.
        /// </summary>
        public static ThresholdDirection DirectionUnspecified { get; } = new ThresholdDirection("DIRECTION_UNSPECIFIED");
        /// <summary>
        /// The threshold will be considered crossed if the actual value is above the threshold value.
        /// </summary>
        public static ThresholdDirection Above { get; } = new ThresholdDirection("ABOVE");
        /// <summary>
        /// The threshold will be considered crossed if the actual value is below the threshold value.
        /// </summary>
        public static ThresholdDirection Below { get; } = new ThresholdDirection("BELOW");

        public static bool operator ==(ThresholdDirection left, ThresholdDirection right) => left.Equals(right);
        public static bool operator !=(ThresholdDirection left, ThresholdDirection right) => !left.Equals(right);

        public static explicit operator string(ThresholdDirection value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ThresholdDirection other && Equals(other);
        public bool Equals(ThresholdDirection other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
