// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.Monitoring.V3
{
    /// <summary>
    /// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
    /// </summary>
    [EnumType]
    public readonly struct AggregationCrossSeriesReducer : IEquatable<AggregationCrossSeriesReducer>
    {
        private readonly string _value;

        private AggregationCrossSeriesReducer(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No cross-time series reduction. The output of the Aligner is returned.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceNone { get; } = new AggregationCrossSeriesReducer("REDUCE_NONE");
        /// <summary>
        /// Reduce by computing the mean value across time series for each alignment period. This reducer is valid for DELTA and GAUGE metrics with numeric or distribution values. The value_type of the output is DOUBLE.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceMean { get; } = new AggregationCrossSeriesReducer("REDUCE_MEAN");
        /// <summary>
        /// Reduce by computing the minimum value across time series for each alignment period. This reducer is valid for DELTA and GAUGE metrics with numeric values. The value_type of the output is the same as the value_type of the input.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceMin { get; } = new AggregationCrossSeriesReducer("REDUCE_MIN");
        /// <summary>
        /// Reduce by computing the maximum value across time series for each alignment period. This reducer is valid for DELTA and GAUGE metrics with numeric values. The value_type of the output is the same as the value_type of the input.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceMax { get; } = new AggregationCrossSeriesReducer("REDUCE_MAX");
        /// <summary>
        /// Reduce by computing the sum across time series for each alignment period. This reducer is valid for DELTA and GAUGE metrics with numeric and distribution values. The value_type of the output is the same as the value_type of the input.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceSum { get; } = new AggregationCrossSeriesReducer("REDUCE_SUM");
        /// <summary>
        /// Reduce by computing the standard deviation across time series for each alignment period. This reducer is valid for DELTA and GAUGE metrics with numeric or distribution values. The value_type of the output is DOUBLE.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceStddev { get; } = new AggregationCrossSeriesReducer("REDUCE_STDDEV");
        /// <summary>
        /// Reduce by computing the number of data points across time series for each alignment period. This reducer is valid for DELTA and GAUGE metrics of numeric, Boolean, distribution, and string value_type. The value_type of the output is INT64.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceCount { get; } = new AggregationCrossSeriesReducer("REDUCE_COUNT");
        /// <summary>
        /// Reduce by computing the number of True-valued data points across time series for each alignment period. This reducer is valid for DELTA and GAUGE metrics of Boolean value_type. The value_type of the output is INT64.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceCountTrue { get; } = new AggregationCrossSeriesReducer("REDUCE_COUNT_TRUE");
        /// <summary>
        /// Reduce by computing the number of False-valued data points across time series for each alignment period. This reducer is valid for DELTA and GAUGE metrics of Boolean value_type. The value_type of the output is INT64.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceCountFalse { get; } = new AggregationCrossSeriesReducer("REDUCE_COUNT_FALSE");
        /// <summary>
        /// Reduce by computing the ratio of the number of True-valued data points to the total number of data points for each alignment period. This reducer is valid for DELTA and GAUGE metrics of Boolean value_type. The output value is in the range 0.0, 1.0 and has value_type DOUBLE.
        /// </summary>
        public static AggregationCrossSeriesReducer ReduceFractionTrue { get; } = new AggregationCrossSeriesReducer("REDUCE_FRACTION_TRUE");
        /// <summary>
        /// Reduce by computing the 99th percentile (https://en.wikipedia.org/wiki/Percentile) of data points across time series for each alignment period. This reducer is valid for GAUGE and DELTA metrics of numeric and distribution type. The value of the output is DOUBLE.
        /// </summary>
        public static AggregationCrossSeriesReducer ReducePercentile99 { get; } = new AggregationCrossSeriesReducer("REDUCE_PERCENTILE_99");
        /// <summary>
        /// Reduce by computing the 95th percentile (https://en.wikipedia.org/wiki/Percentile) of data points across time series for each alignment period. This reducer is valid for GAUGE and DELTA metrics of numeric and distribution type. The value of the output is DOUBLE.
        /// </summary>
        public static AggregationCrossSeriesReducer ReducePercentile95 { get; } = new AggregationCrossSeriesReducer("REDUCE_PERCENTILE_95");
        /// <summary>
        /// Reduce by computing the 50th percentile (https://en.wikipedia.org/wiki/Percentile) of data points across time series for each alignment period. This reducer is valid for GAUGE and DELTA metrics of numeric and distribution type. The value of the output is DOUBLE.
        /// </summary>
        public static AggregationCrossSeriesReducer ReducePercentile50 { get; } = new AggregationCrossSeriesReducer("REDUCE_PERCENTILE_50");
        /// <summary>
        /// Reduce by computing the 5th percentile (https://en.wikipedia.org/wiki/Percentile) of data points across time series for each alignment period. This reducer is valid for GAUGE and DELTA metrics of numeric and distribution type. The value of the output is DOUBLE.
        /// </summary>
        public static AggregationCrossSeriesReducer ReducePercentile05 { get; } = new AggregationCrossSeriesReducer("REDUCE_PERCENTILE_05");

        public static bool operator ==(AggregationCrossSeriesReducer left, AggregationCrossSeriesReducer right) => left.Equals(right);
        public static bool operator !=(AggregationCrossSeriesReducer left, AggregationCrossSeriesReducer right) => !left.Equals(right);

        public static explicit operator string(AggregationCrossSeriesReducer value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AggregationCrossSeriesReducer other && Equals(other);
        public bool Equals(AggregationCrossSeriesReducer other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
    /// </summary>
    [EnumType]
    public readonly struct AggregationPerSeriesAligner : IEquatable<AggregationPerSeriesAligner>
    {
        private readonly string _value;

        private AggregationPerSeriesAligner(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No alignment. Raw data is returned. Not valid if cross-series reduction is requested. The value_type of the result is the same as the value_type of the input.
        /// </summary>
        public static AggregationPerSeriesAligner AlignNone { get; } = new AggregationPerSeriesAligner("ALIGN_NONE");
        /// <summary>
        /// Align and convert to DELTA. The output is delta = y1 - y0.This alignment is valid for CUMULATIVE and DELTA metrics. If the selected alignment period results in periods with no data, then the aligned value for such a period is created by interpolation. The value_type of the aligned result is the same as the value_type of the input.
        /// </summary>
        public static AggregationPerSeriesAligner AlignDelta { get; } = new AggregationPerSeriesAligner("ALIGN_DELTA");
        /// <summary>
        /// Align and convert to a rate. The result is computed as rate = (y1 - y0)/(t1 - t0), or "delta over time". Think of this aligner as providing the slope of the line that passes through the value at the start and at the end of the alignment_period.This aligner is valid for CUMULATIVE and DELTA metrics with numeric values. If the selected alignment period results in periods with no data, then the aligned value for such a period is created by interpolation. The output is a GAUGE metric with value_type DOUBLE.If, by "rate", you mean "percentage change", see the ALIGN_PERCENT_CHANGE aligner instead.
        /// </summary>
        public static AggregationPerSeriesAligner AlignRate { get; } = new AggregationPerSeriesAligner("ALIGN_RATE");
        /// <summary>
        /// Align by interpolating between adjacent points around the alignment period boundary. This aligner is valid for GAUGE metrics with numeric values. The value_type of the aligned result is the same as the value_type of the input.
        /// </summary>
        public static AggregationPerSeriesAligner AlignInterpolate { get; } = new AggregationPerSeriesAligner("ALIGN_INTERPOLATE");
        /// <summary>
        /// Align by moving the most recent data point before the end of the alignment period to the boundary at the end of the alignment period. This aligner is valid for GAUGE metrics. The value_type of the aligned result is the same as the value_type of the input.
        /// </summary>
        public static AggregationPerSeriesAligner AlignNextOlder { get; } = new AggregationPerSeriesAligner("ALIGN_NEXT_OLDER");
        /// <summary>
        /// Align the time series by returning the minimum value in each alignment period. This aligner is valid for GAUGE and DELTA metrics with numeric values. The value_type of the aligned result is the same as the value_type of the input.
        /// </summary>
        public static AggregationPerSeriesAligner AlignMin { get; } = new AggregationPerSeriesAligner("ALIGN_MIN");
        /// <summary>
        /// Align the time series by returning the maximum value in each alignment period. This aligner is valid for GAUGE and DELTA metrics with numeric values. The value_type of the aligned result is the same as the value_type of the input.
        /// </summary>
        public static AggregationPerSeriesAligner AlignMax { get; } = new AggregationPerSeriesAligner("ALIGN_MAX");
        /// <summary>
        /// Align the time series by returning the mean value in each alignment period. This aligner is valid for GAUGE and DELTA metrics with numeric values. The value_type of the aligned result is DOUBLE.
        /// </summary>
        public static AggregationPerSeriesAligner AlignMean { get; } = new AggregationPerSeriesAligner("ALIGN_MEAN");
        /// <summary>
        /// Align the time series by returning the number of values in each alignment period. This aligner is valid for GAUGE and DELTA metrics with numeric or Boolean values. The value_type of the aligned result is INT64.
        /// </summary>
        public static AggregationPerSeriesAligner AlignCount { get; } = new AggregationPerSeriesAligner("ALIGN_COUNT");
        /// <summary>
        /// Align the time series by returning the sum of the values in each alignment period. This aligner is valid for GAUGE and DELTA metrics with numeric and distribution values. The value_type of the aligned result is the same as the value_type of the input.
        /// </summary>
        public static AggregationPerSeriesAligner AlignSum { get; } = new AggregationPerSeriesAligner("ALIGN_SUM");
        /// <summary>
        /// Align the time series by returning the standard deviation of the values in each alignment period. This aligner is valid for GAUGE and DELTA metrics with numeric values. The value_type of the output is DOUBLE.
        /// </summary>
        public static AggregationPerSeriesAligner AlignStddev { get; } = new AggregationPerSeriesAligner("ALIGN_STDDEV");
        /// <summary>
        /// Align the time series by returning the number of True values in each alignment period. This aligner is valid for GAUGE metrics with Boolean values. The value_type of the output is INT64.
        /// </summary>
        public static AggregationPerSeriesAligner AlignCountTrue { get; } = new AggregationPerSeriesAligner("ALIGN_COUNT_TRUE");
        /// <summary>
        /// Align the time series by returning the number of False values in each alignment period. This aligner is valid for GAUGE metrics with Boolean values. The value_type of the output is INT64.
        /// </summary>
        public static AggregationPerSeriesAligner AlignCountFalse { get; } = new AggregationPerSeriesAligner("ALIGN_COUNT_FALSE");
        /// <summary>
        /// Align the time series by returning the ratio of the number of True values to the total number of values in each alignment period. This aligner is valid for GAUGE metrics with Boolean values. The output value is in the range 0.0, 1.0 and has value_type DOUBLE.
        /// </summary>
        public static AggregationPerSeriesAligner AlignFractionTrue { get; } = new AggregationPerSeriesAligner("ALIGN_FRACTION_TRUE");
        /// <summary>
        /// Align the time series by using percentile aggregation (https://en.wikipedia.org/wiki/Percentile). The resulting data point in each alignment period is the 99th percentile of all data points in the period. This aligner is valid for GAUGE and DELTA metrics with distribution values. The output is a GAUGE metric with value_type DOUBLE.
        /// </summary>
        public static AggregationPerSeriesAligner AlignPercentile99 { get; } = new AggregationPerSeriesAligner("ALIGN_PERCENTILE_99");
        /// <summary>
        /// Align the time series by using percentile aggregation (https://en.wikipedia.org/wiki/Percentile). The resulting data point in each alignment period is the 95th percentile of all data points in the period. This aligner is valid for GAUGE and DELTA metrics with distribution values. The output is a GAUGE metric with value_type DOUBLE.
        /// </summary>
        public static AggregationPerSeriesAligner AlignPercentile95 { get; } = new AggregationPerSeriesAligner("ALIGN_PERCENTILE_95");
        /// <summary>
        /// Align the time series by using percentile aggregation (https://en.wikipedia.org/wiki/Percentile). The resulting data point in each alignment period is the 50th percentile of all data points in the period. This aligner is valid for GAUGE and DELTA metrics with distribution values. The output is a GAUGE metric with value_type DOUBLE.
        /// </summary>
        public static AggregationPerSeriesAligner AlignPercentile50 { get; } = new AggregationPerSeriesAligner("ALIGN_PERCENTILE_50");
        /// <summary>
        /// Align the time series by using percentile aggregation (https://en.wikipedia.org/wiki/Percentile). The resulting data point in each alignment period is the 5th percentile of all data points in the period. This aligner is valid for GAUGE and DELTA metrics with distribution values. The output is a GAUGE metric with value_type DOUBLE.
        /// </summary>
        public static AggregationPerSeriesAligner AlignPercentile05 { get; } = new AggregationPerSeriesAligner("ALIGN_PERCENTILE_05");
        /// <summary>
        /// Align and convert to a percentage change. This aligner is valid for GAUGE and DELTA metrics with numeric values. This alignment returns ((current - previous)/previous) * 100, where the value of previous is determined based on the alignment_period.If the values of current and previous are both 0, then the returned value is 0. If only previous is 0, the returned value is infinity.A 10-minute moving mean is computed at each point of the alignment period prior to the above calculation to smooth the metric and prevent false positives from very short-lived spikes. The moving mean is only applicable for data whose values are &gt;= 0. Any values &lt; 0 are treated as a missing datapoint, and are ignored. While DELTA metrics are accepted by this alignment, special care should be taken that the values for the metric will always be positive. The output is a GAUGE metric with value_type DOUBLE.
        /// </summary>
        public static AggregationPerSeriesAligner AlignPercentChange { get; } = new AggregationPerSeriesAligner("ALIGN_PERCENT_CHANGE");

        public static bool operator ==(AggregationPerSeriesAligner left, AggregationPerSeriesAligner right) => left.Equals(right);
        public static bool operator !=(AggregationPerSeriesAligner left, AggregationPerSeriesAligner right) => !left.Equals(right);

        public static explicit operator string(AggregationPerSeriesAligner value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AggregationPerSeriesAligner other && Equals(other);
        public bool Equals(AggregationPerSeriesAligner other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// How to combine the results of multiple conditions to determine if an incident should be opened. If condition_time_series_query_language is present, this must be COMBINE_UNSPECIFIED.
    /// </summary>
    [EnumType]
    public readonly struct AlertPolicyCombiner : IEquatable<AlertPolicyCombiner>
    {
        private readonly string _value;

        private AlertPolicyCombiner(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// An unspecified combiner.
        /// </summary>
        public static AlertPolicyCombiner CombineUnspecified { get; } = new AlertPolicyCombiner("COMBINE_UNSPECIFIED");
        /// <summary>
        /// Combine conditions using the logical AND operator. An incident is created only if all the conditions are met simultaneously. This combiner is satisfied if all conditions are met, even if they are met on completely different resources.
        /// </summary>
        public static AlertPolicyCombiner And { get; } = new AlertPolicyCombiner("AND");
        /// <summary>
        /// Combine conditions using the logical OR operator. An incident is created if any of the listed conditions is met.
        /// </summary>
        public static AlertPolicyCombiner Or { get; } = new AlertPolicyCombiner("OR");
        /// <summary>
        /// Combine conditions using logical AND operator, but unlike the regular AND option, an incident is created only if all conditions are met simultaneously on at least one resource.
        /// </summary>
        public static AlertPolicyCombiner AndWithMatchingResource { get; } = new AlertPolicyCombiner("AND_WITH_MATCHING_RESOURCE");

        public static bool operator ==(AlertPolicyCombiner left, AlertPolicyCombiner right) => left.Equals(right);
        public static bool operator !=(AlertPolicyCombiner left, AlertPolicyCombiner right) => !left.Equals(right);

        public static explicit operator string(AlertPolicyCombiner value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AlertPolicyCombiner other && Equals(other);
        public bool Equals(AlertPolicyCombiner other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. The severity of an alert policy indicates how important incidents generated by that policy are. The severity level will be displayed on the Incident detail page and in notifications.
    /// </summary>
    [EnumType]
    public readonly struct AlertPolicySeverity : IEquatable<AlertPolicySeverity>
    {
        private readonly string _value;

        private AlertPolicySeverity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No severity is specified. This is the default value.
        /// </summary>
        public static AlertPolicySeverity SeverityUnspecified { get; } = new AlertPolicySeverity("SEVERITY_UNSPECIFIED");
        /// <summary>
        /// This is the highest severity level. Use this if the problem could cause significant damage or downtime.
        /// </summary>
        public static AlertPolicySeverity Critical { get; } = new AlertPolicySeverity("CRITICAL");
        /// <summary>
        /// This is the medium severity level. Use this if the problem could cause minor damage or downtime.
        /// </summary>
        public static AlertPolicySeverity Error { get; } = new AlertPolicySeverity("ERROR");
        /// <summary>
        /// This is the lowest severity level. Use this if the problem is not causing any damage or downtime, but could potentially lead to a problem in the future.
        /// </summary>
        public static AlertPolicySeverity Warning { get; } = new AlertPolicySeverity("WARNING");

        public static bool operator ==(AlertPolicySeverity left, AlertPolicySeverity right) => left.Equals(right);
        public static bool operator !=(AlertPolicySeverity left, AlertPolicySeverity right) => !left.Equals(right);

        public static explicit operator string(AlertPolicySeverity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AlertPolicySeverity other && Equals(other);
        public bool Equals(AlertPolicySeverity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of content matcher that will be applied to the server output, compared to the content string when the check is run.
    /// </summary>
    [EnumType]
    public readonly struct ContentMatcherMatcher : IEquatable<ContentMatcherMatcher>
    {
        private readonly string _value;

        private ContentMatcherMatcher(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No content matcher type specified (maintained for backward compatibility, but deprecated for future use). Treated as CONTAINS_STRING.
        /// </summary>
        public static ContentMatcherMatcher ContentMatcherOptionUnspecified { get; } = new ContentMatcherMatcher("CONTENT_MATCHER_OPTION_UNSPECIFIED");
        /// <summary>
        /// Selects substring matching. The match succeeds if the output contains the content string. This is the default value for checks without a matcher option, or where the value of matcher is CONTENT_MATCHER_OPTION_UNSPECIFIED.
        /// </summary>
        public static ContentMatcherMatcher ContainsString { get; } = new ContentMatcherMatcher("CONTAINS_STRING");
        /// <summary>
        /// Selects negation of substring matching. The match succeeds if the output does NOT contain the content string.
        /// </summary>
        public static ContentMatcherMatcher NotContainsString { get; } = new ContentMatcherMatcher("NOT_CONTAINS_STRING");
        /// <summary>
        /// Selects regular-expression matching. The match succeeds if the output matches the regular expression specified in the content string. Regex matching is only supported for HTTP/HTTPS checks.
        /// </summary>
        public static ContentMatcherMatcher MatchesRegex { get; } = new ContentMatcherMatcher("MATCHES_REGEX");
        /// <summary>
        /// Selects negation of regular-expression matching. The match succeeds if the output does NOT match the regular expression specified in the content string. Regex matching is only supported for HTTP/HTTPS checks.
        /// </summary>
        public static ContentMatcherMatcher NotMatchesRegex { get; } = new ContentMatcherMatcher("NOT_MATCHES_REGEX");
        /// <summary>
        /// Selects JSONPath matching. See JsonPathMatcher for details on when the match succeeds. JSONPath matching is only supported for HTTP/HTTPS checks.
        /// </summary>
        public static ContentMatcherMatcher MatchesJsonPath { get; } = new ContentMatcherMatcher("MATCHES_JSON_PATH");
        /// <summary>
        /// Selects JSONPath matching. See JsonPathMatcher for details on when the match succeeds. Succeeds when output does NOT match as specified. JSONPath is only supported for HTTP/HTTPS checks.
        /// </summary>
        public static ContentMatcherMatcher NotMatchesJsonPath { get; } = new ContentMatcherMatcher("NOT_MATCHES_JSON_PATH");

        public static bool operator ==(ContentMatcherMatcher left, ContentMatcherMatcher right) => left.Equals(right);
        public static bool operator !=(ContentMatcherMatcher left, ContentMatcherMatcher right) => !left.Equals(right);

        public static explicit operator string(ContentMatcherMatcher value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContentMatcherMatcher other && Equals(other);
        public bool Equals(ContentMatcherMatcher other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The content type header to use for the check. The following configurations result in errors: 1. Content type is specified in both the headers field and the content_type field. 2. Request method is GET and content_type is not TYPE_UNSPECIFIED 3. Request method is POST and content_type is TYPE_UNSPECIFIED. 4. Request method is POST and a "Content-Type" header is provided via headers field. The content_type field should be used instead.
    /// </summary>
    [EnumType]
    public readonly struct HttpCheckContentType : IEquatable<HttpCheckContentType>
    {
        private readonly string _value;

        private HttpCheckContentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No content type specified.
        /// </summary>
        public static HttpCheckContentType TypeUnspecified { get; } = new HttpCheckContentType("TYPE_UNSPECIFIED");
        /// <summary>
        /// body is in URL-encoded form. Equivalent to setting the Content-Type to application/x-www-form-urlencoded in the HTTP request.
        /// </summary>
        public static HttpCheckContentType UrlEncoded { get; } = new HttpCheckContentType("URL_ENCODED");
        /// <summary>
        /// body is in custom_content_type form. Equivalent to setting the Content-Type to the contents of custom_content_type in the HTTP request.
        /// </summary>
        public static HttpCheckContentType UserProvided { get; } = new HttpCheckContentType("USER_PROVIDED");

        public static bool operator ==(HttpCheckContentType left, HttpCheckContentType right) => left.Equals(right);
        public static bool operator !=(HttpCheckContentType left, HttpCheckContentType right) => !left.Equals(right);

        public static explicit operator string(HttpCheckContentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HttpCheckContentType other && Equals(other);
        public bool Equals(HttpCheckContentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED then request_method defaults to GET.
    /// </summary>
    [EnumType]
    public readonly struct HttpCheckRequestMethod : IEquatable<HttpCheckRequestMethod>
    {
        private readonly string _value;

        private HttpCheckRequestMethod(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No request method specified.
        /// </summary>
        public static HttpCheckRequestMethod MethodUnspecified { get; } = new HttpCheckRequestMethod("METHOD_UNSPECIFIED");
        /// <summary>
        /// GET request.
        /// </summary>
        public static HttpCheckRequestMethod Get { get; } = new HttpCheckRequestMethod("GET");
        /// <summary>
        /// POST request.
        /// </summary>
        public static HttpCheckRequestMethod Post { get; } = new HttpCheckRequestMethod("POST");

        public static bool operator ==(HttpCheckRequestMethod left, HttpCheckRequestMethod right) => left.Equals(right);
        public static bool operator !=(HttpCheckRequestMethod left, HttpCheckRequestMethod right) => !left.Equals(right);

        public static explicit operator string(HttpCheckRequestMethod value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HttpCheckRequestMethod other && Equals(other);
        public bool Equals(HttpCheckRequestMethod other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The current operational state of the internal checker.
    /// </summary>
    [EnumType]
    public readonly struct InternalCheckerState : IEquatable<InternalCheckerState>
    {
        private readonly string _value;

        private InternalCheckerState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// An internal checker should never be in the unspecified state.
        /// </summary>
        public static InternalCheckerState Unspecified { get; } = new InternalCheckerState("UNSPECIFIED");
        /// <summary>
        /// The checker is being created, provisioned, and configured. A checker in this state can be returned by ListInternalCheckers or GetInternalChecker, as well as by examining the long running Operation (https://cloud.google.com/apis/design/design_patterns#long_running_operations) that created it.
        /// </summary>
        public static InternalCheckerState Creating { get; } = new InternalCheckerState("CREATING");
        /// <summary>
        /// The checker is running and available for use. A checker in this state can be returned by ListInternalCheckers or GetInternalChecker as well as by examining the long running Operation (https://cloud.google.com/apis/design/design_patterns#long_running_operations) that created it. If a checker is being torn down, it is neither visible nor usable, so there is no "deleting" or "down" state.
        /// </summary>
        public static InternalCheckerState Running { get; } = new InternalCheckerState("RUNNING");

        public static bool operator ==(InternalCheckerState left, InternalCheckerState right) => left.Equals(right);
        public static bool operator !=(InternalCheckerState left, InternalCheckerState right) => !left.Equals(right);

        public static explicit operator string(InternalCheckerState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InternalCheckerState other && Equals(other);
        public bool Equals(InternalCheckerState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of JSONPath match that will be applied to the JSON output (ContentMatcher.content)
    /// </summary>
    [EnumType]
    public readonly struct JsonPathMatcherJsonMatcher : IEquatable<JsonPathMatcherJsonMatcher>
    {
        private readonly string _value;

        private JsonPathMatcherJsonMatcher(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No JSONPath matcher type specified (not valid).
        /// </summary>
        public static JsonPathMatcherJsonMatcher JsonPathMatcherOptionUnspecified { get; } = new JsonPathMatcherJsonMatcher("JSON_PATH_MATCHER_OPTION_UNSPECIFIED");
        /// <summary>
        /// Selects 'exact string' matching. The match succeeds if the content at the json_path within the output is exactly the same as the content string.
        /// </summary>
        public static JsonPathMatcherJsonMatcher ExactMatch { get; } = new JsonPathMatcherJsonMatcher("EXACT_MATCH");
        /// <summary>
        /// Selects regular-expression matching. The match succeeds if the content at the json_path within the output matches the regular expression specified in the content string.
        /// </summary>
        public static JsonPathMatcherJsonMatcher RegexMatch { get; } = new JsonPathMatcherJsonMatcher("REGEX_MATCH");

        public static bool operator ==(JsonPathMatcherJsonMatcher left, JsonPathMatcherJsonMatcher right) => left.Equals(right);
        public static bool operator !=(JsonPathMatcherJsonMatcher left, JsonPathMatcherJsonMatcher right) => !left.Equals(right);

        public static explicit operator string(JsonPathMatcherJsonMatcher value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is JsonPathMatcherJsonMatcher other && Equals(other);
        public bool Equals(JsonPathMatcherJsonMatcher other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of data that can be assigned to the label.
    /// </summary>
    [EnumType]
    public readonly struct LabelDescriptorValueType : IEquatable<LabelDescriptorValueType>
    {
        private readonly string _value;

        private LabelDescriptorValueType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// A variable-length string, not to exceed 1,024 characters. This is the default value type.
        /// </summary>
        public static LabelDescriptorValueType String { get; } = new LabelDescriptorValueType("STRING");
        /// <summary>
        /// Boolean; true or false.
        /// </summary>
        public static LabelDescriptorValueType Bool { get; } = new LabelDescriptorValueType("BOOL");
        /// <summary>
        /// A 64-bit signed integer.
        /// </summary>
        public static LabelDescriptorValueType Int64 { get; } = new LabelDescriptorValueType("INT64");

        public static bool operator ==(LabelDescriptorValueType left, LabelDescriptorValueType right) => left.Equals(right);
        public static bool operator !=(LabelDescriptorValueType left, LabelDescriptorValueType right) => !left.Equals(right);

        public static explicit operator string(LabelDescriptorValueType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LabelDescriptorValueType other && Equals(other);
        public bool Equals(LabelDescriptorValueType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. The launch stage of the metric definition.
    /// </summary>
    [EnumType]
    public readonly struct MetricDescriptorLaunchStage : IEquatable<MetricDescriptorLaunchStage>
    {
        private readonly string _value;

        private MetricDescriptorLaunchStage(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Do not use this default value.
        /// </summary>
        public static MetricDescriptorLaunchStage LaunchStageUnspecified { get; } = new MetricDescriptorLaunchStage("LAUNCH_STAGE_UNSPECIFIED");
        /// <summary>
        /// The feature is not yet implemented. Users can not use it.
        /// </summary>
        public static MetricDescriptorLaunchStage Unimplemented { get; } = new MetricDescriptorLaunchStage("UNIMPLEMENTED");
        /// <summary>
        /// Prelaunch features are hidden from users and are only visible internally.
        /// </summary>
        public static MetricDescriptorLaunchStage Prelaunch { get; } = new MetricDescriptorLaunchStage("PRELAUNCH");
        /// <summary>
        /// Early Access features are limited to a closed group of testers. To use these features, you must sign up in advance and sign a Trusted Tester agreement (which includes confidentiality provisions). These features may be unstable, changed in backward-incompatible ways, and are not guaranteed to be released.
        /// </summary>
        public static MetricDescriptorLaunchStage EarlyAccess { get; } = new MetricDescriptorLaunchStage("EARLY_ACCESS");
        /// <summary>
        /// Alpha is a limited availability test for releases before they are cleared for widespread use. By Alpha, all significant design issues are resolved and we are in the process of verifying functionality. Alpha customers need to apply for access, agree to applicable terms, and have their projects allowlisted. Alpha releases don't have to be feature complete, no SLAs are provided, and there are no technical support obligations, but they will be far enough along that customers can actually use them in test environments or for limited-use tests -- just like they would in normal production cases.
        /// </summary>
        public static MetricDescriptorLaunchStage Alpha { get; } = new MetricDescriptorLaunchStage("ALPHA");
        /// <summary>
        /// Beta is the point at which we are ready to open a release for any customer to use. There are no SLA or technical support obligations in a Beta release. Products will be complete from a feature perspective, but may have some open outstanding issues. Beta releases are suitable for limited production use cases.
        /// </summary>
        public static MetricDescriptorLaunchStage Beta { get; } = new MetricDescriptorLaunchStage("BETA");
        /// <summary>
        /// GA features are open to all developers and are considered stable and fully qualified for production use.
        /// </summary>
        public static MetricDescriptorLaunchStage Ga { get; } = new MetricDescriptorLaunchStage("GA");
        /// <summary>
        /// Deprecated features are scheduled to be shut down and removed. For more information, see the "Deprecation Policy" section of our Terms of Service (https://cloud.google.com/terms/) and the Google Cloud Platform Subject to the Deprecation Policy (https://cloud.google.com/terms/deprecation) documentation.
        /// </summary>
        public static MetricDescriptorLaunchStage Deprecated { get; } = new MetricDescriptorLaunchStage("DEPRECATED");

        public static bool operator ==(MetricDescriptorLaunchStage left, MetricDescriptorLaunchStage right) => left.Equals(right);
        public static bool operator !=(MetricDescriptorLaunchStage left, MetricDescriptorLaunchStage right) => !left.Equals(right);

        public static explicit operator string(MetricDescriptorLaunchStage value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MetricDescriptorLaunchStage other && Equals(other);
        public bool Equals(MetricDescriptorLaunchStage other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Deprecated. Must use the MetricDescriptor.launch_stage instead.
    /// </summary>
    [EnumType]
    public readonly struct MetricDescriptorMetadataLaunchStage : IEquatable<MetricDescriptorMetadataLaunchStage>
    {
        private readonly string _value;

        private MetricDescriptorMetadataLaunchStage(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Do not use this default value.
        /// </summary>
        public static MetricDescriptorMetadataLaunchStage LaunchStageUnspecified { get; } = new MetricDescriptorMetadataLaunchStage("LAUNCH_STAGE_UNSPECIFIED");
        /// <summary>
        /// The feature is not yet implemented. Users can not use it.
        /// </summary>
        public static MetricDescriptorMetadataLaunchStage Unimplemented { get; } = new MetricDescriptorMetadataLaunchStage("UNIMPLEMENTED");
        /// <summary>
        /// Prelaunch features are hidden from users and are only visible internally.
        /// </summary>
        public static MetricDescriptorMetadataLaunchStage Prelaunch { get; } = new MetricDescriptorMetadataLaunchStage("PRELAUNCH");
        /// <summary>
        /// Early Access features are limited to a closed group of testers. To use these features, you must sign up in advance and sign a Trusted Tester agreement (which includes confidentiality provisions). These features may be unstable, changed in backward-incompatible ways, and are not guaranteed to be released.
        /// </summary>
        public static MetricDescriptorMetadataLaunchStage EarlyAccess { get; } = new MetricDescriptorMetadataLaunchStage("EARLY_ACCESS");
        /// <summary>
        /// Alpha is a limited availability test for releases before they are cleared for widespread use. By Alpha, all significant design issues are resolved and we are in the process of verifying functionality. Alpha customers need to apply for access, agree to applicable terms, and have their projects allowlisted. Alpha releases don't have to be feature complete, no SLAs are provided, and there are no technical support obligations, but they will be far enough along that customers can actually use them in test environments or for limited-use tests -- just like they would in normal production cases.
        /// </summary>
        public static MetricDescriptorMetadataLaunchStage Alpha { get; } = new MetricDescriptorMetadataLaunchStage("ALPHA");
        /// <summary>
        /// Beta is the point at which we are ready to open a release for any customer to use. There are no SLA or technical support obligations in a Beta release. Products will be complete from a feature perspective, but may have some open outstanding issues. Beta releases are suitable for limited production use cases.
        /// </summary>
        public static MetricDescriptorMetadataLaunchStage Beta { get; } = new MetricDescriptorMetadataLaunchStage("BETA");
        /// <summary>
        /// GA features are open to all developers and are considered stable and fully qualified for production use.
        /// </summary>
        public static MetricDescriptorMetadataLaunchStage Ga { get; } = new MetricDescriptorMetadataLaunchStage("GA");
        /// <summary>
        /// Deprecated features are scheduled to be shut down and removed. For more information, see the "Deprecation Policy" section of our Terms of Service (https://cloud.google.com/terms/) and the Google Cloud Platform Subject to the Deprecation Policy (https://cloud.google.com/terms/deprecation) documentation.
        /// </summary>
        public static MetricDescriptorMetadataLaunchStage Deprecated { get; } = new MetricDescriptorMetadataLaunchStage("DEPRECATED");

        public static bool operator ==(MetricDescriptorMetadataLaunchStage left, MetricDescriptorMetadataLaunchStage right) => left.Equals(right);
        public static bool operator !=(MetricDescriptorMetadataLaunchStage left, MetricDescriptorMetadataLaunchStage right) => !left.Equals(right);

        public static explicit operator string(MetricDescriptorMetadataLaunchStage value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MetricDescriptorMetadataLaunchStage other && Equals(other);
        public bool Equals(MetricDescriptorMetadataLaunchStage other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether the metric records instantaneous values, changes to a value, etc. Some combinations of metric_kind and value_type might not be supported.
    /// </summary>
    [EnumType]
    public readonly struct MetricDescriptorMetricKind : IEquatable<MetricDescriptorMetricKind>
    {
        private readonly string _value;

        private MetricDescriptorMetricKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Do not use this default value.
        /// </summary>
        public static MetricDescriptorMetricKind MetricKindUnspecified { get; } = new MetricDescriptorMetricKind("METRIC_KIND_UNSPECIFIED");
        /// <summary>
        /// An instantaneous measurement of a value.
        /// </summary>
        public static MetricDescriptorMetricKind Gauge { get; } = new MetricDescriptorMetricKind("GAUGE");
        /// <summary>
        /// The change in a value during a time interval.
        /// </summary>
        public static MetricDescriptorMetricKind Delta { get; } = new MetricDescriptorMetricKind("DELTA");
        /// <summary>
        /// A value accumulated over a time interval. Cumulative measurements in a time series should have the same start time and increasing end times, until an event resets the cumulative value to zero and sets a new start time for the following points.
        /// </summary>
        public static MetricDescriptorMetricKind Cumulative { get; } = new MetricDescriptorMetricKind("CUMULATIVE");

        public static bool operator ==(MetricDescriptorMetricKind left, MetricDescriptorMetricKind right) => left.Equals(right);
        public static bool operator !=(MetricDescriptorMetricKind left, MetricDescriptorMetricKind right) => !left.Equals(right);

        public static explicit operator string(MetricDescriptorMetricKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MetricDescriptorMetricKind other && Equals(other);
        public bool Equals(MetricDescriptorMetricKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether the measurement is an integer, a floating-point number, etc. Some combinations of metric_kind and value_type might not be supported.
    /// </summary>
    [EnumType]
    public readonly struct MetricDescriptorValueType : IEquatable<MetricDescriptorValueType>
    {
        private readonly string _value;

        private MetricDescriptorValueType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Do not use this default value.
        /// </summary>
        public static MetricDescriptorValueType ValueTypeUnspecified { get; } = new MetricDescriptorValueType("VALUE_TYPE_UNSPECIFIED");
        /// <summary>
        /// The value is a boolean. This value type can be used only if the metric kind is GAUGE.
        /// </summary>
        public static MetricDescriptorValueType Bool { get; } = new MetricDescriptorValueType("BOOL");
        /// <summary>
        /// The value is a signed 64-bit integer.
        /// </summary>
        public static MetricDescriptorValueType Int64 { get; } = new MetricDescriptorValueType("INT64");
        /// <summary>
        /// The value is a double precision floating point number.
        /// </summary>
        public static MetricDescriptorValueType Double { get; } = new MetricDescriptorValueType("DOUBLE");
        /// <summary>
        /// The value is a text string. This value type can be used only if the metric kind is GAUGE.
        /// </summary>
        public static MetricDescriptorValueType String { get; } = new MetricDescriptorValueType("STRING");
        /// <summary>
        /// The value is a Distribution.
        /// </summary>
        public static MetricDescriptorValueType Distribution { get; } = new MetricDescriptorValueType("DISTRIBUTION");
        /// <summary>
        /// The value is money.
        /// </summary>
        public static MetricDescriptorValueType Money { get; } = new MetricDescriptorValueType("MONEY");

        public static bool operator ==(MetricDescriptorValueType left, MetricDescriptorValueType right) => left.Equals(right);
        public static bool operator !=(MetricDescriptorValueType left, MetricDescriptorValueType right) => !left.Equals(right);

        public static explicit operator string(MetricDescriptorValueType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MetricDescriptorValueType other && Equals(other);
        public bool Equals(MetricDescriptorValueType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The comparison to apply between the time series (indicated by filter and aggregation) and the threshold (indicated by threshold_value). The comparison is applied on each time series, with the time series on the left-hand side and the threshold on the right-hand side.Only COMPARISON_LT and COMPARISON_GT are supported currently.
    /// </summary>
    [EnumType]
    public readonly struct MetricThresholdComparison : IEquatable<MetricThresholdComparison>
    {
        private readonly string _value;

        private MetricThresholdComparison(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No ordering relationship is specified.
        /// </summary>
        public static MetricThresholdComparison ComparisonUnspecified { get; } = new MetricThresholdComparison("COMPARISON_UNSPECIFIED");
        /// <summary>
        /// True if the left argument is greater than the right argument.
        /// </summary>
        public static MetricThresholdComparison ComparisonGt { get; } = new MetricThresholdComparison("COMPARISON_GT");
        /// <summary>
        /// True if the left argument is greater than or equal to the right argument.
        /// </summary>
        public static MetricThresholdComparison ComparisonGe { get; } = new MetricThresholdComparison("COMPARISON_GE");
        /// <summary>
        /// True if the left argument is less than the right argument.
        /// </summary>
        public static MetricThresholdComparison ComparisonLt { get; } = new MetricThresholdComparison("COMPARISON_LT");
        /// <summary>
        /// True if the left argument is less than or equal to the right argument.
        /// </summary>
        public static MetricThresholdComparison ComparisonLe { get; } = new MetricThresholdComparison("COMPARISON_LE");
        /// <summary>
        /// True if the left argument is equal to the right argument.
        /// </summary>
        public static MetricThresholdComparison ComparisonEq { get; } = new MetricThresholdComparison("COMPARISON_EQ");
        /// <summary>
        /// True if the left argument is not equal to the right argument.
        /// </summary>
        public static MetricThresholdComparison ComparisonNe { get; } = new MetricThresholdComparison("COMPARISON_NE");

        public static bool operator ==(MetricThresholdComparison left, MetricThresholdComparison right) => left.Equals(right);
        public static bool operator !=(MetricThresholdComparison left, MetricThresholdComparison right) => !left.Equals(right);

        public static explicit operator string(MetricThresholdComparison value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MetricThresholdComparison other && Equals(other);
        public bool Equals(MetricThresholdComparison other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A condition control that determines how metric-threshold conditions are evaluated when data stops arriving.
    /// </summary>
    [EnumType]
    public readonly struct MetricThresholdEvaluationMissingData : IEquatable<MetricThresholdEvaluationMissingData>
    {
        private readonly string _value;

        private MetricThresholdEvaluationMissingData(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// An unspecified evaluation missing data option. Equivalent to EVALUATION_MISSING_DATA_NO_OP.
        /// </summary>
        public static MetricThresholdEvaluationMissingData EvaluationMissingDataUnspecified { get; } = new MetricThresholdEvaluationMissingData("EVALUATION_MISSING_DATA_UNSPECIFIED");
        /// <summary>
        /// If there is no data to evaluate the condition, then evaluate the condition as false.
        /// </summary>
        public static MetricThresholdEvaluationMissingData EvaluationMissingDataInactive { get; } = new MetricThresholdEvaluationMissingData("EVALUATION_MISSING_DATA_INACTIVE");
        /// <summary>
        /// If there is no data to evaluate the condition, then evaluate the condition as true.
        /// </summary>
        public static MetricThresholdEvaluationMissingData EvaluationMissingDataActive { get; } = new MetricThresholdEvaluationMissingData("EVALUATION_MISSING_DATA_ACTIVE");
        /// <summary>
        /// Do not evaluate the condition to any value if there is no data.
        /// </summary>
        public static MetricThresholdEvaluationMissingData EvaluationMissingDataNoOp { get; } = new MetricThresholdEvaluationMissingData("EVALUATION_MISSING_DATA_NO_OP");

        public static bool operator ==(MetricThresholdEvaluationMissingData left, MetricThresholdEvaluationMissingData right) => left.Equals(right);
        public static bool operator !=(MetricThresholdEvaluationMissingData left, MetricThresholdEvaluationMissingData right) => !left.Equals(right);

        public static explicit operator string(MetricThresholdEvaluationMissingData value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MetricThresholdEvaluationMissingData other && Equals(other);
        public bool Equals(MetricThresholdEvaluationMissingData other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A condition control that determines how metric-threshold conditions are evaluated when data stops arriving.
    /// </summary>
    [EnumType]
    public readonly struct MonitoringQueryLanguageConditionEvaluationMissingData : IEquatable<MonitoringQueryLanguageConditionEvaluationMissingData>
    {
        private readonly string _value;

        private MonitoringQueryLanguageConditionEvaluationMissingData(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// An unspecified evaluation missing data option. Equivalent to EVALUATION_MISSING_DATA_NO_OP.
        /// </summary>
        public static MonitoringQueryLanguageConditionEvaluationMissingData EvaluationMissingDataUnspecified { get; } = new MonitoringQueryLanguageConditionEvaluationMissingData("EVALUATION_MISSING_DATA_UNSPECIFIED");
        /// <summary>
        /// If there is no data to evaluate the condition, then evaluate the condition as false.
        /// </summary>
        public static MonitoringQueryLanguageConditionEvaluationMissingData EvaluationMissingDataInactive { get; } = new MonitoringQueryLanguageConditionEvaluationMissingData("EVALUATION_MISSING_DATA_INACTIVE");
        /// <summary>
        /// If there is no data to evaluate the condition, then evaluate the condition as true.
        /// </summary>
        public static MonitoringQueryLanguageConditionEvaluationMissingData EvaluationMissingDataActive { get; } = new MonitoringQueryLanguageConditionEvaluationMissingData("EVALUATION_MISSING_DATA_ACTIVE");
        /// <summary>
        /// Do not evaluate the condition to any value if there is no data.
        /// </summary>
        public static MonitoringQueryLanguageConditionEvaluationMissingData EvaluationMissingDataNoOp { get; } = new MonitoringQueryLanguageConditionEvaluationMissingData("EVALUATION_MISSING_DATA_NO_OP");

        public static bool operator ==(MonitoringQueryLanguageConditionEvaluationMissingData left, MonitoringQueryLanguageConditionEvaluationMissingData right) => left.Equals(right);
        public static bool operator !=(MonitoringQueryLanguageConditionEvaluationMissingData left, MonitoringQueryLanguageConditionEvaluationMissingData right) => !left.Equals(right);

        public static explicit operator string(MonitoringQueryLanguageConditionEvaluationMissingData value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MonitoringQueryLanguageConditionEvaluationMissingData other && Equals(other);
        public bool Equals(MonitoringQueryLanguageConditionEvaluationMissingData other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether this channel has been verified or not. On a ListNotificationChannels or GetNotificationChannel operation, this field is expected to be populated.If the value is UNVERIFIED, then it indicates that the channel is non-functioning (it both requires verification and lacks verification); otherwise, it is assumed that the channel works.If the channel is neither VERIFIED nor UNVERIFIED, it implies that the channel is of a type that does not require verification or that this specific channel has been exempted from verification because it was created prior to verification being required for channels of this type.This field cannot be modified using a standard UpdateNotificationChannel operation. To change the value of this field, you must call VerifyNotificationChannel.
    /// </summary>
    [EnumType]
    public readonly struct NotificationChannelVerificationStatus : IEquatable<NotificationChannelVerificationStatus>
    {
        private readonly string _value;

        private NotificationChannelVerificationStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Sentinel value used to indicate that the state is unknown, omitted, or is not applicable (as in the case of channels that neither support nor require verification in order to function).
        /// </summary>
        public static NotificationChannelVerificationStatus VerificationStatusUnspecified { get; } = new NotificationChannelVerificationStatus("VERIFICATION_STATUS_UNSPECIFIED");
        /// <summary>
        /// The channel has yet to be verified and requires verification to function. Note that this state also applies to the case where the verification process has been initiated by sending a verification code but where the verification code has not been submitted to complete the process.
        /// </summary>
        public static NotificationChannelVerificationStatus Unverified { get; } = new NotificationChannelVerificationStatus("UNVERIFIED");
        /// <summary>
        /// It has been proven that notifications can be received on this notification channel and that someone on the project has access to messages that are delivered to that channel.
        /// </summary>
        public static NotificationChannelVerificationStatus Verified { get; } = new NotificationChannelVerificationStatus("VERIFIED");

        public static bool operator ==(NotificationChannelVerificationStatus left, NotificationChannelVerificationStatus right) => left.Equals(right);
        public static bool operator !=(NotificationChannelVerificationStatus left, NotificationChannelVerificationStatus right) => !left.Equals(right);

        public static explicit operator string(NotificationChannelVerificationStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NotificationChannelVerificationStatus other && Equals(other);
        public bool Equals(NotificationChannelVerificationStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The resource type of the group members.
    /// </summary>
    [EnumType]
    public readonly struct ResourceGroupResourceType : IEquatable<ResourceGroupResourceType>
    {
        private readonly string _value;

        private ResourceGroupResourceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value (not valid).
        /// </summary>
        public static ResourceGroupResourceType ResourceTypeUnspecified { get; } = new ResourceGroupResourceType("RESOURCE_TYPE_UNSPECIFIED");
        /// <summary>
        /// A group of instances from Google Cloud Platform (GCP) or Amazon Web Services (AWS).
        /// </summary>
        public static ResourceGroupResourceType Instance { get; } = new ResourceGroupResourceType("INSTANCE");
        /// <summary>
        /// A group of Amazon ELB load balancers.
        /// </summary>
        public static ResourceGroupResourceType AwsElbLoadBalancer { get; } = new ResourceGroupResourceType("AWS_ELB_LOAD_BALANCER");

        public static bool operator ==(ResourceGroupResourceType left, ResourceGroupResourceType right) => left.Equals(right);
        public static bool operator !=(ResourceGroupResourceType left, ResourceGroupResourceType right) => !left.Equals(right);

        public static explicit operator string(ResourceGroupResourceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourceGroupResourceType other && Equals(other);
        public bool Equals(ResourceGroupResourceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A class of status codes to accept.
    /// </summary>
    [EnumType]
    public readonly struct ResponseStatusCodeStatusClass : IEquatable<ResponseStatusCodeStatusClass>
    {
        private readonly string _value;

        private ResponseStatusCodeStatusClass(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value that matches no status codes.
        /// </summary>
        public static ResponseStatusCodeStatusClass StatusClassUnspecified { get; } = new ResponseStatusCodeStatusClass("STATUS_CLASS_UNSPECIFIED");
        /// <summary>
        /// The class of status codes between 100 and 199.
        /// </summary>
        public static ResponseStatusCodeStatusClass StatusClass1xx { get; } = new ResponseStatusCodeStatusClass("STATUS_CLASS_1XX");
        /// <summary>
        /// The class of status codes between 200 and 299.
        /// </summary>
        public static ResponseStatusCodeStatusClass StatusClass2xx { get; } = new ResponseStatusCodeStatusClass("STATUS_CLASS_2XX");
        /// <summary>
        /// The class of status codes between 300 and 399.
        /// </summary>
        public static ResponseStatusCodeStatusClass StatusClass3xx { get; } = new ResponseStatusCodeStatusClass("STATUS_CLASS_3XX");
        /// <summary>
        /// The class of status codes between 400 and 499.
        /// </summary>
        public static ResponseStatusCodeStatusClass StatusClass4xx { get; } = new ResponseStatusCodeStatusClass("STATUS_CLASS_4XX");
        /// <summary>
        /// The class of status codes between 500 and 599.
        /// </summary>
        public static ResponseStatusCodeStatusClass StatusClass5xx { get; } = new ResponseStatusCodeStatusClass("STATUS_CLASS_5XX");
        /// <summary>
        /// The class of all status codes.
        /// </summary>
        public static ResponseStatusCodeStatusClass StatusClassAny { get; } = new ResponseStatusCodeStatusClass("STATUS_CLASS_ANY");

        public static bool operator ==(ResponseStatusCodeStatusClass left, ResponseStatusCodeStatusClass right) => left.Equals(right);
        public static bool operator !=(ResponseStatusCodeStatusClass left, ResponseStatusCodeStatusClass right) => !left.Equals(right);

        public static explicit operator string(ResponseStatusCodeStatusClass value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResponseStatusCodeStatusClass other && Equals(other);
        public bool Equals(ResponseStatusCodeStatusClass other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A calendar period, semantically "since the start of the current ". At this time, only DAY, WEEK, FORTNIGHT, and MONTH are supported.
    /// </summary>
    [EnumType]
    public readonly struct ServiceLevelObjectiveCalendarPeriod : IEquatable<ServiceLevelObjectiveCalendarPeriod>
    {
        private readonly string _value;

        private ServiceLevelObjectiveCalendarPeriod(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Undefined period, raises an error.
        /// </summary>
        public static ServiceLevelObjectiveCalendarPeriod CalendarPeriodUnspecified { get; } = new ServiceLevelObjectiveCalendarPeriod("CALENDAR_PERIOD_UNSPECIFIED");
        /// <summary>
        /// A day.
        /// </summary>
        public static ServiceLevelObjectiveCalendarPeriod Day { get; } = new ServiceLevelObjectiveCalendarPeriod("DAY");
        /// <summary>
        /// A week. Weeks begin on Monday, following ISO 8601 (https://en.wikipedia.org/wiki/ISO_week_date).
        /// </summary>
        public static ServiceLevelObjectiveCalendarPeriod Week { get; } = new ServiceLevelObjectiveCalendarPeriod("WEEK");
        /// <summary>
        /// A fortnight. The first calendar fortnight of the year begins at the start of week 1 according to ISO 8601 (https://en.wikipedia.org/wiki/ISO_week_date).
        /// </summary>
        public static ServiceLevelObjectiveCalendarPeriod Fortnight { get; } = new ServiceLevelObjectiveCalendarPeriod("FORTNIGHT");
        /// <summary>
        /// A month.
        /// </summary>
        public static ServiceLevelObjectiveCalendarPeriod Month { get; } = new ServiceLevelObjectiveCalendarPeriod("MONTH");
        /// <summary>
        /// A quarter. Quarters start on dates 1-Jan, 1-Apr, 1-Jul, and 1-Oct of each year.
        /// </summary>
        public static ServiceLevelObjectiveCalendarPeriod Quarter { get; } = new ServiceLevelObjectiveCalendarPeriod("QUARTER");
        /// <summary>
        /// A half-year. Half-years start on dates 1-Jan and 1-Jul.
        /// </summary>
        public static ServiceLevelObjectiveCalendarPeriod Half { get; } = new ServiceLevelObjectiveCalendarPeriod("HALF");
        /// <summary>
        /// A year.
        /// </summary>
        public static ServiceLevelObjectiveCalendarPeriod Year { get; } = new ServiceLevelObjectiveCalendarPeriod("YEAR");

        public static bool operator ==(ServiceLevelObjectiveCalendarPeriod left, ServiceLevelObjectiveCalendarPeriod right) => left.Equals(right);
        public static bool operator !=(ServiceLevelObjectiveCalendarPeriod left, ServiceLevelObjectiveCalendarPeriod right) => !left.Equals(right);

        public static explicit operator string(ServiceLevelObjectiveCalendarPeriod value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceLevelObjectiveCalendarPeriod other && Equals(other);
        public bool Equals(ServiceLevelObjectiveCalendarPeriod other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of checkers to use to execute the Uptime check.
    /// </summary>
    [EnumType]
    public readonly struct UptimeCheckConfigCheckerType : IEquatable<UptimeCheckConfigCheckerType>
    {
        private readonly string _value;

        private UptimeCheckConfigCheckerType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// The default checker type. Currently converted to STATIC_IP_CHECKERS on creation, the default conversion behavior may change in the future.
        /// </summary>
        public static UptimeCheckConfigCheckerType CheckerTypeUnspecified { get; } = new UptimeCheckConfigCheckerType("CHECKER_TYPE_UNSPECIFIED");
        /// <summary>
        /// STATIC_IP_CHECKERS are used for uptime checks that perform egress across the public internet. STATIC_IP_CHECKERS use the static IP addresses returned by ListUptimeCheckIps.
        /// </summary>
        public static UptimeCheckConfigCheckerType StaticIpCheckers { get; } = new UptimeCheckConfigCheckerType("STATIC_IP_CHECKERS");
        /// <summary>
        /// VPC_CHECKERS are used for uptime checks that perform egress using Service Directory and private network access. When using VPC_CHECKERS, the monitored resource type must be servicedirectory_service.
        /// </summary>
        public static UptimeCheckConfigCheckerType VpcCheckers { get; } = new UptimeCheckConfigCheckerType("VPC_CHECKERS");

        public static bool operator ==(UptimeCheckConfigCheckerType left, UptimeCheckConfigCheckerType right) => left.Equals(right);
        public static bool operator !=(UptimeCheckConfigCheckerType left, UptimeCheckConfigCheckerType right) => !left.Equals(right);

        public static explicit operator string(UptimeCheckConfigCheckerType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UptimeCheckConfigCheckerType other && Equals(other);
        public bool Equals(UptimeCheckConfigCheckerType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct UptimeCheckConfigSelectedRegionsItem : IEquatable<UptimeCheckConfigSelectedRegionsItem>
    {
        private readonly string _value;

        private UptimeCheckConfigSelectedRegionsItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default value if no region is specified. Will result in Uptime checks running from all regions.
        /// </summary>
        public static UptimeCheckConfigSelectedRegionsItem RegionUnspecified { get; } = new UptimeCheckConfigSelectedRegionsItem("REGION_UNSPECIFIED");
        /// <summary>
        /// Allows checks to run from locations within the United States of America.
        /// </summary>
        public static UptimeCheckConfigSelectedRegionsItem Usa { get; } = new UptimeCheckConfigSelectedRegionsItem("USA");
        /// <summary>
        /// Allows checks to run from locations within the continent of Europe.
        /// </summary>
        public static UptimeCheckConfigSelectedRegionsItem Europe { get; } = new UptimeCheckConfigSelectedRegionsItem("EUROPE");
        /// <summary>
        /// Allows checks to run from locations within the continent of South America.
        /// </summary>
        public static UptimeCheckConfigSelectedRegionsItem SouthAmerica { get; } = new UptimeCheckConfigSelectedRegionsItem("SOUTH_AMERICA");
        /// <summary>
        /// Allows checks to run from locations within the Asia Pacific area (ex: Singapore).
        /// </summary>
        public static UptimeCheckConfigSelectedRegionsItem AsiaPacific { get; } = new UptimeCheckConfigSelectedRegionsItem("ASIA_PACIFIC");
        /// <summary>
        /// Allows checks to run from locations within the western United States of America
        /// </summary>
        public static UptimeCheckConfigSelectedRegionsItem UsaOregon { get; } = new UptimeCheckConfigSelectedRegionsItem("USA_OREGON");
        /// <summary>
        /// Allows checks to run from locations within the central United States of America
        /// </summary>
        public static UptimeCheckConfigSelectedRegionsItem UsaIowa { get; } = new UptimeCheckConfigSelectedRegionsItem("USA_IOWA");
        /// <summary>
        /// Allows checks to run from locations within the eastern United States of America
        /// </summary>
        public static UptimeCheckConfigSelectedRegionsItem UsaVirginia { get; } = new UptimeCheckConfigSelectedRegionsItem("USA_VIRGINIA");

        public static bool operator ==(UptimeCheckConfigSelectedRegionsItem left, UptimeCheckConfigSelectedRegionsItem right) => left.Equals(right);
        public static bool operator !=(UptimeCheckConfigSelectedRegionsItem left, UptimeCheckConfigSelectedRegionsItem right) => !left.Equals(right);

        public static explicit operator string(UptimeCheckConfigSelectedRegionsItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UptimeCheckConfigSelectedRegionsItem other && Equals(other);
        public bool Equals(UptimeCheckConfigSelectedRegionsItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
