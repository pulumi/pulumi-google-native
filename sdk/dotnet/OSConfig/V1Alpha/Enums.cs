// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.OSConfig.V1Alpha
{
    /// <summary>
    /// Required. Policy mode
    /// </summary>
    [EnumType]
    public readonly struct OSPolicyMode : IEquatable<OSPolicyMode>
    {
        private readonly string _value;

        private OSPolicyMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Invalid mode
        /// </summary>
        public static OSPolicyMode ModeUnspecified { get; } = new OSPolicyMode("MODE_UNSPECIFIED");
        /// <summary>
        /// This mode checks if the configuration resources in the policy are in their desired state. No actions are performed if they are not in the desired state. This mode is used for reporting purposes.
        /// </summary>
        public static OSPolicyMode Validation { get; } = new OSPolicyMode("VALIDATION");
        /// <summary>
        /// This mode checks if the configuration resources in the policy are in their desired state, and if not, enforces the desired state.
        /// </summary>
        public static OSPolicyMode Enforcement { get; } = new OSPolicyMode("ENFORCEMENT");

        public static bool operator ==(OSPolicyMode left, OSPolicyMode right) => left.Equals(right);
        public static bool operator !=(OSPolicyMode left, OSPolicyMode right) => !left.Equals(right);

        public static explicit operator string(OSPolicyMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OSPolicyMode other && Equals(other);
        public bool Equals(OSPolicyMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The script interpreter to use.
    /// </summary>
    [EnumType]
    public readonly struct OSPolicyResourceExecResourceExecInterpreter : IEquatable<OSPolicyResourceExecResourceExecInterpreter>
    {
        private readonly string _value;

        private OSPolicyResourceExecResourceExecInterpreter(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Defaults to NONE.
        /// </summary>
        public static OSPolicyResourceExecResourceExecInterpreter InterpreterUnspecified { get; } = new OSPolicyResourceExecResourceExecInterpreter("INTERPRETER_UNSPECIFIED");
        /// <summary>
        /// If an interpreter is not specified, the source is executed directly. This execution, without an interpreter, only succeeds for executables and scripts that have shebang lines.
        /// </summary>
        public static OSPolicyResourceExecResourceExecInterpreter None { get; } = new OSPolicyResourceExecResourceExecInterpreter("NONE");
        /// <summary>
        /// Indicates that the script runs with `/bin/sh` on Linux and `cmd.exe` on Windows.
        /// </summary>
        public static OSPolicyResourceExecResourceExecInterpreter Shell { get; } = new OSPolicyResourceExecResourceExecInterpreter("SHELL");
        /// <summary>
        /// Indicates that the script runs with PowerShell.
        /// </summary>
        public static OSPolicyResourceExecResourceExecInterpreter Powershell { get; } = new OSPolicyResourceExecResourceExecInterpreter("POWERSHELL");

        public static bool operator ==(OSPolicyResourceExecResourceExecInterpreter left, OSPolicyResourceExecResourceExecInterpreter right) => left.Equals(right);
        public static bool operator !=(OSPolicyResourceExecResourceExecInterpreter left, OSPolicyResourceExecResourceExecInterpreter right) => !left.Equals(right);

        public static explicit operator string(OSPolicyResourceExecResourceExecInterpreter value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OSPolicyResourceExecResourceExecInterpreter other && Equals(other);
        public bool Equals(OSPolicyResourceExecResourceExecInterpreter other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. Desired state of the file.
    /// </summary>
    [EnumType]
    public readonly struct OSPolicyResourceFileResourceState : IEquatable<OSPolicyResourceFileResourceState>
    {
        private readonly string _value;

        private OSPolicyResourceFileResourceState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified is invalid.
        /// </summary>
        public static OSPolicyResourceFileResourceState DesiredStateUnspecified { get; } = new OSPolicyResourceFileResourceState("DESIRED_STATE_UNSPECIFIED");
        /// <summary>
        /// Ensure file at path is present.
        /// </summary>
        public static OSPolicyResourceFileResourceState Present { get; } = new OSPolicyResourceFileResourceState("PRESENT");
        /// <summary>
        /// Ensure file at path is absent.
        /// </summary>
        public static OSPolicyResourceFileResourceState Absent { get; } = new OSPolicyResourceFileResourceState("ABSENT");
        /// <summary>
        /// Ensure the contents of the file at path matches. If the file does not exist it will be created.
        /// </summary>
        public static OSPolicyResourceFileResourceState ContentsMatch { get; } = new OSPolicyResourceFileResourceState("CONTENTS_MATCH");

        public static bool operator ==(OSPolicyResourceFileResourceState left, OSPolicyResourceFileResourceState right) => left.Equals(right);
        public static bool operator !=(OSPolicyResourceFileResourceState left, OSPolicyResourceFileResourceState right) => !left.Equals(right);

        public static explicit operator string(OSPolicyResourceFileResourceState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OSPolicyResourceFileResourceState other && Equals(other);
        public bool Equals(OSPolicyResourceFileResourceState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. The desired state the agent should maintain for this package.
    /// </summary>
    [EnumType]
    public readonly struct OSPolicyResourcePackageResourceDesiredState : IEquatable<OSPolicyResourcePackageResourceDesiredState>
    {
        private readonly string _value;

        private OSPolicyResourcePackageResourceDesiredState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified is invalid.
        /// </summary>
        public static OSPolicyResourcePackageResourceDesiredState DesiredStateUnspecified { get; } = new OSPolicyResourcePackageResourceDesiredState("DESIRED_STATE_UNSPECIFIED");
        /// <summary>
        /// Ensure that the package is installed.
        /// </summary>
        public static OSPolicyResourcePackageResourceDesiredState Installed { get; } = new OSPolicyResourcePackageResourceDesiredState("INSTALLED");
        /// <summary>
        /// The agent ensures that the package is not installed and uninstalls it if detected.
        /// </summary>
        public static OSPolicyResourcePackageResourceDesiredState Removed { get; } = new OSPolicyResourcePackageResourceDesiredState("REMOVED");

        public static bool operator ==(OSPolicyResourcePackageResourceDesiredState left, OSPolicyResourcePackageResourceDesiredState right) => left.Equals(right);
        public static bool operator !=(OSPolicyResourcePackageResourceDesiredState left, OSPolicyResourcePackageResourceDesiredState right) => !left.Equals(right);

        public static explicit operator string(OSPolicyResourcePackageResourceDesiredState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OSPolicyResourcePackageResourceDesiredState other && Equals(other);
        public bool Equals(OSPolicyResourcePackageResourceDesiredState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Required. Type of archive files in this repository.
    /// </summary>
    [EnumType]
    public readonly struct OSPolicyResourceRepositoryResourceAptRepositoryArchiveType : IEquatable<OSPolicyResourceRepositoryResourceAptRepositoryArchiveType>
    {
        private readonly string _value;

        private OSPolicyResourceRepositoryResourceAptRepositoryArchiveType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Unspecified is invalid.
        /// </summary>
        public static OSPolicyResourceRepositoryResourceAptRepositoryArchiveType ArchiveTypeUnspecified { get; } = new OSPolicyResourceRepositoryResourceAptRepositoryArchiveType("ARCHIVE_TYPE_UNSPECIFIED");
        /// <summary>
        /// Deb indicates that the archive contains binary files.
        /// </summary>
        public static OSPolicyResourceRepositoryResourceAptRepositoryArchiveType Deb { get; } = new OSPolicyResourceRepositoryResourceAptRepositoryArchiveType("DEB");
        /// <summary>
        /// Deb-src indicates that the archive contains source files.
        /// </summary>
        public static OSPolicyResourceRepositoryResourceAptRepositoryArchiveType DebSrc { get; } = new OSPolicyResourceRepositoryResourceAptRepositoryArchiveType("DEB_SRC");

        public static bool operator ==(OSPolicyResourceRepositoryResourceAptRepositoryArchiveType left, OSPolicyResourceRepositoryResourceAptRepositoryArchiveType right) => left.Equals(right);
        public static bool operator !=(OSPolicyResourceRepositoryResourceAptRepositoryArchiveType left, OSPolicyResourceRepositoryResourceAptRepositoryArchiveType right) => !left.Equals(right);

        public static explicit operator string(OSPolicyResourceRepositoryResourceAptRepositoryArchiveType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is OSPolicyResourceRepositoryResourceAptRepositoryArchiveType other && Equals(other);
        public bool Equals(OSPolicyResourceRepositoryResourceAptRepositoryArchiveType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
