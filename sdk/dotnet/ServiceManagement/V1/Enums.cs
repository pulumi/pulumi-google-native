// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.GoogleNative.ServiceManagement.V1
{
    /// <summary>
    /// The source syntax of the service.
    /// </summary>
    [EnumType]
    public readonly struct ApiSyntax : IEquatable<ApiSyntax>
    {
        private readonly string _value;

        private ApiSyntax(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Syntax `proto2`.
        /// </summary>
        public static ApiSyntax SyntaxProto2 { get; } = new ApiSyntax("SYNTAX_PROTO2");
        /// <summary>
        /// Syntax `proto3`.
        /// </summary>
        public static ApiSyntax SyntaxProto3 { get; } = new ApiSyntax("SYNTAX_PROTO3");

        public static bool operator ==(ApiSyntax left, ApiSyntax right) => left.Equals(right);
        public static bool operator !=(ApiSyntax left, ApiSyntax right) => !left.Equals(right);

        public static explicit operator string(ApiSyntax value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ApiSyntax other && Equals(other);
        public bool Equals(ApiSyntax other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The log type that this config enables.
    /// </summary>
    [EnumType]
    public readonly struct AuditLogConfigLogType : IEquatable<AuditLogConfigLogType>
    {
        private readonly string _value;

        private AuditLogConfigLogType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Default case. Should never be this.
        /// </summary>
        public static AuditLogConfigLogType LogTypeUnspecified { get; } = new AuditLogConfigLogType("LOG_TYPE_UNSPECIFIED");
        /// <summary>
        /// Admin reads. Example: CloudIAM getIamPolicy
        /// </summary>
        public static AuditLogConfigLogType AdminRead { get; } = new AuditLogConfigLogType("ADMIN_READ");
        /// <summary>
        /// Data writes. Example: CloudSQL Users create
        /// </summary>
        public static AuditLogConfigLogType DataWrite { get; } = new AuditLogConfigLogType("DATA_WRITE");
        /// <summary>
        /// Data reads. Example: CloudSQL Users list
        /// </summary>
        public static AuditLogConfigLogType DataRead { get; } = new AuditLogConfigLogType("DATA_READ");

        public static bool operator ==(AuditLogConfigLogType left, AuditLogConfigLogType right) => left.Equals(right);
        public static bool operator !=(AuditLogConfigLogType left, AuditLogConfigLogType right) => !left.Equals(right);

        public static explicit operator string(AuditLogConfigLogType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AuditLogConfigLogType other && Equals(other);
        public bool Equals(AuditLogConfigLogType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct BackendRulePathTranslation : IEquatable<BackendRulePathTranslation>
    {
        private readonly string _value;

        private BackendRulePathTranslation(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BackendRulePathTranslation PathTranslationUnspecified { get; } = new BackendRulePathTranslation("PATH_TRANSLATION_UNSPECIFIED");
        /// <summary>
        /// Use the backend address as-is, with no modification to the path. If the URL pattern contains variables, the variable names and values will be appended to the query string. If a query string parameter and a URL pattern variable have the same name, this may result in duplicate keys in the query string. # Examples Given the following operation config: Method path: /api/company/{cid}/user/{uid} Backend address: https://example.cloudfunctions.net/getUser Requests to the following request paths will call the backend at the translated path: Request path: /api/company/widgetworks/user/johndoe Translated: https://example.cloudfunctions.net/getUser?cid=widgetworks&amp;uid=johndoe Request path: /api/company/widgetworks/user/johndoe?timezone=EST Translated: https://example.cloudfunctions.net/getUser?timezone=EST&amp;cid=widgetworks&amp;uid=johndoe
        /// </summary>
        public static BackendRulePathTranslation ConstantAddress { get; } = new BackendRulePathTranslation("CONSTANT_ADDRESS");
        /// <summary>
        /// The request path will be appended to the backend address. # Examples Given the following operation config: Method path: /api/company/{cid}/user/{uid} Backend address: https://example.appspot.com Requests to the following request paths will call the backend at the translated path: Request path: /api/company/widgetworks/user/johndoe Translated: https://example.appspot.com/api/company/widgetworks/user/johndoe Request path: /api/company/widgetworks/user/johndoe?timezone=EST Translated: https://example.appspot.com/api/company/widgetworks/user/johndoe?timezone=EST
        /// </summary>
        public static BackendRulePathTranslation AppendPathToAddress { get; } = new BackendRulePathTranslation("APPEND_PATH_TO_ADDRESS");

        public static bool operator ==(BackendRulePathTranslation left, BackendRulePathTranslation right) => left.Equals(right);
        public static bool operator !=(BackendRulePathTranslation left, BackendRulePathTranslation right) => !left.Equals(right);

        public static explicit operator string(BackendRulePathTranslation value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BackendRulePathTranslation other && Equals(other);
        public bool Equals(BackendRulePathTranslation other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The source syntax.
    /// </summary>
    [EnumType]
    public readonly struct EnumSyntax : IEquatable<EnumSyntax>
    {
        private readonly string _value;

        private EnumSyntax(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Syntax `proto2`.
        /// </summary>
        public static EnumSyntax SyntaxProto2 { get; } = new EnumSyntax("SYNTAX_PROTO2");
        /// <summary>
        /// Syntax `proto3`.
        /// </summary>
        public static EnumSyntax SyntaxProto3 { get; } = new EnumSyntax("SYNTAX_PROTO3");

        public static bool operator ==(EnumSyntax left, EnumSyntax right) => left.Equals(right);
        public static bool operator !=(EnumSyntax left, EnumSyntax right) => !left.Equals(right);

        public static explicit operator string(EnumSyntax value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EnumSyntax other && Equals(other);
        public bool Equals(EnumSyntax other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The field cardinality.
    /// </summary>
    [EnumType]
    public readonly struct FieldCardinality : IEquatable<FieldCardinality>
    {
        private readonly string _value;

        private FieldCardinality(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// For fields with unknown cardinality.
        /// </summary>
        public static FieldCardinality CardinalityUnknown { get; } = new FieldCardinality("CARDINALITY_UNKNOWN");
        /// <summary>
        /// For optional fields.
        /// </summary>
        public static FieldCardinality CardinalityOptional { get; } = new FieldCardinality("CARDINALITY_OPTIONAL");
        /// <summary>
        /// For required fields. Proto2 syntax only.
        /// </summary>
        public static FieldCardinality CardinalityRequired { get; } = new FieldCardinality("CARDINALITY_REQUIRED");
        /// <summary>
        /// For repeated fields.
        /// </summary>
        public static FieldCardinality CardinalityRepeated { get; } = new FieldCardinality("CARDINALITY_REPEATED");

        public static bool operator ==(FieldCardinality left, FieldCardinality right) => left.Equals(right);
        public static bool operator !=(FieldCardinality left, FieldCardinality right) => !left.Equals(right);

        public static explicit operator string(FieldCardinality value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FieldCardinality other && Equals(other);
        public bool Equals(FieldCardinality other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The field type.
    /// </summary>
    [EnumType]
    public readonly struct FieldKind : IEquatable<FieldKind>
    {
        private readonly string _value;

        private FieldKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Field type unknown.
        /// </summary>
        public static FieldKind TypeUnknown { get; } = new FieldKind("TYPE_UNKNOWN");
        /// <summary>
        /// Field type double.
        /// </summary>
        public static FieldKind TypeDouble { get; } = new FieldKind("TYPE_DOUBLE");
        /// <summary>
        /// Field type float.
        /// </summary>
        public static FieldKind TypeFloat { get; } = new FieldKind("TYPE_FLOAT");
        /// <summary>
        /// Field type int64.
        /// </summary>
        public static FieldKind TypeInt64 { get; } = new FieldKind("TYPE_INT64");
        /// <summary>
        /// Field type uint64.
        /// </summary>
        public static FieldKind TypeUint64 { get; } = new FieldKind("TYPE_UINT64");
        /// <summary>
        /// Field type int32.
        /// </summary>
        public static FieldKind TypeInt32 { get; } = new FieldKind("TYPE_INT32");
        /// <summary>
        /// Field type fixed64.
        /// </summary>
        public static FieldKind TypeFixed64 { get; } = new FieldKind("TYPE_FIXED64");
        /// <summary>
        /// Field type fixed32.
        /// </summary>
        public static FieldKind TypeFixed32 { get; } = new FieldKind("TYPE_FIXED32");
        /// <summary>
        /// Field type bool.
        /// </summary>
        public static FieldKind TypeBool { get; } = new FieldKind("TYPE_BOOL");
        /// <summary>
        /// Field type string.
        /// </summary>
        public static FieldKind TypeString { get; } = new FieldKind("TYPE_STRING");
        /// <summary>
        /// Field type group. Proto2 syntax only, and deprecated.
        /// </summary>
        public static FieldKind TypeGroup { get; } = new FieldKind("TYPE_GROUP");
        /// <summary>
        /// Field type message.
        /// </summary>
        public static FieldKind TypeMessage { get; } = new FieldKind("TYPE_MESSAGE");
        /// <summary>
        /// Field type bytes.
        /// </summary>
        public static FieldKind TypeBytes { get; } = new FieldKind("TYPE_BYTES");
        /// <summary>
        /// Field type uint32.
        /// </summary>
        public static FieldKind TypeUint32 { get; } = new FieldKind("TYPE_UINT32");
        /// <summary>
        /// Field type enum.
        /// </summary>
        public static FieldKind TypeEnum { get; } = new FieldKind("TYPE_ENUM");
        /// <summary>
        /// Field type sfixed32.
        /// </summary>
        public static FieldKind TypeSfixed32 { get; } = new FieldKind("TYPE_SFIXED32");
        /// <summary>
        /// Field type sfixed64.
        /// </summary>
        public static FieldKind TypeSfixed64 { get; } = new FieldKind("TYPE_SFIXED64");
        /// <summary>
        /// Field type sint32.
        /// </summary>
        public static FieldKind TypeSint32 { get; } = new FieldKind("TYPE_SINT32");
        /// <summary>
        /// Field type sint64.
        /// </summary>
        public static FieldKind TypeSint64 { get; } = new FieldKind("TYPE_SINT64");

        public static bool operator ==(FieldKind left, FieldKind right) => left.Equals(right);
        public static bool operator !=(FieldKind left, FieldKind right) => !left.Equals(right);

        public static explicit operator string(FieldKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FieldKind other && Equals(other);
        public bool Equals(FieldKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of data that can be assigned to the label.
    /// </summary>
    [EnumType]
    public readonly struct LabelDescriptorValueType : IEquatable<LabelDescriptorValueType>
    {
        private readonly string _value;

        private LabelDescriptorValueType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// A variable-length string. This is the default.
        /// </summary>
        public static LabelDescriptorValueType String { get; } = new LabelDescriptorValueType("STRING");
        /// <summary>
        /// Boolean; true or false.
        /// </summary>
        public static LabelDescriptorValueType Bool { get; } = new LabelDescriptorValueType("BOOL");
        /// <summary>
        /// A 64-bit signed integer.
        /// </summary>
        public static LabelDescriptorValueType Int64 { get; } = new LabelDescriptorValueType("INT64");

        public static bool operator ==(LabelDescriptorValueType left, LabelDescriptorValueType right) => left.Equals(right);
        public static bool operator !=(LabelDescriptorValueType left, LabelDescriptorValueType right) => !left.Equals(right);

        public static explicit operator string(LabelDescriptorValueType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LabelDescriptorValueType other && Equals(other);
        public bool Equals(LabelDescriptorValueType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The source syntax of this method.
    /// </summary>
    [EnumType]
    public readonly struct MethodSyntax : IEquatable<MethodSyntax>
    {
        private readonly string _value;

        private MethodSyntax(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Syntax `proto2`.
        /// </summary>
        public static MethodSyntax SyntaxProto2 { get; } = new MethodSyntax("SYNTAX_PROTO2");
        /// <summary>
        /// Syntax `proto3`.
        /// </summary>
        public static MethodSyntax SyntaxProto3 { get; } = new MethodSyntax("SYNTAX_PROTO3");

        public static bool operator ==(MethodSyntax left, MethodSyntax right) => left.Equals(right);
        public static bool operator !=(MethodSyntax left, MethodSyntax right) => !left.Equals(right);

        public static explicit operator string(MethodSyntax value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MethodSyntax other && Equals(other);
        public bool Equals(MethodSyntax other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. The launch stage of the metric definition.
    /// </summary>
    [EnumType]
    public readonly struct MetricDescriptorLaunchStage : IEquatable<MetricDescriptorLaunchStage>
    {
        private readonly string _value;

        private MetricDescriptorLaunchStage(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Do not use this default value.
        /// </summary>
        public static MetricDescriptorLaunchStage LaunchStageUnspecified { get; } = new MetricDescriptorLaunchStage("LAUNCH_STAGE_UNSPECIFIED");
        /// <summary>
        /// The feature is not yet implemented. Users can not use it.
        /// </summary>
        public static MetricDescriptorLaunchStage Unimplemented { get; } = new MetricDescriptorLaunchStage("UNIMPLEMENTED");
        /// <summary>
        /// Prelaunch features are hidden from users and are only visible internally.
        /// </summary>
        public static MetricDescriptorLaunchStage Prelaunch { get; } = new MetricDescriptorLaunchStage("PRELAUNCH");
        /// <summary>
        /// Early Access features are limited to a closed group of testers. To use these features, you must sign up in advance and sign a Trusted Tester agreement (which includes confidentiality provisions). These features may be unstable, changed in backward-incompatible ways, and are not guaranteed to be released.
        /// </summary>
        public static MetricDescriptorLaunchStage EarlyAccess { get; } = new MetricDescriptorLaunchStage("EARLY_ACCESS");
        /// <summary>
        /// Alpha is a limited availability test for releases before they are cleared for widespread use. By Alpha, all significant design issues are resolved and we are in the process of verifying functionality. Alpha customers need to apply for access, agree to applicable terms, and have their projects allowlisted. Alpha releases don’t have to be feature complete, no SLAs are provided, and there are no technical support obligations, but they will be far enough along that customers can actually use them in test environments or for limited-use tests -- just like they would in normal production cases.
        /// </summary>
        public static MetricDescriptorLaunchStage Alpha { get; } = new MetricDescriptorLaunchStage("ALPHA");
        /// <summary>
        /// Beta is the point at which we are ready to open a release for any customer to use. There are no SLA or technical support obligations in a Beta release. Products will be complete from a feature perspective, but may have some open outstanding issues. Beta releases are suitable for limited production use cases.
        /// </summary>
        public static MetricDescriptorLaunchStage Beta { get; } = new MetricDescriptorLaunchStage("BETA");
        /// <summary>
        /// GA features are open to all developers and are considered stable and fully qualified for production use.
        /// </summary>
        public static MetricDescriptorLaunchStage Ga { get; } = new MetricDescriptorLaunchStage("GA");
        /// <summary>
        /// Deprecated features are scheduled to be shut down and removed. For more information, see the “Deprecation Policy” section of our [Terms of Service](https://cloud.google.com/terms/) and the [Google Cloud Platform Subject to the Deprecation Policy](https://cloud.google.com/terms/deprecation) documentation.
        /// </summary>
        public static MetricDescriptorLaunchStage Deprecated { get; } = new MetricDescriptorLaunchStage("DEPRECATED");

        public static bool operator ==(MetricDescriptorLaunchStage left, MetricDescriptorLaunchStage right) => left.Equals(right);
        public static bool operator !=(MetricDescriptorLaunchStage left, MetricDescriptorLaunchStage right) => !left.Equals(right);

        public static explicit operator string(MetricDescriptorLaunchStage value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MetricDescriptorLaunchStage other && Equals(other);
        public bool Equals(MetricDescriptorLaunchStage other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether the metric records instantaneous values, changes to a value, etc. Some combinations of `metric_kind` and `value_type` might not be supported.
    /// </summary>
    [EnumType]
    public readonly struct MetricDescriptorMetricKind : IEquatable<MetricDescriptorMetricKind>
    {
        private readonly string _value;

        private MetricDescriptorMetricKind(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Do not use this default value.
        /// </summary>
        public static MetricDescriptorMetricKind MetricKindUnspecified { get; } = new MetricDescriptorMetricKind("METRIC_KIND_UNSPECIFIED");
        /// <summary>
        /// An instantaneous measurement of a value.
        /// </summary>
        public static MetricDescriptorMetricKind Gauge { get; } = new MetricDescriptorMetricKind("GAUGE");
        /// <summary>
        /// The change in a value during a time interval.
        /// </summary>
        public static MetricDescriptorMetricKind Delta { get; } = new MetricDescriptorMetricKind("DELTA");
        /// <summary>
        /// A value accumulated over a time interval. Cumulative measurements in a time series should have the same start time and increasing end times, until an event resets the cumulative value to zero and sets a new start time for the following points.
        /// </summary>
        public static MetricDescriptorMetricKind Cumulative { get; } = new MetricDescriptorMetricKind("CUMULATIVE");

        public static bool operator ==(MetricDescriptorMetricKind left, MetricDescriptorMetricKind right) => left.Equals(right);
        public static bool operator !=(MetricDescriptorMetricKind left, MetricDescriptorMetricKind right) => !left.Equals(right);

        public static explicit operator string(MetricDescriptorMetricKind value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MetricDescriptorMetricKind other && Equals(other);
        public bool Equals(MetricDescriptorMetricKind other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether the measurement is an integer, a floating-point number, etc. Some combinations of `metric_kind` and `value_type` might not be supported.
    /// </summary>
    [EnumType]
    public readonly struct MetricDescriptorValueType : IEquatable<MetricDescriptorValueType>
    {
        private readonly string _value;

        private MetricDescriptorValueType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Do not use this default value.
        /// </summary>
        public static MetricDescriptorValueType ValueTypeUnspecified { get; } = new MetricDescriptorValueType("VALUE_TYPE_UNSPECIFIED");
        /// <summary>
        /// The value is a boolean. This value type can be used only if the metric kind is `GAUGE`.
        /// </summary>
        public static MetricDescriptorValueType Bool { get; } = new MetricDescriptorValueType("BOOL");
        /// <summary>
        /// The value is a signed 64-bit integer.
        /// </summary>
        public static MetricDescriptorValueType Int64 { get; } = new MetricDescriptorValueType("INT64");
        /// <summary>
        /// The value is a double precision floating point number.
        /// </summary>
        public static MetricDescriptorValueType Double { get; } = new MetricDescriptorValueType("DOUBLE");
        /// <summary>
        /// The value is a text string. This value type can be used only if the metric kind is `GAUGE`.
        /// </summary>
        public static MetricDescriptorValueType String { get; } = new MetricDescriptorValueType("STRING");
        /// <summary>
        /// The value is a `Distribution`.
        /// </summary>
        public static MetricDescriptorValueType Distribution { get; } = new MetricDescriptorValueType("DISTRIBUTION");
        /// <summary>
        /// The value is money.
        /// </summary>
        public static MetricDescriptorValueType Money { get; } = new MetricDescriptorValueType("MONEY");

        public static bool operator ==(MetricDescriptorValueType left, MetricDescriptorValueType right) => left.Equals(right);
        public static bool operator !=(MetricDescriptorValueType left, MetricDescriptorValueType right) => !left.Equals(right);

        public static explicit operator string(MetricDescriptorValueType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MetricDescriptorValueType other && Equals(other);
        public bool Equals(MetricDescriptorValueType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional. The launch stage of the monitored resource definition.
    /// </summary>
    [EnumType]
    public readonly struct MonitoredResourceDescriptorLaunchStage : IEquatable<MonitoredResourceDescriptorLaunchStage>
    {
        private readonly string _value;

        private MonitoredResourceDescriptorLaunchStage(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Do not use this default value.
        /// </summary>
        public static MonitoredResourceDescriptorLaunchStage LaunchStageUnspecified { get; } = new MonitoredResourceDescriptorLaunchStage("LAUNCH_STAGE_UNSPECIFIED");
        /// <summary>
        /// The feature is not yet implemented. Users can not use it.
        /// </summary>
        public static MonitoredResourceDescriptorLaunchStage Unimplemented { get; } = new MonitoredResourceDescriptorLaunchStage("UNIMPLEMENTED");
        /// <summary>
        /// Prelaunch features are hidden from users and are only visible internally.
        /// </summary>
        public static MonitoredResourceDescriptorLaunchStage Prelaunch { get; } = new MonitoredResourceDescriptorLaunchStage("PRELAUNCH");
        /// <summary>
        /// Early Access features are limited to a closed group of testers. To use these features, you must sign up in advance and sign a Trusted Tester agreement (which includes confidentiality provisions). These features may be unstable, changed in backward-incompatible ways, and are not guaranteed to be released.
        /// </summary>
        public static MonitoredResourceDescriptorLaunchStage EarlyAccess { get; } = new MonitoredResourceDescriptorLaunchStage("EARLY_ACCESS");
        /// <summary>
        /// Alpha is a limited availability test for releases before they are cleared for widespread use. By Alpha, all significant design issues are resolved and we are in the process of verifying functionality. Alpha customers need to apply for access, agree to applicable terms, and have their projects allowlisted. Alpha releases don’t have to be feature complete, no SLAs are provided, and there are no technical support obligations, but they will be far enough along that customers can actually use them in test environments or for limited-use tests -- just like they would in normal production cases.
        /// </summary>
        public static MonitoredResourceDescriptorLaunchStage Alpha { get; } = new MonitoredResourceDescriptorLaunchStage("ALPHA");
        /// <summary>
        /// Beta is the point at which we are ready to open a release for any customer to use. There are no SLA or technical support obligations in a Beta release. Products will be complete from a feature perspective, but may have some open outstanding issues. Beta releases are suitable for limited production use cases.
        /// </summary>
        public static MonitoredResourceDescriptorLaunchStage Beta { get; } = new MonitoredResourceDescriptorLaunchStage("BETA");
        /// <summary>
        /// GA features are open to all developers and are considered stable and fully qualified for production use.
        /// </summary>
        public static MonitoredResourceDescriptorLaunchStage Ga { get; } = new MonitoredResourceDescriptorLaunchStage("GA");
        /// <summary>
        /// Deprecated features are scheduled to be shut down and removed. For more information, see the “Deprecation Policy” section of our [Terms of Service](https://cloud.google.com/terms/) and the [Google Cloud Platform Subject to the Deprecation Policy](https://cloud.google.com/terms/deprecation) documentation.
        /// </summary>
        public static MonitoredResourceDescriptorLaunchStage Deprecated { get; } = new MonitoredResourceDescriptorLaunchStage("DEPRECATED");

        public static bool operator ==(MonitoredResourceDescriptorLaunchStage left, MonitoredResourceDescriptorLaunchStage right) => left.Equals(right);
        public static bool operator !=(MonitoredResourceDescriptorLaunchStage left, MonitoredResourceDescriptorLaunchStage right) => !left.Equals(right);

        public static explicit operator string(MonitoredResourceDescriptorLaunchStage value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MonitoredResourceDescriptorLaunchStage other && Equals(other);
        public bool Equals(MonitoredResourceDescriptorLaunchStage other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The status of this rollout. Readonly. In case of a failed rollout, the system will automatically rollback to the current Rollout version. Readonly.
    /// </summary>
    [EnumType]
    public readonly struct RolloutStatus : IEquatable<RolloutStatus>
    {
        private readonly string _value;

        private RolloutStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// No status specified.
        /// </summary>
        public static RolloutStatus RolloutStatusUnspecified { get; } = new RolloutStatus("ROLLOUT_STATUS_UNSPECIFIED");
        /// <summary>
        /// The Rollout is in progress.
        /// </summary>
        public static RolloutStatus InProgress { get; } = new RolloutStatus("IN_PROGRESS");
        /// <summary>
        /// The Rollout has completed successfully.
        /// </summary>
        public static RolloutStatus Success { get; } = new RolloutStatus("SUCCESS");
        /// <summary>
        /// The Rollout has been cancelled. This can happen if you have overlapping Rollout pushes, and the previous ones will be cancelled.
        /// </summary>
        public static RolloutStatus Cancelled { get; } = new RolloutStatus("CANCELLED");
        /// <summary>
        /// The Rollout has failed and the rollback attempt has failed too.
        /// </summary>
        public static RolloutStatus Failed { get; } = new RolloutStatus("FAILED");
        /// <summary>
        /// The Rollout has not started yet and is pending for execution.
        /// </summary>
        public static RolloutStatus Pending { get; } = new RolloutStatus("PENDING");
        /// <summary>
        /// The Rollout has failed and rolled back to the previous successful Rollout.
        /// </summary>
        public static RolloutStatus FailedRolledBack { get; } = new RolloutStatus("FAILED_ROLLED_BACK");

        public static bool operator ==(RolloutStatus left, RolloutStatus right) => left.Equals(right);
        public static bool operator !=(RolloutStatus left, RolloutStatus right) => !left.Equals(right);

        public static explicit operator string(RolloutStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RolloutStatus other && Equals(other);
        public bool Equals(RolloutStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The source syntax.
    /// </summary>
    [EnumType]
    public readonly struct TypeSyntax : IEquatable<TypeSyntax>
    {
        private readonly string _value;

        private TypeSyntax(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Syntax `proto2`.
        /// </summary>
        public static TypeSyntax SyntaxProto2 { get; } = new TypeSyntax("SYNTAX_PROTO2");
        /// <summary>
        /// Syntax `proto3`.
        /// </summary>
        public static TypeSyntax SyntaxProto3 { get; } = new TypeSyntax("SYNTAX_PROTO3");

        public static bool operator ==(TypeSyntax left, TypeSyntax right) => left.Equals(right);
        public static bool operator !=(TypeSyntax left, TypeSyntax right) => !left.Equals(right);

        public static explicit operator string(TypeSyntax value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TypeSyntax other && Equals(other);
        public bool Equals(TypeSyntax other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
