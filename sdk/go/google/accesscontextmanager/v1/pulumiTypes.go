// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Identification for an API Operation.
type ApiOperation struct {
	// API methods or permissions to allow. Method or permission must belong to the service specified by `service_name` field. A single MethodSelector entry with `*` specified for the `method` field will allow all methods AND permissions for the service specified in `service_name`.
	MethodSelectors []MethodSelector `pulumi:"methodSelectors"`
	// The name of the API whose methods or permissions the IngressPolicy or EgressPolicy want to allow. A single ApiOperation with `service_name` field set to `*` will allow all methods AND permissions for all services.
	ServiceName *string `pulumi:"serviceName"`
}

// ApiOperationInput is an input type that accepts ApiOperationArgs and ApiOperationOutput values.
// You can construct a concrete instance of `ApiOperationInput` via:
//
//          ApiOperationArgs{...}
type ApiOperationInput interface {
	pulumi.Input

	ToApiOperationOutput() ApiOperationOutput
	ToApiOperationOutputWithContext(context.Context) ApiOperationOutput
}

// Identification for an API Operation.
type ApiOperationArgs struct {
	// API methods or permissions to allow. Method or permission must belong to the service specified by `service_name` field. A single MethodSelector entry with `*` specified for the `method` field will allow all methods AND permissions for the service specified in `service_name`.
	MethodSelectors MethodSelectorArrayInput `pulumi:"methodSelectors"`
	// The name of the API whose methods or permissions the IngressPolicy or EgressPolicy want to allow. A single ApiOperation with `service_name` field set to `*` will allow all methods AND permissions for all services.
	ServiceName pulumi.StringPtrInput `pulumi:"serviceName"`
}

func (ApiOperationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ApiOperation)(nil)).Elem()
}

func (i ApiOperationArgs) ToApiOperationOutput() ApiOperationOutput {
	return i.ToApiOperationOutputWithContext(context.Background())
}

func (i ApiOperationArgs) ToApiOperationOutputWithContext(ctx context.Context) ApiOperationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApiOperationOutput)
}

// ApiOperationArrayInput is an input type that accepts ApiOperationArray and ApiOperationArrayOutput values.
// You can construct a concrete instance of `ApiOperationArrayInput` via:
//
//          ApiOperationArray{ ApiOperationArgs{...} }
type ApiOperationArrayInput interface {
	pulumi.Input

	ToApiOperationArrayOutput() ApiOperationArrayOutput
	ToApiOperationArrayOutputWithContext(context.Context) ApiOperationArrayOutput
}

type ApiOperationArray []ApiOperationInput

func (ApiOperationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ApiOperation)(nil)).Elem()
}

func (i ApiOperationArray) ToApiOperationArrayOutput() ApiOperationArrayOutput {
	return i.ToApiOperationArrayOutputWithContext(context.Background())
}

func (i ApiOperationArray) ToApiOperationArrayOutputWithContext(ctx context.Context) ApiOperationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApiOperationArrayOutput)
}

// Identification for an API Operation.
type ApiOperationOutput struct{ *pulumi.OutputState }

func (ApiOperationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApiOperation)(nil)).Elem()
}

func (o ApiOperationOutput) ToApiOperationOutput() ApiOperationOutput {
	return o
}

func (o ApiOperationOutput) ToApiOperationOutputWithContext(ctx context.Context) ApiOperationOutput {
	return o
}

// API methods or permissions to allow. Method or permission must belong to the service specified by `service_name` field. A single MethodSelector entry with `*` specified for the `method` field will allow all methods AND permissions for the service specified in `service_name`.
func (o ApiOperationOutput) MethodSelectors() MethodSelectorArrayOutput {
	return o.ApplyT(func(v ApiOperation) []MethodSelector { return v.MethodSelectors }).(MethodSelectorArrayOutput)
}

// The name of the API whose methods or permissions the IngressPolicy or EgressPolicy want to allow. A single ApiOperation with `service_name` field set to `*` will allow all methods AND permissions for all services.
func (o ApiOperationOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ApiOperation) *string { return v.ServiceName }).(pulumi.StringPtrOutput)
}

type ApiOperationArrayOutput struct{ *pulumi.OutputState }

func (ApiOperationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ApiOperation)(nil)).Elem()
}

func (o ApiOperationArrayOutput) ToApiOperationArrayOutput() ApiOperationArrayOutput {
	return o
}

func (o ApiOperationArrayOutput) ToApiOperationArrayOutputWithContext(ctx context.Context) ApiOperationArrayOutput {
	return o
}

func (o ApiOperationArrayOutput) Index(i pulumi.IntInput) ApiOperationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ApiOperation {
		return vs[0].([]ApiOperation)[vs[1].(int)]
	}).(ApiOperationOutput)
}

// Identification for an API Operation.
type ApiOperationResponse struct {
	// API methods or permissions to allow. Method or permission must belong to the service specified by `service_name` field. A single MethodSelector entry with `*` specified for the `method` field will allow all methods AND permissions for the service specified in `service_name`.
	MethodSelectors []MethodSelectorResponse `pulumi:"methodSelectors"`
	// The name of the API whose methods or permissions the IngressPolicy or EgressPolicy want to allow. A single ApiOperation with `service_name` field set to `*` will allow all methods AND permissions for all services.
	ServiceName string `pulumi:"serviceName"`
}

// Identification for an API Operation.
type ApiOperationResponseOutput struct{ *pulumi.OutputState }

func (ApiOperationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApiOperationResponse)(nil)).Elem()
}

func (o ApiOperationResponseOutput) ToApiOperationResponseOutput() ApiOperationResponseOutput {
	return o
}

func (o ApiOperationResponseOutput) ToApiOperationResponseOutputWithContext(ctx context.Context) ApiOperationResponseOutput {
	return o
}

// API methods or permissions to allow. Method or permission must belong to the service specified by `service_name` field. A single MethodSelector entry with `*` specified for the `method` field will allow all methods AND permissions for the service specified in `service_name`.
func (o ApiOperationResponseOutput) MethodSelectors() MethodSelectorResponseArrayOutput {
	return o.ApplyT(func(v ApiOperationResponse) []MethodSelectorResponse { return v.MethodSelectors }).(MethodSelectorResponseArrayOutput)
}

// The name of the API whose methods or permissions the IngressPolicy or EgressPolicy want to allow. A single ApiOperation with `service_name` field set to `*` will allow all methods AND permissions for all services.
func (o ApiOperationResponseOutput) ServiceName() pulumi.StringOutput {
	return o.ApplyT(func(v ApiOperationResponse) string { return v.ServiceName }).(pulumi.StringOutput)
}

type ApiOperationResponseArrayOutput struct{ *pulumi.OutputState }

func (ApiOperationResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ApiOperationResponse)(nil)).Elem()
}

func (o ApiOperationResponseArrayOutput) ToApiOperationResponseArrayOutput() ApiOperationResponseArrayOutput {
	return o
}

func (o ApiOperationResponseArrayOutput) ToApiOperationResponseArrayOutputWithContext(ctx context.Context) ApiOperationResponseArrayOutput {
	return o
}

func (o ApiOperationResponseArrayOutput) Index(i pulumi.IntInput) ApiOperationResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ApiOperationResponse {
		return vs[0].([]ApiOperationResponse)[vs[1].(int)]
	}).(ApiOperationResponseOutput)
}

// `BasicLevel` is an `AccessLevel` using a set of recommended features.
type BasicLevel struct {
	// How the `conditions` list should be combined to determine if a request is granted this `AccessLevel`. If AND is used, each `Condition` in `conditions` must be satisfied for the `AccessLevel` to be applied. If OR is used, at least one `Condition` in `conditions` must be satisfied for the `AccessLevel` to be applied. Default behavior is AND.
	CombiningFunction *BasicLevelCombiningFunction `pulumi:"combiningFunction"`
	// A list of requirements for the `AccessLevel` to be granted.
	Conditions []Condition `pulumi:"conditions"`
}

// BasicLevelInput is an input type that accepts BasicLevelArgs and BasicLevelOutput values.
// You can construct a concrete instance of `BasicLevelInput` via:
//
//          BasicLevelArgs{...}
type BasicLevelInput interface {
	pulumi.Input

	ToBasicLevelOutput() BasicLevelOutput
	ToBasicLevelOutputWithContext(context.Context) BasicLevelOutput
}

// `BasicLevel` is an `AccessLevel` using a set of recommended features.
type BasicLevelArgs struct {
	// How the `conditions` list should be combined to determine if a request is granted this `AccessLevel`. If AND is used, each `Condition` in `conditions` must be satisfied for the `AccessLevel` to be applied. If OR is used, at least one `Condition` in `conditions` must be satisfied for the `AccessLevel` to be applied. Default behavior is AND.
	CombiningFunction BasicLevelCombiningFunctionPtrInput `pulumi:"combiningFunction"`
	// A list of requirements for the `AccessLevel` to be granted.
	Conditions ConditionArrayInput `pulumi:"conditions"`
}

func (BasicLevelArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicLevel)(nil)).Elem()
}

func (i BasicLevelArgs) ToBasicLevelOutput() BasicLevelOutput {
	return i.ToBasicLevelOutputWithContext(context.Background())
}

func (i BasicLevelArgs) ToBasicLevelOutputWithContext(ctx context.Context) BasicLevelOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicLevelOutput)
}

func (i BasicLevelArgs) ToBasicLevelPtrOutput() BasicLevelPtrOutput {
	return i.ToBasicLevelPtrOutputWithContext(context.Background())
}

func (i BasicLevelArgs) ToBasicLevelPtrOutputWithContext(ctx context.Context) BasicLevelPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicLevelOutput).ToBasicLevelPtrOutputWithContext(ctx)
}

// BasicLevelPtrInput is an input type that accepts BasicLevelArgs, BasicLevelPtr and BasicLevelPtrOutput values.
// You can construct a concrete instance of `BasicLevelPtrInput` via:
//
//          BasicLevelArgs{...}
//
//  or:
//
//          nil
type BasicLevelPtrInput interface {
	pulumi.Input

	ToBasicLevelPtrOutput() BasicLevelPtrOutput
	ToBasicLevelPtrOutputWithContext(context.Context) BasicLevelPtrOutput
}

type basicLevelPtrType BasicLevelArgs

func BasicLevelPtr(v *BasicLevelArgs) BasicLevelPtrInput {
	return (*basicLevelPtrType)(v)
}

func (*basicLevelPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicLevel)(nil)).Elem()
}

func (i *basicLevelPtrType) ToBasicLevelPtrOutput() BasicLevelPtrOutput {
	return i.ToBasicLevelPtrOutputWithContext(context.Background())
}

func (i *basicLevelPtrType) ToBasicLevelPtrOutputWithContext(ctx context.Context) BasicLevelPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicLevelPtrOutput)
}

// `BasicLevel` is an `AccessLevel` using a set of recommended features.
type BasicLevelOutput struct{ *pulumi.OutputState }

func (BasicLevelOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicLevel)(nil)).Elem()
}

func (o BasicLevelOutput) ToBasicLevelOutput() BasicLevelOutput {
	return o
}

func (o BasicLevelOutput) ToBasicLevelOutputWithContext(ctx context.Context) BasicLevelOutput {
	return o
}

func (o BasicLevelOutput) ToBasicLevelPtrOutput() BasicLevelPtrOutput {
	return o.ToBasicLevelPtrOutputWithContext(context.Background())
}

func (o BasicLevelOutput) ToBasicLevelPtrOutputWithContext(ctx context.Context) BasicLevelPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BasicLevel) *BasicLevel {
		return &v
	}).(BasicLevelPtrOutput)
}

// How the `conditions` list should be combined to determine if a request is granted this `AccessLevel`. If AND is used, each `Condition` in `conditions` must be satisfied for the `AccessLevel` to be applied. If OR is used, at least one `Condition` in `conditions` must be satisfied for the `AccessLevel` to be applied. Default behavior is AND.
func (o BasicLevelOutput) CombiningFunction() BasicLevelCombiningFunctionPtrOutput {
	return o.ApplyT(func(v BasicLevel) *BasicLevelCombiningFunction { return v.CombiningFunction }).(BasicLevelCombiningFunctionPtrOutput)
}

// A list of requirements for the `AccessLevel` to be granted.
func (o BasicLevelOutput) Conditions() ConditionArrayOutput {
	return o.ApplyT(func(v BasicLevel) []Condition { return v.Conditions }).(ConditionArrayOutput)
}

type BasicLevelPtrOutput struct{ *pulumi.OutputState }

func (BasicLevelPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicLevel)(nil)).Elem()
}

func (o BasicLevelPtrOutput) ToBasicLevelPtrOutput() BasicLevelPtrOutput {
	return o
}

func (o BasicLevelPtrOutput) ToBasicLevelPtrOutputWithContext(ctx context.Context) BasicLevelPtrOutput {
	return o
}

func (o BasicLevelPtrOutput) Elem() BasicLevelOutput {
	return o.ApplyT(func(v *BasicLevel) BasicLevel {
		if v != nil {
			return *v
		}
		var ret BasicLevel
		return ret
	}).(BasicLevelOutput)
}

// How the `conditions` list should be combined to determine if a request is granted this `AccessLevel`. If AND is used, each `Condition` in `conditions` must be satisfied for the `AccessLevel` to be applied. If OR is used, at least one `Condition` in `conditions` must be satisfied for the `AccessLevel` to be applied. Default behavior is AND.
func (o BasicLevelPtrOutput) CombiningFunction() BasicLevelCombiningFunctionPtrOutput {
	return o.ApplyT(func(v *BasicLevel) *BasicLevelCombiningFunction {
		if v == nil {
			return nil
		}
		return v.CombiningFunction
	}).(BasicLevelCombiningFunctionPtrOutput)
}

// A list of requirements for the `AccessLevel` to be granted.
func (o BasicLevelPtrOutput) Conditions() ConditionArrayOutput {
	return o.ApplyT(func(v *BasicLevel) []Condition {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(ConditionArrayOutput)
}

// `BasicLevel` is an `AccessLevel` using a set of recommended features.
type BasicLevelResponse struct {
	// How the `conditions` list should be combined to determine if a request is granted this `AccessLevel`. If AND is used, each `Condition` in `conditions` must be satisfied for the `AccessLevel` to be applied. If OR is used, at least one `Condition` in `conditions` must be satisfied for the `AccessLevel` to be applied. Default behavior is AND.
	CombiningFunction string `pulumi:"combiningFunction"`
	// A list of requirements for the `AccessLevel` to be granted.
	Conditions []ConditionResponse `pulumi:"conditions"`
}

// `BasicLevel` is an `AccessLevel` using a set of recommended features.
type BasicLevelResponseOutput struct{ *pulumi.OutputState }

func (BasicLevelResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicLevelResponse)(nil)).Elem()
}

func (o BasicLevelResponseOutput) ToBasicLevelResponseOutput() BasicLevelResponseOutput {
	return o
}

func (o BasicLevelResponseOutput) ToBasicLevelResponseOutputWithContext(ctx context.Context) BasicLevelResponseOutput {
	return o
}

// How the `conditions` list should be combined to determine if a request is granted this `AccessLevel`. If AND is used, each `Condition` in `conditions` must be satisfied for the `AccessLevel` to be applied. If OR is used, at least one `Condition` in `conditions` must be satisfied for the `AccessLevel` to be applied. Default behavior is AND.
func (o BasicLevelResponseOutput) CombiningFunction() pulumi.StringOutput {
	return o.ApplyT(func(v BasicLevelResponse) string { return v.CombiningFunction }).(pulumi.StringOutput)
}

// A list of requirements for the `AccessLevel` to be granted.
func (o BasicLevelResponseOutput) Conditions() ConditionResponseArrayOutput {
	return o.ApplyT(func(v BasicLevelResponse) []ConditionResponse { return v.Conditions }).(ConditionResponseArrayOutput)
}

// A condition necessary for an `AccessLevel` to be granted. The Condition is an AND over its fields. So a Condition is true if: 1) the request IP is from one of the listed subnetworks AND 2) the originating device complies with the listed device policy AND 3) all listed access levels are granted AND 4) the request was sent at a time allowed by the DateTimeRestriction.
type Condition struct {
	// Device specific restrictions, all restrictions must hold for the Condition to be true. If not specified, all devices are allowed.
	DevicePolicy *DevicePolicy `pulumi:"devicePolicy"`
	// CIDR block IP subnetwork specification. May be IPv4 or IPv6. Note that for a CIDR IP address block, the specified IP address portion must be properly truncated (i.e. all the host bits must be zero) or the input is considered malformed. For example, "192.0.2.0/24" is accepted but "192.0.2.1/24" is not. Similarly, for IPv6, "2001:db8::/32" is accepted whereas "2001:db8::1/32" is not. The originating IP of a request must be in one of the listed subnets in order for this Condition to be true. If empty, all IP addresses are allowed.
	IpSubnetworks []string `pulumi:"ipSubnetworks"`
	// The request must be made by one of the provided user or service accounts. Groups are not supported. Syntax: `user:{emailid}` `serviceAccount:{emailid}` If not specified, a request may come from any user.
	Members []string `pulumi:"members"`
	// Whether to negate the Condition. If true, the Condition becomes a NAND over its non-empty fields, each field must be false for the Condition overall to be satisfied. Defaults to false.
	Negate *bool `pulumi:"negate"`
	// The request must originate from one of the provided countries/regions. Must be valid ISO 3166-1 alpha-2 codes.
	Regions []string `pulumi:"regions"`
	// A list of other access levels defined in the same `Policy`, referenced by resource name. Referencing an `AccessLevel` which does not exist is an error. All access levels listed must be granted for the Condition to be true. Example: "`accessPolicies/MY_POLICY/accessLevels/LEVEL_NAME"`
	RequiredAccessLevels []string `pulumi:"requiredAccessLevels"`
}

// ConditionInput is an input type that accepts ConditionArgs and ConditionOutput values.
// You can construct a concrete instance of `ConditionInput` via:
//
//          ConditionArgs{...}
type ConditionInput interface {
	pulumi.Input

	ToConditionOutput() ConditionOutput
	ToConditionOutputWithContext(context.Context) ConditionOutput
}

// A condition necessary for an `AccessLevel` to be granted. The Condition is an AND over its fields. So a Condition is true if: 1) the request IP is from one of the listed subnetworks AND 2) the originating device complies with the listed device policy AND 3) all listed access levels are granted AND 4) the request was sent at a time allowed by the DateTimeRestriction.
type ConditionArgs struct {
	// Device specific restrictions, all restrictions must hold for the Condition to be true. If not specified, all devices are allowed.
	DevicePolicy DevicePolicyPtrInput `pulumi:"devicePolicy"`
	// CIDR block IP subnetwork specification. May be IPv4 or IPv6. Note that for a CIDR IP address block, the specified IP address portion must be properly truncated (i.e. all the host bits must be zero) or the input is considered malformed. For example, "192.0.2.0/24" is accepted but "192.0.2.1/24" is not. Similarly, for IPv6, "2001:db8::/32" is accepted whereas "2001:db8::1/32" is not. The originating IP of a request must be in one of the listed subnets in order for this Condition to be true. If empty, all IP addresses are allowed.
	IpSubnetworks pulumi.StringArrayInput `pulumi:"ipSubnetworks"`
	// The request must be made by one of the provided user or service accounts. Groups are not supported. Syntax: `user:{emailid}` `serviceAccount:{emailid}` If not specified, a request may come from any user.
	Members pulumi.StringArrayInput `pulumi:"members"`
	// Whether to negate the Condition. If true, the Condition becomes a NAND over its non-empty fields, each field must be false for the Condition overall to be satisfied. Defaults to false.
	Negate pulumi.BoolPtrInput `pulumi:"negate"`
	// The request must originate from one of the provided countries/regions. Must be valid ISO 3166-1 alpha-2 codes.
	Regions pulumi.StringArrayInput `pulumi:"regions"`
	// A list of other access levels defined in the same `Policy`, referenced by resource name. Referencing an `AccessLevel` which does not exist is an error. All access levels listed must be granted for the Condition to be true. Example: "`accessPolicies/MY_POLICY/accessLevels/LEVEL_NAME"`
	RequiredAccessLevels pulumi.StringArrayInput `pulumi:"requiredAccessLevels"`
}

func (ConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Condition)(nil)).Elem()
}

func (i ConditionArgs) ToConditionOutput() ConditionOutput {
	return i.ToConditionOutputWithContext(context.Background())
}

func (i ConditionArgs) ToConditionOutputWithContext(ctx context.Context) ConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConditionOutput)
}

// ConditionArrayInput is an input type that accepts ConditionArray and ConditionArrayOutput values.
// You can construct a concrete instance of `ConditionArrayInput` via:
//
//          ConditionArray{ ConditionArgs{...} }
type ConditionArrayInput interface {
	pulumi.Input

	ToConditionArrayOutput() ConditionArrayOutput
	ToConditionArrayOutputWithContext(context.Context) ConditionArrayOutput
}

type ConditionArray []ConditionInput

func (ConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Condition)(nil)).Elem()
}

func (i ConditionArray) ToConditionArrayOutput() ConditionArrayOutput {
	return i.ToConditionArrayOutputWithContext(context.Background())
}

func (i ConditionArray) ToConditionArrayOutputWithContext(ctx context.Context) ConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConditionArrayOutput)
}

// A condition necessary for an `AccessLevel` to be granted. The Condition is an AND over its fields. So a Condition is true if: 1) the request IP is from one of the listed subnetworks AND 2) the originating device complies with the listed device policy AND 3) all listed access levels are granted AND 4) the request was sent at a time allowed by the DateTimeRestriction.
type ConditionOutput struct{ *pulumi.OutputState }

func (ConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Condition)(nil)).Elem()
}

func (o ConditionOutput) ToConditionOutput() ConditionOutput {
	return o
}

func (o ConditionOutput) ToConditionOutputWithContext(ctx context.Context) ConditionOutput {
	return o
}

// Device specific restrictions, all restrictions must hold for the Condition to be true. If not specified, all devices are allowed.
func (o ConditionOutput) DevicePolicy() DevicePolicyPtrOutput {
	return o.ApplyT(func(v Condition) *DevicePolicy { return v.DevicePolicy }).(DevicePolicyPtrOutput)
}

// CIDR block IP subnetwork specification. May be IPv4 or IPv6. Note that for a CIDR IP address block, the specified IP address portion must be properly truncated (i.e. all the host bits must be zero) or the input is considered malformed. For example, "192.0.2.0/24" is accepted but "192.0.2.1/24" is not. Similarly, for IPv6, "2001:db8::/32" is accepted whereas "2001:db8::1/32" is not. The originating IP of a request must be in one of the listed subnets in order for this Condition to be true. If empty, all IP addresses are allowed.
func (o ConditionOutput) IpSubnetworks() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Condition) []string { return v.IpSubnetworks }).(pulumi.StringArrayOutput)
}

// The request must be made by one of the provided user or service accounts. Groups are not supported. Syntax: `user:{emailid}` `serviceAccount:{emailid}` If not specified, a request may come from any user.
func (o ConditionOutput) Members() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Condition) []string { return v.Members }).(pulumi.StringArrayOutput)
}

// Whether to negate the Condition. If true, the Condition becomes a NAND over its non-empty fields, each field must be false for the Condition overall to be satisfied. Defaults to false.
func (o ConditionOutput) Negate() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Condition) *bool { return v.Negate }).(pulumi.BoolPtrOutput)
}

// The request must originate from one of the provided countries/regions. Must be valid ISO 3166-1 alpha-2 codes.
func (o ConditionOutput) Regions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Condition) []string { return v.Regions }).(pulumi.StringArrayOutput)
}

// A list of other access levels defined in the same `Policy`, referenced by resource name. Referencing an `AccessLevel` which does not exist is an error. All access levels listed must be granted for the Condition to be true. Example: "`accessPolicies/MY_POLICY/accessLevels/LEVEL_NAME"`
func (o ConditionOutput) RequiredAccessLevels() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Condition) []string { return v.RequiredAccessLevels }).(pulumi.StringArrayOutput)
}

type ConditionArrayOutput struct{ *pulumi.OutputState }

func (ConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Condition)(nil)).Elem()
}

func (o ConditionArrayOutput) ToConditionArrayOutput() ConditionArrayOutput {
	return o
}

func (o ConditionArrayOutput) ToConditionArrayOutputWithContext(ctx context.Context) ConditionArrayOutput {
	return o
}

func (o ConditionArrayOutput) Index(i pulumi.IntInput) ConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Condition {
		return vs[0].([]Condition)[vs[1].(int)]
	}).(ConditionOutput)
}

// A condition necessary for an `AccessLevel` to be granted. The Condition is an AND over its fields. So a Condition is true if: 1) the request IP is from one of the listed subnetworks AND 2) the originating device complies with the listed device policy AND 3) all listed access levels are granted AND 4) the request was sent at a time allowed by the DateTimeRestriction.
type ConditionResponse struct {
	// Device specific restrictions, all restrictions must hold for the Condition to be true. If not specified, all devices are allowed.
	DevicePolicy DevicePolicyResponse `pulumi:"devicePolicy"`
	// CIDR block IP subnetwork specification. May be IPv4 or IPv6. Note that for a CIDR IP address block, the specified IP address portion must be properly truncated (i.e. all the host bits must be zero) or the input is considered malformed. For example, "192.0.2.0/24" is accepted but "192.0.2.1/24" is not. Similarly, for IPv6, "2001:db8::/32" is accepted whereas "2001:db8::1/32" is not. The originating IP of a request must be in one of the listed subnets in order for this Condition to be true. If empty, all IP addresses are allowed.
	IpSubnetworks []string `pulumi:"ipSubnetworks"`
	// The request must be made by one of the provided user or service accounts. Groups are not supported. Syntax: `user:{emailid}` `serviceAccount:{emailid}` If not specified, a request may come from any user.
	Members []string `pulumi:"members"`
	// Whether to negate the Condition. If true, the Condition becomes a NAND over its non-empty fields, each field must be false for the Condition overall to be satisfied. Defaults to false.
	Negate bool `pulumi:"negate"`
	// The request must originate from one of the provided countries/regions. Must be valid ISO 3166-1 alpha-2 codes.
	Regions []string `pulumi:"regions"`
	// A list of other access levels defined in the same `Policy`, referenced by resource name. Referencing an `AccessLevel` which does not exist is an error. All access levels listed must be granted for the Condition to be true. Example: "`accessPolicies/MY_POLICY/accessLevels/LEVEL_NAME"`
	RequiredAccessLevels []string `pulumi:"requiredAccessLevels"`
}

// A condition necessary for an `AccessLevel` to be granted. The Condition is an AND over its fields. So a Condition is true if: 1) the request IP is from one of the listed subnetworks AND 2) the originating device complies with the listed device policy AND 3) all listed access levels are granted AND 4) the request was sent at a time allowed by the DateTimeRestriction.
type ConditionResponseOutput struct{ *pulumi.OutputState }

func (ConditionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ConditionResponse)(nil)).Elem()
}

func (o ConditionResponseOutput) ToConditionResponseOutput() ConditionResponseOutput {
	return o
}

func (o ConditionResponseOutput) ToConditionResponseOutputWithContext(ctx context.Context) ConditionResponseOutput {
	return o
}

// Device specific restrictions, all restrictions must hold for the Condition to be true. If not specified, all devices are allowed.
func (o ConditionResponseOutput) DevicePolicy() DevicePolicyResponseOutput {
	return o.ApplyT(func(v ConditionResponse) DevicePolicyResponse { return v.DevicePolicy }).(DevicePolicyResponseOutput)
}

// CIDR block IP subnetwork specification. May be IPv4 or IPv6. Note that for a CIDR IP address block, the specified IP address portion must be properly truncated (i.e. all the host bits must be zero) or the input is considered malformed. For example, "192.0.2.0/24" is accepted but "192.0.2.1/24" is not. Similarly, for IPv6, "2001:db8::/32" is accepted whereas "2001:db8::1/32" is not. The originating IP of a request must be in one of the listed subnets in order for this Condition to be true. If empty, all IP addresses are allowed.
func (o ConditionResponseOutput) IpSubnetworks() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ConditionResponse) []string { return v.IpSubnetworks }).(pulumi.StringArrayOutput)
}

// The request must be made by one of the provided user or service accounts. Groups are not supported. Syntax: `user:{emailid}` `serviceAccount:{emailid}` If not specified, a request may come from any user.
func (o ConditionResponseOutput) Members() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ConditionResponse) []string { return v.Members }).(pulumi.StringArrayOutput)
}

// Whether to negate the Condition. If true, the Condition becomes a NAND over its non-empty fields, each field must be false for the Condition overall to be satisfied. Defaults to false.
func (o ConditionResponseOutput) Negate() pulumi.BoolOutput {
	return o.ApplyT(func(v ConditionResponse) bool { return v.Negate }).(pulumi.BoolOutput)
}

// The request must originate from one of the provided countries/regions. Must be valid ISO 3166-1 alpha-2 codes.
func (o ConditionResponseOutput) Regions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ConditionResponse) []string { return v.Regions }).(pulumi.StringArrayOutput)
}

// A list of other access levels defined in the same `Policy`, referenced by resource name. Referencing an `AccessLevel` which does not exist is an error. All access levels listed must be granted for the Condition to be true. Example: "`accessPolicies/MY_POLICY/accessLevels/LEVEL_NAME"`
func (o ConditionResponseOutput) RequiredAccessLevels() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ConditionResponse) []string { return v.RequiredAccessLevels }).(pulumi.StringArrayOutput)
}

type ConditionResponseArrayOutput struct{ *pulumi.OutputState }

func (ConditionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ConditionResponse)(nil)).Elem()
}

func (o ConditionResponseArrayOutput) ToConditionResponseArrayOutput() ConditionResponseArrayOutput {
	return o
}

func (o ConditionResponseArrayOutput) ToConditionResponseArrayOutputWithContext(ctx context.Context) ConditionResponseArrayOutput {
	return o
}

func (o ConditionResponseArrayOutput) Index(i pulumi.IntInput) ConditionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ConditionResponse {
		return vs[0].([]ConditionResponse)[vs[1].(int)]
	}).(ConditionResponseOutput)
}

// `CustomLevel` is an `AccessLevel` using the Cloud Common Expression Language to represent the necessary conditions for the level to apply to a request. See CEL spec at: https://github.com/google/cel-spec
type CustomLevel struct {
	// A Cloud CEL expression evaluating to a boolean.
	Expr Expr `pulumi:"expr"`
}

// CustomLevelInput is an input type that accepts CustomLevelArgs and CustomLevelOutput values.
// You can construct a concrete instance of `CustomLevelInput` via:
//
//          CustomLevelArgs{...}
type CustomLevelInput interface {
	pulumi.Input

	ToCustomLevelOutput() CustomLevelOutput
	ToCustomLevelOutputWithContext(context.Context) CustomLevelOutput
}

// `CustomLevel` is an `AccessLevel` using the Cloud Common Expression Language to represent the necessary conditions for the level to apply to a request. See CEL spec at: https://github.com/google/cel-spec
type CustomLevelArgs struct {
	// A Cloud CEL expression evaluating to a boolean.
	Expr ExprInput `pulumi:"expr"`
}

func (CustomLevelArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CustomLevel)(nil)).Elem()
}

func (i CustomLevelArgs) ToCustomLevelOutput() CustomLevelOutput {
	return i.ToCustomLevelOutputWithContext(context.Background())
}

func (i CustomLevelArgs) ToCustomLevelOutputWithContext(ctx context.Context) CustomLevelOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomLevelOutput)
}

func (i CustomLevelArgs) ToCustomLevelPtrOutput() CustomLevelPtrOutput {
	return i.ToCustomLevelPtrOutputWithContext(context.Background())
}

func (i CustomLevelArgs) ToCustomLevelPtrOutputWithContext(ctx context.Context) CustomLevelPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomLevelOutput).ToCustomLevelPtrOutputWithContext(ctx)
}

// CustomLevelPtrInput is an input type that accepts CustomLevelArgs, CustomLevelPtr and CustomLevelPtrOutput values.
// You can construct a concrete instance of `CustomLevelPtrInput` via:
//
//          CustomLevelArgs{...}
//
//  or:
//
//          nil
type CustomLevelPtrInput interface {
	pulumi.Input

	ToCustomLevelPtrOutput() CustomLevelPtrOutput
	ToCustomLevelPtrOutputWithContext(context.Context) CustomLevelPtrOutput
}

type customLevelPtrType CustomLevelArgs

func CustomLevelPtr(v *CustomLevelArgs) CustomLevelPtrInput {
	return (*customLevelPtrType)(v)
}

func (*customLevelPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CustomLevel)(nil)).Elem()
}

func (i *customLevelPtrType) ToCustomLevelPtrOutput() CustomLevelPtrOutput {
	return i.ToCustomLevelPtrOutputWithContext(context.Background())
}

func (i *customLevelPtrType) ToCustomLevelPtrOutputWithContext(ctx context.Context) CustomLevelPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomLevelPtrOutput)
}

// `CustomLevel` is an `AccessLevel` using the Cloud Common Expression Language to represent the necessary conditions for the level to apply to a request. See CEL spec at: https://github.com/google/cel-spec
type CustomLevelOutput struct{ *pulumi.OutputState }

func (CustomLevelOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CustomLevel)(nil)).Elem()
}

func (o CustomLevelOutput) ToCustomLevelOutput() CustomLevelOutput {
	return o
}

func (o CustomLevelOutput) ToCustomLevelOutputWithContext(ctx context.Context) CustomLevelOutput {
	return o
}

func (o CustomLevelOutput) ToCustomLevelPtrOutput() CustomLevelPtrOutput {
	return o.ToCustomLevelPtrOutputWithContext(context.Background())
}

func (o CustomLevelOutput) ToCustomLevelPtrOutputWithContext(ctx context.Context) CustomLevelPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CustomLevel) *CustomLevel {
		return &v
	}).(CustomLevelPtrOutput)
}

// A Cloud CEL expression evaluating to a boolean.
func (o CustomLevelOutput) Expr() ExprOutput {
	return o.ApplyT(func(v CustomLevel) Expr { return v.Expr }).(ExprOutput)
}

type CustomLevelPtrOutput struct{ *pulumi.OutputState }

func (CustomLevelPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CustomLevel)(nil)).Elem()
}

func (o CustomLevelPtrOutput) ToCustomLevelPtrOutput() CustomLevelPtrOutput {
	return o
}

func (o CustomLevelPtrOutput) ToCustomLevelPtrOutputWithContext(ctx context.Context) CustomLevelPtrOutput {
	return o
}

func (o CustomLevelPtrOutput) Elem() CustomLevelOutput {
	return o.ApplyT(func(v *CustomLevel) CustomLevel {
		if v != nil {
			return *v
		}
		var ret CustomLevel
		return ret
	}).(CustomLevelOutput)
}

// A Cloud CEL expression evaluating to a boolean.
func (o CustomLevelPtrOutput) Expr() ExprPtrOutput {
	return o.ApplyT(func(v *CustomLevel) *Expr {
		if v == nil {
			return nil
		}
		return &v.Expr
	}).(ExprPtrOutput)
}

// `CustomLevel` is an `AccessLevel` using the Cloud Common Expression Language to represent the necessary conditions for the level to apply to a request. See CEL spec at: https://github.com/google/cel-spec
type CustomLevelResponse struct {
	// A Cloud CEL expression evaluating to a boolean.
	Expr ExprResponse `pulumi:"expr"`
}

// `CustomLevel` is an `AccessLevel` using the Cloud Common Expression Language to represent the necessary conditions for the level to apply to a request. See CEL spec at: https://github.com/google/cel-spec
type CustomLevelResponseOutput struct{ *pulumi.OutputState }

func (CustomLevelResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CustomLevelResponse)(nil)).Elem()
}

func (o CustomLevelResponseOutput) ToCustomLevelResponseOutput() CustomLevelResponseOutput {
	return o
}

func (o CustomLevelResponseOutput) ToCustomLevelResponseOutputWithContext(ctx context.Context) CustomLevelResponseOutput {
	return o
}

// A Cloud CEL expression evaluating to a boolean.
func (o CustomLevelResponseOutput) Expr() ExprResponseOutput {
	return o.ApplyT(func(v CustomLevelResponse) ExprResponse { return v.Expr }).(ExprResponseOutput)
}

// `DevicePolicy` specifies device specific restrictions necessary to acquire a given access level. A `DevicePolicy` specifies requirements for requests from devices to be granted access levels, it does not do any enforcement on the device. `DevicePolicy` acts as an AND over all specified fields, and each repeated field is an OR over its elements. Any unset fields are ignored. For example, if the proto is { os_type : DESKTOP_WINDOWS, os_type : DESKTOP_LINUX, encryption_status: ENCRYPTED}, then the DevicePolicy will be true for requests originating from encrypted Linux desktops and encrypted Windows desktops.
type DevicePolicy struct {
	// Allowed device management levels, an empty list allows all management levels.
	AllowedDeviceManagementLevels []DevicePolicyAllowedDeviceManagementLevelsItem `pulumi:"allowedDeviceManagementLevels"`
	// Allowed encryptions statuses, an empty list allows all statuses.
	AllowedEncryptionStatuses []DevicePolicyAllowedEncryptionStatusesItem `pulumi:"allowedEncryptionStatuses"`
	// Allowed OS versions, an empty list allows all types and all versions.
	OsConstraints []OsConstraint `pulumi:"osConstraints"`
	// Whether the device needs to be approved by the customer admin.
	RequireAdminApproval *bool `pulumi:"requireAdminApproval"`
	// Whether the device needs to be corp owned.
	RequireCorpOwned *bool `pulumi:"requireCorpOwned"`
	// Whether or not screenlock is required for the DevicePolicy to be true. Defaults to `false`.
	RequireScreenlock *bool `pulumi:"requireScreenlock"`
}

// DevicePolicyInput is an input type that accepts DevicePolicyArgs and DevicePolicyOutput values.
// You can construct a concrete instance of `DevicePolicyInput` via:
//
//          DevicePolicyArgs{...}
type DevicePolicyInput interface {
	pulumi.Input

	ToDevicePolicyOutput() DevicePolicyOutput
	ToDevicePolicyOutputWithContext(context.Context) DevicePolicyOutput
}

// `DevicePolicy` specifies device specific restrictions necessary to acquire a given access level. A `DevicePolicy` specifies requirements for requests from devices to be granted access levels, it does not do any enforcement on the device. `DevicePolicy` acts as an AND over all specified fields, and each repeated field is an OR over its elements. Any unset fields are ignored. For example, if the proto is { os_type : DESKTOP_WINDOWS, os_type : DESKTOP_LINUX, encryption_status: ENCRYPTED}, then the DevicePolicy will be true for requests originating from encrypted Linux desktops and encrypted Windows desktops.
type DevicePolicyArgs struct {
	// Allowed device management levels, an empty list allows all management levels.
	AllowedDeviceManagementLevels DevicePolicyAllowedDeviceManagementLevelsItemArrayInput `pulumi:"allowedDeviceManagementLevels"`
	// Allowed encryptions statuses, an empty list allows all statuses.
	AllowedEncryptionStatuses DevicePolicyAllowedEncryptionStatusesItemArrayInput `pulumi:"allowedEncryptionStatuses"`
	// Allowed OS versions, an empty list allows all types and all versions.
	OsConstraints OsConstraintArrayInput `pulumi:"osConstraints"`
	// Whether the device needs to be approved by the customer admin.
	RequireAdminApproval pulumi.BoolPtrInput `pulumi:"requireAdminApproval"`
	// Whether the device needs to be corp owned.
	RequireCorpOwned pulumi.BoolPtrInput `pulumi:"requireCorpOwned"`
	// Whether or not screenlock is required for the DevicePolicy to be true. Defaults to `false`.
	RequireScreenlock pulumi.BoolPtrInput `pulumi:"requireScreenlock"`
}

func (DevicePolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DevicePolicy)(nil)).Elem()
}

func (i DevicePolicyArgs) ToDevicePolicyOutput() DevicePolicyOutput {
	return i.ToDevicePolicyOutputWithContext(context.Background())
}

func (i DevicePolicyArgs) ToDevicePolicyOutputWithContext(ctx context.Context) DevicePolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DevicePolicyOutput)
}

func (i DevicePolicyArgs) ToDevicePolicyPtrOutput() DevicePolicyPtrOutput {
	return i.ToDevicePolicyPtrOutputWithContext(context.Background())
}

func (i DevicePolicyArgs) ToDevicePolicyPtrOutputWithContext(ctx context.Context) DevicePolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DevicePolicyOutput).ToDevicePolicyPtrOutputWithContext(ctx)
}

// DevicePolicyPtrInput is an input type that accepts DevicePolicyArgs, DevicePolicyPtr and DevicePolicyPtrOutput values.
// You can construct a concrete instance of `DevicePolicyPtrInput` via:
//
//          DevicePolicyArgs{...}
//
//  or:
//
//          nil
type DevicePolicyPtrInput interface {
	pulumi.Input

	ToDevicePolicyPtrOutput() DevicePolicyPtrOutput
	ToDevicePolicyPtrOutputWithContext(context.Context) DevicePolicyPtrOutput
}

type devicePolicyPtrType DevicePolicyArgs

func DevicePolicyPtr(v *DevicePolicyArgs) DevicePolicyPtrInput {
	return (*devicePolicyPtrType)(v)
}

func (*devicePolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DevicePolicy)(nil)).Elem()
}

func (i *devicePolicyPtrType) ToDevicePolicyPtrOutput() DevicePolicyPtrOutput {
	return i.ToDevicePolicyPtrOutputWithContext(context.Background())
}

func (i *devicePolicyPtrType) ToDevicePolicyPtrOutputWithContext(ctx context.Context) DevicePolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DevicePolicyPtrOutput)
}

// `DevicePolicy` specifies device specific restrictions necessary to acquire a given access level. A `DevicePolicy` specifies requirements for requests from devices to be granted access levels, it does not do any enforcement on the device. `DevicePolicy` acts as an AND over all specified fields, and each repeated field is an OR over its elements. Any unset fields are ignored. For example, if the proto is { os_type : DESKTOP_WINDOWS, os_type : DESKTOP_LINUX, encryption_status: ENCRYPTED}, then the DevicePolicy will be true for requests originating from encrypted Linux desktops and encrypted Windows desktops.
type DevicePolicyOutput struct{ *pulumi.OutputState }

func (DevicePolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DevicePolicy)(nil)).Elem()
}

func (o DevicePolicyOutput) ToDevicePolicyOutput() DevicePolicyOutput {
	return o
}

func (o DevicePolicyOutput) ToDevicePolicyOutputWithContext(ctx context.Context) DevicePolicyOutput {
	return o
}

func (o DevicePolicyOutput) ToDevicePolicyPtrOutput() DevicePolicyPtrOutput {
	return o.ToDevicePolicyPtrOutputWithContext(context.Background())
}

func (o DevicePolicyOutput) ToDevicePolicyPtrOutputWithContext(ctx context.Context) DevicePolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DevicePolicy) *DevicePolicy {
		return &v
	}).(DevicePolicyPtrOutput)
}

// Allowed device management levels, an empty list allows all management levels.
func (o DevicePolicyOutput) AllowedDeviceManagementLevels() DevicePolicyAllowedDeviceManagementLevelsItemArrayOutput {
	return o.ApplyT(func(v DevicePolicy) []DevicePolicyAllowedDeviceManagementLevelsItem {
		return v.AllowedDeviceManagementLevels
	}).(DevicePolicyAllowedDeviceManagementLevelsItemArrayOutput)
}

// Allowed encryptions statuses, an empty list allows all statuses.
func (o DevicePolicyOutput) AllowedEncryptionStatuses() DevicePolicyAllowedEncryptionStatusesItemArrayOutput {
	return o.ApplyT(func(v DevicePolicy) []DevicePolicyAllowedEncryptionStatusesItem { return v.AllowedEncryptionStatuses }).(DevicePolicyAllowedEncryptionStatusesItemArrayOutput)
}

// Allowed OS versions, an empty list allows all types and all versions.
func (o DevicePolicyOutput) OsConstraints() OsConstraintArrayOutput {
	return o.ApplyT(func(v DevicePolicy) []OsConstraint { return v.OsConstraints }).(OsConstraintArrayOutput)
}

// Whether the device needs to be approved by the customer admin.
func (o DevicePolicyOutput) RequireAdminApproval() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DevicePolicy) *bool { return v.RequireAdminApproval }).(pulumi.BoolPtrOutput)
}

// Whether the device needs to be corp owned.
func (o DevicePolicyOutput) RequireCorpOwned() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DevicePolicy) *bool { return v.RequireCorpOwned }).(pulumi.BoolPtrOutput)
}

// Whether or not screenlock is required for the DevicePolicy to be true. Defaults to `false`.
func (o DevicePolicyOutput) RequireScreenlock() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DevicePolicy) *bool { return v.RequireScreenlock }).(pulumi.BoolPtrOutput)
}

type DevicePolicyPtrOutput struct{ *pulumi.OutputState }

func (DevicePolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DevicePolicy)(nil)).Elem()
}

func (o DevicePolicyPtrOutput) ToDevicePolicyPtrOutput() DevicePolicyPtrOutput {
	return o
}

func (o DevicePolicyPtrOutput) ToDevicePolicyPtrOutputWithContext(ctx context.Context) DevicePolicyPtrOutput {
	return o
}

func (o DevicePolicyPtrOutput) Elem() DevicePolicyOutput {
	return o.ApplyT(func(v *DevicePolicy) DevicePolicy {
		if v != nil {
			return *v
		}
		var ret DevicePolicy
		return ret
	}).(DevicePolicyOutput)
}

// Allowed device management levels, an empty list allows all management levels.
func (o DevicePolicyPtrOutput) AllowedDeviceManagementLevels() DevicePolicyAllowedDeviceManagementLevelsItemArrayOutput {
	return o.ApplyT(func(v *DevicePolicy) []DevicePolicyAllowedDeviceManagementLevelsItem {
		if v == nil {
			return nil
		}
		return v.AllowedDeviceManagementLevels
	}).(DevicePolicyAllowedDeviceManagementLevelsItemArrayOutput)
}

// Allowed encryptions statuses, an empty list allows all statuses.
func (o DevicePolicyPtrOutput) AllowedEncryptionStatuses() DevicePolicyAllowedEncryptionStatusesItemArrayOutput {
	return o.ApplyT(func(v *DevicePolicy) []DevicePolicyAllowedEncryptionStatusesItem {
		if v == nil {
			return nil
		}
		return v.AllowedEncryptionStatuses
	}).(DevicePolicyAllowedEncryptionStatusesItemArrayOutput)
}

// Allowed OS versions, an empty list allows all types and all versions.
func (o DevicePolicyPtrOutput) OsConstraints() OsConstraintArrayOutput {
	return o.ApplyT(func(v *DevicePolicy) []OsConstraint {
		if v == nil {
			return nil
		}
		return v.OsConstraints
	}).(OsConstraintArrayOutput)
}

// Whether the device needs to be approved by the customer admin.
func (o DevicePolicyPtrOutput) RequireAdminApproval() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DevicePolicy) *bool {
		if v == nil {
			return nil
		}
		return v.RequireAdminApproval
	}).(pulumi.BoolPtrOutput)
}

// Whether the device needs to be corp owned.
func (o DevicePolicyPtrOutput) RequireCorpOwned() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DevicePolicy) *bool {
		if v == nil {
			return nil
		}
		return v.RequireCorpOwned
	}).(pulumi.BoolPtrOutput)
}

// Whether or not screenlock is required for the DevicePolicy to be true. Defaults to `false`.
func (o DevicePolicyPtrOutput) RequireScreenlock() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DevicePolicy) *bool {
		if v == nil {
			return nil
		}
		return v.RequireScreenlock
	}).(pulumi.BoolPtrOutput)
}

// `DevicePolicy` specifies device specific restrictions necessary to acquire a given access level. A `DevicePolicy` specifies requirements for requests from devices to be granted access levels, it does not do any enforcement on the device. `DevicePolicy` acts as an AND over all specified fields, and each repeated field is an OR over its elements. Any unset fields are ignored. For example, if the proto is { os_type : DESKTOP_WINDOWS, os_type : DESKTOP_LINUX, encryption_status: ENCRYPTED}, then the DevicePolicy will be true for requests originating from encrypted Linux desktops and encrypted Windows desktops.
type DevicePolicyResponse struct {
	// Allowed device management levels, an empty list allows all management levels.
	AllowedDeviceManagementLevels []string `pulumi:"allowedDeviceManagementLevels"`
	// Allowed encryptions statuses, an empty list allows all statuses.
	AllowedEncryptionStatuses []string `pulumi:"allowedEncryptionStatuses"`
	// Allowed OS versions, an empty list allows all types and all versions.
	OsConstraints []OsConstraintResponse `pulumi:"osConstraints"`
	// Whether the device needs to be approved by the customer admin.
	RequireAdminApproval bool `pulumi:"requireAdminApproval"`
	// Whether the device needs to be corp owned.
	RequireCorpOwned bool `pulumi:"requireCorpOwned"`
	// Whether or not screenlock is required for the DevicePolicy to be true. Defaults to `false`.
	RequireScreenlock bool `pulumi:"requireScreenlock"`
}

// `DevicePolicy` specifies device specific restrictions necessary to acquire a given access level. A `DevicePolicy` specifies requirements for requests from devices to be granted access levels, it does not do any enforcement on the device. `DevicePolicy` acts as an AND over all specified fields, and each repeated field is an OR over its elements. Any unset fields are ignored. For example, if the proto is { os_type : DESKTOP_WINDOWS, os_type : DESKTOP_LINUX, encryption_status: ENCRYPTED}, then the DevicePolicy will be true for requests originating from encrypted Linux desktops and encrypted Windows desktops.
type DevicePolicyResponseOutput struct{ *pulumi.OutputState }

func (DevicePolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DevicePolicyResponse)(nil)).Elem()
}

func (o DevicePolicyResponseOutput) ToDevicePolicyResponseOutput() DevicePolicyResponseOutput {
	return o
}

func (o DevicePolicyResponseOutput) ToDevicePolicyResponseOutputWithContext(ctx context.Context) DevicePolicyResponseOutput {
	return o
}

// Allowed device management levels, an empty list allows all management levels.
func (o DevicePolicyResponseOutput) AllowedDeviceManagementLevels() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DevicePolicyResponse) []string { return v.AllowedDeviceManagementLevels }).(pulumi.StringArrayOutput)
}

// Allowed encryptions statuses, an empty list allows all statuses.
func (o DevicePolicyResponseOutput) AllowedEncryptionStatuses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DevicePolicyResponse) []string { return v.AllowedEncryptionStatuses }).(pulumi.StringArrayOutput)
}

// Allowed OS versions, an empty list allows all types and all versions.
func (o DevicePolicyResponseOutput) OsConstraints() OsConstraintResponseArrayOutput {
	return o.ApplyT(func(v DevicePolicyResponse) []OsConstraintResponse { return v.OsConstraints }).(OsConstraintResponseArrayOutput)
}

// Whether the device needs to be approved by the customer admin.
func (o DevicePolicyResponseOutput) RequireAdminApproval() pulumi.BoolOutput {
	return o.ApplyT(func(v DevicePolicyResponse) bool { return v.RequireAdminApproval }).(pulumi.BoolOutput)
}

// Whether the device needs to be corp owned.
func (o DevicePolicyResponseOutput) RequireCorpOwned() pulumi.BoolOutput {
	return o.ApplyT(func(v DevicePolicyResponse) bool { return v.RequireCorpOwned }).(pulumi.BoolOutput)
}

// Whether or not screenlock is required for the DevicePolicy to be true. Defaults to `false`.
func (o DevicePolicyResponseOutput) RequireScreenlock() pulumi.BoolOutput {
	return o.ApplyT(func(v DevicePolicyResponse) bool { return v.RequireScreenlock }).(pulumi.BoolOutput)
}

// Defines the conditions under which an EgressPolicy matches a request. Conditions based on information about the source of the request. Note that if the destination of the request is also protected by a ServicePerimeter, then that ServicePerimeter must have an IngressPolicy which allows access in order for this request to succeed.
type EgressFrom struct {
	// A list of identities that are allowed access through this [EgressPolicy]. Should be in the format of email address. The email address should represent individual user or service account only.
	Identities []string `pulumi:"identities"`
	// Specifies the type of identities that are allowed access to outside the perimeter. If left unspecified, then members of `identities` field will be allowed access.
	IdentityType *EgressFromIdentityType `pulumi:"identityType"`
}

// EgressFromInput is an input type that accepts EgressFromArgs and EgressFromOutput values.
// You can construct a concrete instance of `EgressFromInput` via:
//
//          EgressFromArgs{...}
type EgressFromInput interface {
	pulumi.Input

	ToEgressFromOutput() EgressFromOutput
	ToEgressFromOutputWithContext(context.Context) EgressFromOutput
}

// Defines the conditions under which an EgressPolicy matches a request. Conditions based on information about the source of the request. Note that if the destination of the request is also protected by a ServicePerimeter, then that ServicePerimeter must have an IngressPolicy which allows access in order for this request to succeed.
type EgressFromArgs struct {
	// A list of identities that are allowed access through this [EgressPolicy]. Should be in the format of email address. The email address should represent individual user or service account only.
	Identities pulumi.StringArrayInput `pulumi:"identities"`
	// Specifies the type of identities that are allowed access to outside the perimeter. If left unspecified, then members of `identities` field will be allowed access.
	IdentityType EgressFromIdentityTypePtrInput `pulumi:"identityType"`
}

func (EgressFromArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EgressFrom)(nil)).Elem()
}

func (i EgressFromArgs) ToEgressFromOutput() EgressFromOutput {
	return i.ToEgressFromOutputWithContext(context.Background())
}

func (i EgressFromArgs) ToEgressFromOutputWithContext(ctx context.Context) EgressFromOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EgressFromOutput)
}

func (i EgressFromArgs) ToEgressFromPtrOutput() EgressFromPtrOutput {
	return i.ToEgressFromPtrOutputWithContext(context.Background())
}

func (i EgressFromArgs) ToEgressFromPtrOutputWithContext(ctx context.Context) EgressFromPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EgressFromOutput).ToEgressFromPtrOutputWithContext(ctx)
}

// EgressFromPtrInput is an input type that accepts EgressFromArgs, EgressFromPtr and EgressFromPtrOutput values.
// You can construct a concrete instance of `EgressFromPtrInput` via:
//
//          EgressFromArgs{...}
//
//  or:
//
//          nil
type EgressFromPtrInput interface {
	pulumi.Input

	ToEgressFromPtrOutput() EgressFromPtrOutput
	ToEgressFromPtrOutputWithContext(context.Context) EgressFromPtrOutput
}

type egressFromPtrType EgressFromArgs

func EgressFromPtr(v *EgressFromArgs) EgressFromPtrInput {
	return (*egressFromPtrType)(v)
}

func (*egressFromPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**EgressFrom)(nil)).Elem()
}

func (i *egressFromPtrType) ToEgressFromPtrOutput() EgressFromPtrOutput {
	return i.ToEgressFromPtrOutputWithContext(context.Background())
}

func (i *egressFromPtrType) ToEgressFromPtrOutputWithContext(ctx context.Context) EgressFromPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EgressFromPtrOutput)
}

// Defines the conditions under which an EgressPolicy matches a request. Conditions based on information about the source of the request. Note that if the destination of the request is also protected by a ServicePerimeter, then that ServicePerimeter must have an IngressPolicy which allows access in order for this request to succeed.
type EgressFromOutput struct{ *pulumi.OutputState }

func (EgressFromOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EgressFrom)(nil)).Elem()
}

func (o EgressFromOutput) ToEgressFromOutput() EgressFromOutput {
	return o
}

func (o EgressFromOutput) ToEgressFromOutputWithContext(ctx context.Context) EgressFromOutput {
	return o
}

func (o EgressFromOutput) ToEgressFromPtrOutput() EgressFromPtrOutput {
	return o.ToEgressFromPtrOutputWithContext(context.Background())
}

func (o EgressFromOutput) ToEgressFromPtrOutputWithContext(ctx context.Context) EgressFromPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v EgressFrom) *EgressFrom {
		return &v
	}).(EgressFromPtrOutput)
}

// A list of identities that are allowed access through this [EgressPolicy]. Should be in the format of email address. The email address should represent individual user or service account only.
func (o EgressFromOutput) Identities() pulumi.StringArrayOutput {
	return o.ApplyT(func(v EgressFrom) []string { return v.Identities }).(pulumi.StringArrayOutput)
}

// Specifies the type of identities that are allowed access to outside the perimeter. If left unspecified, then members of `identities` field will be allowed access.
func (o EgressFromOutput) IdentityType() EgressFromIdentityTypePtrOutput {
	return o.ApplyT(func(v EgressFrom) *EgressFromIdentityType { return v.IdentityType }).(EgressFromIdentityTypePtrOutput)
}

type EgressFromPtrOutput struct{ *pulumi.OutputState }

func (EgressFromPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EgressFrom)(nil)).Elem()
}

func (o EgressFromPtrOutput) ToEgressFromPtrOutput() EgressFromPtrOutput {
	return o
}

func (o EgressFromPtrOutput) ToEgressFromPtrOutputWithContext(ctx context.Context) EgressFromPtrOutput {
	return o
}

func (o EgressFromPtrOutput) Elem() EgressFromOutput {
	return o.ApplyT(func(v *EgressFrom) EgressFrom {
		if v != nil {
			return *v
		}
		var ret EgressFrom
		return ret
	}).(EgressFromOutput)
}

// A list of identities that are allowed access through this [EgressPolicy]. Should be in the format of email address. The email address should represent individual user or service account only.
func (o EgressFromPtrOutput) Identities() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *EgressFrom) []string {
		if v == nil {
			return nil
		}
		return v.Identities
	}).(pulumi.StringArrayOutput)
}

// Specifies the type of identities that are allowed access to outside the perimeter. If left unspecified, then members of `identities` field will be allowed access.
func (o EgressFromPtrOutput) IdentityType() EgressFromIdentityTypePtrOutput {
	return o.ApplyT(func(v *EgressFrom) *EgressFromIdentityType {
		if v == nil {
			return nil
		}
		return v.IdentityType
	}).(EgressFromIdentityTypePtrOutput)
}

// Defines the conditions under which an EgressPolicy matches a request. Conditions based on information about the source of the request. Note that if the destination of the request is also protected by a ServicePerimeter, then that ServicePerimeter must have an IngressPolicy which allows access in order for this request to succeed.
type EgressFromResponse struct {
	// A list of identities that are allowed access through this [EgressPolicy]. Should be in the format of email address. The email address should represent individual user or service account only.
	Identities []string `pulumi:"identities"`
	// Specifies the type of identities that are allowed access to outside the perimeter. If left unspecified, then members of `identities` field will be allowed access.
	IdentityType string `pulumi:"identityType"`
}

// Defines the conditions under which an EgressPolicy matches a request. Conditions based on information about the source of the request. Note that if the destination of the request is also protected by a ServicePerimeter, then that ServicePerimeter must have an IngressPolicy which allows access in order for this request to succeed.
type EgressFromResponseOutput struct{ *pulumi.OutputState }

func (EgressFromResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EgressFromResponse)(nil)).Elem()
}

func (o EgressFromResponseOutput) ToEgressFromResponseOutput() EgressFromResponseOutput {
	return o
}

func (o EgressFromResponseOutput) ToEgressFromResponseOutputWithContext(ctx context.Context) EgressFromResponseOutput {
	return o
}

// A list of identities that are allowed access through this [EgressPolicy]. Should be in the format of email address. The email address should represent individual user or service account only.
func (o EgressFromResponseOutput) Identities() pulumi.StringArrayOutput {
	return o.ApplyT(func(v EgressFromResponse) []string { return v.Identities }).(pulumi.StringArrayOutput)
}

// Specifies the type of identities that are allowed access to outside the perimeter. If left unspecified, then members of `identities` field will be allowed access.
func (o EgressFromResponseOutput) IdentityType() pulumi.StringOutput {
	return o.ApplyT(func(v EgressFromResponse) string { return v.IdentityType }).(pulumi.StringOutput)
}

// Policy for egress from perimeter. EgressPolicies match requests based on `egress_from` and `egress_to` stanzas. For an EgressPolicy to match, both `egress_from` and `egress_to` stanzas must be matched. If an EgressPolicy matches a request, the request is allowed to span the ServicePerimeter boundary. For example, an EgressPolicy can be used to allow VMs on networks within the ServicePerimeter to access a defined set of projects outside the perimeter in certain contexts (e.g. to read data from a Cloud Storage bucket or query against a BigQuery dataset). EgressPolicies are concerned with the *resources* that a request relates as well as the API services and API actions being used. They do not related to the direction of data movement. More detailed documentation for this concept can be found in the descriptions of EgressFrom and EgressTo.
type EgressPolicy struct {
	// Defines conditions on the source of a request causing this EgressPolicy to apply.
	EgressFrom *EgressFrom `pulumi:"egressFrom"`
	// Defines the conditions on the ApiOperation and destination resources that cause this EgressPolicy to apply.
	EgressTo *EgressTo `pulumi:"egressTo"`
}

// EgressPolicyInput is an input type that accepts EgressPolicyArgs and EgressPolicyOutput values.
// You can construct a concrete instance of `EgressPolicyInput` via:
//
//          EgressPolicyArgs{...}
type EgressPolicyInput interface {
	pulumi.Input

	ToEgressPolicyOutput() EgressPolicyOutput
	ToEgressPolicyOutputWithContext(context.Context) EgressPolicyOutput
}

// Policy for egress from perimeter. EgressPolicies match requests based on `egress_from` and `egress_to` stanzas. For an EgressPolicy to match, both `egress_from` and `egress_to` stanzas must be matched. If an EgressPolicy matches a request, the request is allowed to span the ServicePerimeter boundary. For example, an EgressPolicy can be used to allow VMs on networks within the ServicePerimeter to access a defined set of projects outside the perimeter in certain contexts (e.g. to read data from a Cloud Storage bucket or query against a BigQuery dataset). EgressPolicies are concerned with the *resources* that a request relates as well as the API services and API actions being used. They do not related to the direction of data movement. More detailed documentation for this concept can be found in the descriptions of EgressFrom and EgressTo.
type EgressPolicyArgs struct {
	// Defines conditions on the source of a request causing this EgressPolicy to apply.
	EgressFrom EgressFromPtrInput `pulumi:"egressFrom"`
	// Defines the conditions on the ApiOperation and destination resources that cause this EgressPolicy to apply.
	EgressTo EgressToPtrInput `pulumi:"egressTo"`
}

func (EgressPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EgressPolicy)(nil)).Elem()
}

func (i EgressPolicyArgs) ToEgressPolicyOutput() EgressPolicyOutput {
	return i.ToEgressPolicyOutputWithContext(context.Background())
}

func (i EgressPolicyArgs) ToEgressPolicyOutputWithContext(ctx context.Context) EgressPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EgressPolicyOutput)
}

// EgressPolicyArrayInput is an input type that accepts EgressPolicyArray and EgressPolicyArrayOutput values.
// You can construct a concrete instance of `EgressPolicyArrayInput` via:
//
//          EgressPolicyArray{ EgressPolicyArgs{...} }
type EgressPolicyArrayInput interface {
	pulumi.Input

	ToEgressPolicyArrayOutput() EgressPolicyArrayOutput
	ToEgressPolicyArrayOutputWithContext(context.Context) EgressPolicyArrayOutput
}

type EgressPolicyArray []EgressPolicyInput

func (EgressPolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]EgressPolicy)(nil)).Elem()
}

func (i EgressPolicyArray) ToEgressPolicyArrayOutput() EgressPolicyArrayOutput {
	return i.ToEgressPolicyArrayOutputWithContext(context.Background())
}

func (i EgressPolicyArray) ToEgressPolicyArrayOutputWithContext(ctx context.Context) EgressPolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EgressPolicyArrayOutput)
}

// Policy for egress from perimeter. EgressPolicies match requests based on `egress_from` and `egress_to` stanzas. For an EgressPolicy to match, both `egress_from` and `egress_to` stanzas must be matched. If an EgressPolicy matches a request, the request is allowed to span the ServicePerimeter boundary. For example, an EgressPolicy can be used to allow VMs on networks within the ServicePerimeter to access a defined set of projects outside the perimeter in certain contexts (e.g. to read data from a Cloud Storage bucket or query against a BigQuery dataset). EgressPolicies are concerned with the *resources* that a request relates as well as the API services and API actions being used. They do not related to the direction of data movement. More detailed documentation for this concept can be found in the descriptions of EgressFrom and EgressTo.
type EgressPolicyOutput struct{ *pulumi.OutputState }

func (EgressPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EgressPolicy)(nil)).Elem()
}

func (o EgressPolicyOutput) ToEgressPolicyOutput() EgressPolicyOutput {
	return o
}

func (o EgressPolicyOutput) ToEgressPolicyOutputWithContext(ctx context.Context) EgressPolicyOutput {
	return o
}

// Defines conditions on the source of a request causing this EgressPolicy to apply.
func (o EgressPolicyOutput) EgressFrom() EgressFromPtrOutput {
	return o.ApplyT(func(v EgressPolicy) *EgressFrom { return v.EgressFrom }).(EgressFromPtrOutput)
}

// Defines the conditions on the ApiOperation and destination resources that cause this EgressPolicy to apply.
func (o EgressPolicyOutput) EgressTo() EgressToPtrOutput {
	return o.ApplyT(func(v EgressPolicy) *EgressTo { return v.EgressTo }).(EgressToPtrOutput)
}

type EgressPolicyArrayOutput struct{ *pulumi.OutputState }

func (EgressPolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]EgressPolicy)(nil)).Elem()
}

func (o EgressPolicyArrayOutput) ToEgressPolicyArrayOutput() EgressPolicyArrayOutput {
	return o
}

func (o EgressPolicyArrayOutput) ToEgressPolicyArrayOutputWithContext(ctx context.Context) EgressPolicyArrayOutput {
	return o
}

func (o EgressPolicyArrayOutput) Index(i pulumi.IntInput) EgressPolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) EgressPolicy {
		return vs[0].([]EgressPolicy)[vs[1].(int)]
	}).(EgressPolicyOutput)
}

// Policy for egress from perimeter. EgressPolicies match requests based on `egress_from` and `egress_to` stanzas. For an EgressPolicy to match, both `egress_from` and `egress_to` stanzas must be matched. If an EgressPolicy matches a request, the request is allowed to span the ServicePerimeter boundary. For example, an EgressPolicy can be used to allow VMs on networks within the ServicePerimeter to access a defined set of projects outside the perimeter in certain contexts (e.g. to read data from a Cloud Storage bucket or query against a BigQuery dataset). EgressPolicies are concerned with the *resources* that a request relates as well as the API services and API actions being used. They do not related to the direction of data movement. More detailed documentation for this concept can be found in the descriptions of EgressFrom and EgressTo.
type EgressPolicyResponse struct {
	// Defines conditions on the source of a request causing this EgressPolicy to apply.
	EgressFrom EgressFromResponse `pulumi:"egressFrom"`
	// Defines the conditions on the ApiOperation and destination resources that cause this EgressPolicy to apply.
	EgressTo EgressToResponse `pulumi:"egressTo"`
}

// Policy for egress from perimeter. EgressPolicies match requests based on `egress_from` and `egress_to` stanzas. For an EgressPolicy to match, both `egress_from` and `egress_to` stanzas must be matched. If an EgressPolicy matches a request, the request is allowed to span the ServicePerimeter boundary. For example, an EgressPolicy can be used to allow VMs on networks within the ServicePerimeter to access a defined set of projects outside the perimeter in certain contexts (e.g. to read data from a Cloud Storage bucket or query against a BigQuery dataset). EgressPolicies are concerned with the *resources* that a request relates as well as the API services and API actions being used. They do not related to the direction of data movement. More detailed documentation for this concept can be found in the descriptions of EgressFrom and EgressTo.
type EgressPolicyResponseOutput struct{ *pulumi.OutputState }

func (EgressPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EgressPolicyResponse)(nil)).Elem()
}

func (o EgressPolicyResponseOutput) ToEgressPolicyResponseOutput() EgressPolicyResponseOutput {
	return o
}

func (o EgressPolicyResponseOutput) ToEgressPolicyResponseOutputWithContext(ctx context.Context) EgressPolicyResponseOutput {
	return o
}

// Defines conditions on the source of a request causing this EgressPolicy to apply.
func (o EgressPolicyResponseOutput) EgressFrom() EgressFromResponseOutput {
	return o.ApplyT(func(v EgressPolicyResponse) EgressFromResponse { return v.EgressFrom }).(EgressFromResponseOutput)
}

// Defines the conditions on the ApiOperation and destination resources that cause this EgressPolicy to apply.
func (o EgressPolicyResponseOutput) EgressTo() EgressToResponseOutput {
	return o.ApplyT(func(v EgressPolicyResponse) EgressToResponse { return v.EgressTo }).(EgressToResponseOutput)
}

type EgressPolicyResponseArrayOutput struct{ *pulumi.OutputState }

func (EgressPolicyResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]EgressPolicyResponse)(nil)).Elem()
}

func (o EgressPolicyResponseArrayOutput) ToEgressPolicyResponseArrayOutput() EgressPolicyResponseArrayOutput {
	return o
}

func (o EgressPolicyResponseArrayOutput) ToEgressPolicyResponseArrayOutputWithContext(ctx context.Context) EgressPolicyResponseArrayOutput {
	return o
}

func (o EgressPolicyResponseArrayOutput) Index(i pulumi.IntInput) EgressPolicyResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) EgressPolicyResponse {
		return vs[0].([]EgressPolicyResponse)[vs[1].(int)]
	}).(EgressPolicyResponseOutput)
}

// Defines the conditions under which an EgressPolicy matches a request. Conditions are based on information about the ApiOperation intended to be performed on the `resources` specified. Note that if the destination of the request is also protected by a ServicePerimeter, then that ServicePerimeter must have an IngressPolicy which allows access in order for this request to succeed. The request must match `operations` AND `resources` fields in order to be allowed egress out of the perimeter.
type EgressTo struct {
	// A list of ApiOperations allowed to be performed by the sources specified in the corresponding EgressFrom. A request matches if it uses an operation/service in this list.
	Operations []ApiOperation `pulumi:"operations"`
	// A list of resources, currently only projects in the form `projects/`, that are allowed to be accessed by sources defined in the corresponding EgressFrom. A request matches if it contains a resource in this list. If `*` is specified for `resources`, then this EgressTo rule will authorize access to all resources outside the perimeter.
	Resources []string `pulumi:"resources"`
}

// EgressToInput is an input type that accepts EgressToArgs and EgressToOutput values.
// You can construct a concrete instance of `EgressToInput` via:
//
//          EgressToArgs{...}
type EgressToInput interface {
	pulumi.Input

	ToEgressToOutput() EgressToOutput
	ToEgressToOutputWithContext(context.Context) EgressToOutput
}

// Defines the conditions under which an EgressPolicy matches a request. Conditions are based on information about the ApiOperation intended to be performed on the `resources` specified. Note that if the destination of the request is also protected by a ServicePerimeter, then that ServicePerimeter must have an IngressPolicy which allows access in order for this request to succeed. The request must match `operations` AND `resources` fields in order to be allowed egress out of the perimeter.
type EgressToArgs struct {
	// A list of ApiOperations allowed to be performed by the sources specified in the corresponding EgressFrom. A request matches if it uses an operation/service in this list.
	Operations ApiOperationArrayInput `pulumi:"operations"`
	// A list of resources, currently only projects in the form `projects/`, that are allowed to be accessed by sources defined in the corresponding EgressFrom. A request matches if it contains a resource in this list. If `*` is specified for `resources`, then this EgressTo rule will authorize access to all resources outside the perimeter.
	Resources pulumi.StringArrayInput `pulumi:"resources"`
}

func (EgressToArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EgressTo)(nil)).Elem()
}

func (i EgressToArgs) ToEgressToOutput() EgressToOutput {
	return i.ToEgressToOutputWithContext(context.Background())
}

func (i EgressToArgs) ToEgressToOutputWithContext(ctx context.Context) EgressToOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EgressToOutput)
}

func (i EgressToArgs) ToEgressToPtrOutput() EgressToPtrOutput {
	return i.ToEgressToPtrOutputWithContext(context.Background())
}

func (i EgressToArgs) ToEgressToPtrOutputWithContext(ctx context.Context) EgressToPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EgressToOutput).ToEgressToPtrOutputWithContext(ctx)
}

// EgressToPtrInput is an input type that accepts EgressToArgs, EgressToPtr and EgressToPtrOutput values.
// You can construct a concrete instance of `EgressToPtrInput` via:
//
//          EgressToArgs{...}
//
//  or:
//
//          nil
type EgressToPtrInput interface {
	pulumi.Input

	ToEgressToPtrOutput() EgressToPtrOutput
	ToEgressToPtrOutputWithContext(context.Context) EgressToPtrOutput
}

type egressToPtrType EgressToArgs

func EgressToPtr(v *EgressToArgs) EgressToPtrInput {
	return (*egressToPtrType)(v)
}

func (*egressToPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**EgressTo)(nil)).Elem()
}

func (i *egressToPtrType) ToEgressToPtrOutput() EgressToPtrOutput {
	return i.ToEgressToPtrOutputWithContext(context.Background())
}

func (i *egressToPtrType) ToEgressToPtrOutputWithContext(ctx context.Context) EgressToPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EgressToPtrOutput)
}

// Defines the conditions under which an EgressPolicy matches a request. Conditions are based on information about the ApiOperation intended to be performed on the `resources` specified. Note that if the destination of the request is also protected by a ServicePerimeter, then that ServicePerimeter must have an IngressPolicy which allows access in order for this request to succeed. The request must match `operations` AND `resources` fields in order to be allowed egress out of the perimeter.
type EgressToOutput struct{ *pulumi.OutputState }

func (EgressToOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EgressTo)(nil)).Elem()
}

func (o EgressToOutput) ToEgressToOutput() EgressToOutput {
	return o
}

func (o EgressToOutput) ToEgressToOutputWithContext(ctx context.Context) EgressToOutput {
	return o
}

func (o EgressToOutput) ToEgressToPtrOutput() EgressToPtrOutput {
	return o.ToEgressToPtrOutputWithContext(context.Background())
}

func (o EgressToOutput) ToEgressToPtrOutputWithContext(ctx context.Context) EgressToPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v EgressTo) *EgressTo {
		return &v
	}).(EgressToPtrOutput)
}

// A list of ApiOperations allowed to be performed by the sources specified in the corresponding EgressFrom. A request matches if it uses an operation/service in this list.
func (o EgressToOutput) Operations() ApiOperationArrayOutput {
	return o.ApplyT(func(v EgressTo) []ApiOperation { return v.Operations }).(ApiOperationArrayOutput)
}

// A list of resources, currently only projects in the form `projects/`, that are allowed to be accessed by sources defined in the corresponding EgressFrom. A request matches if it contains a resource in this list. If `*` is specified for `resources`, then this EgressTo rule will authorize access to all resources outside the perimeter.
func (o EgressToOutput) Resources() pulumi.StringArrayOutput {
	return o.ApplyT(func(v EgressTo) []string { return v.Resources }).(pulumi.StringArrayOutput)
}

type EgressToPtrOutput struct{ *pulumi.OutputState }

func (EgressToPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EgressTo)(nil)).Elem()
}

func (o EgressToPtrOutput) ToEgressToPtrOutput() EgressToPtrOutput {
	return o
}

func (o EgressToPtrOutput) ToEgressToPtrOutputWithContext(ctx context.Context) EgressToPtrOutput {
	return o
}

func (o EgressToPtrOutput) Elem() EgressToOutput {
	return o.ApplyT(func(v *EgressTo) EgressTo {
		if v != nil {
			return *v
		}
		var ret EgressTo
		return ret
	}).(EgressToOutput)
}

// A list of ApiOperations allowed to be performed by the sources specified in the corresponding EgressFrom. A request matches if it uses an operation/service in this list.
func (o EgressToPtrOutput) Operations() ApiOperationArrayOutput {
	return o.ApplyT(func(v *EgressTo) []ApiOperation {
		if v == nil {
			return nil
		}
		return v.Operations
	}).(ApiOperationArrayOutput)
}

// A list of resources, currently only projects in the form `projects/`, that are allowed to be accessed by sources defined in the corresponding EgressFrom. A request matches if it contains a resource in this list. If `*` is specified for `resources`, then this EgressTo rule will authorize access to all resources outside the perimeter.
func (o EgressToPtrOutput) Resources() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *EgressTo) []string {
		if v == nil {
			return nil
		}
		return v.Resources
	}).(pulumi.StringArrayOutput)
}

// Defines the conditions under which an EgressPolicy matches a request. Conditions are based on information about the ApiOperation intended to be performed on the `resources` specified. Note that if the destination of the request is also protected by a ServicePerimeter, then that ServicePerimeter must have an IngressPolicy which allows access in order for this request to succeed. The request must match `operations` AND `resources` fields in order to be allowed egress out of the perimeter.
type EgressToResponse struct {
	// A list of ApiOperations allowed to be performed by the sources specified in the corresponding EgressFrom. A request matches if it uses an operation/service in this list.
	Operations []ApiOperationResponse `pulumi:"operations"`
	// A list of resources, currently only projects in the form `projects/`, that are allowed to be accessed by sources defined in the corresponding EgressFrom. A request matches if it contains a resource in this list. If `*` is specified for `resources`, then this EgressTo rule will authorize access to all resources outside the perimeter.
	Resources []string `pulumi:"resources"`
}

// Defines the conditions under which an EgressPolicy matches a request. Conditions are based on information about the ApiOperation intended to be performed on the `resources` specified. Note that if the destination of the request is also protected by a ServicePerimeter, then that ServicePerimeter must have an IngressPolicy which allows access in order for this request to succeed. The request must match `operations` AND `resources` fields in order to be allowed egress out of the perimeter.
type EgressToResponseOutput struct{ *pulumi.OutputState }

func (EgressToResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EgressToResponse)(nil)).Elem()
}

func (o EgressToResponseOutput) ToEgressToResponseOutput() EgressToResponseOutput {
	return o
}

func (o EgressToResponseOutput) ToEgressToResponseOutputWithContext(ctx context.Context) EgressToResponseOutput {
	return o
}

// A list of ApiOperations allowed to be performed by the sources specified in the corresponding EgressFrom. A request matches if it uses an operation/service in this list.
func (o EgressToResponseOutput) Operations() ApiOperationResponseArrayOutput {
	return o.ApplyT(func(v EgressToResponse) []ApiOperationResponse { return v.Operations }).(ApiOperationResponseArrayOutput)
}

// A list of resources, currently only projects in the form `projects/`, that are allowed to be accessed by sources defined in the corresponding EgressFrom. A request matches if it contains a resource in this list. If `*` is specified for `resources`, then this EgressTo rule will authorize access to all resources outside the perimeter.
func (o EgressToResponseOutput) Resources() pulumi.StringArrayOutput {
	return o.ApplyT(func(v EgressToResponse) []string { return v.Resources }).(pulumi.StringArrayOutput)
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type Expr struct {
	// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
	Description *string `pulumi:"description"`
	// Textual representation of an expression in Common Expression Language syntax.
	Expression *string `pulumi:"expression"`
	// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
	Location *string `pulumi:"location"`
	// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
	Title *string `pulumi:"title"`
}

// ExprInput is an input type that accepts ExprArgs and ExprOutput values.
// You can construct a concrete instance of `ExprInput` via:
//
//          ExprArgs{...}
type ExprInput interface {
	pulumi.Input

	ToExprOutput() ExprOutput
	ToExprOutputWithContext(context.Context) ExprOutput
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprArgs struct {
	// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Textual representation of an expression in Common Expression Language syntax.
	Expression pulumi.StringPtrInput `pulumi:"expression"`
	// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
	Location pulumi.StringPtrInput `pulumi:"location"`
	// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
	Title pulumi.StringPtrInput `pulumi:"title"`
}

func (ExprArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Expr)(nil)).Elem()
}

func (i ExprArgs) ToExprOutput() ExprOutput {
	return i.ToExprOutputWithContext(context.Background())
}

func (i ExprArgs) ToExprOutputWithContext(ctx context.Context) ExprOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExprOutput)
}

func (i ExprArgs) ToExprPtrOutput() ExprPtrOutput {
	return i.ToExprPtrOutputWithContext(context.Background())
}

func (i ExprArgs) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExprOutput).ToExprPtrOutputWithContext(ctx)
}

// ExprPtrInput is an input type that accepts ExprArgs, ExprPtr and ExprPtrOutput values.
// You can construct a concrete instance of `ExprPtrInput` via:
//
//          ExprArgs{...}
//
//  or:
//
//          nil
type ExprPtrInput interface {
	pulumi.Input

	ToExprPtrOutput() ExprPtrOutput
	ToExprPtrOutputWithContext(context.Context) ExprPtrOutput
}

type exprPtrType ExprArgs

func ExprPtr(v *ExprArgs) ExprPtrInput {
	return (*exprPtrType)(v)
}

func (*exprPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Expr)(nil)).Elem()
}

func (i *exprPtrType) ToExprPtrOutput() ExprPtrOutput {
	return i.ToExprPtrOutputWithContext(context.Background())
}

func (i *exprPtrType) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExprPtrOutput)
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprOutput struct{ *pulumi.OutputState }

func (ExprOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Expr)(nil)).Elem()
}

func (o ExprOutput) ToExprOutput() ExprOutput {
	return o
}

func (o ExprOutput) ToExprOutputWithContext(ctx context.Context) ExprOutput {
	return o
}

func (o ExprOutput) ToExprPtrOutput() ExprPtrOutput {
	return o.ToExprPtrOutputWithContext(context.Background())
}

func (o ExprOutput) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Expr) *Expr {
		return &v
	}).(ExprPtrOutput)
}

// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
func (o ExprOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Textual representation of an expression in Common Expression Language syntax.
func (o ExprOutput) Expression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Expression }).(pulumi.StringPtrOutput)
}

// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
func (o ExprOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Location }).(pulumi.StringPtrOutput)
}

// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
func (o ExprOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Title }).(pulumi.StringPtrOutput)
}

type ExprPtrOutput struct{ *pulumi.OutputState }

func (ExprPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Expr)(nil)).Elem()
}

func (o ExprPtrOutput) ToExprPtrOutput() ExprPtrOutput {
	return o
}

func (o ExprPtrOutput) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return o
}

func (o ExprPtrOutput) Elem() ExprOutput {
	return o.ApplyT(func(v *Expr) Expr {
		if v != nil {
			return *v
		}
		var ret Expr
		return ret
	}).(ExprOutput)
}

// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
func (o ExprPtrOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Description
	}).(pulumi.StringPtrOutput)
}

// Textual representation of an expression in Common Expression Language syntax.
func (o ExprPtrOutput) Expression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Expression
	}).(pulumi.StringPtrOutput)
}

// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
func (o ExprPtrOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Location
	}).(pulumi.StringPtrOutput)
}

// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
func (o ExprPtrOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Title
	}).(pulumi.StringPtrOutput)
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprResponse struct {
	// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
	Description string `pulumi:"description"`
	// Textual representation of an expression in Common Expression Language syntax.
	Expression string `pulumi:"expression"`
	// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
	Location string `pulumi:"location"`
	// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
	Title string `pulumi:"title"`
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprResponseOutput struct{ *pulumi.OutputState }

func (ExprResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ExprResponse)(nil)).Elem()
}

func (o ExprResponseOutput) ToExprResponseOutput() ExprResponseOutput {
	return o
}

func (o ExprResponseOutput) ToExprResponseOutputWithContext(ctx context.Context) ExprResponseOutput {
	return o
}

// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
func (o ExprResponseOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v ExprResponse) string { return v.Description }).(pulumi.StringOutput)
}

// Textual representation of an expression in Common Expression Language syntax.
func (o ExprResponseOutput) Expression() pulumi.StringOutput {
	return o.ApplyT(func(v ExprResponse) string { return v.Expression }).(pulumi.StringOutput)
}

// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
func (o ExprResponseOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v ExprResponse) string { return v.Location }).(pulumi.StringOutput)
}

// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
func (o ExprResponseOutput) Title() pulumi.StringOutput {
	return o.ApplyT(func(v ExprResponse) string { return v.Title }).(pulumi.StringOutput)
}

// Defines the conditions under which an IngressPolicy matches a request. Conditions are based on information about the source of the request. The request must satisfy what is defined in `sources` AND identity related fields in order to match.
type IngressFrom struct {
	// A list of identities that are allowed access through this ingress policy. Should be in the format of email address. The email address should represent individual user or service account only.
	Identities []string `pulumi:"identities"`
	// Specifies the type of identities that are allowed access from outside the perimeter. If left unspecified, then members of `identities` field will be allowed access.
	IdentityType *IngressFromIdentityType `pulumi:"identityType"`
	// Sources that this IngressPolicy authorizes access from.
	Sources []IngressSource `pulumi:"sources"`
}

// IngressFromInput is an input type that accepts IngressFromArgs and IngressFromOutput values.
// You can construct a concrete instance of `IngressFromInput` via:
//
//          IngressFromArgs{...}
type IngressFromInput interface {
	pulumi.Input

	ToIngressFromOutput() IngressFromOutput
	ToIngressFromOutputWithContext(context.Context) IngressFromOutput
}

// Defines the conditions under which an IngressPolicy matches a request. Conditions are based on information about the source of the request. The request must satisfy what is defined in `sources` AND identity related fields in order to match.
type IngressFromArgs struct {
	// A list of identities that are allowed access through this ingress policy. Should be in the format of email address. The email address should represent individual user or service account only.
	Identities pulumi.StringArrayInput `pulumi:"identities"`
	// Specifies the type of identities that are allowed access from outside the perimeter. If left unspecified, then members of `identities` field will be allowed access.
	IdentityType IngressFromIdentityTypePtrInput `pulumi:"identityType"`
	// Sources that this IngressPolicy authorizes access from.
	Sources IngressSourceArrayInput `pulumi:"sources"`
}

func (IngressFromArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IngressFrom)(nil)).Elem()
}

func (i IngressFromArgs) ToIngressFromOutput() IngressFromOutput {
	return i.ToIngressFromOutputWithContext(context.Background())
}

func (i IngressFromArgs) ToIngressFromOutputWithContext(ctx context.Context) IngressFromOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IngressFromOutput)
}

func (i IngressFromArgs) ToIngressFromPtrOutput() IngressFromPtrOutput {
	return i.ToIngressFromPtrOutputWithContext(context.Background())
}

func (i IngressFromArgs) ToIngressFromPtrOutputWithContext(ctx context.Context) IngressFromPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IngressFromOutput).ToIngressFromPtrOutputWithContext(ctx)
}

// IngressFromPtrInput is an input type that accepts IngressFromArgs, IngressFromPtr and IngressFromPtrOutput values.
// You can construct a concrete instance of `IngressFromPtrInput` via:
//
//          IngressFromArgs{...}
//
//  or:
//
//          nil
type IngressFromPtrInput interface {
	pulumi.Input

	ToIngressFromPtrOutput() IngressFromPtrOutput
	ToIngressFromPtrOutputWithContext(context.Context) IngressFromPtrOutput
}

type ingressFromPtrType IngressFromArgs

func IngressFromPtr(v *IngressFromArgs) IngressFromPtrInput {
	return (*ingressFromPtrType)(v)
}

func (*ingressFromPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IngressFrom)(nil)).Elem()
}

func (i *ingressFromPtrType) ToIngressFromPtrOutput() IngressFromPtrOutput {
	return i.ToIngressFromPtrOutputWithContext(context.Background())
}

func (i *ingressFromPtrType) ToIngressFromPtrOutputWithContext(ctx context.Context) IngressFromPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IngressFromPtrOutput)
}

// Defines the conditions under which an IngressPolicy matches a request. Conditions are based on information about the source of the request. The request must satisfy what is defined in `sources` AND identity related fields in order to match.
type IngressFromOutput struct{ *pulumi.OutputState }

func (IngressFromOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IngressFrom)(nil)).Elem()
}

func (o IngressFromOutput) ToIngressFromOutput() IngressFromOutput {
	return o
}

func (o IngressFromOutput) ToIngressFromOutputWithContext(ctx context.Context) IngressFromOutput {
	return o
}

func (o IngressFromOutput) ToIngressFromPtrOutput() IngressFromPtrOutput {
	return o.ToIngressFromPtrOutputWithContext(context.Background())
}

func (o IngressFromOutput) ToIngressFromPtrOutputWithContext(ctx context.Context) IngressFromPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v IngressFrom) *IngressFrom {
		return &v
	}).(IngressFromPtrOutput)
}

// A list of identities that are allowed access through this ingress policy. Should be in the format of email address. The email address should represent individual user or service account only.
func (o IngressFromOutput) Identities() pulumi.StringArrayOutput {
	return o.ApplyT(func(v IngressFrom) []string { return v.Identities }).(pulumi.StringArrayOutput)
}

// Specifies the type of identities that are allowed access from outside the perimeter. If left unspecified, then members of `identities` field will be allowed access.
func (o IngressFromOutput) IdentityType() IngressFromIdentityTypePtrOutput {
	return o.ApplyT(func(v IngressFrom) *IngressFromIdentityType { return v.IdentityType }).(IngressFromIdentityTypePtrOutput)
}

// Sources that this IngressPolicy authorizes access from.
func (o IngressFromOutput) Sources() IngressSourceArrayOutput {
	return o.ApplyT(func(v IngressFrom) []IngressSource { return v.Sources }).(IngressSourceArrayOutput)
}

type IngressFromPtrOutput struct{ *pulumi.OutputState }

func (IngressFromPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IngressFrom)(nil)).Elem()
}

func (o IngressFromPtrOutput) ToIngressFromPtrOutput() IngressFromPtrOutput {
	return o
}

func (o IngressFromPtrOutput) ToIngressFromPtrOutputWithContext(ctx context.Context) IngressFromPtrOutput {
	return o
}

func (o IngressFromPtrOutput) Elem() IngressFromOutput {
	return o.ApplyT(func(v *IngressFrom) IngressFrom {
		if v != nil {
			return *v
		}
		var ret IngressFrom
		return ret
	}).(IngressFromOutput)
}

// A list of identities that are allowed access through this ingress policy. Should be in the format of email address. The email address should represent individual user or service account only.
func (o IngressFromPtrOutput) Identities() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *IngressFrom) []string {
		if v == nil {
			return nil
		}
		return v.Identities
	}).(pulumi.StringArrayOutput)
}

// Specifies the type of identities that are allowed access from outside the perimeter. If left unspecified, then members of `identities` field will be allowed access.
func (o IngressFromPtrOutput) IdentityType() IngressFromIdentityTypePtrOutput {
	return o.ApplyT(func(v *IngressFrom) *IngressFromIdentityType {
		if v == nil {
			return nil
		}
		return v.IdentityType
	}).(IngressFromIdentityTypePtrOutput)
}

// Sources that this IngressPolicy authorizes access from.
func (o IngressFromPtrOutput) Sources() IngressSourceArrayOutput {
	return o.ApplyT(func(v *IngressFrom) []IngressSource {
		if v == nil {
			return nil
		}
		return v.Sources
	}).(IngressSourceArrayOutput)
}

// Defines the conditions under which an IngressPolicy matches a request. Conditions are based on information about the source of the request. The request must satisfy what is defined in `sources` AND identity related fields in order to match.
type IngressFromResponse struct {
	// A list of identities that are allowed access through this ingress policy. Should be in the format of email address. The email address should represent individual user or service account only.
	Identities []string `pulumi:"identities"`
	// Specifies the type of identities that are allowed access from outside the perimeter. If left unspecified, then members of `identities` field will be allowed access.
	IdentityType string `pulumi:"identityType"`
	// Sources that this IngressPolicy authorizes access from.
	Sources []IngressSourceResponse `pulumi:"sources"`
}

// Defines the conditions under which an IngressPolicy matches a request. Conditions are based on information about the source of the request. The request must satisfy what is defined in `sources` AND identity related fields in order to match.
type IngressFromResponseOutput struct{ *pulumi.OutputState }

func (IngressFromResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IngressFromResponse)(nil)).Elem()
}

func (o IngressFromResponseOutput) ToIngressFromResponseOutput() IngressFromResponseOutput {
	return o
}

func (o IngressFromResponseOutput) ToIngressFromResponseOutputWithContext(ctx context.Context) IngressFromResponseOutput {
	return o
}

// A list of identities that are allowed access through this ingress policy. Should be in the format of email address. The email address should represent individual user or service account only.
func (o IngressFromResponseOutput) Identities() pulumi.StringArrayOutput {
	return o.ApplyT(func(v IngressFromResponse) []string { return v.Identities }).(pulumi.StringArrayOutput)
}

// Specifies the type of identities that are allowed access from outside the perimeter. If left unspecified, then members of `identities` field will be allowed access.
func (o IngressFromResponseOutput) IdentityType() pulumi.StringOutput {
	return o.ApplyT(func(v IngressFromResponse) string { return v.IdentityType }).(pulumi.StringOutput)
}

// Sources that this IngressPolicy authorizes access from.
func (o IngressFromResponseOutput) Sources() IngressSourceResponseArrayOutput {
	return o.ApplyT(func(v IngressFromResponse) []IngressSourceResponse { return v.Sources }).(IngressSourceResponseArrayOutput)
}

// Policy for ingress into ServicePerimeter. IngressPolicies match requests based on `ingress_from` and `ingress_to` stanzas. For an ingress policy to match, both the `ingress_from` and `ingress_to` stanzas must be matched. If an IngressPolicy matches a request, the request is allowed through the perimeter boundary from outside the perimeter. For example, access from the internet can be allowed either based on an AccessLevel or, for traffic hosted on Google Cloud, the project of the source network. For access from private networks, using the project of the hosting network is required. Individual ingress policies can be limited by restricting which services and/or actions they match using the `ingress_to` field.
type IngressPolicy struct {
	// Defines the conditions on the source of a request causing this IngressPolicy to apply.
	IngressFrom *IngressFrom `pulumi:"ingressFrom"`
	// Defines the conditions on the ApiOperation and request destination that cause this IngressPolicy to apply.
	IngressTo *IngressTo `pulumi:"ingressTo"`
}

// IngressPolicyInput is an input type that accepts IngressPolicyArgs and IngressPolicyOutput values.
// You can construct a concrete instance of `IngressPolicyInput` via:
//
//          IngressPolicyArgs{...}
type IngressPolicyInput interface {
	pulumi.Input

	ToIngressPolicyOutput() IngressPolicyOutput
	ToIngressPolicyOutputWithContext(context.Context) IngressPolicyOutput
}

// Policy for ingress into ServicePerimeter. IngressPolicies match requests based on `ingress_from` and `ingress_to` stanzas. For an ingress policy to match, both the `ingress_from` and `ingress_to` stanzas must be matched. If an IngressPolicy matches a request, the request is allowed through the perimeter boundary from outside the perimeter. For example, access from the internet can be allowed either based on an AccessLevel or, for traffic hosted on Google Cloud, the project of the source network. For access from private networks, using the project of the hosting network is required. Individual ingress policies can be limited by restricting which services and/or actions they match using the `ingress_to` field.
type IngressPolicyArgs struct {
	// Defines the conditions on the source of a request causing this IngressPolicy to apply.
	IngressFrom IngressFromPtrInput `pulumi:"ingressFrom"`
	// Defines the conditions on the ApiOperation and request destination that cause this IngressPolicy to apply.
	IngressTo IngressToPtrInput `pulumi:"ingressTo"`
}

func (IngressPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IngressPolicy)(nil)).Elem()
}

func (i IngressPolicyArgs) ToIngressPolicyOutput() IngressPolicyOutput {
	return i.ToIngressPolicyOutputWithContext(context.Background())
}

func (i IngressPolicyArgs) ToIngressPolicyOutputWithContext(ctx context.Context) IngressPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IngressPolicyOutput)
}

// IngressPolicyArrayInput is an input type that accepts IngressPolicyArray and IngressPolicyArrayOutput values.
// You can construct a concrete instance of `IngressPolicyArrayInput` via:
//
//          IngressPolicyArray{ IngressPolicyArgs{...} }
type IngressPolicyArrayInput interface {
	pulumi.Input

	ToIngressPolicyArrayOutput() IngressPolicyArrayOutput
	ToIngressPolicyArrayOutputWithContext(context.Context) IngressPolicyArrayOutput
}

type IngressPolicyArray []IngressPolicyInput

func (IngressPolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IngressPolicy)(nil)).Elem()
}

func (i IngressPolicyArray) ToIngressPolicyArrayOutput() IngressPolicyArrayOutput {
	return i.ToIngressPolicyArrayOutputWithContext(context.Background())
}

func (i IngressPolicyArray) ToIngressPolicyArrayOutputWithContext(ctx context.Context) IngressPolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IngressPolicyArrayOutput)
}

// Policy for ingress into ServicePerimeter. IngressPolicies match requests based on `ingress_from` and `ingress_to` stanzas. For an ingress policy to match, both the `ingress_from` and `ingress_to` stanzas must be matched. If an IngressPolicy matches a request, the request is allowed through the perimeter boundary from outside the perimeter. For example, access from the internet can be allowed either based on an AccessLevel or, for traffic hosted on Google Cloud, the project of the source network. For access from private networks, using the project of the hosting network is required. Individual ingress policies can be limited by restricting which services and/or actions they match using the `ingress_to` field.
type IngressPolicyOutput struct{ *pulumi.OutputState }

func (IngressPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IngressPolicy)(nil)).Elem()
}

func (o IngressPolicyOutput) ToIngressPolicyOutput() IngressPolicyOutput {
	return o
}

func (o IngressPolicyOutput) ToIngressPolicyOutputWithContext(ctx context.Context) IngressPolicyOutput {
	return o
}

// Defines the conditions on the source of a request causing this IngressPolicy to apply.
func (o IngressPolicyOutput) IngressFrom() IngressFromPtrOutput {
	return o.ApplyT(func(v IngressPolicy) *IngressFrom { return v.IngressFrom }).(IngressFromPtrOutput)
}

// Defines the conditions on the ApiOperation and request destination that cause this IngressPolicy to apply.
func (o IngressPolicyOutput) IngressTo() IngressToPtrOutput {
	return o.ApplyT(func(v IngressPolicy) *IngressTo { return v.IngressTo }).(IngressToPtrOutput)
}

type IngressPolicyArrayOutput struct{ *pulumi.OutputState }

func (IngressPolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IngressPolicy)(nil)).Elem()
}

func (o IngressPolicyArrayOutput) ToIngressPolicyArrayOutput() IngressPolicyArrayOutput {
	return o
}

func (o IngressPolicyArrayOutput) ToIngressPolicyArrayOutputWithContext(ctx context.Context) IngressPolicyArrayOutput {
	return o
}

func (o IngressPolicyArrayOutput) Index(i pulumi.IntInput) IngressPolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IngressPolicy {
		return vs[0].([]IngressPolicy)[vs[1].(int)]
	}).(IngressPolicyOutput)
}

// Policy for ingress into ServicePerimeter. IngressPolicies match requests based on `ingress_from` and `ingress_to` stanzas. For an ingress policy to match, both the `ingress_from` and `ingress_to` stanzas must be matched. If an IngressPolicy matches a request, the request is allowed through the perimeter boundary from outside the perimeter. For example, access from the internet can be allowed either based on an AccessLevel or, for traffic hosted on Google Cloud, the project of the source network. For access from private networks, using the project of the hosting network is required. Individual ingress policies can be limited by restricting which services and/or actions they match using the `ingress_to` field.
type IngressPolicyResponse struct {
	// Defines the conditions on the source of a request causing this IngressPolicy to apply.
	IngressFrom IngressFromResponse `pulumi:"ingressFrom"`
	// Defines the conditions on the ApiOperation and request destination that cause this IngressPolicy to apply.
	IngressTo IngressToResponse `pulumi:"ingressTo"`
}

// Policy for ingress into ServicePerimeter. IngressPolicies match requests based on `ingress_from` and `ingress_to` stanzas. For an ingress policy to match, both the `ingress_from` and `ingress_to` stanzas must be matched. If an IngressPolicy matches a request, the request is allowed through the perimeter boundary from outside the perimeter. For example, access from the internet can be allowed either based on an AccessLevel or, for traffic hosted on Google Cloud, the project of the source network. For access from private networks, using the project of the hosting network is required. Individual ingress policies can be limited by restricting which services and/or actions they match using the `ingress_to` field.
type IngressPolicyResponseOutput struct{ *pulumi.OutputState }

func (IngressPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IngressPolicyResponse)(nil)).Elem()
}

func (o IngressPolicyResponseOutput) ToIngressPolicyResponseOutput() IngressPolicyResponseOutput {
	return o
}

func (o IngressPolicyResponseOutput) ToIngressPolicyResponseOutputWithContext(ctx context.Context) IngressPolicyResponseOutput {
	return o
}

// Defines the conditions on the source of a request causing this IngressPolicy to apply.
func (o IngressPolicyResponseOutput) IngressFrom() IngressFromResponseOutput {
	return o.ApplyT(func(v IngressPolicyResponse) IngressFromResponse { return v.IngressFrom }).(IngressFromResponseOutput)
}

// Defines the conditions on the ApiOperation and request destination that cause this IngressPolicy to apply.
func (o IngressPolicyResponseOutput) IngressTo() IngressToResponseOutput {
	return o.ApplyT(func(v IngressPolicyResponse) IngressToResponse { return v.IngressTo }).(IngressToResponseOutput)
}

type IngressPolicyResponseArrayOutput struct{ *pulumi.OutputState }

func (IngressPolicyResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IngressPolicyResponse)(nil)).Elem()
}

func (o IngressPolicyResponseArrayOutput) ToIngressPolicyResponseArrayOutput() IngressPolicyResponseArrayOutput {
	return o
}

func (o IngressPolicyResponseArrayOutput) ToIngressPolicyResponseArrayOutputWithContext(ctx context.Context) IngressPolicyResponseArrayOutput {
	return o
}

func (o IngressPolicyResponseArrayOutput) Index(i pulumi.IntInput) IngressPolicyResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IngressPolicyResponse {
		return vs[0].([]IngressPolicyResponse)[vs[1].(int)]
	}).(IngressPolicyResponseOutput)
}

// The source that IngressPolicy authorizes access from.
type IngressSource struct {
	// An AccessLevel resource name that allow resources within the ServicePerimeters to be accessed from the internet. AccessLevels listed must be in the same policy as this ServicePerimeter. Referencing a nonexistent AccessLevel will cause an error. If no AccessLevel names are listed, resources within the perimeter can only be accessed via Google Cloud calls with request origins within the perimeter. Example: `accessPolicies/MY_POLICY/accessLevels/MY_LEVEL`. If a single `*` is specified for `access_level`, then all IngressSources will be allowed.
	AccessLevel *string `pulumi:"accessLevel"`
	// A Google Cloud resource that is allowed to ingress the perimeter. Requests from these resources will be allowed to access perimeter data. Currently only projects are allowed. Format: `projects/{project_number}` The project may be in any Google Cloud organization, not just the organization that the perimeter is defined in. `*` is not allowed, the case of allowing all Google Cloud resources only is not supported.
	Resource *string `pulumi:"resource"`
}

// IngressSourceInput is an input type that accepts IngressSourceArgs and IngressSourceOutput values.
// You can construct a concrete instance of `IngressSourceInput` via:
//
//          IngressSourceArgs{...}
type IngressSourceInput interface {
	pulumi.Input

	ToIngressSourceOutput() IngressSourceOutput
	ToIngressSourceOutputWithContext(context.Context) IngressSourceOutput
}

// The source that IngressPolicy authorizes access from.
type IngressSourceArgs struct {
	// An AccessLevel resource name that allow resources within the ServicePerimeters to be accessed from the internet. AccessLevels listed must be in the same policy as this ServicePerimeter. Referencing a nonexistent AccessLevel will cause an error. If no AccessLevel names are listed, resources within the perimeter can only be accessed via Google Cloud calls with request origins within the perimeter. Example: `accessPolicies/MY_POLICY/accessLevels/MY_LEVEL`. If a single `*` is specified for `access_level`, then all IngressSources will be allowed.
	AccessLevel pulumi.StringPtrInput `pulumi:"accessLevel"`
	// A Google Cloud resource that is allowed to ingress the perimeter. Requests from these resources will be allowed to access perimeter data. Currently only projects are allowed. Format: `projects/{project_number}` The project may be in any Google Cloud organization, not just the organization that the perimeter is defined in. `*` is not allowed, the case of allowing all Google Cloud resources only is not supported.
	Resource pulumi.StringPtrInput `pulumi:"resource"`
}

func (IngressSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IngressSource)(nil)).Elem()
}

func (i IngressSourceArgs) ToIngressSourceOutput() IngressSourceOutput {
	return i.ToIngressSourceOutputWithContext(context.Background())
}

func (i IngressSourceArgs) ToIngressSourceOutputWithContext(ctx context.Context) IngressSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IngressSourceOutput)
}

// IngressSourceArrayInput is an input type that accepts IngressSourceArray and IngressSourceArrayOutput values.
// You can construct a concrete instance of `IngressSourceArrayInput` via:
//
//          IngressSourceArray{ IngressSourceArgs{...} }
type IngressSourceArrayInput interface {
	pulumi.Input

	ToIngressSourceArrayOutput() IngressSourceArrayOutput
	ToIngressSourceArrayOutputWithContext(context.Context) IngressSourceArrayOutput
}

type IngressSourceArray []IngressSourceInput

func (IngressSourceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IngressSource)(nil)).Elem()
}

func (i IngressSourceArray) ToIngressSourceArrayOutput() IngressSourceArrayOutput {
	return i.ToIngressSourceArrayOutputWithContext(context.Background())
}

func (i IngressSourceArray) ToIngressSourceArrayOutputWithContext(ctx context.Context) IngressSourceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IngressSourceArrayOutput)
}

// The source that IngressPolicy authorizes access from.
type IngressSourceOutput struct{ *pulumi.OutputState }

func (IngressSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IngressSource)(nil)).Elem()
}

func (o IngressSourceOutput) ToIngressSourceOutput() IngressSourceOutput {
	return o
}

func (o IngressSourceOutput) ToIngressSourceOutputWithContext(ctx context.Context) IngressSourceOutput {
	return o
}

// An AccessLevel resource name that allow resources within the ServicePerimeters to be accessed from the internet. AccessLevels listed must be in the same policy as this ServicePerimeter. Referencing a nonexistent AccessLevel will cause an error. If no AccessLevel names are listed, resources within the perimeter can only be accessed via Google Cloud calls with request origins within the perimeter. Example: `accessPolicies/MY_POLICY/accessLevels/MY_LEVEL`. If a single `*` is specified for `access_level`, then all IngressSources will be allowed.
func (o IngressSourceOutput) AccessLevel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IngressSource) *string { return v.AccessLevel }).(pulumi.StringPtrOutput)
}

// A Google Cloud resource that is allowed to ingress the perimeter. Requests from these resources will be allowed to access perimeter data. Currently only projects are allowed. Format: `projects/{project_number}` The project may be in any Google Cloud organization, not just the organization that the perimeter is defined in. `*` is not allowed, the case of allowing all Google Cloud resources only is not supported.
func (o IngressSourceOutput) Resource() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IngressSource) *string { return v.Resource }).(pulumi.StringPtrOutput)
}

type IngressSourceArrayOutput struct{ *pulumi.OutputState }

func (IngressSourceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IngressSource)(nil)).Elem()
}

func (o IngressSourceArrayOutput) ToIngressSourceArrayOutput() IngressSourceArrayOutput {
	return o
}

func (o IngressSourceArrayOutput) ToIngressSourceArrayOutputWithContext(ctx context.Context) IngressSourceArrayOutput {
	return o
}

func (o IngressSourceArrayOutput) Index(i pulumi.IntInput) IngressSourceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IngressSource {
		return vs[0].([]IngressSource)[vs[1].(int)]
	}).(IngressSourceOutput)
}

// The source that IngressPolicy authorizes access from.
type IngressSourceResponse struct {
	// An AccessLevel resource name that allow resources within the ServicePerimeters to be accessed from the internet. AccessLevels listed must be in the same policy as this ServicePerimeter. Referencing a nonexistent AccessLevel will cause an error. If no AccessLevel names are listed, resources within the perimeter can only be accessed via Google Cloud calls with request origins within the perimeter. Example: `accessPolicies/MY_POLICY/accessLevels/MY_LEVEL`. If a single `*` is specified for `access_level`, then all IngressSources will be allowed.
	AccessLevel string `pulumi:"accessLevel"`
	// A Google Cloud resource that is allowed to ingress the perimeter. Requests from these resources will be allowed to access perimeter data. Currently only projects are allowed. Format: `projects/{project_number}` The project may be in any Google Cloud organization, not just the organization that the perimeter is defined in. `*` is not allowed, the case of allowing all Google Cloud resources only is not supported.
	Resource string `pulumi:"resource"`
}

// The source that IngressPolicy authorizes access from.
type IngressSourceResponseOutput struct{ *pulumi.OutputState }

func (IngressSourceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IngressSourceResponse)(nil)).Elem()
}

func (o IngressSourceResponseOutput) ToIngressSourceResponseOutput() IngressSourceResponseOutput {
	return o
}

func (o IngressSourceResponseOutput) ToIngressSourceResponseOutputWithContext(ctx context.Context) IngressSourceResponseOutput {
	return o
}

// An AccessLevel resource name that allow resources within the ServicePerimeters to be accessed from the internet. AccessLevels listed must be in the same policy as this ServicePerimeter. Referencing a nonexistent AccessLevel will cause an error. If no AccessLevel names are listed, resources within the perimeter can only be accessed via Google Cloud calls with request origins within the perimeter. Example: `accessPolicies/MY_POLICY/accessLevels/MY_LEVEL`. If a single `*` is specified for `access_level`, then all IngressSources will be allowed.
func (o IngressSourceResponseOutput) AccessLevel() pulumi.StringOutput {
	return o.ApplyT(func(v IngressSourceResponse) string { return v.AccessLevel }).(pulumi.StringOutput)
}

// A Google Cloud resource that is allowed to ingress the perimeter. Requests from these resources will be allowed to access perimeter data. Currently only projects are allowed. Format: `projects/{project_number}` The project may be in any Google Cloud organization, not just the organization that the perimeter is defined in. `*` is not allowed, the case of allowing all Google Cloud resources only is not supported.
func (o IngressSourceResponseOutput) Resource() pulumi.StringOutput {
	return o.ApplyT(func(v IngressSourceResponse) string { return v.Resource }).(pulumi.StringOutput)
}

type IngressSourceResponseArrayOutput struct{ *pulumi.OutputState }

func (IngressSourceResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IngressSourceResponse)(nil)).Elem()
}

func (o IngressSourceResponseArrayOutput) ToIngressSourceResponseArrayOutput() IngressSourceResponseArrayOutput {
	return o
}

func (o IngressSourceResponseArrayOutput) ToIngressSourceResponseArrayOutputWithContext(ctx context.Context) IngressSourceResponseArrayOutput {
	return o
}

func (o IngressSourceResponseArrayOutput) Index(i pulumi.IntInput) IngressSourceResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IngressSourceResponse {
		return vs[0].([]IngressSourceResponse)[vs[1].(int)]
	}).(IngressSourceResponseOutput)
}

// Defines the conditions under which an IngressPolicy matches a request. Conditions are based on information about the ApiOperation intended to be performed on the target resource of the request. The request must satisfy what is defined in `operations` AND `resources` in order to match.
type IngressTo struct {
	// A list of ApiOperations allowed to be performed by the sources specified in corresponding IngressFrom in this ServicePerimeter.
	Operations []ApiOperation `pulumi:"operations"`
	// A list of resources, currently only projects in the form `projects/`, protected by this ServicePerimeter that are allowed to be accessed by sources defined in the corresponding IngressFrom. If a single `*` is specified, then access to all resources inside the perimeter are allowed.
	Resources []string `pulumi:"resources"`
}

// IngressToInput is an input type that accepts IngressToArgs and IngressToOutput values.
// You can construct a concrete instance of `IngressToInput` via:
//
//          IngressToArgs{...}
type IngressToInput interface {
	pulumi.Input

	ToIngressToOutput() IngressToOutput
	ToIngressToOutputWithContext(context.Context) IngressToOutput
}

// Defines the conditions under which an IngressPolicy matches a request. Conditions are based on information about the ApiOperation intended to be performed on the target resource of the request. The request must satisfy what is defined in `operations` AND `resources` in order to match.
type IngressToArgs struct {
	// A list of ApiOperations allowed to be performed by the sources specified in corresponding IngressFrom in this ServicePerimeter.
	Operations ApiOperationArrayInput `pulumi:"operations"`
	// A list of resources, currently only projects in the form `projects/`, protected by this ServicePerimeter that are allowed to be accessed by sources defined in the corresponding IngressFrom. If a single `*` is specified, then access to all resources inside the perimeter are allowed.
	Resources pulumi.StringArrayInput `pulumi:"resources"`
}

func (IngressToArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IngressTo)(nil)).Elem()
}

func (i IngressToArgs) ToIngressToOutput() IngressToOutput {
	return i.ToIngressToOutputWithContext(context.Background())
}

func (i IngressToArgs) ToIngressToOutputWithContext(ctx context.Context) IngressToOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IngressToOutput)
}

func (i IngressToArgs) ToIngressToPtrOutput() IngressToPtrOutput {
	return i.ToIngressToPtrOutputWithContext(context.Background())
}

func (i IngressToArgs) ToIngressToPtrOutputWithContext(ctx context.Context) IngressToPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IngressToOutput).ToIngressToPtrOutputWithContext(ctx)
}

// IngressToPtrInput is an input type that accepts IngressToArgs, IngressToPtr and IngressToPtrOutput values.
// You can construct a concrete instance of `IngressToPtrInput` via:
//
//          IngressToArgs{...}
//
//  or:
//
//          nil
type IngressToPtrInput interface {
	pulumi.Input

	ToIngressToPtrOutput() IngressToPtrOutput
	ToIngressToPtrOutputWithContext(context.Context) IngressToPtrOutput
}

type ingressToPtrType IngressToArgs

func IngressToPtr(v *IngressToArgs) IngressToPtrInput {
	return (*ingressToPtrType)(v)
}

func (*ingressToPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IngressTo)(nil)).Elem()
}

func (i *ingressToPtrType) ToIngressToPtrOutput() IngressToPtrOutput {
	return i.ToIngressToPtrOutputWithContext(context.Background())
}

func (i *ingressToPtrType) ToIngressToPtrOutputWithContext(ctx context.Context) IngressToPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IngressToPtrOutput)
}

// Defines the conditions under which an IngressPolicy matches a request. Conditions are based on information about the ApiOperation intended to be performed on the target resource of the request. The request must satisfy what is defined in `operations` AND `resources` in order to match.
type IngressToOutput struct{ *pulumi.OutputState }

func (IngressToOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IngressTo)(nil)).Elem()
}

func (o IngressToOutput) ToIngressToOutput() IngressToOutput {
	return o
}

func (o IngressToOutput) ToIngressToOutputWithContext(ctx context.Context) IngressToOutput {
	return o
}

func (o IngressToOutput) ToIngressToPtrOutput() IngressToPtrOutput {
	return o.ToIngressToPtrOutputWithContext(context.Background())
}

func (o IngressToOutput) ToIngressToPtrOutputWithContext(ctx context.Context) IngressToPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v IngressTo) *IngressTo {
		return &v
	}).(IngressToPtrOutput)
}

// A list of ApiOperations allowed to be performed by the sources specified in corresponding IngressFrom in this ServicePerimeter.
func (o IngressToOutput) Operations() ApiOperationArrayOutput {
	return o.ApplyT(func(v IngressTo) []ApiOperation { return v.Operations }).(ApiOperationArrayOutput)
}

// A list of resources, currently only projects in the form `projects/`, protected by this ServicePerimeter that are allowed to be accessed by sources defined in the corresponding IngressFrom. If a single `*` is specified, then access to all resources inside the perimeter are allowed.
func (o IngressToOutput) Resources() pulumi.StringArrayOutput {
	return o.ApplyT(func(v IngressTo) []string { return v.Resources }).(pulumi.StringArrayOutput)
}

type IngressToPtrOutput struct{ *pulumi.OutputState }

func (IngressToPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IngressTo)(nil)).Elem()
}

func (o IngressToPtrOutput) ToIngressToPtrOutput() IngressToPtrOutput {
	return o
}

func (o IngressToPtrOutput) ToIngressToPtrOutputWithContext(ctx context.Context) IngressToPtrOutput {
	return o
}

func (o IngressToPtrOutput) Elem() IngressToOutput {
	return o.ApplyT(func(v *IngressTo) IngressTo {
		if v != nil {
			return *v
		}
		var ret IngressTo
		return ret
	}).(IngressToOutput)
}

// A list of ApiOperations allowed to be performed by the sources specified in corresponding IngressFrom in this ServicePerimeter.
func (o IngressToPtrOutput) Operations() ApiOperationArrayOutput {
	return o.ApplyT(func(v *IngressTo) []ApiOperation {
		if v == nil {
			return nil
		}
		return v.Operations
	}).(ApiOperationArrayOutput)
}

// A list of resources, currently only projects in the form `projects/`, protected by this ServicePerimeter that are allowed to be accessed by sources defined in the corresponding IngressFrom. If a single `*` is specified, then access to all resources inside the perimeter are allowed.
func (o IngressToPtrOutput) Resources() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *IngressTo) []string {
		if v == nil {
			return nil
		}
		return v.Resources
	}).(pulumi.StringArrayOutput)
}

// Defines the conditions under which an IngressPolicy matches a request. Conditions are based on information about the ApiOperation intended to be performed on the target resource of the request. The request must satisfy what is defined in `operations` AND `resources` in order to match.
type IngressToResponse struct {
	// A list of ApiOperations allowed to be performed by the sources specified in corresponding IngressFrom in this ServicePerimeter.
	Operations []ApiOperationResponse `pulumi:"operations"`
	// A list of resources, currently only projects in the form `projects/`, protected by this ServicePerimeter that are allowed to be accessed by sources defined in the corresponding IngressFrom. If a single `*` is specified, then access to all resources inside the perimeter are allowed.
	Resources []string `pulumi:"resources"`
}

// Defines the conditions under which an IngressPolicy matches a request. Conditions are based on information about the ApiOperation intended to be performed on the target resource of the request. The request must satisfy what is defined in `operations` AND `resources` in order to match.
type IngressToResponseOutput struct{ *pulumi.OutputState }

func (IngressToResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IngressToResponse)(nil)).Elem()
}

func (o IngressToResponseOutput) ToIngressToResponseOutput() IngressToResponseOutput {
	return o
}

func (o IngressToResponseOutput) ToIngressToResponseOutputWithContext(ctx context.Context) IngressToResponseOutput {
	return o
}

// A list of ApiOperations allowed to be performed by the sources specified in corresponding IngressFrom in this ServicePerimeter.
func (o IngressToResponseOutput) Operations() ApiOperationResponseArrayOutput {
	return o.ApplyT(func(v IngressToResponse) []ApiOperationResponse { return v.Operations }).(ApiOperationResponseArrayOutput)
}

// A list of resources, currently only projects in the form `projects/`, protected by this ServicePerimeter that are allowed to be accessed by sources defined in the corresponding IngressFrom. If a single `*` is specified, then access to all resources inside the perimeter are allowed.
func (o IngressToResponseOutput) Resources() pulumi.StringArrayOutput {
	return o.ApplyT(func(v IngressToResponse) []string { return v.Resources }).(pulumi.StringArrayOutput)
}

// An allowed method or permission of a service specified in ApiOperation.
type MethodSelector struct {
	// Value for `method` should be a valid method name for the corresponding `service_name` in ApiOperation. If `*` used as value for `method`, then ALL methods and permissions are allowed.
	Method *string `pulumi:"method"`
	// Value for `permission` should be a valid Cloud IAM permission for the corresponding `service_name` in ApiOperation.
	Permission *string `pulumi:"permission"`
}

// MethodSelectorInput is an input type that accepts MethodSelectorArgs and MethodSelectorOutput values.
// You can construct a concrete instance of `MethodSelectorInput` via:
//
//          MethodSelectorArgs{...}
type MethodSelectorInput interface {
	pulumi.Input

	ToMethodSelectorOutput() MethodSelectorOutput
	ToMethodSelectorOutputWithContext(context.Context) MethodSelectorOutput
}

// An allowed method or permission of a service specified in ApiOperation.
type MethodSelectorArgs struct {
	// Value for `method` should be a valid method name for the corresponding `service_name` in ApiOperation. If `*` used as value for `method`, then ALL methods and permissions are allowed.
	Method pulumi.StringPtrInput `pulumi:"method"`
	// Value for `permission` should be a valid Cloud IAM permission for the corresponding `service_name` in ApiOperation.
	Permission pulumi.StringPtrInput `pulumi:"permission"`
}

func (MethodSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MethodSelector)(nil)).Elem()
}

func (i MethodSelectorArgs) ToMethodSelectorOutput() MethodSelectorOutput {
	return i.ToMethodSelectorOutputWithContext(context.Background())
}

func (i MethodSelectorArgs) ToMethodSelectorOutputWithContext(ctx context.Context) MethodSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MethodSelectorOutput)
}

// MethodSelectorArrayInput is an input type that accepts MethodSelectorArray and MethodSelectorArrayOutput values.
// You can construct a concrete instance of `MethodSelectorArrayInput` via:
//
//          MethodSelectorArray{ MethodSelectorArgs{...} }
type MethodSelectorArrayInput interface {
	pulumi.Input

	ToMethodSelectorArrayOutput() MethodSelectorArrayOutput
	ToMethodSelectorArrayOutputWithContext(context.Context) MethodSelectorArrayOutput
}

type MethodSelectorArray []MethodSelectorInput

func (MethodSelectorArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MethodSelector)(nil)).Elem()
}

func (i MethodSelectorArray) ToMethodSelectorArrayOutput() MethodSelectorArrayOutput {
	return i.ToMethodSelectorArrayOutputWithContext(context.Background())
}

func (i MethodSelectorArray) ToMethodSelectorArrayOutputWithContext(ctx context.Context) MethodSelectorArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MethodSelectorArrayOutput)
}

// An allowed method or permission of a service specified in ApiOperation.
type MethodSelectorOutput struct{ *pulumi.OutputState }

func (MethodSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MethodSelector)(nil)).Elem()
}

func (o MethodSelectorOutput) ToMethodSelectorOutput() MethodSelectorOutput {
	return o
}

func (o MethodSelectorOutput) ToMethodSelectorOutputWithContext(ctx context.Context) MethodSelectorOutput {
	return o
}

// Value for `method` should be a valid method name for the corresponding `service_name` in ApiOperation. If `*` used as value for `method`, then ALL methods and permissions are allowed.
func (o MethodSelectorOutput) Method() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MethodSelector) *string { return v.Method }).(pulumi.StringPtrOutput)
}

// Value for `permission` should be a valid Cloud IAM permission for the corresponding `service_name` in ApiOperation.
func (o MethodSelectorOutput) Permission() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MethodSelector) *string { return v.Permission }).(pulumi.StringPtrOutput)
}

type MethodSelectorArrayOutput struct{ *pulumi.OutputState }

func (MethodSelectorArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MethodSelector)(nil)).Elem()
}

func (o MethodSelectorArrayOutput) ToMethodSelectorArrayOutput() MethodSelectorArrayOutput {
	return o
}

func (o MethodSelectorArrayOutput) ToMethodSelectorArrayOutputWithContext(ctx context.Context) MethodSelectorArrayOutput {
	return o
}

func (o MethodSelectorArrayOutput) Index(i pulumi.IntInput) MethodSelectorOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) MethodSelector {
		return vs[0].([]MethodSelector)[vs[1].(int)]
	}).(MethodSelectorOutput)
}

// An allowed method or permission of a service specified in ApiOperation.
type MethodSelectorResponse struct {
	// Value for `method` should be a valid method name for the corresponding `service_name` in ApiOperation. If `*` used as value for `method`, then ALL methods and permissions are allowed.
	Method string `pulumi:"method"`
	// Value for `permission` should be a valid Cloud IAM permission for the corresponding `service_name` in ApiOperation.
	Permission string `pulumi:"permission"`
}

// An allowed method or permission of a service specified in ApiOperation.
type MethodSelectorResponseOutput struct{ *pulumi.OutputState }

func (MethodSelectorResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MethodSelectorResponse)(nil)).Elem()
}

func (o MethodSelectorResponseOutput) ToMethodSelectorResponseOutput() MethodSelectorResponseOutput {
	return o
}

func (o MethodSelectorResponseOutput) ToMethodSelectorResponseOutputWithContext(ctx context.Context) MethodSelectorResponseOutput {
	return o
}

// Value for `method` should be a valid method name for the corresponding `service_name` in ApiOperation. If `*` used as value for `method`, then ALL methods and permissions are allowed.
func (o MethodSelectorResponseOutput) Method() pulumi.StringOutput {
	return o.ApplyT(func(v MethodSelectorResponse) string { return v.Method }).(pulumi.StringOutput)
}

// Value for `permission` should be a valid Cloud IAM permission for the corresponding `service_name` in ApiOperation.
func (o MethodSelectorResponseOutput) Permission() pulumi.StringOutput {
	return o.ApplyT(func(v MethodSelectorResponse) string { return v.Permission }).(pulumi.StringOutput)
}

type MethodSelectorResponseArrayOutput struct{ *pulumi.OutputState }

func (MethodSelectorResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MethodSelectorResponse)(nil)).Elem()
}

func (o MethodSelectorResponseArrayOutput) ToMethodSelectorResponseArrayOutput() MethodSelectorResponseArrayOutput {
	return o
}

func (o MethodSelectorResponseArrayOutput) ToMethodSelectorResponseArrayOutputWithContext(ctx context.Context) MethodSelectorResponseArrayOutput {
	return o
}

func (o MethodSelectorResponseArrayOutput) Index(i pulumi.IntInput) MethodSelectorResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) MethodSelectorResponse {
		return vs[0].([]MethodSelectorResponse)[vs[1].(int)]
	}).(MethodSelectorResponseOutput)
}

// A restriction on the OS type and version of devices making requests.
type OsConstraint struct {
	// The minimum allowed OS version. If not set, any version of this OS satisfies the constraint. Format: `"major.minor.patch"`. Examples: `"10.5.301"`, `"9.2.1"`.
	MinimumVersion *string `pulumi:"minimumVersion"`
	// The allowed OS type.
	OsType OsConstraintOsType `pulumi:"osType"`
	// Only allows requests from devices with a verified Chrome OS. Verifications includes requirements that the device is enterprise-managed, conformant to domain policies, and the caller has permission to call the API targeted by the request.
	RequireVerifiedChromeOs *bool `pulumi:"requireVerifiedChromeOs"`
}

// OsConstraintInput is an input type that accepts OsConstraintArgs and OsConstraintOutput values.
// You can construct a concrete instance of `OsConstraintInput` via:
//
//          OsConstraintArgs{...}
type OsConstraintInput interface {
	pulumi.Input

	ToOsConstraintOutput() OsConstraintOutput
	ToOsConstraintOutputWithContext(context.Context) OsConstraintOutput
}

// A restriction on the OS type and version of devices making requests.
type OsConstraintArgs struct {
	// The minimum allowed OS version. If not set, any version of this OS satisfies the constraint. Format: `"major.minor.patch"`. Examples: `"10.5.301"`, `"9.2.1"`.
	MinimumVersion pulumi.StringPtrInput `pulumi:"minimumVersion"`
	// The allowed OS type.
	OsType OsConstraintOsTypeInput `pulumi:"osType"`
	// Only allows requests from devices with a verified Chrome OS. Verifications includes requirements that the device is enterprise-managed, conformant to domain policies, and the caller has permission to call the API targeted by the request.
	RequireVerifiedChromeOs pulumi.BoolPtrInput `pulumi:"requireVerifiedChromeOs"`
}

func (OsConstraintArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OsConstraint)(nil)).Elem()
}

func (i OsConstraintArgs) ToOsConstraintOutput() OsConstraintOutput {
	return i.ToOsConstraintOutputWithContext(context.Background())
}

func (i OsConstraintArgs) ToOsConstraintOutputWithContext(ctx context.Context) OsConstraintOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OsConstraintOutput)
}

// OsConstraintArrayInput is an input type that accepts OsConstraintArray and OsConstraintArrayOutput values.
// You can construct a concrete instance of `OsConstraintArrayInput` via:
//
//          OsConstraintArray{ OsConstraintArgs{...} }
type OsConstraintArrayInput interface {
	pulumi.Input

	ToOsConstraintArrayOutput() OsConstraintArrayOutput
	ToOsConstraintArrayOutputWithContext(context.Context) OsConstraintArrayOutput
}

type OsConstraintArray []OsConstraintInput

func (OsConstraintArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OsConstraint)(nil)).Elem()
}

func (i OsConstraintArray) ToOsConstraintArrayOutput() OsConstraintArrayOutput {
	return i.ToOsConstraintArrayOutputWithContext(context.Background())
}

func (i OsConstraintArray) ToOsConstraintArrayOutputWithContext(ctx context.Context) OsConstraintArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OsConstraintArrayOutput)
}

// A restriction on the OS type and version of devices making requests.
type OsConstraintOutput struct{ *pulumi.OutputState }

func (OsConstraintOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OsConstraint)(nil)).Elem()
}

func (o OsConstraintOutput) ToOsConstraintOutput() OsConstraintOutput {
	return o
}

func (o OsConstraintOutput) ToOsConstraintOutputWithContext(ctx context.Context) OsConstraintOutput {
	return o
}

// The minimum allowed OS version. If not set, any version of this OS satisfies the constraint. Format: `"major.minor.patch"`. Examples: `"10.5.301"`, `"9.2.1"`.
func (o OsConstraintOutput) MinimumVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OsConstraint) *string { return v.MinimumVersion }).(pulumi.StringPtrOutput)
}

// The allowed OS type.
func (o OsConstraintOutput) OsType() OsConstraintOsTypeOutput {
	return o.ApplyT(func(v OsConstraint) OsConstraintOsType { return v.OsType }).(OsConstraintOsTypeOutput)
}

// Only allows requests from devices with a verified Chrome OS. Verifications includes requirements that the device is enterprise-managed, conformant to domain policies, and the caller has permission to call the API targeted by the request.
func (o OsConstraintOutput) RequireVerifiedChromeOs() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v OsConstraint) *bool { return v.RequireVerifiedChromeOs }).(pulumi.BoolPtrOutput)
}

type OsConstraintArrayOutput struct{ *pulumi.OutputState }

func (OsConstraintArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OsConstraint)(nil)).Elem()
}

func (o OsConstraintArrayOutput) ToOsConstraintArrayOutput() OsConstraintArrayOutput {
	return o
}

func (o OsConstraintArrayOutput) ToOsConstraintArrayOutputWithContext(ctx context.Context) OsConstraintArrayOutput {
	return o
}

func (o OsConstraintArrayOutput) Index(i pulumi.IntInput) OsConstraintOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) OsConstraint {
		return vs[0].([]OsConstraint)[vs[1].(int)]
	}).(OsConstraintOutput)
}

// A restriction on the OS type and version of devices making requests.
type OsConstraintResponse struct {
	// The minimum allowed OS version. If not set, any version of this OS satisfies the constraint. Format: `"major.minor.patch"`. Examples: `"10.5.301"`, `"9.2.1"`.
	MinimumVersion string `pulumi:"minimumVersion"`
	// The allowed OS type.
	OsType string `pulumi:"osType"`
	// Only allows requests from devices with a verified Chrome OS. Verifications includes requirements that the device is enterprise-managed, conformant to domain policies, and the caller has permission to call the API targeted by the request.
	RequireVerifiedChromeOs bool `pulumi:"requireVerifiedChromeOs"`
}

// A restriction on the OS type and version of devices making requests.
type OsConstraintResponseOutput struct{ *pulumi.OutputState }

func (OsConstraintResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OsConstraintResponse)(nil)).Elem()
}

func (o OsConstraintResponseOutput) ToOsConstraintResponseOutput() OsConstraintResponseOutput {
	return o
}

func (o OsConstraintResponseOutput) ToOsConstraintResponseOutputWithContext(ctx context.Context) OsConstraintResponseOutput {
	return o
}

// The minimum allowed OS version. If not set, any version of this OS satisfies the constraint. Format: `"major.minor.patch"`. Examples: `"10.5.301"`, `"9.2.1"`.
func (o OsConstraintResponseOutput) MinimumVersion() pulumi.StringOutput {
	return o.ApplyT(func(v OsConstraintResponse) string { return v.MinimumVersion }).(pulumi.StringOutput)
}

// The allowed OS type.
func (o OsConstraintResponseOutput) OsType() pulumi.StringOutput {
	return o.ApplyT(func(v OsConstraintResponse) string { return v.OsType }).(pulumi.StringOutput)
}

// Only allows requests from devices with a verified Chrome OS. Verifications includes requirements that the device is enterprise-managed, conformant to domain policies, and the caller has permission to call the API targeted by the request.
func (o OsConstraintResponseOutput) RequireVerifiedChromeOs() pulumi.BoolOutput {
	return o.ApplyT(func(v OsConstraintResponse) bool { return v.RequireVerifiedChromeOs }).(pulumi.BoolOutput)
}

type OsConstraintResponseArrayOutput struct{ *pulumi.OutputState }

func (OsConstraintResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]OsConstraintResponse)(nil)).Elem()
}

func (o OsConstraintResponseArrayOutput) ToOsConstraintResponseArrayOutput() OsConstraintResponseArrayOutput {
	return o
}

func (o OsConstraintResponseArrayOutput) ToOsConstraintResponseArrayOutputWithContext(ctx context.Context) OsConstraintResponseArrayOutput {
	return o
}

func (o OsConstraintResponseArrayOutput) Index(i pulumi.IntInput) OsConstraintResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) OsConstraintResponse {
		return vs[0].([]OsConstraintResponse)[vs[1].(int)]
	}).(OsConstraintResponseOutput)
}

// `ServicePerimeterConfig` specifies a set of Google Cloud resources that describe specific Service Perimeter configuration.
type ServicePerimeterConfig struct {
	// A list of `AccessLevel` resource names that allow resources within the `ServicePerimeter` to be accessed from the internet. `AccessLevels` listed must be in the same policy as this `ServicePerimeter`. Referencing a nonexistent `AccessLevel` is a syntax error. If no `AccessLevel` names are listed, resources within the perimeter can only be accessed via Google Cloud calls with request origins within the perimeter. Example: `"accessPolicies/MY_POLICY/accessLevels/MY_LEVEL"`. For Service Perimeter Bridge, must be empty.
	AccessLevels []string `pulumi:"accessLevels"`
	// List of EgressPolicies to apply to the perimeter. A perimeter may have multiple EgressPolicies, each of which is evaluated separately. Access is granted if any EgressPolicy grants it. Must be empty for a perimeter bridge.
	EgressPolicies []EgressPolicy `pulumi:"egressPolicies"`
	// List of IngressPolicies to apply to the perimeter. A perimeter may have multiple IngressPolicies, each of which is evaluated separately. Access is granted if any Ingress Policy grants it. Must be empty for a perimeter bridge.
	IngressPolicies []IngressPolicy `pulumi:"ingressPolicies"`
	// A list of Google Cloud resources that are inside of the service perimeter. Currently only projects are allowed. Format: `projects/{project_number}`
	Resources []string `pulumi:"resources"`
	// Google Cloud services that are subject to the Service Perimeter restrictions. For example, if `storage.googleapis.com` is specified, access to the storage buckets inside the perimeter must meet the perimeter's access restrictions.
	RestrictedServices []string `pulumi:"restrictedServices"`
	// Configuration for APIs allowed within Perimeter.
	VpcAccessibleServices *VpcAccessibleServices `pulumi:"vpcAccessibleServices"`
}

// ServicePerimeterConfigInput is an input type that accepts ServicePerimeterConfigArgs and ServicePerimeterConfigOutput values.
// You can construct a concrete instance of `ServicePerimeterConfigInput` via:
//
//          ServicePerimeterConfigArgs{...}
type ServicePerimeterConfigInput interface {
	pulumi.Input

	ToServicePerimeterConfigOutput() ServicePerimeterConfigOutput
	ToServicePerimeterConfigOutputWithContext(context.Context) ServicePerimeterConfigOutput
}

// `ServicePerimeterConfig` specifies a set of Google Cloud resources that describe specific Service Perimeter configuration.
type ServicePerimeterConfigArgs struct {
	// A list of `AccessLevel` resource names that allow resources within the `ServicePerimeter` to be accessed from the internet. `AccessLevels` listed must be in the same policy as this `ServicePerimeter`. Referencing a nonexistent `AccessLevel` is a syntax error. If no `AccessLevel` names are listed, resources within the perimeter can only be accessed via Google Cloud calls with request origins within the perimeter. Example: `"accessPolicies/MY_POLICY/accessLevels/MY_LEVEL"`. For Service Perimeter Bridge, must be empty.
	AccessLevels pulumi.StringArrayInput `pulumi:"accessLevels"`
	// List of EgressPolicies to apply to the perimeter. A perimeter may have multiple EgressPolicies, each of which is evaluated separately. Access is granted if any EgressPolicy grants it. Must be empty for a perimeter bridge.
	EgressPolicies EgressPolicyArrayInput `pulumi:"egressPolicies"`
	// List of IngressPolicies to apply to the perimeter. A perimeter may have multiple IngressPolicies, each of which is evaluated separately. Access is granted if any Ingress Policy grants it. Must be empty for a perimeter bridge.
	IngressPolicies IngressPolicyArrayInput `pulumi:"ingressPolicies"`
	// A list of Google Cloud resources that are inside of the service perimeter. Currently only projects are allowed. Format: `projects/{project_number}`
	Resources pulumi.StringArrayInput `pulumi:"resources"`
	// Google Cloud services that are subject to the Service Perimeter restrictions. For example, if `storage.googleapis.com` is specified, access to the storage buckets inside the perimeter must meet the perimeter's access restrictions.
	RestrictedServices pulumi.StringArrayInput `pulumi:"restrictedServices"`
	// Configuration for APIs allowed within Perimeter.
	VpcAccessibleServices VpcAccessibleServicesPtrInput `pulumi:"vpcAccessibleServices"`
}

func (ServicePerimeterConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePerimeterConfig)(nil)).Elem()
}

func (i ServicePerimeterConfigArgs) ToServicePerimeterConfigOutput() ServicePerimeterConfigOutput {
	return i.ToServicePerimeterConfigOutputWithContext(context.Background())
}

func (i ServicePerimeterConfigArgs) ToServicePerimeterConfigOutputWithContext(ctx context.Context) ServicePerimeterConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServicePerimeterConfigOutput)
}

func (i ServicePerimeterConfigArgs) ToServicePerimeterConfigPtrOutput() ServicePerimeterConfigPtrOutput {
	return i.ToServicePerimeterConfigPtrOutputWithContext(context.Background())
}

func (i ServicePerimeterConfigArgs) ToServicePerimeterConfigPtrOutputWithContext(ctx context.Context) ServicePerimeterConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServicePerimeterConfigOutput).ToServicePerimeterConfigPtrOutputWithContext(ctx)
}

// ServicePerimeterConfigPtrInput is an input type that accepts ServicePerimeterConfigArgs, ServicePerimeterConfigPtr and ServicePerimeterConfigPtrOutput values.
// You can construct a concrete instance of `ServicePerimeterConfigPtrInput` via:
//
//          ServicePerimeterConfigArgs{...}
//
//  or:
//
//          nil
type ServicePerimeterConfigPtrInput interface {
	pulumi.Input

	ToServicePerimeterConfigPtrOutput() ServicePerimeterConfigPtrOutput
	ToServicePerimeterConfigPtrOutputWithContext(context.Context) ServicePerimeterConfigPtrOutput
}

type servicePerimeterConfigPtrType ServicePerimeterConfigArgs

func ServicePerimeterConfigPtr(v *ServicePerimeterConfigArgs) ServicePerimeterConfigPtrInput {
	return (*servicePerimeterConfigPtrType)(v)
}

func (*servicePerimeterConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ServicePerimeterConfig)(nil)).Elem()
}

func (i *servicePerimeterConfigPtrType) ToServicePerimeterConfigPtrOutput() ServicePerimeterConfigPtrOutput {
	return i.ToServicePerimeterConfigPtrOutputWithContext(context.Background())
}

func (i *servicePerimeterConfigPtrType) ToServicePerimeterConfigPtrOutputWithContext(ctx context.Context) ServicePerimeterConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServicePerimeterConfigPtrOutput)
}

// `ServicePerimeterConfig` specifies a set of Google Cloud resources that describe specific Service Perimeter configuration.
type ServicePerimeterConfigOutput struct{ *pulumi.OutputState }

func (ServicePerimeterConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePerimeterConfig)(nil)).Elem()
}

func (o ServicePerimeterConfigOutput) ToServicePerimeterConfigOutput() ServicePerimeterConfigOutput {
	return o
}

func (o ServicePerimeterConfigOutput) ToServicePerimeterConfigOutputWithContext(ctx context.Context) ServicePerimeterConfigOutput {
	return o
}

func (o ServicePerimeterConfigOutput) ToServicePerimeterConfigPtrOutput() ServicePerimeterConfigPtrOutput {
	return o.ToServicePerimeterConfigPtrOutputWithContext(context.Background())
}

func (o ServicePerimeterConfigOutput) ToServicePerimeterConfigPtrOutputWithContext(ctx context.Context) ServicePerimeterConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ServicePerimeterConfig) *ServicePerimeterConfig {
		return &v
	}).(ServicePerimeterConfigPtrOutput)
}

// A list of `AccessLevel` resource names that allow resources within the `ServicePerimeter` to be accessed from the internet. `AccessLevels` listed must be in the same policy as this `ServicePerimeter`. Referencing a nonexistent `AccessLevel` is a syntax error. If no `AccessLevel` names are listed, resources within the perimeter can only be accessed via Google Cloud calls with request origins within the perimeter. Example: `"accessPolicies/MY_POLICY/accessLevels/MY_LEVEL"`. For Service Perimeter Bridge, must be empty.
func (o ServicePerimeterConfigOutput) AccessLevels() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ServicePerimeterConfig) []string { return v.AccessLevels }).(pulumi.StringArrayOutput)
}

// List of EgressPolicies to apply to the perimeter. A perimeter may have multiple EgressPolicies, each of which is evaluated separately. Access is granted if any EgressPolicy grants it. Must be empty for a perimeter bridge.
func (o ServicePerimeterConfigOutput) EgressPolicies() EgressPolicyArrayOutput {
	return o.ApplyT(func(v ServicePerimeterConfig) []EgressPolicy { return v.EgressPolicies }).(EgressPolicyArrayOutput)
}

// List of IngressPolicies to apply to the perimeter. A perimeter may have multiple IngressPolicies, each of which is evaluated separately. Access is granted if any Ingress Policy grants it. Must be empty for a perimeter bridge.
func (o ServicePerimeterConfigOutput) IngressPolicies() IngressPolicyArrayOutput {
	return o.ApplyT(func(v ServicePerimeterConfig) []IngressPolicy { return v.IngressPolicies }).(IngressPolicyArrayOutput)
}

// A list of Google Cloud resources that are inside of the service perimeter. Currently only projects are allowed. Format: `projects/{project_number}`
func (o ServicePerimeterConfigOutput) Resources() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ServicePerimeterConfig) []string { return v.Resources }).(pulumi.StringArrayOutput)
}

// Google Cloud services that are subject to the Service Perimeter restrictions. For example, if `storage.googleapis.com` is specified, access to the storage buckets inside the perimeter must meet the perimeter's access restrictions.
func (o ServicePerimeterConfigOutput) RestrictedServices() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ServicePerimeterConfig) []string { return v.RestrictedServices }).(pulumi.StringArrayOutput)
}

// Configuration for APIs allowed within Perimeter.
func (o ServicePerimeterConfigOutput) VpcAccessibleServices() VpcAccessibleServicesPtrOutput {
	return o.ApplyT(func(v ServicePerimeterConfig) *VpcAccessibleServices { return v.VpcAccessibleServices }).(VpcAccessibleServicesPtrOutput)
}

type ServicePerimeterConfigPtrOutput struct{ *pulumi.OutputState }

func (ServicePerimeterConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServicePerimeterConfig)(nil)).Elem()
}

func (o ServicePerimeterConfigPtrOutput) ToServicePerimeterConfigPtrOutput() ServicePerimeterConfigPtrOutput {
	return o
}

func (o ServicePerimeterConfigPtrOutput) ToServicePerimeterConfigPtrOutputWithContext(ctx context.Context) ServicePerimeterConfigPtrOutput {
	return o
}

func (o ServicePerimeterConfigPtrOutput) Elem() ServicePerimeterConfigOutput {
	return o.ApplyT(func(v *ServicePerimeterConfig) ServicePerimeterConfig {
		if v != nil {
			return *v
		}
		var ret ServicePerimeterConfig
		return ret
	}).(ServicePerimeterConfigOutput)
}

// A list of `AccessLevel` resource names that allow resources within the `ServicePerimeter` to be accessed from the internet. `AccessLevels` listed must be in the same policy as this `ServicePerimeter`. Referencing a nonexistent `AccessLevel` is a syntax error. If no `AccessLevel` names are listed, resources within the perimeter can only be accessed via Google Cloud calls with request origins within the perimeter. Example: `"accessPolicies/MY_POLICY/accessLevels/MY_LEVEL"`. For Service Perimeter Bridge, must be empty.
func (o ServicePerimeterConfigPtrOutput) AccessLevels() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ServicePerimeterConfig) []string {
		if v == nil {
			return nil
		}
		return v.AccessLevels
	}).(pulumi.StringArrayOutput)
}

// List of EgressPolicies to apply to the perimeter. A perimeter may have multiple EgressPolicies, each of which is evaluated separately. Access is granted if any EgressPolicy grants it. Must be empty for a perimeter bridge.
func (o ServicePerimeterConfigPtrOutput) EgressPolicies() EgressPolicyArrayOutput {
	return o.ApplyT(func(v *ServicePerimeterConfig) []EgressPolicy {
		if v == nil {
			return nil
		}
		return v.EgressPolicies
	}).(EgressPolicyArrayOutput)
}

// List of IngressPolicies to apply to the perimeter. A perimeter may have multiple IngressPolicies, each of which is evaluated separately. Access is granted if any Ingress Policy grants it. Must be empty for a perimeter bridge.
func (o ServicePerimeterConfigPtrOutput) IngressPolicies() IngressPolicyArrayOutput {
	return o.ApplyT(func(v *ServicePerimeterConfig) []IngressPolicy {
		if v == nil {
			return nil
		}
		return v.IngressPolicies
	}).(IngressPolicyArrayOutput)
}

// A list of Google Cloud resources that are inside of the service perimeter. Currently only projects are allowed. Format: `projects/{project_number}`
func (o ServicePerimeterConfigPtrOutput) Resources() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ServicePerimeterConfig) []string {
		if v == nil {
			return nil
		}
		return v.Resources
	}).(pulumi.StringArrayOutput)
}

// Google Cloud services that are subject to the Service Perimeter restrictions. For example, if `storage.googleapis.com` is specified, access to the storage buckets inside the perimeter must meet the perimeter's access restrictions.
func (o ServicePerimeterConfigPtrOutput) RestrictedServices() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ServicePerimeterConfig) []string {
		if v == nil {
			return nil
		}
		return v.RestrictedServices
	}).(pulumi.StringArrayOutput)
}

// Configuration for APIs allowed within Perimeter.
func (o ServicePerimeterConfigPtrOutput) VpcAccessibleServices() VpcAccessibleServicesPtrOutput {
	return o.ApplyT(func(v *ServicePerimeterConfig) *VpcAccessibleServices {
		if v == nil {
			return nil
		}
		return v.VpcAccessibleServices
	}).(VpcAccessibleServicesPtrOutput)
}

// `ServicePerimeterConfig` specifies a set of Google Cloud resources that describe specific Service Perimeter configuration.
type ServicePerimeterConfigResponse struct {
	// A list of `AccessLevel` resource names that allow resources within the `ServicePerimeter` to be accessed from the internet. `AccessLevels` listed must be in the same policy as this `ServicePerimeter`. Referencing a nonexistent `AccessLevel` is a syntax error. If no `AccessLevel` names are listed, resources within the perimeter can only be accessed via Google Cloud calls with request origins within the perimeter. Example: `"accessPolicies/MY_POLICY/accessLevels/MY_LEVEL"`. For Service Perimeter Bridge, must be empty.
	AccessLevels []string `pulumi:"accessLevels"`
	// List of EgressPolicies to apply to the perimeter. A perimeter may have multiple EgressPolicies, each of which is evaluated separately. Access is granted if any EgressPolicy grants it. Must be empty for a perimeter bridge.
	EgressPolicies []EgressPolicyResponse `pulumi:"egressPolicies"`
	// List of IngressPolicies to apply to the perimeter. A perimeter may have multiple IngressPolicies, each of which is evaluated separately. Access is granted if any Ingress Policy grants it. Must be empty for a perimeter bridge.
	IngressPolicies []IngressPolicyResponse `pulumi:"ingressPolicies"`
	// A list of Google Cloud resources that are inside of the service perimeter. Currently only projects are allowed. Format: `projects/{project_number}`
	Resources []string `pulumi:"resources"`
	// Google Cloud services that are subject to the Service Perimeter restrictions. For example, if `storage.googleapis.com` is specified, access to the storage buckets inside the perimeter must meet the perimeter's access restrictions.
	RestrictedServices []string `pulumi:"restrictedServices"`
	// Configuration for APIs allowed within Perimeter.
	VpcAccessibleServices VpcAccessibleServicesResponse `pulumi:"vpcAccessibleServices"`
}

// `ServicePerimeterConfig` specifies a set of Google Cloud resources that describe specific Service Perimeter configuration.
type ServicePerimeterConfigResponseOutput struct{ *pulumi.OutputState }

func (ServicePerimeterConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServicePerimeterConfigResponse)(nil)).Elem()
}

func (o ServicePerimeterConfigResponseOutput) ToServicePerimeterConfigResponseOutput() ServicePerimeterConfigResponseOutput {
	return o
}

func (o ServicePerimeterConfigResponseOutput) ToServicePerimeterConfigResponseOutputWithContext(ctx context.Context) ServicePerimeterConfigResponseOutput {
	return o
}

// A list of `AccessLevel` resource names that allow resources within the `ServicePerimeter` to be accessed from the internet. `AccessLevels` listed must be in the same policy as this `ServicePerimeter`. Referencing a nonexistent `AccessLevel` is a syntax error. If no `AccessLevel` names are listed, resources within the perimeter can only be accessed via Google Cloud calls with request origins within the perimeter. Example: `"accessPolicies/MY_POLICY/accessLevels/MY_LEVEL"`. For Service Perimeter Bridge, must be empty.
func (o ServicePerimeterConfigResponseOutput) AccessLevels() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ServicePerimeterConfigResponse) []string { return v.AccessLevels }).(pulumi.StringArrayOutput)
}

// List of EgressPolicies to apply to the perimeter. A perimeter may have multiple EgressPolicies, each of which is evaluated separately. Access is granted if any EgressPolicy grants it. Must be empty for a perimeter bridge.
func (o ServicePerimeterConfigResponseOutput) EgressPolicies() EgressPolicyResponseArrayOutput {
	return o.ApplyT(func(v ServicePerimeterConfigResponse) []EgressPolicyResponse { return v.EgressPolicies }).(EgressPolicyResponseArrayOutput)
}

// List of IngressPolicies to apply to the perimeter. A perimeter may have multiple IngressPolicies, each of which is evaluated separately. Access is granted if any Ingress Policy grants it. Must be empty for a perimeter bridge.
func (o ServicePerimeterConfigResponseOutput) IngressPolicies() IngressPolicyResponseArrayOutput {
	return o.ApplyT(func(v ServicePerimeterConfigResponse) []IngressPolicyResponse { return v.IngressPolicies }).(IngressPolicyResponseArrayOutput)
}

// A list of Google Cloud resources that are inside of the service perimeter. Currently only projects are allowed. Format: `projects/{project_number}`
func (o ServicePerimeterConfigResponseOutput) Resources() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ServicePerimeterConfigResponse) []string { return v.Resources }).(pulumi.StringArrayOutput)
}

// Google Cloud services that are subject to the Service Perimeter restrictions. For example, if `storage.googleapis.com` is specified, access to the storage buckets inside the perimeter must meet the perimeter's access restrictions.
func (o ServicePerimeterConfigResponseOutput) RestrictedServices() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ServicePerimeterConfigResponse) []string { return v.RestrictedServices }).(pulumi.StringArrayOutput)
}

// Configuration for APIs allowed within Perimeter.
func (o ServicePerimeterConfigResponseOutput) VpcAccessibleServices() VpcAccessibleServicesResponseOutput {
	return o.ApplyT(func(v ServicePerimeterConfigResponse) VpcAccessibleServicesResponse { return v.VpcAccessibleServices }).(VpcAccessibleServicesResponseOutput)
}

// Specifies how APIs are allowed to communicate within the Service Perimeter.
type VpcAccessibleServices struct {
	// The list of APIs usable within the Service Perimeter. Must be empty unless 'enable_restriction' is True. You can specify a list of individual services, as well as include the 'RESTRICTED-SERVICES' value, which automatically includes all of the services protected by the perimeter.
	AllowedServices []string `pulumi:"allowedServices"`
	// Whether to restrict API calls within the Service Perimeter to the list of APIs specified in 'allowed_services'.
	EnableRestriction *bool `pulumi:"enableRestriction"`
}

// VpcAccessibleServicesInput is an input type that accepts VpcAccessibleServicesArgs and VpcAccessibleServicesOutput values.
// You can construct a concrete instance of `VpcAccessibleServicesInput` via:
//
//          VpcAccessibleServicesArgs{...}
type VpcAccessibleServicesInput interface {
	pulumi.Input

	ToVpcAccessibleServicesOutput() VpcAccessibleServicesOutput
	ToVpcAccessibleServicesOutputWithContext(context.Context) VpcAccessibleServicesOutput
}

// Specifies how APIs are allowed to communicate within the Service Perimeter.
type VpcAccessibleServicesArgs struct {
	// The list of APIs usable within the Service Perimeter. Must be empty unless 'enable_restriction' is True. You can specify a list of individual services, as well as include the 'RESTRICTED-SERVICES' value, which automatically includes all of the services protected by the perimeter.
	AllowedServices pulumi.StringArrayInput `pulumi:"allowedServices"`
	// Whether to restrict API calls within the Service Perimeter to the list of APIs specified in 'allowed_services'.
	EnableRestriction pulumi.BoolPtrInput `pulumi:"enableRestriction"`
}

func (VpcAccessibleServicesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VpcAccessibleServices)(nil)).Elem()
}

func (i VpcAccessibleServicesArgs) ToVpcAccessibleServicesOutput() VpcAccessibleServicesOutput {
	return i.ToVpcAccessibleServicesOutputWithContext(context.Background())
}

func (i VpcAccessibleServicesArgs) ToVpcAccessibleServicesOutputWithContext(ctx context.Context) VpcAccessibleServicesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpcAccessibleServicesOutput)
}

func (i VpcAccessibleServicesArgs) ToVpcAccessibleServicesPtrOutput() VpcAccessibleServicesPtrOutput {
	return i.ToVpcAccessibleServicesPtrOutputWithContext(context.Background())
}

func (i VpcAccessibleServicesArgs) ToVpcAccessibleServicesPtrOutputWithContext(ctx context.Context) VpcAccessibleServicesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpcAccessibleServicesOutput).ToVpcAccessibleServicesPtrOutputWithContext(ctx)
}

// VpcAccessibleServicesPtrInput is an input type that accepts VpcAccessibleServicesArgs, VpcAccessibleServicesPtr and VpcAccessibleServicesPtrOutput values.
// You can construct a concrete instance of `VpcAccessibleServicesPtrInput` via:
//
//          VpcAccessibleServicesArgs{...}
//
//  or:
//
//          nil
type VpcAccessibleServicesPtrInput interface {
	pulumi.Input

	ToVpcAccessibleServicesPtrOutput() VpcAccessibleServicesPtrOutput
	ToVpcAccessibleServicesPtrOutputWithContext(context.Context) VpcAccessibleServicesPtrOutput
}

type vpcAccessibleServicesPtrType VpcAccessibleServicesArgs

func VpcAccessibleServicesPtr(v *VpcAccessibleServicesArgs) VpcAccessibleServicesPtrInput {
	return (*vpcAccessibleServicesPtrType)(v)
}

func (*vpcAccessibleServicesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**VpcAccessibleServices)(nil)).Elem()
}

func (i *vpcAccessibleServicesPtrType) ToVpcAccessibleServicesPtrOutput() VpcAccessibleServicesPtrOutput {
	return i.ToVpcAccessibleServicesPtrOutputWithContext(context.Background())
}

func (i *vpcAccessibleServicesPtrType) ToVpcAccessibleServicesPtrOutputWithContext(ctx context.Context) VpcAccessibleServicesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpcAccessibleServicesPtrOutput)
}

// Specifies how APIs are allowed to communicate within the Service Perimeter.
type VpcAccessibleServicesOutput struct{ *pulumi.OutputState }

func (VpcAccessibleServicesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VpcAccessibleServices)(nil)).Elem()
}

func (o VpcAccessibleServicesOutput) ToVpcAccessibleServicesOutput() VpcAccessibleServicesOutput {
	return o
}

func (o VpcAccessibleServicesOutput) ToVpcAccessibleServicesOutputWithContext(ctx context.Context) VpcAccessibleServicesOutput {
	return o
}

func (o VpcAccessibleServicesOutput) ToVpcAccessibleServicesPtrOutput() VpcAccessibleServicesPtrOutput {
	return o.ToVpcAccessibleServicesPtrOutputWithContext(context.Background())
}

func (o VpcAccessibleServicesOutput) ToVpcAccessibleServicesPtrOutputWithContext(ctx context.Context) VpcAccessibleServicesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v VpcAccessibleServices) *VpcAccessibleServices {
		return &v
	}).(VpcAccessibleServicesPtrOutput)
}

// The list of APIs usable within the Service Perimeter. Must be empty unless 'enable_restriction' is True. You can specify a list of individual services, as well as include the 'RESTRICTED-SERVICES' value, which automatically includes all of the services protected by the perimeter.
func (o VpcAccessibleServicesOutput) AllowedServices() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VpcAccessibleServices) []string { return v.AllowedServices }).(pulumi.StringArrayOutput)
}

// Whether to restrict API calls within the Service Perimeter to the list of APIs specified in 'allowed_services'.
func (o VpcAccessibleServicesOutput) EnableRestriction() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VpcAccessibleServices) *bool { return v.EnableRestriction }).(pulumi.BoolPtrOutput)
}

type VpcAccessibleServicesPtrOutput struct{ *pulumi.OutputState }

func (VpcAccessibleServicesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VpcAccessibleServices)(nil)).Elem()
}

func (o VpcAccessibleServicesPtrOutput) ToVpcAccessibleServicesPtrOutput() VpcAccessibleServicesPtrOutput {
	return o
}

func (o VpcAccessibleServicesPtrOutput) ToVpcAccessibleServicesPtrOutputWithContext(ctx context.Context) VpcAccessibleServicesPtrOutput {
	return o
}

func (o VpcAccessibleServicesPtrOutput) Elem() VpcAccessibleServicesOutput {
	return o.ApplyT(func(v *VpcAccessibleServices) VpcAccessibleServices {
		if v != nil {
			return *v
		}
		var ret VpcAccessibleServices
		return ret
	}).(VpcAccessibleServicesOutput)
}

// The list of APIs usable within the Service Perimeter. Must be empty unless 'enable_restriction' is True. You can specify a list of individual services, as well as include the 'RESTRICTED-SERVICES' value, which automatically includes all of the services protected by the perimeter.
func (o VpcAccessibleServicesPtrOutput) AllowedServices() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *VpcAccessibleServices) []string {
		if v == nil {
			return nil
		}
		return v.AllowedServices
	}).(pulumi.StringArrayOutput)
}

// Whether to restrict API calls within the Service Perimeter to the list of APIs specified in 'allowed_services'.
func (o VpcAccessibleServicesPtrOutput) EnableRestriction() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VpcAccessibleServices) *bool {
		if v == nil {
			return nil
		}
		return v.EnableRestriction
	}).(pulumi.BoolPtrOutput)
}

// Specifies how APIs are allowed to communicate within the Service Perimeter.
type VpcAccessibleServicesResponse struct {
	// The list of APIs usable within the Service Perimeter. Must be empty unless 'enable_restriction' is True. You can specify a list of individual services, as well as include the 'RESTRICTED-SERVICES' value, which automatically includes all of the services protected by the perimeter.
	AllowedServices []string `pulumi:"allowedServices"`
	// Whether to restrict API calls within the Service Perimeter to the list of APIs specified in 'allowed_services'.
	EnableRestriction bool `pulumi:"enableRestriction"`
}

// Specifies how APIs are allowed to communicate within the Service Perimeter.
type VpcAccessibleServicesResponseOutput struct{ *pulumi.OutputState }

func (VpcAccessibleServicesResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VpcAccessibleServicesResponse)(nil)).Elem()
}

func (o VpcAccessibleServicesResponseOutput) ToVpcAccessibleServicesResponseOutput() VpcAccessibleServicesResponseOutput {
	return o
}

func (o VpcAccessibleServicesResponseOutput) ToVpcAccessibleServicesResponseOutputWithContext(ctx context.Context) VpcAccessibleServicesResponseOutput {
	return o
}

// The list of APIs usable within the Service Perimeter. Must be empty unless 'enable_restriction' is True. You can specify a list of individual services, as well as include the 'RESTRICTED-SERVICES' value, which automatically includes all of the services protected by the perimeter.
func (o VpcAccessibleServicesResponseOutput) AllowedServices() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VpcAccessibleServicesResponse) []string { return v.AllowedServices }).(pulumi.StringArrayOutput)
}

// Whether to restrict API calls within the Service Perimeter to the list of APIs specified in 'allowed_services'.
func (o VpcAccessibleServicesResponseOutput) EnableRestriction() pulumi.BoolOutput {
	return o.ApplyT(func(v VpcAccessibleServicesResponse) bool { return v.EnableRestriction }).(pulumi.BoolOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ApiOperationInput)(nil)).Elem(), ApiOperationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ApiOperationArrayInput)(nil)).Elem(), ApiOperationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*BasicLevelInput)(nil)).Elem(), BasicLevelArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BasicLevelPtrInput)(nil)).Elem(), BasicLevelArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConditionInput)(nil)).Elem(), ConditionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConditionArrayInput)(nil)).Elem(), ConditionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CustomLevelInput)(nil)).Elem(), CustomLevelArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CustomLevelPtrInput)(nil)).Elem(), CustomLevelArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DevicePolicyInput)(nil)).Elem(), DevicePolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DevicePolicyPtrInput)(nil)).Elem(), DevicePolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*EgressFromInput)(nil)).Elem(), EgressFromArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*EgressFromPtrInput)(nil)).Elem(), EgressFromArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*EgressPolicyInput)(nil)).Elem(), EgressPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*EgressPolicyArrayInput)(nil)).Elem(), EgressPolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*EgressToInput)(nil)).Elem(), EgressToArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*EgressToPtrInput)(nil)).Elem(), EgressToArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ExprInput)(nil)).Elem(), ExprArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ExprPtrInput)(nil)).Elem(), ExprArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IngressFromInput)(nil)).Elem(), IngressFromArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IngressFromPtrInput)(nil)).Elem(), IngressFromArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IngressPolicyInput)(nil)).Elem(), IngressPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IngressPolicyArrayInput)(nil)).Elem(), IngressPolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IngressSourceInput)(nil)).Elem(), IngressSourceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IngressSourceArrayInput)(nil)).Elem(), IngressSourceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IngressToInput)(nil)).Elem(), IngressToArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IngressToPtrInput)(nil)).Elem(), IngressToArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MethodSelectorInput)(nil)).Elem(), MethodSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MethodSelectorArrayInput)(nil)).Elem(), MethodSelectorArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*OsConstraintInput)(nil)).Elem(), OsConstraintArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OsConstraintArrayInput)(nil)).Elem(), OsConstraintArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServicePerimeterConfigInput)(nil)).Elem(), ServicePerimeterConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServicePerimeterConfigPtrInput)(nil)).Elem(), ServicePerimeterConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VpcAccessibleServicesInput)(nil)).Elem(), VpcAccessibleServicesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VpcAccessibleServicesPtrInput)(nil)).Elem(), VpcAccessibleServicesArgs{})
	pulumi.RegisterOutputType(ApiOperationOutput{})
	pulumi.RegisterOutputType(ApiOperationArrayOutput{})
	pulumi.RegisterOutputType(ApiOperationResponseOutput{})
	pulumi.RegisterOutputType(ApiOperationResponseArrayOutput{})
	pulumi.RegisterOutputType(BasicLevelOutput{})
	pulumi.RegisterOutputType(BasicLevelPtrOutput{})
	pulumi.RegisterOutputType(BasicLevelResponseOutput{})
	pulumi.RegisterOutputType(ConditionOutput{})
	pulumi.RegisterOutputType(ConditionArrayOutput{})
	pulumi.RegisterOutputType(ConditionResponseOutput{})
	pulumi.RegisterOutputType(ConditionResponseArrayOutput{})
	pulumi.RegisterOutputType(CustomLevelOutput{})
	pulumi.RegisterOutputType(CustomLevelPtrOutput{})
	pulumi.RegisterOutputType(CustomLevelResponseOutput{})
	pulumi.RegisterOutputType(DevicePolicyOutput{})
	pulumi.RegisterOutputType(DevicePolicyPtrOutput{})
	pulumi.RegisterOutputType(DevicePolicyResponseOutput{})
	pulumi.RegisterOutputType(EgressFromOutput{})
	pulumi.RegisterOutputType(EgressFromPtrOutput{})
	pulumi.RegisterOutputType(EgressFromResponseOutput{})
	pulumi.RegisterOutputType(EgressPolicyOutput{})
	pulumi.RegisterOutputType(EgressPolicyArrayOutput{})
	pulumi.RegisterOutputType(EgressPolicyResponseOutput{})
	pulumi.RegisterOutputType(EgressPolicyResponseArrayOutput{})
	pulumi.RegisterOutputType(EgressToOutput{})
	pulumi.RegisterOutputType(EgressToPtrOutput{})
	pulumi.RegisterOutputType(EgressToResponseOutput{})
	pulumi.RegisterOutputType(ExprOutput{})
	pulumi.RegisterOutputType(ExprPtrOutput{})
	pulumi.RegisterOutputType(ExprResponseOutput{})
	pulumi.RegisterOutputType(IngressFromOutput{})
	pulumi.RegisterOutputType(IngressFromPtrOutput{})
	pulumi.RegisterOutputType(IngressFromResponseOutput{})
	pulumi.RegisterOutputType(IngressPolicyOutput{})
	pulumi.RegisterOutputType(IngressPolicyArrayOutput{})
	pulumi.RegisterOutputType(IngressPolicyResponseOutput{})
	pulumi.RegisterOutputType(IngressPolicyResponseArrayOutput{})
	pulumi.RegisterOutputType(IngressSourceOutput{})
	pulumi.RegisterOutputType(IngressSourceArrayOutput{})
	pulumi.RegisterOutputType(IngressSourceResponseOutput{})
	pulumi.RegisterOutputType(IngressSourceResponseArrayOutput{})
	pulumi.RegisterOutputType(IngressToOutput{})
	pulumi.RegisterOutputType(IngressToPtrOutput{})
	pulumi.RegisterOutputType(IngressToResponseOutput{})
	pulumi.RegisterOutputType(MethodSelectorOutput{})
	pulumi.RegisterOutputType(MethodSelectorArrayOutput{})
	pulumi.RegisterOutputType(MethodSelectorResponseOutput{})
	pulumi.RegisterOutputType(MethodSelectorResponseArrayOutput{})
	pulumi.RegisterOutputType(OsConstraintOutput{})
	pulumi.RegisterOutputType(OsConstraintArrayOutput{})
	pulumi.RegisterOutputType(OsConstraintResponseOutput{})
	pulumi.RegisterOutputType(OsConstraintResponseArrayOutput{})
	pulumi.RegisterOutputType(ServicePerimeterConfigOutput{})
	pulumi.RegisterOutputType(ServicePerimeterConfigPtrOutput{})
	pulumi.RegisterOutputType(ServicePerimeterConfigResponseOutput{})
	pulumi.RegisterOutputType(VpcAccessibleServicesOutput{})
	pulumi.RegisterOutputType(VpcAccessibleServicesPtrOutput{})
	pulumi.RegisterOutputType(VpcAccessibleServicesResponseOutput{})
}
