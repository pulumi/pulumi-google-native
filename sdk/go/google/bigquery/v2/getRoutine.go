// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v2

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-google-native/sdk/go/google/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Gets the specified routine resource by routine ID.
func LookupRoutine(ctx *pulumi.Context, args *LookupRoutineArgs, opts ...pulumi.InvokeOption) (*LookupRoutineResult, error) {
	opts = internal.PkgInvokeDefaultOpts(opts)
	var rv LookupRoutineResult
	err := ctx.Invoke("google-native:bigquery/v2:getRoutine", args, &rv, opts...)
	if err != nil {
		return nil, err
	}
	return &rv, nil
}

type LookupRoutineArgs struct {
	DatasetId string  `pulumi:"datasetId"`
	Project   *string `pulumi:"project"`
	ReadMask  *string `pulumi:"readMask"`
	RoutineId string  `pulumi:"routineId"`
}

type LookupRoutineResult struct {
	// Optional.
	Arguments []ArgumentResponse `pulumi:"arguments"`
	// The time when this routine was created, in milliseconds since the epoch.
	CreationTime string `pulumi:"creationTime"`
	// Optional. If set to `DATA_MASKING`, the function is validated and made available as a masking function. For more information, see [Create custom masking routines](https://cloud.google.com/bigquery/docs/user-defined-functions#custom-mask).
	DataGovernanceType string `pulumi:"dataGovernanceType"`
	// The body of the routine. For functions, this is the expression in the AS clause. If language=SQL, it is the substring inside (but excluding) the parentheses. For example, for the function created with the following statement: `CREATE FUNCTION JoinLines(x string, y string) as (concat(x, "\n", y))` The definition_body is `concat(x, "\n", y)` (\n is not replaced with linebreak). If language=JAVASCRIPT, it is the evaluated string in the AS clause. For example, for the function created with the following statement: `CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS 'return "\n";\n'` The definition_body is `return "\n";\n` Note that both \n are replaced with linebreaks.
	DefinitionBody string `pulumi:"definitionBody"`
	// Optional. The description of the routine, if defined.
	Description string `pulumi:"description"`
	// Optional. The determinism level of the JavaScript UDF, if defined.
	DeterminismLevel string `pulumi:"determinismLevel"`
	// A hash of this resource.
	Etag string `pulumi:"etag"`
	// Optional. If language = "JAVASCRIPT", this field stores the path of the imported JAVASCRIPT libraries.
	ImportedLibraries []string `pulumi:"importedLibraries"`
	// Optional. Defaults to "SQL" if remote_function_options field is absent, not set otherwise.
	Language string `pulumi:"language"`
	// The time when this routine was last modified, in milliseconds since the epoch.
	LastModifiedTime string `pulumi:"lastModifiedTime"`
	// Optional. Remote function specific options.
	RemoteFunctionOptions RemoteFunctionOptionsResponse `pulumi:"remoteFunctionOptions"`
	// Optional. Can be set only if routine_type = "TABLE_VALUED_FUNCTION". If absent, the return table type is inferred from definition_body at query time in each query that references this routine. If present, then the columns in the evaluated table result will be cast to match the column types specified in return table type, at query time.
	ReturnTableType StandardSqlTableTypeResponse `pulumi:"returnTableType"`
	// Optional if language = "SQL"; required otherwise. Cannot be set if routine_type = "TABLE_VALUED_FUNCTION". If absent, the return type is inferred from definition_body at query time in each query that references this routine. If present, then the evaluated result will be cast to the specified returned type at query time. For example, for the functions created with the following statements: * `CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);` * `CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));` * `CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));` The return_type is `{type_kind: "FLOAT64"}` for `Add` and `Decrement`, and is absent for `Increment` (inferred as FLOAT64 at query time). Suppose the function `Add` is replaced by `CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);` Then the inferred return type of `Increment` is automatically changed to INT64 at query time, while the return type of `Decrement` remains FLOAT64.
	ReturnType StandardSqlDataTypeResponse `pulumi:"returnType"`
	// Reference describing the ID of this routine.
	RoutineReference RoutineReferenceResponse `pulumi:"routineReference"`
	// The type of routine.
	RoutineType string `pulumi:"routineType"`
	// Optional. The security mode of the routine, if defined. If not defined, the security mode is automatically determined from the routine's configuration.
	SecurityMode string `pulumi:"securityMode"`
	// Optional. Spark specific options.
	SparkOptions SparkOptionsResponse `pulumi:"sparkOptions"`
	// Optional. Use this option to catch many common errors. Error checking is not exhaustive, and successfully creating a procedure doesn't guarantee that the procedure will successfully execute at runtime. If `strictMode` is set to `TRUE`, the procedure body is further checked for errors such as non-existent tables or columns. The `CREATE PROCEDURE` statement fails if the body fails any of these checks. If `strictMode` is set to `FALSE`, the procedure body is checked only for syntax. For procedures that invoke themselves recursively, specify `strictMode=FALSE` to avoid non-existent procedure errors during validation. Default value is `TRUE`.
	StrictMode bool `pulumi:"strictMode"`
}

func LookupRoutineOutput(ctx *pulumi.Context, args LookupRoutineOutputArgs, opts ...pulumi.InvokeOption) LookupRoutineResultOutput {
	return pulumi.ToOutputWithContext(context.Background(), args).
		ApplyT(func(v interface{}) (LookupRoutineResult, error) {
			args := v.(LookupRoutineArgs)
			r, err := LookupRoutine(ctx, &args, opts...)
			var s LookupRoutineResult
			if r != nil {
				s = *r
			}
			return s, err
		}).(LookupRoutineResultOutput)
}

type LookupRoutineOutputArgs struct {
	DatasetId pulumi.StringInput    `pulumi:"datasetId"`
	Project   pulumi.StringPtrInput `pulumi:"project"`
	ReadMask  pulumi.StringPtrInput `pulumi:"readMask"`
	RoutineId pulumi.StringInput    `pulumi:"routineId"`
}

func (LookupRoutineOutputArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LookupRoutineArgs)(nil)).Elem()
}

type LookupRoutineResultOutput struct{ *pulumi.OutputState }

func (LookupRoutineResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LookupRoutineResult)(nil)).Elem()
}

func (o LookupRoutineResultOutput) ToLookupRoutineResultOutput() LookupRoutineResultOutput {
	return o
}

func (o LookupRoutineResultOutput) ToLookupRoutineResultOutputWithContext(ctx context.Context) LookupRoutineResultOutput {
	return o
}

// Optional.
func (o LookupRoutineResultOutput) Arguments() ArgumentResponseArrayOutput {
	return o.ApplyT(func(v LookupRoutineResult) []ArgumentResponse { return v.Arguments }).(ArgumentResponseArrayOutput)
}

// The time when this routine was created, in milliseconds since the epoch.
func (o LookupRoutineResultOutput) CreationTime() pulumi.StringOutput {
	return o.ApplyT(func(v LookupRoutineResult) string { return v.CreationTime }).(pulumi.StringOutput)
}

// Optional. If set to `DATA_MASKING`, the function is validated and made available as a masking function. For more information, see [Create custom masking routines](https://cloud.google.com/bigquery/docs/user-defined-functions#custom-mask).
func (o LookupRoutineResultOutput) DataGovernanceType() pulumi.StringOutput {
	return o.ApplyT(func(v LookupRoutineResult) string { return v.DataGovernanceType }).(pulumi.StringOutput)
}

// The body of the routine. For functions, this is the expression in the AS clause. If language=SQL, it is the substring inside (but excluding) the parentheses. For example, for the function created with the following statement: `CREATE FUNCTION JoinLines(x string, y string) as (concat(x, "\n", y))` The definition_body is `concat(x, "\n", y)` (\n is not replaced with linebreak). If language=JAVASCRIPT, it is the evaluated string in the AS clause. For example, for the function created with the following statement: `CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS 'return "\n";\n'` The definition_body is `return "\n";\n` Note that both \n are replaced with linebreaks.
func (o LookupRoutineResultOutput) DefinitionBody() pulumi.StringOutput {
	return o.ApplyT(func(v LookupRoutineResult) string { return v.DefinitionBody }).(pulumi.StringOutput)
}

// Optional. The description of the routine, if defined.
func (o LookupRoutineResultOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v LookupRoutineResult) string { return v.Description }).(pulumi.StringOutput)
}

// Optional. The determinism level of the JavaScript UDF, if defined.
func (o LookupRoutineResultOutput) DeterminismLevel() pulumi.StringOutput {
	return o.ApplyT(func(v LookupRoutineResult) string { return v.DeterminismLevel }).(pulumi.StringOutput)
}

// A hash of this resource.
func (o LookupRoutineResultOutput) Etag() pulumi.StringOutput {
	return o.ApplyT(func(v LookupRoutineResult) string { return v.Etag }).(pulumi.StringOutput)
}

// Optional. If language = "JAVASCRIPT", this field stores the path of the imported JAVASCRIPT libraries.
func (o LookupRoutineResultOutput) ImportedLibraries() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LookupRoutineResult) []string { return v.ImportedLibraries }).(pulumi.StringArrayOutput)
}

// Optional. Defaults to "SQL" if remote_function_options field is absent, not set otherwise.
func (o LookupRoutineResultOutput) Language() pulumi.StringOutput {
	return o.ApplyT(func(v LookupRoutineResult) string { return v.Language }).(pulumi.StringOutput)
}

// The time when this routine was last modified, in milliseconds since the epoch.
func (o LookupRoutineResultOutput) LastModifiedTime() pulumi.StringOutput {
	return o.ApplyT(func(v LookupRoutineResult) string { return v.LastModifiedTime }).(pulumi.StringOutput)
}

// Optional. Remote function specific options.
func (o LookupRoutineResultOutput) RemoteFunctionOptions() RemoteFunctionOptionsResponseOutput {
	return o.ApplyT(func(v LookupRoutineResult) RemoteFunctionOptionsResponse { return v.RemoteFunctionOptions }).(RemoteFunctionOptionsResponseOutput)
}

// Optional. Can be set only if routine_type = "TABLE_VALUED_FUNCTION". If absent, the return table type is inferred from definition_body at query time in each query that references this routine. If present, then the columns in the evaluated table result will be cast to match the column types specified in return table type, at query time.
func (o LookupRoutineResultOutput) ReturnTableType() StandardSqlTableTypeResponseOutput {
	return o.ApplyT(func(v LookupRoutineResult) StandardSqlTableTypeResponse { return v.ReturnTableType }).(StandardSqlTableTypeResponseOutput)
}

// Optional if language = "SQL"; required otherwise. Cannot be set if routine_type = "TABLE_VALUED_FUNCTION". If absent, the return type is inferred from definition_body at query time in each query that references this routine. If present, then the evaluated result will be cast to the specified returned type at query time. For example, for the functions created with the following statements: * `CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);` * `CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));` * `CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));` The return_type is `{type_kind: "FLOAT64"}` for `Add` and `Decrement`, and is absent for `Increment` (inferred as FLOAT64 at query time). Suppose the function `Add` is replaced by `CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);` Then the inferred return type of `Increment` is automatically changed to INT64 at query time, while the return type of `Decrement` remains FLOAT64.
func (o LookupRoutineResultOutput) ReturnType() StandardSqlDataTypeResponseOutput {
	return o.ApplyT(func(v LookupRoutineResult) StandardSqlDataTypeResponse { return v.ReturnType }).(StandardSqlDataTypeResponseOutput)
}

// Reference describing the ID of this routine.
func (o LookupRoutineResultOutput) RoutineReference() RoutineReferenceResponseOutput {
	return o.ApplyT(func(v LookupRoutineResult) RoutineReferenceResponse { return v.RoutineReference }).(RoutineReferenceResponseOutput)
}

// The type of routine.
func (o LookupRoutineResultOutput) RoutineType() pulumi.StringOutput {
	return o.ApplyT(func(v LookupRoutineResult) string { return v.RoutineType }).(pulumi.StringOutput)
}

// Optional. The security mode of the routine, if defined. If not defined, the security mode is automatically determined from the routine's configuration.
func (o LookupRoutineResultOutput) SecurityMode() pulumi.StringOutput {
	return o.ApplyT(func(v LookupRoutineResult) string { return v.SecurityMode }).(pulumi.StringOutput)
}

// Optional. Spark specific options.
func (o LookupRoutineResultOutput) SparkOptions() SparkOptionsResponseOutput {
	return o.ApplyT(func(v LookupRoutineResult) SparkOptionsResponse { return v.SparkOptions }).(SparkOptionsResponseOutput)
}

// Optional. Use this option to catch many common errors. Error checking is not exhaustive, and successfully creating a procedure doesn't guarantee that the procedure will successfully execute at runtime. If `strictMode` is set to `TRUE`, the procedure body is further checked for errors such as non-existent tables or columns. The `CREATE PROCEDURE` statement fails if the body fails any of these checks. If `strictMode` is set to `FALSE`, the procedure body is checked only for syntax. For procedures that invoke themselves recursively, specify `strictMode=FALSE` to avoid non-existent procedure errors during validation. Default value is `TRUE`.
func (o LookupRoutineResultOutput) StrictMode() pulumi.BoolOutput {
	return o.ApplyT(func(v LookupRoutineResult) bool { return v.StrictMode }).(pulumi.BoolOutput)
}

func init() {
	pulumi.RegisterOutputType(LookupRoutineResultOutput{})
}
