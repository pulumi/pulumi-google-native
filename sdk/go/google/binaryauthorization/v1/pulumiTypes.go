// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-google-native/sdk/go/google/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = internal.GetEnvOrDefault

// An attestation authenticator that will be used to verify attestations. Typically this is just a set of public keys. Conceptually, an authenticator can be treated as always returning either "authenticated" or "not authenticated" when presented with a signed attestation (almost always assumed to be a [DSSE](https://github.com/secure-systems-lab/dsse) attestation). The details of how an authenticator makes this decision are specific to the type of 'authenticator' that this message wraps.
type AttestationAuthenticator struct {
	// Optional. A user-provided name for this `AttestationAuthenticator`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
	DisplayName *string `pulumi:"displayName"`
	// Optional. A set of raw PKIX SubjectPublicKeyInfo format public keys. If any public key in the set validates the attestation signature, then the signature is considered authenticated (i.e. any one key is sufficient to authenticate).
	PkixPublicKeySet *PkixPublicKeySet `pulumi:"pkixPublicKeySet"`
}

// AttestationAuthenticatorInput is an input type that accepts AttestationAuthenticatorArgs and AttestationAuthenticatorOutput values.
// You can construct a concrete instance of `AttestationAuthenticatorInput` via:
//
//	AttestationAuthenticatorArgs{...}
type AttestationAuthenticatorInput interface {
	pulumi.Input

	ToAttestationAuthenticatorOutput() AttestationAuthenticatorOutput
	ToAttestationAuthenticatorOutputWithContext(context.Context) AttestationAuthenticatorOutput
}

// An attestation authenticator that will be used to verify attestations. Typically this is just a set of public keys. Conceptually, an authenticator can be treated as always returning either "authenticated" or "not authenticated" when presented with a signed attestation (almost always assumed to be a [DSSE](https://github.com/secure-systems-lab/dsse) attestation). The details of how an authenticator makes this decision are specific to the type of 'authenticator' that this message wraps.
type AttestationAuthenticatorArgs struct {
	// Optional. A user-provided name for this `AttestationAuthenticator`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
	DisplayName pulumi.StringPtrInput `pulumi:"displayName"`
	// Optional. A set of raw PKIX SubjectPublicKeyInfo format public keys. If any public key in the set validates the attestation signature, then the signature is considered authenticated (i.e. any one key is sufficient to authenticate).
	PkixPublicKeySet PkixPublicKeySetPtrInput `pulumi:"pkixPublicKeySet"`
}

func (AttestationAuthenticatorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AttestationAuthenticator)(nil)).Elem()
}

func (i AttestationAuthenticatorArgs) ToAttestationAuthenticatorOutput() AttestationAuthenticatorOutput {
	return i.ToAttestationAuthenticatorOutputWithContext(context.Background())
}

func (i AttestationAuthenticatorArgs) ToAttestationAuthenticatorOutputWithContext(ctx context.Context) AttestationAuthenticatorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttestationAuthenticatorOutput)
}

// AttestationAuthenticatorArrayInput is an input type that accepts AttestationAuthenticatorArray and AttestationAuthenticatorArrayOutput values.
// You can construct a concrete instance of `AttestationAuthenticatorArrayInput` via:
//
//	AttestationAuthenticatorArray{ AttestationAuthenticatorArgs{...} }
type AttestationAuthenticatorArrayInput interface {
	pulumi.Input

	ToAttestationAuthenticatorArrayOutput() AttestationAuthenticatorArrayOutput
	ToAttestationAuthenticatorArrayOutputWithContext(context.Context) AttestationAuthenticatorArrayOutput
}

type AttestationAuthenticatorArray []AttestationAuthenticatorInput

func (AttestationAuthenticatorArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AttestationAuthenticator)(nil)).Elem()
}

func (i AttestationAuthenticatorArray) ToAttestationAuthenticatorArrayOutput() AttestationAuthenticatorArrayOutput {
	return i.ToAttestationAuthenticatorArrayOutputWithContext(context.Background())
}

func (i AttestationAuthenticatorArray) ToAttestationAuthenticatorArrayOutputWithContext(ctx context.Context) AttestationAuthenticatorArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttestationAuthenticatorArrayOutput)
}

// An attestation authenticator that will be used to verify attestations. Typically this is just a set of public keys. Conceptually, an authenticator can be treated as always returning either "authenticated" or "not authenticated" when presented with a signed attestation (almost always assumed to be a [DSSE](https://github.com/secure-systems-lab/dsse) attestation). The details of how an authenticator makes this decision are specific to the type of 'authenticator' that this message wraps.
type AttestationAuthenticatorOutput struct{ *pulumi.OutputState }

func (AttestationAuthenticatorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AttestationAuthenticator)(nil)).Elem()
}

func (o AttestationAuthenticatorOutput) ToAttestationAuthenticatorOutput() AttestationAuthenticatorOutput {
	return o
}

func (o AttestationAuthenticatorOutput) ToAttestationAuthenticatorOutputWithContext(ctx context.Context) AttestationAuthenticatorOutput {
	return o
}

// Optional. A user-provided name for this `AttestationAuthenticator`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
func (o AttestationAuthenticatorOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AttestationAuthenticator) *string { return v.DisplayName }).(pulumi.StringPtrOutput)
}

// Optional. A set of raw PKIX SubjectPublicKeyInfo format public keys. If any public key in the set validates the attestation signature, then the signature is considered authenticated (i.e. any one key is sufficient to authenticate).
func (o AttestationAuthenticatorOutput) PkixPublicKeySet() PkixPublicKeySetPtrOutput {
	return o.ApplyT(func(v AttestationAuthenticator) *PkixPublicKeySet { return v.PkixPublicKeySet }).(PkixPublicKeySetPtrOutput)
}

type AttestationAuthenticatorArrayOutput struct{ *pulumi.OutputState }

func (AttestationAuthenticatorArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AttestationAuthenticator)(nil)).Elem()
}

func (o AttestationAuthenticatorArrayOutput) ToAttestationAuthenticatorArrayOutput() AttestationAuthenticatorArrayOutput {
	return o
}

func (o AttestationAuthenticatorArrayOutput) ToAttestationAuthenticatorArrayOutputWithContext(ctx context.Context) AttestationAuthenticatorArrayOutput {
	return o
}

func (o AttestationAuthenticatorArrayOutput) Index(i pulumi.IntInput) AttestationAuthenticatorOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AttestationAuthenticator {
		return vs[0].([]AttestationAuthenticator)[vs[1].(int)]
	}).(AttestationAuthenticatorOutput)
}

// An attestation authenticator that will be used to verify attestations. Typically this is just a set of public keys. Conceptually, an authenticator can be treated as always returning either "authenticated" or "not authenticated" when presented with a signed attestation (almost always assumed to be a [DSSE](https://github.com/secure-systems-lab/dsse) attestation). The details of how an authenticator makes this decision are specific to the type of 'authenticator' that this message wraps.
type AttestationAuthenticatorResponse struct {
	// Optional. A user-provided name for this `AttestationAuthenticator`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
	DisplayName string `pulumi:"displayName"`
	// Optional. A set of raw PKIX SubjectPublicKeyInfo format public keys. If any public key in the set validates the attestation signature, then the signature is considered authenticated (i.e. any one key is sufficient to authenticate).
	PkixPublicKeySet PkixPublicKeySetResponse `pulumi:"pkixPublicKeySet"`
}

// An attestation authenticator that will be used to verify attestations. Typically this is just a set of public keys. Conceptually, an authenticator can be treated as always returning either "authenticated" or "not authenticated" when presented with a signed attestation (almost always assumed to be a [DSSE](https://github.com/secure-systems-lab/dsse) attestation). The details of how an authenticator makes this decision are specific to the type of 'authenticator' that this message wraps.
type AttestationAuthenticatorResponseOutput struct{ *pulumi.OutputState }

func (AttestationAuthenticatorResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AttestationAuthenticatorResponse)(nil)).Elem()
}

func (o AttestationAuthenticatorResponseOutput) ToAttestationAuthenticatorResponseOutput() AttestationAuthenticatorResponseOutput {
	return o
}

func (o AttestationAuthenticatorResponseOutput) ToAttestationAuthenticatorResponseOutputWithContext(ctx context.Context) AttestationAuthenticatorResponseOutput {
	return o
}

// Optional. A user-provided name for this `AttestationAuthenticator`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
func (o AttestationAuthenticatorResponseOutput) DisplayName() pulumi.StringOutput {
	return o.ApplyT(func(v AttestationAuthenticatorResponse) string { return v.DisplayName }).(pulumi.StringOutput)
}

// Optional. A set of raw PKIX SubjectPublicKeyInfo format public keys. If any public key in the set validates the attestation signature, then the signature is considered authenticated (i.e. any one key is sufficient to authenticate).
func (o AttestationAuthenticatorResponseOutput) PkixPublicKeySet() PkixPublicKeySetResponseOutput {
	return o.ApplyT(func(v AttestationAuthenticatorResponse) PkixPublicKeySetResponse { return v.PkixPublicKeySet }).(PkixPublicKeySetResponseOutput)
}

type AttestationAuthenticatorResponseArrayOutput struct{ *pulumi.OutputState }

func (AttestationAuthenticatorResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AttestationAuthenticatorResponse)(nil)).Elem()
}

func (o AttestationAuthenticatorResponseArrayOutput) ToAttestationAuthenticatorResponseArrayOutput() AttestationAuthenticatorResponseArrayOutput {
	return o
}

func (o AttestationAuthenticatorResponseArrayOutput) ToAttestationAuthenticatorResponseArrayOutputWithContext(ctx context.Context) AttestationAuthenticatorResponseArrayOutput {
	return o
}

func (o AttestationAuthenticatorResponseArrayOutput) Index(i pulumi.IntInput) AttestationAuthenticatorResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AttestationAuthenticatorResponse {
		return vs[0].([]AttestationAuthenticatorResponse)[vs[1].(int)]
	}).(AttestationAuthenticatorResponseOutput)
}

// Specifies the locations for fetching the provenance attestations.
type AttestationSource struct {
	// The IDs of the Google Cloud projects that store the SLSA attestations as Container Analysis Occurrences, in the format `projects/[PROJECT_ID]`. Maximum number of `container_analysis_attestation_projects` allowed in each `AttestationSource` is 10.
	ContainerAnalysisAttestationProjects []string `pulumi:"containerAnalysisAttestationProjects"`
}

// AttestationSourceInput is an input type that accepts AttestationSourceArgs and AttestationSourceOutput values.
// You can construct a concrete instance of `AttestationSourceInput` via:
//
//	AttestationSourceArgs{...}
type AttestationSourceInput interface {
	pulumi.Input

	ToAttestationSourceOutput() AttestationSourceOutput
	ToAttestationSourceOutputWithContext(context.Context) AttestationSourceOutput
}

// Specifies the locations for fetching the provenance attestations.
type AttestationSourceArgs struct {
	// The IDs of the Google Cloud projects that store the SLSA attestations as Container Analysis Occurrences, in the format `projects/[PROJECT_ID]`. Maximum number of `container_analysis_attestation_projects` allowed in each `AttestationSource` is 10.
	ContainerAnalysisAttestationProjects pulumi.StringArrayInput `pulumi:"containerAnalysisAttestationProjects"`
}

func (AttestationSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AttestationSource)(nil)).Elem()
}

func (i AttestationSourceArgs) ToAttestationSourceOutput() AttestationSourceOutput {
	return i.ToAttestationSourceOutputWithContext(context.Background())
}

func (i AttestationSourceArgs) ToAttestationSourceOutputWithContext(ctx context.Context) AttestationSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttestationSourceOutput)
}

func (i AttestationSourceArgs) ToAttestationSourcePtrOutput() AttestationSourcePtrOutput {
	return i.ToAttestationSourcePtrOutputWithContext(context.Background())
}

func (i AttestationSourceArgs) ToAttestationSourcePtrOutputWithContext(ctx context.Context) AttestationSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttestationSourceOutput).ToAttestationSourcePtrOutputWithContext(ctx)
}

// AttestationSourcePtrInput is an input type that accepts AttestationSourceArgs, AttestationSourcePtr and AttestationSourcePtrOutput values.
// You can construct a concrete instance of `AttestationSourcePtrInput` via:
//
//	        AttestationSourceArgs{...}
//
//	or:
//
//	        nil
type AttestationSourcePtrInput interface {
	pulumi.Input

	ToAttestationSourcePtrOutput() AttestationSourcePtrOutput
	ToAttestationSourcePtrOutputWithContext(context.Context) AttestationSourcePtrOutput
}

type attestationSourcePtrType AttestationSourceArgs

func AttestationSourcePtr(v *AttestationSourceArgs) AttestationSourcePtrInput {
	return (*attestationSourcePtrType)(v)
}

func (*attestationSourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AttestationSource)(nil)).Elem()
}

func (i *attestationSourcePtrType) ToAttestationSourcePtrOutput() AttestationSourcePtrOutput {
	return i.ToAttestationSourcePtrOutputWithContext(context.Background())
}

func (i *attestationSourcePtrType) ToAttestationSourcePtrOutputWithContext(ctx context.Context) AttestationSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttestationSourcePtrOutput)
}

// Specifies the locations for fetching the provenance attestations.
type AttestationSourceOutput struct{ *pulumi.OutputState }

func (AttestationSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AttestationSource)(nil)).Elem()
}

func (o AttestationSourceOutput) ToAttestationSourceOutput() AttestationSourceOutput {
	return o
}

func (o AttestationSourceOutput) ToAttestationSourceOutputWithContext(ctx context.Context) AttestationSourceOutput {
	return o
}

func (o AttestationSourceOutput) ToAttestationSourcePtrOutput() AttestationSourcePtrOutput {
	return o.ToAttestationSourcePtrOutputWithContext(context.Background())
}

func (o AttestationSourceOutput) ToAttestationSourcePtrOutputWithContext(ctx context.Context) AttestationSourcePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AttestationSource) *AttestationSource {
		return &v
	}).(AttestationSourcePtrOutput)
}

// The IDs of the Google Cloud projects that store the SLSA attestations as Container Analysis Occurrences, in the format `projects/[PROJECT_ID]`. Maximum number of `container_analysis_attestation_projects` allowed in each `AttestationSource` is 10.
func (o AttestationSourceOutput) ContainerAnalysisAttestationProjects() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AttestationSource) []string { return v.ContainerAnalysisAttestationProjects }).(pulumi.StringArrayOutput)
}

type AttestationSourcePtrOutput struct{ *pulumi.OutputState }

func (AttestationSourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AttestationSource)(nil)).Elem()
}

func (o AttestationSourcePtrOutput) ToAttestationSourcePtrOutput() AttestationSourcePtrOutput {
	return o
}

func (o AttestationSourcePtrOutput) ToAttestationSourcePtrOutputWithContext(ctx context.Context) AttestationSourcePtrOutput {
	return o
}

func (o AttestationSourcePtrOutput) Elem() AttestationSourceOutput {
	return o.ApplyT(func(v *AttestationSource) AttestationSource {
		if v != nil {
			return *v
		}
		var ret AttestationSource
		return ret
	}).(AttestationSourceOutput)
}

// The IDs of the Google Cloud projects that store the SLSA attestations as Container Analysis Occurrences, in the format `projects/[PROJECT_ID]`. Maximum number of `container_analysis_attestation_projects` allowed in each `AttestationSource` is 10.
func (o AttestationSourcePtrOutput) ContainerAnalysisAttestationProjects() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *AttestationSource) []string {
		if v == nil {
			return nil
		}
		return v.ContainerAnalysisAttestationProjects
	}).(pulumi.StringArrayOutput)
}

// Specifies the locations for fetching the provenance attestations.
type AttestationSourceResponse struct {
	// The IDs of the Google Cloud projects that store the SLSA attestations as Container Analysis Occurrences, in the format `projects/[PROJECT_ID]`. Maximum number of `container_analysis_attestation_projects` allowed in each `AttestationSource` is 10.
	ContainerAnalysisAttestationProjects []string `pulumi:"containerAnalysisAttestationProjects"`
}

// Specifies the locations for fetching the provenance attestations.
type AttestationSourceResponseOutput struct{ *pulumi.OutputState }

func (AttestationSourceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AttestationSourceResponse)(nil)).Elem()
}

func (o AttestationSourceResponseOutput) ToAttestationSourceResponseOutput() AttestationSourceResponseOutput {
	return o
}

func (o AttestationSourceResponseOutput) ToAttestationSourceResponseOutputWithContext(ctx context.Context) AttestationSourceResponseOutput {
	return o
}

// The IDs of the Google Cloud projects that store the SLSA attestations as Container Analysis Occurrences, in the format `projects/[PROJECT_ID]`. Maximum number of `container_analysis_attestation_projects` allowed in each `AttestationSource` is 10.
func (o AttestationSourceResponseOutput) ContainerAnalysisAttestationProjects() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AttestationSourceResponse) []string { return v.ContainerAnalysisAttestationProjects }).(pulumi.StringArrayOutput)
}

// An attestor public key that will be used to verify attestations signed by this attestor.
type AttestorPublicKey struct {
	// ASCII-armored representation of a PGP public key, as the entire output by the command `gpg --export --armor foo@example.com` (either LF or CRLF line endings). When using this field, `id` should be left blank. The Binary Authorization API handlers will calculate the ID and fill it in automatically. Binary Authorization computes this ID as the OpenPGP RFC4880 V4 fingerprint, represented as upper-case hex. If `id` is provided by the caller, it will be overwritten by the API-calculated ID.
	AsciiArmoredPgpPublicKey *string `pulumi:"asciiArmoredPgpPublicKey"`
	// Optional. A descriptive comment. This field may be updated.
	Comment *string `pulumi:"comment"`
	// The ID of this public key. Signatures verified by Binary Authorization must include the ID of the public key that can be used to verify them, and that ID must match the contents of this field exactly. Additional restrictions on this field can be imposed based on which public key type is encapsulated. See the documentation on `public_key` cases below for details.
	Id *string `pulumi:"id"`
	// A raw PKIX SubjectPublicKeyInfo format public key. NOTE: `id` may be explicitly provided by the caller when using this type of public key, but it MUST be a valid RFC3986 URI. If `id` is left blank, a default one will be computed based on the digest of the DER encoding of the public key.
	PkixPublicKey *PkixPublicKey `pulumi:"pkixPublicKey"`
}

// AttestorPublicKeyInput is an input type that accepts AttestorPublicKeyArgs and AttestorPublicKeyOutput values.
// You can construct a concrete instance of `AttestorPublicKeyInput` via:
//
//	AttestorPublicKeyArgs{...}
type AttestorPublicKeyInput interface {
	pulumi.Input

	ToAttestorPublicKeyOutput() AttestorPublicKeyOutput
	ToAttestorPublicKeyOutputWithContext(context.Context) AttestorPublicKeyOutput
}

// An attestor public key that will be used to verify attestations signed by this attestor.
type AttestorPublicKeyArgs struct {
	// ASCII-armored representation of a PGP public key, as the entire output by the command `gpg --export --armor foo@example.com` (either LF or CRLF line endings). When using this field, `id` should be left blank. The Binary Authorization API handlers will calculate the ID and fill it in automatically. Binary Authorization computes this ID as the OpenPGP RFC4880 V4 fingerprint, represented as upper-case hex. If `id` is provided by the caller, it will be overwritten by the API-calculated ID.
	AsciiArmoredPgpPublicKey pulumi.StringPtrInput `pulumi:"asciiArmoredPgpPublicKey"`
	// Optional. A descriptive comment. This field may be updated.
	Comment pulumi.StringPtrInput `pulumi:"comment"`
	// The ID of this public key. Signatures verified by Binary Authorization must include the ID of the public key that can be used to verify them, and that ID must match the contents of this field exactly. Additional restrictions on this field can be imposed based on which public key type is encapsulated. See the documentation on `public_key` cases below for details.
	Id pulumi.StringPtrInput `pulumi:"id"`
	// A raw PKIX SubjectPublicKeyInfo format public key. NOTE: `id` may be explicitly provided by the caller when using this type of public key, but it MUST be a valid RFC3986 URI. If `id` is left blank, a default one will be computed based on the digest of the DER encoding of the public key.
	PkixPublicKey PkixPublicKeyPtrInput `pulumi:"pkixPublicKey"`
}

func (AttestorPublicKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AttestorPublicKey)(nil)).Elem()
}

func (i AttestorPublicKeyArgs) ToAttestorPublicKeyOutput() AttestorPublicKeyOutput {
	return i.ToAttestorPublicKeyOutputWithContext(context.Background())
}

func (i AttestorPublicKeyArgs) ToAttestorPublicKeyOutputWithContext(ctx context.Context) AttestorPublicKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttestorPublicKeyOutput)
}

// AttestorPublicKeyArrayInput is an input type that accepts AttestorPublicKeyArray and AttestorPublicKeyArrayOutput values.
// You can construct a concrete instance of `AttestorPublicKeyArrayInput` via:
//
//	AttestorPublicKeyArray{ AttestorPublicKeyArgs{...} }
type AttestorPublicKeyArrayInput interface {
	pulumi.Input

	ToAttestorPublicKeyArrayOutput() AttestorPublicKeyArrayOutput
	ToAttestorPublicKeyArrayOutputWithContext(context.Context) AttestorPublicKeyArrayOutput
}

type AttestorPublicKeyArray []AttestorPublicKeyInput

func (AttestorPublicKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AttestorPublicKey)(nil)).Elem()
}

func (i AttestorPublicKeyArray) ToAttestorPublicKeyArrayOutput() AttestorPublicKeyArrayOutput {
	return i.ToAttestorPublicKeyArrayOutputWithContext(context.Background())
}

func (i AttestorPublicKeyArray) ToAttestorPublicKeyArrayOutputWithContext(ctx context.Context) AttestorPublicKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttestorPublicKeyArrayOutput)
}

// An attestor public key that will be used to verify attestations signed by this attestor.
type AttestorPublicKeyOutput struct{ *pulumi.OutputState }

func (AttestorPublicKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AttestorPublicKey)(nil)).Elem()
}

func (o AttestorPublicKeyOutput) ToAttestorPublicKeyOutput() AttestorPublicKeyOutput {
	return o
}

func (o AttestorPublicKeyOutput) ToAttestorPublicKeyOutputWithContext(ctx context.Context) AttestorPublicKeyOutput {
	return o
}

// ASCII-armored representation of a PGP public key, as the entire output by the command `gpg --export --armor foo@example.com` (either LF or CRLF line endings). When using this field, `id` should be left blank. The Binary Authorization API handlers will calculate the ID and fill it in automatically. Binary Authorization computes this ID as the OpenPGP RFC4880 V4 fingerprint, represented as upper-case hex. If `id` is provided by the caller, it will be overwritten by the API-calculated ID.
func (o AttestorPublicKeyOutput) AsciiArmoredPgpPublicKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AttestorPublicKey) *string { return v.AsciiArmoredPgpPublicKey }).(pulumi.StringPtrOutput)
}

// Optional. A descriptive comment. This field may be updated.
func (o AttestorPublicKeyOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AttestorPublicKey) *string { return v.Comment }).(pulumi.StringPtrOutput)
}

// The ID of this public key. Signatures verified by Binary Authorization must include the ID of the public key that can be used to verify them, and that ID must match the contents of this field exactly. Additional restrictions on this field can be imposed based on which public key type is encapsulated. See the documentation on `public_key` cases below for details.
func (o AttestorPublicKeyOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AttestorPublicKey) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// A raw PKIX SubjectPublicKeyInfo format public key. NOTE: `id` may be explicitly provided by the caller when using this type of public key, but it MUST be a valid RFC3986 URI. If `id` is left blank, a default one will be computed based on the digest of the DER encoding of the public key.
func (o AttestorPublicKeyOutput) PkixPublicKey() PkixPublicKeyPtrOutput {
	return o.ApplyT(func(v AttestorPublicKey) *PkixPublicKey { return v.PkixPublicKey }).(PkixPublicKeyPtrOutput)
}

type AttestorPublicKeyArrayOutput struct{ *pulumi.OutputState }

func (AttestorPublicKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AttestorPublicKey)(nil)).Elem()
}

func (o AttestorPublicKeyArrayOutput) ToAttestorPublicKeyArrayOutput() AttestorPublicKeyArrayOutput {
	return o
}

func (o AttestorPublicKeyArrayOutput) ToAttestorPublicKeyArrayOutputWithContext(ctx context.Context) AttestorPublicKeyArrayOutput {
	return o
}

func (o AttestorPublicKeyArrayOutput) Index(i pulumi.IntInput) AttestorPublicKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AttestorPublicKey {
		return vs[0].([]AttestorPublicKey)[vs[1].(int)]
	}).(AttestorPublicKeyOutput)
}

// An attestor public key that will be used to verify attestations signed by this attestor.
type AttestorPublicKeyResponse struct {
	// ASCII-armored representation of a PGP public key, as the entire output by the command `gpg --export --armor foo@example.com` (either LF or CRLF line endings). When using this field, `id` should be left blank. The Binary Authorization API handlers will calculate the ID and fill it in automatically. Binary Authorization computes this ID as the OpenPGP RFC4880 V4 fingerprint, represented as upper-case hex. If `id` is provided by the caller, it will be overwritten by the API-calculated ID.
	AsciiArmoredPgpPublicKey string `pulumi:"asciiArmoredPgpPublicKey"`
	// Optional. A descriptive comment. This field may be updated.
	Comment string `pulumi:"comment"`
	// A raw PKIX SubjectPublicKeyInfo format public key. NOTE: `id` may be explicitly provided by the caller when using this type of public key, but it MUST be a valid RFC3986 URI. If `id` is left blank, a default one will be computed based on the digest of the DER encoding of the public key.
	PkixPublicKey PkixPublicKeyResponse `pulumi:"pkixPublicKey"`
}

// An attestor public key that will be used to verify attestations signed by this attestor.
type AttestorPublicKeyResponseOutput struct{ *pulumi.OutputState }

func (AttestorPublicKeyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AttestorPublicKeyResponse)(nil)).Elem()
}

func (o AttestorPublicKeyResponseOutput) ToAttestorPublicKeyResponseOutput() AttestorPublicKeyResponseOutput {
	return o
}

func (o AttestorPublicKeyResponseOutput) ToAttestorPublicKeyResponseOutputWithContext(ctx context.Context) AttestorPublicKeyResponseOutput {
	return o
}

// ASCII-armored representation of a PGP public key, as the entire output by the command `gpg --export --armor foo@example.com` (either LF or CRLF line endings). When using this field, `id` should be left blank. The Binary Authorization API handlers will calculate the ID and fill it in automatically. Binary Authorization computes this ID as the OpenPGP RFC4880 V4 fingerprint, represented as upper-case hex. If `id` is provided by the caller, it will be overwritten by the API-calculated ID.
func (o AttestorPublicKeyResponseOutput) AsciiArmoredPgpPublicKey() pulumi.StringOutput {
	return o.ApplyT(func(v AttestorPublicKeyResponse) string { return v.AsciiArmoredPgpPublicKey }).(pulumi.StringOutput)
}

// Optional. A descriptive comment. This field may be updated.
func (o AttestorPublicKeyResponseOutput) Comment() pulumi.StringOutput {
	return o.ApplyT(func(v AttestorPublicKeyResponse) string { return v.Comment }).(pulumi.StringOutput)
}

// A raw PKIX SubjectPublicKeyInfo format public key. NOTE: `id` may be explicitly provided by the caller when using this type of public key, but it MUST be a valid RFC3986 URI. If `id` is left blank, a default one will be computed based on the digest of the DER encoding of the public key.
func (o AttestorPublicKeyResponseOutput) PkixPublicKey() PkixPublicKeyResponseOutput {
	return o.ApplyT(func(v AttestorPublicKeyResponse) PkixPublicKeyResponse { return v.PkixPublicKey }).(PkixPublicKeyResponseOutput)
}

type AttestorPublicKeyResponseArrayOutput struct{ *pulumi.OutputState }

func (AttestorPublicKeyResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AttestorPublicKeyResponse)(nil)).Elem()
}

func (o AttestorPublicKeyResponseArrayOutput) ToAttestorPublicKeyResponseArrayOutput() AttestorPublicKeyResponseArrayOutput {
	return o
}

func (o AttestorPublicKeyResponseArrayOutput) ToAttestorPublicKeyResponseArrayOutputWithContext(ctx context.Context) AttestorPublicKeyResponseArrayOutput {
	return o
}

func (o AttestorPublicKeyResponseArrayOutput) Index(i pulumi.IntInput) AttestorPublicKeyResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AttestorPublicKeyResponse {
		return vs[0].([]AttestorPublicKeyResponse)[vs[1].(int)]
	}).(AttestorPublicKeyResponseOutput)
}

// Associates `members`, or principals, with a `role`.
type Binding struct {
	// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
	Condition *Expr `pulumi:"condition"`
	// Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`: A single identity in a workforce identity pool. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/group/{group_id}`: All workforce identities in a group. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/attribute.{attribute_name}/{attribute_value}`: All workforce identities with a specific attribute value. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/*`: All identities in a workforce identity pool. * `principal://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/subject/{subject_attribute_value}`: A single identity in a workload identity pool. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/group/{group_id}`: A workload identity pool group. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/attribute.{attribute_name}/{attribute_value}`: All identities in a workload identity pool with a certain attribute. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/*`: All identities in a workload identity pool. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `deleted:principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`: Deleted single identity in a workforce identity pool. For example, `deleted:principal://iam.googleapis.com/locations/global/workforcePools/my-pool-id/subject/my-subject-attribute-value`.
	Members []string `pulumi:"members"`
	// Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`. For an overview of the IAM roles and permissions, see the [IAM documentation](https://cloud.google.com/iam/docs/roles-overview). For a list of the available pre-defined roles, see [here](https://cloud.google.com/iam/docs/understanding-roles).
	Role *string `pulumi:"role"`
}

// BindingInput is an input type that accepts BindingArgs and BindingOutput values.
// You can construct a concrete instance of `BindingInput` via:
//
//	BindingArgs{...}
type BindingInput interface {
	pulumi.Input

	ToBindingOutput() BindingOutput
	ToBindingOutputWithContext(context.Context) BindingOutput
}

// Associates `members`, or principals, with a `role`.
type BindingArgs struct {
	// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
	Condition ExprPtrInput `pulumi:"condition"`
	// Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`: A single identity in a workforce identity pool. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/group/{group_id}`: All workforce identities in a group. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/attribute.{attribute_name}/{attribute_value}`: All workforce identities with a specific attribute value. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/*`: All identities in a workforce identity pool. * `principal://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/subject/{subject_attribute_value}`: A single identity in a workload identity pool. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/group/{group_id}`: A workload identity pool group. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/attribute.{attribute_name}/{attribute_value}`: All identities in a workload identity pool with a certain attribute. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/*`: All identities in a workload identity pool. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `deleted:principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`: Deleted single identity in a workforce identity pool. For example, `deleted:principal://iam.googleapis.com/locations/global/workforcePools/my-pool-id/subject/my-subject-attribute-value`.
	Members pulumi.StringArrayInput `pulumi:"members"`
	// Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`. For an overview of the IAM roles and permissions, see the [IAM documentation](https://cloud.google.com/iam/docs/roles-overview). For a list of the available pre-defined roles, see [here](https://cloud.google.com/iam/docs/understanding-roles).
	Role pulumi.StringPtrInput `pulumi:"role"`
}

func (BindingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Binding)(nil)).Elem()
}

func (i BindingArgs) ToBindingOutput() BindingOutput {
	return i.ToBindingOutputWithContext(context.Background())
}

func (i BindingArgs) ToBindingOutputWithContext(ctx context.Context) BindingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BindingOutput)
}

// BindingArrayInput is an input type that accepts BindingArray and BindingArrayOutput values.
// You can construct a concrete instance of `BindingArrayInput` via:
//
//	BindingArray{ BindingArgs{...} }
type BindingArrayInput interface {
	pulumi.Input

	ToBindingArrayOutput() BindingArrayOutput
	ToBindingArrayOutputWithContext(context.Context) BindingArrayOutput
}

type BindingArray []BindingInput

func (BindingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Binding)(nil)).Elem()
}

func (i BindingArray) ToBindingArrayOutput() BindingArrayOutput {
	return i.ToBindingArrayOutputWithContext(context.Background())
}

func (i BindingArray) ToBindingArrayOutputWithContext(ctx context.Context) BindingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BindingArrayOutput)
}

// Associates `members`, or principals, with a `role`.
type BindingOutput struct{ *pulumi.OutputState }

func (BindingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Binding)(nil)).Elem()
}

func (o BindingOutput) ToBindingOutput() BindingOutput {
	return o
}

func (o BindingOutput) ToBindingOutputWithContext(ctx context.Context) BindingOutput {
	return o
}

// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
func (o BindingOutput) Condition() ExprPtrOutput {
	return o.ApplyT(func(v Binding) *Expr { return v.Condition }).(ExprPtrOutput)
}

// Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`: A single identity in a workforce identity pool. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/group/{group_id}`: All workforce identities in a group. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/attribute.{attribute_name}/{attribute_value}`: All workforce identities with a specific attribute value. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/*`: All identities in a workforce identity pool. * `principal://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/subject/{subject_attribute_value}`: A single identity in a workload identity pool. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/group/{group_id}`: A workload identity pool group. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/attribute.{attribute_name}/{attribute_value}`: All identities in a workload identity pool with a certain attribute. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/*`: All identities in a workload identity pool. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `deleted:principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`: Deleted single identity in a workforce identity pool. For example, `deleted:principal://iam.googleapis.com/locations/global/workforcePools/my-pool-id/subject/my-subject-attribute-value`.
func (o BindingOutput) Members() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Binding) []string { return v.Members }).(pulumi.StringArrayOutput)
}

// Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`. For an overview of the IAM roles and permissions, see the [IAM documentation](https://cloud.google.com/iam/docs/roles-overview). For a list of the available pre-defined roles, see [here](https://cloud.google.com/iam/docs/understanding-roles).
func (o BindingOutput) Role() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Binding) *string { return v.Role }).(pulumi.StringPtrOutput)
}

type BindingArrayOutput struct{ *pulumi.OutputState }

func (BindingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Binding)(nil)).Elem()
}

func (o BindingArrayOutput) ToBindingArrayOutput() BindingArrayOutput {
	return o
}

func (o BindingArrayOutput) ToBindingArrayOutputWithContext(ctx context.Context) BindingArrayOutput {
	return o
}

func (o BindingArrayOutput) Index(i pulumi.IntInput) BindingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Binding {
		return vs[0].([]Binding)[vs[1].(int)]
	}).(BindingOutput)
}

// Associates `members`, or principals, with a `role`.
type BindingResponse struct {
	// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
	Condition ExprResponse `pulumi:"condition"`
	// Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`: A single identity in a workforce identity pool. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/group/{group_id}`: All workforce identities in a group. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/attribute.{attribute_name}/{attribute_value}`: All workforce identities with a specific attribute value. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/*`: All identities in a workforce identity pool. * `principal://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/subject/{subject_attribute_value}`: A single identity in a workload identity pool. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/group/{group_id}`: A workload identity pool group. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/attribute.{attribute_name}/{attribute_value}`: All identities in a workload identity pool with a certain attribute. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/*`: All identities in a workload identity pool. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `deleted:principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`: Deleted single identity in a workforce identity pool. For example, `deleted:principal://iam.googleapis.com/locations/global/workforcePools/my-pool-id/subject/my-subject-attribute-value`.
	Members []string `pulumi:"members"`
	// Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`. For an overview of the IAM roles and permissions, see the [IAM documentation](https://cloud.google.com/iam/docs/roles-overview). For a list of the available pre-defined roles, see [here](https://cloud.google.com/iam/docs/understanding-roles).
	Role string `pulumi:"role"`
}

// Associates `members`, or principals, with a `role`.
type BindingResponseOutput struct{ *pulumi.OutputState }

func (BindingResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BindingResponse)(nil)).Elem()
}

func (o BindingResponseOutput) ToBindingResponseOutput() BindingResponseOutput {
	return o
}

func (o BindingResponseOutput) ToBindingResponseOutputWithContext(ctx context.Context) BindingResponseOutput {
	return o
}

// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
func (o BindingResponseOutput) Condition() ExprResponseOutput {
	return o.ApplyT(func(v BindingResponse) ExprResponse { return v.Condition }).(ExprResponseOutput)
}

// Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`: A single identity in a workforce identity pool. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/group/{group_id}`: All workforce identities in a group. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/attribute.{attribute_name}/{attribute_value}`: All workforce identities with a specific attribute value. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/*`: All identities in a workforce identity pool. * `principal://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/subject/{subject_attribute_value}`: A single identity in a workload identity pool. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/group/{group_id}`: A workload identity pool group. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/attribute.{attribute_name}/{attribute_value}`: All identities in a workload identity pool with a certain attribute. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/*`: All identities in a workload identity pool. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `deleted:principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`: Deleted single identity in a workforce identity pool. For example, `deleted:principal://iam.googleapis.com/locations/global/workforcePools/my-pool-id/subject/my-subject-attribute-value`.
func (o BindingResponseOutput) Members() pulumi.StringArrayOutput {
	return o.ApplyT(func(v BindingResponse) []string { return v.Members }).(pulumi.StringArrayOutput)
}

// Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`. For an overview of the IAM roles and permissions, see the [IAM documentation](https://cloud.google.com/iam/docs/roles-overview). For a list of the available pre-defined roles, see [here](https://cloud.google.com/iam/docs/understanding-roles).
func (o BindingResponseOutput) Role() pulumi.StringOutput {
	return o.ApplyT(func(v BindingResponse) string { return v.Role }).(pulumi.StringOutput)
}

type BindingResponseArrayOutput struct{ *pulumi.OutputState }

func (BindingResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BindingResponse)(nil)).Elem()
}

func (o BindingResponseArrayOutput) ToBindingResponseArrayOutput() BindingResponseArrayOutput {
	return o
}

func (o BindingResponseArrayOutput) ToBindingResponseArrayOutputWithContext(ctx context.Context) BindingResponseArrayOutput {
	return o
}

func (o BindingResponseArrayOutput) Index(i pulumi.IntInput) BindingResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) BindingResponse {
		return vs[0].([]BindingResponse)[vs[1].(int)]
	}).(BindingResponseOutput)
}

// A single check to perform against a Pod. Checks are grouped into `CheckSet` objects, which are defined by the top-level policy.
type Check struct {
	// Optional. A special-case check that always denies. Note that this still only applies when the scope of the `CheckSet` applies and the image isn't exempted by an image allowlist. This check is primarily useful for testing, or to set the default behavior for all unmatched scopes to "deny".
	AlwaysDeny *bool `pulumi:"alwaysDeny"`
	// Optional. A user-provided name for this check. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
	DisplayName *string `pulumi:"displayName"`
	// Optional. Images exempted from this check. If any of the patterns match the image url, the check will not be evaluated.
	ImageAllowlist *ImageAllowlist `pulumi:"imageAllowlist"`
	// Optional. Require that an image is no older than a configured expiration time. Image age is determined by its upload time.
	ImageFreshnessCheck *ImageFreshnessCheck `pulumi:"imageFreshnessCheck"`
	// Optional. Require that an image was signed by Cosign with a trusted key. This check requires that both the image and signature are stored in Artifact Registry.
	SigstoreSignatureCheck *SigstoreSignatureCheck `pulumi:"sigstoreSignatureCheck"`
	// Optional. Require a SimpleSigning-type attestation for every image in the deployment.
	SimpleSigningAttestationCheck *SimpleSigningAttestationCheck `pulumi:"simpleSigningAttestationCheck"`
	// Optional. Require that an image was built by a trusted builder (such as Google Cloud Build), meets requirements for Supply chain Levels for Software Artifacts (SLSA), and was built from a trusted source code repostitory.
	SlsaCheck *SlsaCheck `pulumi:"slsaCheck"`
	// Optional. Require that an image lives in a trusted directory.
	TrustedDirectoryCheck *TrustedDirectoryCheck `pulumi:"trustedDirectoryCheck"`
	// Optional. Require that an image does not contain vulnerabilities that violate the configured rules, such as based on severity levels.
	VulnerabilityCheck *VulnerabilityCheck `pulumi:"vulnerabilityCheck"`
}

// CheckInput is an input type that accepts CheckArgs and CheckOutput values.
// You can construct a concrete instance of `CheckInput` via:
//
//	CheckArgs{...}
type CheckInput interface {
	pulumi.Input

	ToCheckOutput() CheckOutput
	ToCheckOutputWithContext(context.Context) CheckOutput
}

// A single check to perform against a Pod. Checks are grouped into `CheckSet` objects, which are defined by the top-level policy.
type CheckArgs struct {
	// Optional. A special-case check that always denies. Note that this still only applies when the scope of the `CheckSet` applies and the image isn't exempted by an image allowlist. This check is primarily useful for testing, or to set the default behavior for all unmatched scopes to "deny".
	AlwaysDeny pulumi.BoolPtrInput `pulumi:"alwaysDeny"`
	// Optional. A user-provided name for this check. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
	DisplayName pulumi.StringPtrInput `pulumi:"displayName"`
	// Optional. Images exempted from this check. If any of the patterns match the image url, the check will not be evaluated.
	ImageAllowlist ImageAllowlistPtrInput `pulumi:"imageAllowlist"`
	// Optional. Require that an image is no older than a configured expiration time. Image age is determined by its upload time.
	ImageFreshnessCheck ImageFreshnessCheckPtrInput `pulumi:"imageFreshnessCheck"`
	// Optional. Require that an image was signed by Cosign with a trusted key. This check requires that both the image and signature are stored in Artifact Registry.
	SigstoreSignatureCheck SigstoreSignatureCheckPtrInput `pulumi:"sigstoreSignatureCheck"`
	// Optional. Require a SimpleSigning-type attestation for every image in the deployment.
	SimpleSigningAttestationCheck SimpleSigningAttestationCheckPtrInput `pulumi:"simpleSigningAttestationCheck"`
	// Optional. Require that an image was built by a trusted builder (such as Google Cloud Build), meets requirements for Supply chain Levels for Software Artifacts (SLSA), and was built from a trusted source code repostitory.
	SlsaCheck SlsaCheckPtrInput `pulumi:"slsaCheck"`
	// Optional. Require that an image lives in a trusted directory.
	TrustedDirectoryCheck TrustedDirectoryCheckPtrInput `pulumi:"trustedDirectoryCheck"`
	// Optional. Require that an image does not contain vulnerabilities that violate the configured rules, such as based on severity levels.
	VulnerabilityCheck VulnerabilityCheckPtrInput `pulumi:"vulnerabilityCheck"`
}

func (CheckArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Check)(nil)).Elem()
}

func (i CheckArgs) ToCheckOutput() CheckOutput {
	return i.ToCheckOutputWithContext(context.Background())
}

func (i CheckArgs) ToCheckOutputWithContext(ctx context.Context) CheckOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CheckOutput)
}

// CheckArrayInput is an input type that accepts CheckArray and CheckArrayOutput values.
// You can construct a concrete instance of `CheckArrayInput` via:
//
//	CheckArray{ CheckArgs{...} }
type CheckArrayInput interface {
	pulumi.Input

	ToCheckArrayOutput() CheckArrayOutput
	ToCheckArrayOutputWithContext(context.Context) CheckArrayOutput
}

type CheckArray []CheckInput

func (CheckArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Check)(nil)).Elem()
}

func (i CheckArray) ToCheckArrayOutput() CheckArrayOutput {
	return i.ToCheckArrayOutputWithContext(context.Background())
}

func (i CheckArray) ToCheckArrayOutputWithContext(ctx context.Context) CheckArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CheckArrayOutput)
}

// A single check to perform against a Pod. Checks are grouped into `CheckSet` objects, which are defined by the top-level policy.
type CheckOutput struct{ *pulumi.OutputState }

func (CheckOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Check)(nil)).Elem()
}

func (o CheckOutput) ToCheckOutput() CheckOutput {
	return o
}

func (o CheckOutput) ToCheckOutputWithContext(ctx context.Context) CheckOutput {
	return o
}

// Optional. A special-case check that always denies. Note that this still only applies when the scope of the `CheckSet` applies and the image isn't exempted by an image allowlist. This check is primarily useful for testing, or to set the default behavior for all unmatched scopes to "deny".
func (o CheckOutput) AlwaysDeny() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Check) *bool { return v.AlwaysDeny }).(pulumi.BoolPtrOutput)
}

// Optional. A user-provided name for this check. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
func (o CheckOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Check) *string { return v.DisplayName }).(pulumi.StringPtrOutput)
}

// Optional. Images exempted from this check. If any of the patterns match the image url, the check will not be evaluated.
func (o CheckOutput) ImageAllowlist() ImageAllowlistPtrOutput {
	return o.ApplyT(func(v Check) *ImageAllowlist { return v.ImageAllowlist }).(ImageAllowlistPtrOutput)
}

// Optional. Require that an image is no older than a configured expiration time. Image age is determined by its upload time.
func (o CheckOutput) ImageFreshnessCheck() ImageFreshnessCheckPtrOutput {
	return o.ApplyT(func(v Check) *ImageFreshnessCheck { return v.ImageFreshnessCheck }).(ImageFreshnessCheckPtrOutput)
}

// Optional. Require that an image was signed by Cosign with a trusted key. This check requires that both the image and signature are stored in Artifact Registry.
func (o CheckOutput) SigstoreSignatureCheck() SigstoreSignatureCheckPtrOutput {
	return o.ApplyT(func(v Check) *SigstoreSignatureCheck { return v.SigstoreSignatureCheck }).(SigstoreSignatureCheckPtrOutput)
}

// Optional. Require a SimpleSigning-type attestation for every image in the deployment.
func (o CheckOutput) SimpleSigningAttestationCheck() SimpleSigningAttestationCheckPtrOutput {
	return o.ApplyT(func(v Check) *SimpleSigningAttestationCheck { return v.SimpleSigningAttestationCheck }).(SimpleSigningAttestationCheckPtrOutput)
}

// Optional. Require that an image was built by a trusted builder (such as Google Cloud Build), meets requirements for Supply chain Levels for Software Artifacts (SLSA), and was built from a trusted source code repostitory.
func (o CheckOutput) SlsaCheck() SlsaCheckPtrOutput {
	return o.ApplyT(func(v Check) *SlsaCheck { return v.SlsaCheck }).(SlsaCheckPtrOutput)
}

// Optional. Require that an image lives in a trusted directory.
func (o CheckOutput) TrustedDirectoryCheck() TrustedDirectoryCheckPtrOutput {
	return o.ApplyT(func(v Check) *TrustedDirectoryCheck { return v.TrustedDirectoryCheck }).(TrustedDirectoryCheckPtrOutput)
}

// Optional. Require that an image does not contain vulnerabilities that violate the configured rules, such as based on severity levels.
func (o CheckOutput) VulnerabilityCheck() VulnerabilityCheckPtrOutput {
	return o.ApplyT(func(v Check) *VulnerabilityCheck { return v.VulnerabilityCheck }).(VulnerabilityCheckPtrOutput)
}

type CheckArrayOutput struct{ *pulumi.OutputState }

func (CheckArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Check)(nil)).Elem()
}

func (o CheckArrayOutput) ToCheckArrayOutput() CheckArrayOutput {
	return o
}

func (o CheckArrayOutput) ToCheckArrayOutputWithContext(ctx context.Context) CheckArrayOutput {
	return o
}

func (o CheckArrayOutput) Index(i pulumi.IntInput) CheckOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Check {
		return vs[0].([]Check)[vs[1].(int)]
	}).(CheckOutput)
}

// A single check to perform against a Pod. Checks are grouped into `CheckSet` objects, which are defined by the top-level policy.
type CheckResponse struct {
	// Optional. A special-case check that always denies. Note that this still only applies when the scope of the `CheckSet` applies and the image isn't exempted by an image allowlist. This check is primarily useful for testing, or to set the default behavior for all unmatched scopes to "deny".
	AlwaysDeny bool `pulumi:"alwaysDeny"`
	// Optional. A user-provided name for this check. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
	DisplayName string `pulumi:"displayName"`
	// Optional. Images exempted from this check. If any of the patterns match the image url, the check will not be evaluated.
	ImageAllowlist ImageAllowlistResponse `pulumi:"imageAllowlist"`
	// Optional. Require that an image is no older than a configured expiration time. Image age is determined by its upload time.
	ImageFreshnessCheck ImageFreshnessCheckResponse `pulumi:"imageFreshnessCheck"`
	// Optional. Require that an image was signed by Cosign with a trusted key. This check requires that both the image and signature are stored in Artifact Registry.
	SigstoreSignatureCheck SigstoreSignatureCheckResponse `pulumi:"sigstoreSignatureCheck"`
	// Optional. Require a SimpleSigning-type attestation for every image in the deployment.
	SimpleSigningAttestationCheck SimpleSigningAttestationCheckResponse `pulumi:"simpleSigningAttestationCheck"`
	// Optional. Require that an image was built by a trusted builder (such as Google Cloud Build), meets requirements for Supply chain Levels for Software Artifacts (SLSA), and was built from a trusted source code repostitory.
	SlsaCheck SlsaCheckResponse `pulumi:"slsaCheck"`
	// Optional. Require that an image lives in a trusted directory.
	TrustedDirectoryCheck TrustedDirectoryCheckResponse `pulumi:"trustedDirectoryCheck"`
	// Optional. Require that an image does not contain vulnerabilities that violate the configured rules, such as based on severity levels.
	VulnerabilityCheck VulnerabilityCheckResponse `pulumi:"vulnerabilityCheck"`
}

// A single check to perform against a Pod. Checks are grouped into `CheckSet` objects, which are defined by the top-level policy.
type CheckResponseOutput struct{ *pulumi.OutputState }

func (CheckResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CheckResponse)(nil)).Elem()
}

func (o CheckResponseOutput) ToCheckResponseOutput() CheckResponseOutput {
	return o
}

func (o CheckResponseOutput) ToCheckResponseOutputWithContext(ctx context.Context) CheckResponseOutput {
	return o
}

// Optional. A special-case check that always denies. Note that this still only applies when the scope of the `CheckSet` applies and the image isn't exempted by an image allowlist. This check is primarily useful for testing, or to set the default behavior for all unmatched scopes to "deny".
func (o CheckResponseOutput) AlwaysDeny() pulumi.BoolOutput {
	return o.ApplyT(func(v CheckResponse) bool { return v.AlwaysDeny }).(pulumi.BoolOutput)
}

// Optional. A user-provided name for this check. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
func (o CheckResponseOutput) DisplayName() pulumi.StringOutput {
	return o.ApplyT(func(v CheckResponse) string { return v.DisplayName }).(pulumi.StringOutput)
}

// Optional. Images exempted from this check. If any of the patterns match the image url, the check will not be evaluated.
func (o CheckResponseOutput) ImageAllowlist() ImageAllowlistResponseOutput {
	return o.ApplyT(func(v CheckResponse) ImageAllowlistResponse { return v.ImageAllowlist }).(ImageAllowlistResponseOutput)
}

// Optional. Require that an image is no older than a configured expiration time. Image age is determined by its upload time.
func (o CheckResponseOutput) ImageFreshnessCheck() ImageFreshnessCheckResponseOutput {
	return o.ApplyT(func(v CheckResponse) ImageFreshnessCheckResponse { return v.ImageFreshnessCheck }).(ImageFreshnessCheckResponseOutput)
}

// Optional. Require that an image was signed by Cosign with a trusted key. This check requires that both the image and signature are stored in Artifact Registry.
func (o CheckResponseOutput) SigstoreSignatureCheck() SigstoreSignatureCheckResponseOutput {
	return o.ApplyT(func(v CheckResponse) SigstoreSignatureCheckResponse { return v.SigstoreSignatureCheck }).(SigstoreSignatureCheckResponseOutput)
}

// Optional. Require a SimpleSigning-type attestation for every image in the deployment.
func (o CheckResponseOutput) SimpleSigningAttestationCheck() SimpleSigningAttestationCheckResponseOutput {
	return o.ApplyT(func(v CheckResponse) SimpleSigningAttestationCheckResponse { return v.SimpleSigningAttestationCheck }).(SimpleSigningAttestationCheckResponseOutput)
}

// Optional. Require that an image was built by a trusted builder (such as Google Cloud Build), meets requirements for Supply chain Levels for Software Artifacts (SLSA), and was built from a trusted source code repostitory.
func (o CheckResponseOutput) SlsaCheck() SlsaCheckResponseOutput {
	return o.ApplyT(func(v CheckResponse) SlsaCheckResponse { return v.SlsaCheck }).(SlsaCheckResponseOutput)
}

// Optional. Require that an image lives in a trusted directory.
func (o CheckResponseOutput) TrustedDirectoryCheck() TrustedDirectoryCheckResponseOutput {
	return o.ApplyT(func(v CheckResponse) TrustedDirectoryCheckResponse { return v.TrustedDirectoryCheck }).(TrustedDirectoryCheckResponseOutput)
}

// Optional. Require that an image does not contain vulnerabilities that violate the configured rules, such as based on severity levels.
func (o CheckResponseOutput) VulnerabilityCheck() VulnerabilityCheckResponseOutput {
	return o.ApplyT(func(v CheckResponse) VulnerabilityCheckResponse { return v.VulnerabilityCheck }).(VulnerabilityCheckResponseOutput)
}

type CheckResponseArrayOutput struct{ *pulumi.OutputState }

func (CheckResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CheckResponse)(nil)).Elem()
}

func (o CheckResponseArrayOutput) ToCheckResponseArrayOutput() CheckResponseArrayOutput {
	return o
}

func (o CheckResponseArrayOutput) ToCheckResponseArrayOutputWithContext(ctx context.Context) CheckResponseArrayOutput {
	return o
}

func (o CheckResponseArrayOutput) Index(i pulumi.IntInput) CheckResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CheckResponse {
		return vs[0].([]CheckResponse)[vs[1].(int)]
	}).(CheckResponseOutput)
}

// A conjunction of policy checks, scoped to a particular namespace or Kubernetes service account. In order for evaluation of a `CheckSet` to return "allowed" for a given image in a given Pod, one of the following conditions must be satisfied: * The image is explicitly exempted by an entry in `image_allowlist`, OR * ALL of the `checks` evaluate to "allowed".
type CheckSet struct {
	// Optional. The checks to apply. The ultimate result of evaluating the check set will be "allow" if and only if every check in `checks` evaluates to "allow". If `checks` is empty, the default behavior is "always allow".
	Checks []Check `pulumi:"checks"`
	// Optional. A user-provided name for this `CheckSet`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
	DisplayName *string `pulumi:"displayName"`
	// Optional. Images exempted from this `CheckSet`. If any of the patterns match the image being evaluated, no checks in the `CheckSet` will be evaluated.
	ImageAllowlist *ImageAllowlist `pulumi:"imageAllowlist"`
	// Optional. The scope to which this `CheckSet` applies. If unset or an empty string (the default), applies to all namespaces and service accounts. See the `Scope` message documentation for details on scoping rules.
	Scope *Scope `pulumi:"scope"`
}

// CheckSetInput is an input type that accepts CheckSetArgs and CheckSetOutput values.
// You can construct a concrete instance of `CheckSetInput` via:
//
//	CheckSetArgs{...}
type CheckSetInput interface {
	pulumi.Input

	ToCheckSetOutput() CheckSetOutput
	ToCheckSetOutputWithContext(context.Context) CheckSetOutput
}

// A conjunction of policy checks, scoped to a particular namespace or Kubernetes service account. In order for evaluation of a `CheckSet` to return "allowed" for a given image in a given Pod, one of the following conditions must be satisfied: * The image is explicitly exempted by an entry in `image_allowlist`, OR * ALL of the `checks` evaluate to "allowed".
type CheckSetArgs struct {
	// Optional. The checks to apply. The ultimate result of evaluating the check set will be "allow" if and only if every check in `checks` evaluates to "allow". If `checks` is empty, the default behavior is "always allow".
	Checks CheckArrayInput `pulumi:"checks"`
	// Optional. A user-provided name for this `CheckSet`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
	DisplayName pulumi.StringPtrInput `pulumi:"displayName"`
	// Optional. Images exempted from this `CheckSet`. If any of the patterns match the image being evaluated, no checks in the `CheckSet` will be evaluated.
	ImageAllowlist ImageAllowlistPtrInput `pulumi:"imageAllowlist"`
	// Optional. The scope to which this `CheckSet` applies. If unset or an empty string (the default), applies to all namespaces and service accounts. See the `Scope` message documentation for details on scoping rules.
	Scope ScopePtrInput `pulumi:"scope"`
}

func (CheckSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CheckSet)(nil)).Elem()
}

func (i CheckSetArgs) ToCheckSetOutput() CheckSetOutput {
	return i.ToCheckSetOutputWithContext(context.Background())
}

func (i CheckSetArgs) ToCheckSetOutputWithContext(ctx context.Context) CheckSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CheckSetOutput)
}

// CheckSetArrayInput is an input type that accepts CheckSetArray and CheckSetArrayOutput values.
// You can construct a concrete instance of `CheckSetArrayInput` via:
//
//	CheckSetArray{ CheckSetArgs{...} }
type CheckSetArrayInput interface {
	pulumi.Input

	ToCheckSetArrayOutput() CheckSetArrayOutput
	ToCheckSetArrayOutputWithContext(context.Context) CheckSetArrayOutput
}

type CheckSetArray []CheckSetInput

func (CheckSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CheckSet)(nil)).Elem()
}

func (i CheckSetArray) ToCheckSetArrayOutput() CheckSetArrayOutput {
	return i.ToCheckSetArrayOutputWithContext(context.Background())
}

func (i CheckSetArray) ToCheckSetArrayOutputWithContext(ctx context.Context) CheckSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CheckSetArrayOutput)
}

// A conjunction of policy checks, scoped to a particular namespace or Kubernetes service account. In order for evaluation of a `CheckSet` to return "allowed" for a given image in a given Pod, one of the following conditions must be satisfied: * The image is explicitly exempted by an entry in `image_allowlist`, OR * ALL of the `checks` evaluate to "allowed".
type CheckSetOutput struct{ *pulumi.OutputState }

func (CheckSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CheckSet)(nil)).Elem()
}

func (o CheckSetOutput) ToCheckSetOutput() CheckSetOutput {
	return o
}

func (o CheckSetOutput) ToCheckSetOutputWithContext(ctx context.Context) CheckSetOutput {
	return o
}

// Optional. The checks to apply. The ultimate result of evaluating the check set will be "allow" if and only if every check in `checks` evaluates to "allow". If `checks` is empty, the default behavior is "always allow".
func (o CheckSetOutput) Checks() CheckArrayOutput {
	return o.ApplyT(func(v CheckSet) []Check { return v.Checks }).(CheckArrayOutput)
}

// Optional. A user-provided name for this `CheckSet`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
func (o CheckSetOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CheckSet) *string { return v.DisplayName }).(pulumi.StringPtrOutput)
}

// Optional. Images exempted from this `CheckSet`. If any of the patterns match the image being evaluated, no checks in the `CheckSet` will be evaluated.
func (o CheckSetOutput) ImageAllowlist() ImageAllowlistPtrOutput {
	return o.ApplyT(func(v CheckSet) *ImageAllowlist { return v.ImageAllowlist }).(ImageAllowlistPtrOutput)
}

// Optional. The scope to which this `CheckSet` applies. If unset or an empty string (the default), applies to all namespaces and service accounts. See the `Scope` message documentation for details on scoping rules.
func (o CheckSetOutput) Scope() ScopePtrOutput {
	return o.ApplyT(func(v CheckSet) *Scope { return v.Scope }).(ScopePtrOutput)
}

type CheckSetArrayOutput struct{ *pulumi.OutputState }

func (CheckSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CheckSet)(nil)).Elem()
}

func (o CheckSetArrayOutput) ToCheckSetArrayOutput() CheckSetArrayOutput {
	return o
}

func (o CheckSetArrayOutput) ToCheckSetArrayOutputWithContext(ctx context.Context) CheckSetArrayOutput {
	return o
}

func (o CheckSetArrayOutput) Index(i pulumi.IntInput) CheckSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CheckSet {
		return vs[0].([]CheckSet)[vs[1].(int)]
	}).(CheckSetOutput)
}

// A conjunction of policy checks, scoped to a particular namespace or Kubernetes service account. In order for evaluation of a `CheckSet` to return "allowed" for a given image in a given Pod, one of the following conditions must be satisfied: * The image is explicitly exempted by an entry in `image_allowlist`, OR * ALL of the `checks` evaluate to "allowed".
type CheckSetResponse struct {
	// Optional. The checks to apply. The ultimate result of evaluating the check set will be "allow" if and only if every check in `checks` evaluates to "allow". If `checks` is empty, the default behavior is "always allow".
	Checks []CheckResponse `pulumi:"checks"`
	// Optional. A user-provided name for this `CheckSet`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
	DisplayName string `pulumi:"displayName"`
	// Optional. Images exempted from this `CheckSet`. If any of the patterns match the image being evaluated, no checks in the `CheckSet` will be evaluated.
	ImageAllowlist ImageAllowlistResponse `pulumi:"imageAllowlist"`
	// Optional. The scope to which this `CheckSet` applies. If unset or an empty string (the default), applies to all namespaces and service accounts. See the `Scope` message documentation for details on scoping rules.
	Scope ScopeResponse `pulumi:"scope"`
}

// A conjunction of policy checks, scoped to a particular namespace or Kubernetes service account. In order for evaluation of a `CheckSet` to return "allowed" for a given image in a given Pod, one of the following conditions must be satisfied: * The image is explicitly exempted by an entry in `image_allowlist`, OR * ALL of the `checks` evaluate to "allowed".
type CheckSetResponseOutput struct{ *pulumi.OutputState }

func (CheckSetResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CheckSetResponse)(nil)).Elem()
}

func (o CheckSetResponseOutput) ToCheckSetResponseOutput() CheckSetResponseOutput {
	return o
}

func (o CheckSetResponseOutput) ToCheckSetResponseOutputWithContext(ctx context.Context) CheckSetResponseOutput {
	return o
}

// Optional. The checks to apply. The ultimate result of evaluating the check set will be "allow" if and only if every check in `checks` evaluates to "allow". If `checks` is empty, the default behavior is "always allow".
func (o CheckSetResponseOutput) Checks() CheckResponseArrayOutput {
	return o.ApplyT(func(v CheckSetResponse) []CheckResponse { return v.Checks }).(CheckResponseArrayOutput)
}

// Optional. A user-provided name for this `CheckSet`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
func (o CheckSetResponseOutput) DisplayName() pulumi.StringOutput {
	return o.ApplyT(func(v CheckSetResponse) string { return v.DisplayName }).(pulumi.StringOutput)
}

// Optional. Images exempted from this `CheckSet`. If any of the patterns match the image being evaluated, no checks in the `CheckSet` will be evaluated.
func (o CheckSetResponseOutput) ImageAllowlist() ImageAllowlistResponseOutput {
	return o.ApplyT(func(v CheckSetResponse) ImageAllowlistResponse { return v.ImageAllowlist }).(ImageAllowlistResponseOutput)
}

// Optional. The scope to which this `CheckSet` applies. If unset or an empty string (the default), applies to all namespaces and service accounts. See the `Scope` message documentation for details on scoping rules.
func (o CheckSetResponseOutput) Scope() ScopeResponseOutput {
	return o.ApplyT(func(v CheckSetResponse) ScopeResponse { return v.Scope }).(ScopeResponseOutput)
}

type CheckSetResponseArrayOutput struct{ *pulumi.OutputState }

func (CheckSetResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CheckSetResponse)(nil)).Elem()
}

func (o CheckSetResponseArrayOutput) ToCheckSetResponseArrayOutput() CheckSetResponseArrayOutput {
	return o
}

func (o CheckSetResponseArrayOutput) ToCheckSetResponseArrayOutputWithContext(ctx context.Context) CheckSetResponseArrayOutput {
	return o
}

func (o CheckSetResponseArrayOutput) Index(i pulumi.IntInput) CheckSetResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CheckSetResponse {
		return vs[0].([]CheckSetResponse)[vs[1].(int)]
	}).(CheckSetResponseOutput)
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type Expr struct {
	// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
	Description *string `pulumi:"description"`
	// Textual representation of an expression in Common Expression Language syntax.
	Expression *string `pulumi:"expression"`
	// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
	Location *string `pulumi:"location"`
	// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
	Title *string `pulumi:"title"`
}

// ExprInput is an input type that accepts ExprArgs and ExprOutput values.
// You can construct a concrete instance of `ExprInput` via:
//
//	ExprArgs{...}
type ExprInput interface {
	pulumi.Input

	ToExprOutput() ExprOutput
	ToExprOutputWithContext(context.Context) ExprOutput
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprArgs struct {
	// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Textual representation of an expression in Common Expression Language syntax.
	Expression pulumi.StringPtrInput `pulumi:"expression"`
	// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
	Location pulumi.StringPtrInput `pulumi:"location"`
	// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
	Title pulumi.StringPtrInput `pulumi:"title"`
}

func (ExprArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Expr)(nil)).Elem()
}

func (i ExprArgs) ToExprOutput() ExprOutput {
	return i.ToExprOutputWithContext(context.Background())
}

func (i ExprArgs) ToExprOutputWithContext(ctx context.Context) ExprOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExprOutput)
}

func (i ExprArgs) ToExprPtrOutput() ExprPtrOutput {
	return i.ToExprPtrOutputWithContext(context.Background())
}

func (i ExprArgs) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExprOutput).ToExprPtrOutputWithContext(ctx)
}

// ExprPtrInput is an input type that accepts ExprArgs, ExprPtr and ExprPtrOutput values.
// You can construct a concrete instance of `ExprPtrInput` via:
//
//	        ExprArgs{...}
//
//	or:
//
//	        nil
type ExprPtrInput interface {
	pulumi.Input

	ToExprPtrOutput() ExprPtrOutput
	ToExprPtrOutputWithContext(context.Context) ExprPtrOutput
}

type exprPtrType ExprArgs

func ExprPtr(v *ExprArgs) ExprPtrInput {
	return (*exprPtrType)(v)
}

func (*exprPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Expr)(nil)).Elem()
}

func (i *exprPtrType) ToExprPtrOutput() ExprPtrOutput {
	return i.ToExprPtrOutputWithContext(context.Background())
}

func (i *exprPtrType) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExprPtrOutput)
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprOutput struct{ *pulumi.OutputState }

func (ExprOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Expr)(nil)).Elem()
}

func (o ExprOutput) ToExprOutput() ExprOutput {
	return o
}

func (o ExprOutput) ToExprOutputWithContext(ctx context.Context) ExprOutput {
	return o
}

func (o ExprOutput) ToExprPtrOutput() ExprPtrOutput {
	return o.ToExprPtrOutputWithContext(context.Background())
}

func (o ExprOutput) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Expr) *Expr {
		return &v
	}).(ExprPtrOutput)
}

// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
func (o ExprOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Textual representation of an expression in Common Expression Language syntax.
func (o ExprOutput) Expression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Expression }).(pulumi.StringPtrOutput)
}

// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
func (o ExprOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Location }).(pulumi.StringPtrOutput)
}

// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
func (o ExprOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Title }).(pulumi.StringPtrOutput)
}

type ExprPtrOutput struct{ *pulumi.OutputState }

func (ExprPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Expr)(nil)).Elem()
}

func (o ExprPtrOutput) ToExprPtrOutput() ExprPtrOutput {
	return o
}

func (o ExprPtrOutput) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return o
}

func (o ExprPtrOutput) Elem() ExprOutput {
	return o.ApplyT(func(v *Expr) Expr {
		if v != nil {
			return *v
		}
		var ret Expr
		return ret
	}).(ExprOutput)
}

// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
func (o ExprPtrOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Description
	}).(pulumi.StringPtrOutput)
}

// Textual representation of an expression in Common Expression Language syntax.
func (o ExprPtrOutput) Expression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Expression
	}).(pulumi.StringPtrOutput)
}

// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
func (o ExprPtrOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Location
	}).(pulumi.StringPtrOutput)
}

// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
func (o ExprPtrOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Title
	}).(pulumi.StringPtrOutput)
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprResponse struct {
	// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
	Description string `pulumi:"description"`
	// Textual representation of an expression in Common Expression Language syntax.
	Expression string `pulumi:"expression"`
	// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
	Location string `pulumi:"location"`
	// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
	Title string `pulumi:"title"`
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprResponseOutput struct{ *pulumi.OutputState }

func (ExprResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ExprResponse)(nil)).Elem()
}

func (o ExprResponseOutput) ToExprResponseOutput() ExprResponseOutput {
	return o
}

func (o ExprResponseOutput) ToExprResponseOutputWithContext(ctx context.Context) ExprResponseOutput {
	return o
}

// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
func (o ExprResponseOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v ExprResponse) string { return v.Description }).(pulumi.StringOutput)
}

// Textual representation of an expression in Common Expression Language syntax.
func (o ExprResponseOutput) Expression() pulumi.StringOutput {
	return o.ApplyT(func(v ExprResponse) string { return v.Expression }).(pulumi.StringOutput)
}

// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
func (o ExprResponseOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v ExprResponse) string { return v.Location }).(pulumi.StringOutput)
}

// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
func (o ExprResponseOutput) Title() pulumi.StringOutput {
	return o.ApplyT(func(v ExprResponse) string { return v.Title }).(pulumi.StringOutput)
}

// A Binary Authorization policy for a GKE cluster. This is one type of policy that can occur as a `PlatformPolicy`.
type GkePolicy struct {
	// Optional. The `CheckSet` objects to apply, scoped by namespace or namespace and service account. Exactly one `CheckSet` will be evaluated for a given Pod (unless the list is empty, in which case the behavior is "always allow"). If multiple `CheckSet` objects have scopes that match the namespace and service account of the Pod being evaluated, only the `CheckSet` with the MOST SPECIFIC scope will match. `CheckSet` objects must be listed in order of decreasing specificity, i.e. if a scope matches a given service account (which must include the namespace), it must come before a `CheckSet` with a scope matching just that namespace. This property is enforced by server-side validation. The purpose of this restriction is to ensure that if more than one `CheckSet` matches a given Pod, the `CheckSet` that will be evaluated will always be the first in the list to match (because if any other matches, it must be less specific). If `check_sets` is empty, the default behavior is to allow all images. If `check_sets` is non-empty, the last `check_sets` entry must always be a `CheckSet` with no scope set, i.e. a catchall to handle any situation not caught by the preceding `CheckSet` objects.
	CheckSets []CheckSet `pulumi:"checkSets"`
	// Optional. Images exempted from this policy. If any of the patterns match the image being evaluated, the rest of the policy will not be evaluated.
	ImageAllowlist *ImageAllowlist `pulumi:"imageAllowlist"`
}

// GkePolicyInput is an input type that accepts GkePolicyArgs and GkePolicyOutput values.
// You can construct a concrete instance of `GkePolicyInput` via:
//
//	GkePolicyArgs{...}
type GkePolicyInput interface {
	pulumi.Input

	ToGkePolicyOutput() GkePolicyOutput
	ToGkePolicyOutputWithContext(context.Context) GkePolicyOutput
}

// A Binary Authorization policy for a GKE cluster. This is one type of policy that can occur as a `PlatformPolicy`.
type GkePolicyArgs struct {
	// Optional. The `CheckSet` objects to apply, scoped by namespace or namespace and service account. Exactly one `CheckSet` will be evaluated for a given Pod (unless the list is empty, in which case the behavior is "always allow"). If multiple `CheckSet` objects have scopes that match the namespace and service account of the Pod being evaluated, only the `CheckSet` with the MOST SPECIFIC scope will match. `CheckSet` objects must be listed in order of decreasing specificity, i.e. if a scope matches a given service account (which must include the namespace), it must come before a `CheckSet` with a scope matching just that namespace. This property is enforced by server-side validation. The purpose of this restriction is to ensure that if more than one `CheckSet` matches a given Pod, the `CheckSet` that will be evaluated will always be the first in the list to match (because if any other matches, it must be less specific). If `check_sets` is empty, the default behavior is to allow all images. If `check_sets` is non-empty, the last `check_sets` entry must always be a `CheckSet` with no scope set, i.e. a catchall to handle any situation not caught by the preceding `CheckSet` objects.
	CheckSets CheckSetArrayInput `pulumi:"checkSets"`
	// Optional. Images exempted from this policy. If any of the patterns match the image being evaluated, the rest of the policy will not be evaluated.
	ImageAllowlist ImageAllowlistPtrInput `pulumi:"imageAllowlist"`
}

func (GkePolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GkePolicy)(nil)).Elem()
}

func (i GkePolicyArgs) ToGkePolicyOutput() GkePolicyOutput {
	return i.ToGkePolicyOutputWithContext(context.Background())
}

func (i GkePolicyArgs) ToGkePolicyOutputWithContext(ctx context.Context) GkePolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GkePolicyOutput)
}

func (i GkePolicyArgs) ToGkePolicyPtrOutput() GkePolicyPtrOutput {
	return i.ToGkePolicyPtrOutputWithContext(context.Background())
}

func (i GkePolicyArgs) ToGkePolicyPtrOutputWithContext(ctx context.Context) GkePolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GkePolicyOutput).ToGkePolicyPtrOutputWithContext(ctx)
}

// GkePolicyPtrInput is an input type that accepts GkePolicyArgs, GkePolicyPtr and GkePolicyPtrOutput values.
// You can construct a concrete instance of `GkePolicyPtrInput` via:
//
//	        GkePolicyArgs{...}
//
//	or:
//
//	        nil
type GkePolicyPtrInput interface {
	pulumi.Input

	ToGkePolicyPtrOutput() GkePolicyPtrOutput
	ToGkePolicyPtrOutputWithContext(context.Context) GkePolicyPtrOutput
}

type gkePolicyPtrType GkePolicyArgs

func GkePolicyPtr(v *GkePolicyArgs) GkePolicyPtrInput {
	return (*gkePolicyPtrType)(v)
}

func (*gkePolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GkePolicy)(nil)).Elem()
}

func (i *gkePolicyPtrType) ToGkePolicyPtrOutput() GkePolicyPtrOutput {
	return i.ToGkePolicyPtrOutputWithContext(context.Background())
}

func (i *gkePolicyPtrType) ToGkePolicyPtrOutputWithContext(ctx context.Context) GkePolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GkePolicyPtrOutput)
}

// A Binary Authorization policy for a GKE cluster. This is one type of policy that can occur as a `PlatformPolicy`.
type GkePolicyOutput struct{ *pulumi.OutputState }

func (GkePolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GkePolicy)(nil)).Elem()
}

func (o GkePolicyOutput) ToGkePolicyOutput() GkePolicyOutput {
	return o
}

func (o GkePolicyOutput) ToGkePolicyOutputWithContext(ctx context.Context) GkePolicyOutput {
	return o
}

func (o GkePolicyOutput) ToGkePolicyPtrOutput() GkePolicyPtrOutput {
	return o.ToGkePolicyPtrOutputWithContext(context.Background())
}

func (o GkePolicyOutput) ToGkePolicyPtrOutputWithContext(ctx context.Context) GkePolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GkePolicy) *GkePolicy {
		return &v
	}).(GkePolicyPtrOutput)
}

// Optional. The `CheckSet` objects to apply, scoped by namespace or namespace and service account. Exactly one `CheckSet` will be evaluated for a given Pod (unless the list is empty, in which case the behavior is "always allow"). If multiple `CheckSet` objects have scopes that match the namespace and service account of the Pod being evaluated, only the `CheckSet` with the MOST SPECIFIC scope will match. `CheckSet` objects must be listed in order of decreasing specificity, i.e. if a scope matches a given service account (which must include the namespace), it must come before a `CheckSet` with a scope matching just that namespace. This property is enforced by server-side validation. The purpose of this restriction is to ensure that if more than one `CheckSet` matches a given Pod, the `CheckSet` that will be evaluated will always be the first in the list to match (because if any other matches, it must be less specific). If `check_sets` is empty, the default behavior is to allow all images. If `check_sets` is non-empty, the last `check_sets` entry must always be a `CheckSet` with no scope set, i.e. a catchall to handle any situation not caught by the preceding `CheckSet` objects.
func (o GkePolicyOutput) CheckSets() CheckSetArrayOutput {
	return o.ApplyT(func(v GkePolicy) []CheckSet { return v.CheckSets }).(CheckSetArrayOutput)
}

// Optional. Images exempted from this policy. If any of the patterns match the image being evaluated, the rest of the policy will not be evaluated.
func (o GkePolicyOutput) ImageAllowlist() ImageAllowlistPtrOutput {
	return o.ApplyT(func(v GkePolicy) *ImageAllowlist { return v.ImageAllowlist }).(ImageAllowlistPtrOutput)
}

type GkePolicyPtrOutput struct{ *pulumi.OutputState }

func (GkePolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GkePolicy)(nil)).Elem()
}

func (o GkePolicyPtrOutput) ToGkePolicyPtrOutput() GkePolicyPtrOutput {
	return o
}

func (o GkePolicyPtrOutput) ToGkePolicyPtrOutputWithContext(ctx context.Context) GkePolicyPtrOutput {
	return o
}

func (o GkePolicyPtrOutput) Elem() GkePolicyOutput {
	return o.ApplyT(func(v *GkePolicy) GkePolicy {
		if v != nil {
			return *v
		}
		var ret GkePolicy
		return ret
	}).(GkePolicyOutput)
}

// Optional. The `CheckSet` objects to apply, scoped by namespace or namespace and service account. Exactly one `CheckSet` will be evaluated for a given Pod (unless the list is empty, in which case the behavior is "always allow"). If multiple `CheckSet` objects have scopes that match the namespace and service account of the Pod being evaluated, only the `CheckSet` with the MOST SPECIFIC scope will match. `CheckSet` objects must be listed in order of decreasing specificity, i.e. if a scope matches a given service account (which must include the namespace), it must come before a `CheckSet` with a scope matching just that namespace. This property is enforced by server-side validation. The purpose of this restriction is to ensure that if more than one `CheckSet` matches a given Pod, the `CheckSet` that will be evaluated will always be the first in the list to match (because if any other matches, it must be less specific). If `check_sets` is empty, the default behavior is to allow all images. If `check_sets` is non-empty, the last `check_sets` entry must always be a `CheckSet` with no scope set, i.e. a catchall to handle any situation not caught by the preceding `CheckSet` objects.
func (o GkePolicyPtrOutput) CheckSets() CheckSetArrayOutput {
	return o.ApplyT(func(v *GkePolicy) []CheckSet {
		if v == nil {
			return nil
		}
		return v.CheckSets
	}).(CheckSetArrayOutput)
}

// Optional. Images exempted from this policy. If any of the patterns match the image being evaluated, the rest of the policy will not be evaluated.
func (o GkePolicyPtrOutput) ImageAllowlist() ImageAllowlistPtrOutput {
	return o.ApplyT(func(v *GkePolicy) *ImageAllowlist {
		if v == nil {
			return nil
		}
		return v.ImageAllowlist
	}).(ImageAllowlistPtrOutput)
}

// A Binary Authorization policy for a GKE cluster. This is one type of policy that can occur as a `PlatformPolicy`.
type GkePolicyResponse struct {
	// Optional. The `CheckSet` objects to apply, scoped by namespace or namespace and service account. Exactly one `CheckSet` will be evaluated for a given Pod (unless the list is empty, in which case the behavior is "always allow"). If multiple `CheckSet` objects have scopes that match the namespace and service account of the Pod being evaluated, only the `CheckSet` with the MOST SPECIFIC scope will match. `CheckSet` objects must be listed in order of decreasing specificity, i.e. if a scope matches a given service account (which must include the namespace), it must come before a `CheckSet` with a scope matching just that namespace. This property is enforced by server-side validation. The purpose of this restriction is to ensure that if more than one `CheckSet` matches a given Pod, the `CheckSet` that will be evaluated will always be the first in the list to match (because if any other matches, it must be less specific). If `check_sets` is empty, the default behavior is to allow all images. If `check_sets` is non-empty, the last `check_sets` entry must always be a `CheckSet` with no scope set, i.e. a catchall to handle any situation not caught by the preceding `CheckSet` objects.
	CheckSets []CheckSetResponse `pulumi:"checkSets"`
	// Optional. Images exempted from this policy. If any of the patterns match the image being evaluated, the rest of the policy will not be evaluated.
	ImageAllowlist ImageAllowlistResponse `pulumi:"imageAllowlist"`
}

// A Binary Authorization policy for a GKE cluster. This is one type of policy that can occur as a `PlatformPolicy`.
type GkePolicyResponseOutput struct{ *pulumi.OutputState }

func (GkePolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GkePolicyResponse)(nil)).Elem()
}

func (o GkePolicyResponseOutput) ToGkePolicyResponseOutput() GkePolicyResponseOutput {
	return o
}

func (o GkePolicyResponseOutput) ToGkePolicyResponseOutputWithContext(ctx context.Context) GkePolicyResponseOutput {
	return o
}

// Optional. The `CheckSet` objects to apply, scoped by namespace or namespace and service account. Exactly one `CheckSet` will be evaluated for a given Pod (unless the list is empty, in which case the behavior is "always allow"). If multiple `CheckSet` objects have scopes that match the namespace and service account of the Pod being evaluated, only the `CheckSet` with the MOST SPECIFIC scope will match. `CheckSet` objects must be listed in order of decreasing specificity, i.e. if a scope matches a given service account (which must include the namespace), it must come before a `CheckSet` with a scope matching just that namespace. This property is enforced by server-side validation. The purpose of this restriction is to ensure that if more than one `CheckSet` matches a given Pod, the `CheckSet` that will be evaluated will always be the first in the list to match (because if any other matches, it must be less specific). If `check_sets` is empty, the default behavior is to allow all images. If `check_sets` is non-empty, the last `check_sets` entry must always be a `CheckSet` with no scope set, i.e. a catchall to handle any situation not caught by the preceding `CheckSet` objects.
func (o GkePolicyResponseOutput) CheckSets() CheckSetResponseArrayOutput {
	return o.ApplyT(func(v GkePolicyResponse) []CheckSetResponse { return v.CheckSets }).(CheckSetResponseArrayOutput)
}

// Optional. Images exempted from this policy. If any of the patterns match the image being evaluated, the rest of the policy will not be evaluated.
func (o GkePolicyResponseOutput) ImageAllowlist() ImageAllowlistResponseOutput {
	return o.ApplyT(func(v GkePolicyResponse) ImageAllowlistResponse { return v.ImageAllowlist }).(ImageAllowlistResponseOutput)
}

// Images that are exempted from normal checks based on name pattern only.
type ImageAllowlist struct {
	// A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
	AllowPattern []string `pulumi:"allowPattern"`
}

// ImageAllowlistInput is an input type that accepts ImageAllowlistArgs and ImageAllowlistOutput values.
// You can construct a concrete instance of `ImageAllowlistInput` via:
//
//	ImageAllowlistArgs{...}
type ImageAllowlistInput interface {
	pulumi.Input

	ToImageAllowlistOutput() ImageAllowlistOutput
	ToImageAllowlistOutputWithContext(context.Context) ImageAllowlistOutput
}

// Images that are exempted from normal checks based on name pattern only.
type ImageAllowlistArgs struct {
	// A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
	AllowPattern pulumi.StringArrayInput `pulumi:"allowPattern"`
}

func (ImageAllowlistArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ImageAllowlist)(nil)).Elem()
}

func (i ImageAllowlistArgs) ToImageAllowlistOutput() ImageAllowlistOutput {
	return i.ToImageAllowlistOutputWithContext(context.Background())
}

func (i ImageAllowlistArgs) ToImageAllowlistOutputWithContext(ctx context.Context) ImageAllowlistOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageAllowlistOutput)
}

func (i ImageAllowlistArgs) ToImageAllowlistPtrOutput() ImageAllowlistPtrOutput {
	return i.ToImageAllowlistPtrOutputWithContext(context.Background())
}

func (i ImageAllowlistArgs) ToImageAllowlistPtrOutputWithContext(ctx context.Context) ImageAllowlistPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageAllowlistOutput).ToImageAllowlistPtrOutputWithContext(ctx)
}

// ImageAllowlistPtrInput is an input type that accepts ImageAllowlistArgs, ImageAllowlistPtr and ImageAllowlistPtrOutput values.
// You can construct a concrete instance of `ImageAllowlistPtrInput` via:
//
//	        ImageAllowlistArgs{...}
//
//	or:
//
//	        nil
type ImageAllowlistPtrInput interface {
	pulumi.Input

	ToImageAllowlistPtrOutput() ImageAllowlistPtrOutput
	ToImageAllowlistPtrOutputWithContext(context.Context) ImageAllowlistPtrOutput
}

type imageAllowlistPtrType ImageAllowlistArgs

func ImageAllowlistPtr(v *ImageAllowlistArgs) ImageAllowlistPtrInput {
	return (*imageAllowlistPtrType)(v)
}

func (*imageAllowlistPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ImageAllowlist)(nil)).Elem()
}

func (i *imageAllowlistPtrType) ToImageAllowlistPtrOutput() ImageAllowlistPtrOutput {
	return i.ToImageAllowlistPtrOutputWithContext(context.Background())
}

func (i *imageAllowlistPtrType) ToImageAllowlistPtrOutputWithContext(ctx context.Context) ImageAllowlistPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageAllowlistPtrOutput)
}

// Images that are exempted from normal checks based on name pattern only.
type ImageAllowlistOutput struct{ *pulumi.OutputState }

func (ImageAllowlistOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ImageAllowlist)(nil)).Elem()
}

func (o ImageAllowlistOutput) ToImageAllowlistOutput() ImageAllowlistOutput {
	return o
}

func (o ImageAllowlistOutput) ToImageAllowlistOutputWithContext(ctx context.Context) ImageAllowlistOutput {
	return o
}

func (o ImageAllowlistOutput) ToImageAllowlistPtrOutput() ImageAllowlistPtrOutput {
	return o.ToImageAllowlistPtrOutputWithContext(context.Background())
}

func (o ImageAllowlistOutput) ToImageAllowlistPtrOutputWithContext(ctx context.Context) ImageAllowlistPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ImageAllowlist) *ImageAllowlist {
		return &v
	}).(ImageAllowlistPtrOutput)
}

// A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
func (o ImageAllowlistOutput) AllowPattern() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ImageAllowlist) []string { return v.AllowPattern }).(pulumi.StringArrayOutput)
}

type ImageAllowlistPtrOutput struct{ *pulumi.OutputState }

func (ImageAllowlistPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ImageAllowlist)(nil)).Elem()
}

func (o ImageAllowlistPtrOutput) ToImageAllowlistPtrOutput() ImageAllowlistPtrOutput {
	return o
}

func (o ImageAllowlistPtrOutput) ToImageAllowlistPtrOutputWithContext(ctx context.Context) ImageAllowlistPtrOutput {
	return o
}

func (o ImageAllowlistPtrOutput) Elem() ImageAllowlistOutput {
	return o.ApplyT(func(v *ImageAllowlist) ImageAllowlist {
		if v != nil {
			return *v
		}
		var ret ImageAllowlist
		return ret
	}).(ImageAllowlistOutput)
}

// A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
func (o ImageAllowlistPtrOutput) AllowPattern() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ImageAllowlist) []string {
		if v == nil {
			return nil
		}
		return v.AllowPattern
	}).(pulumi.StringArrayOutput)
}

// Images that are exempted from normal checks based on name pattern only.
type ImageAllowlistResponse struct {
	// A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
	AllowPattern []string `pulumi:"allowPattern"`
}

// Images that are exempted from normal checks based on name pattern only.
type ImageAllowlistResponseOutput struct{ *pulumi.OutputState }

func (ImageAllowlistResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ImageAllowlistResponse)(nil)).Elem()
}

func (o ImageAllowlistResponseOutput) ToImageAllowlistResponseOutput() ImageAllowlistResponseOutput {
	return o
}

func (o ImageAllowlistResponseOutput) ToImageAllowlistResponseOutputWithContext(ctx context.Context) ImageAllowlistResponseOutput {
	return o
}

// A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
func (o ImageAllowlistResponseOutput) AllowPattern() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ImageAllowlistResponse) []string { return v.AllowPattern }).(pulumi.StringArrayOutput)
}

// An image freshness check, which rejects images that were uploaded before the set number of days ago to the supported repositories.
type ImageFreshnessCheck struct {
	// The max number of days that is allowed since the image was uploaded. Must be greater than zero.
	MaxUploadAgeDays int `pulumi:"maxUploadAgeDays"`
}

// ImageFreshnessCheckInput is an input type that accepts ImageFreshnessCheckArgs and ImageFreshnessCheckOutput values.
// You can construct a concrete instance of `ImageFreshnessCheckInput` via:
//
//	ImageFreshnessCheckArgs{...}
type ImageFreshnessCheckInput interface {
	pulumi.Input

	ToImageFreshnessCheckOutput() ImageFreshnessCheckOutput
	ToImageFreshnessCheckOutputWithContext(context.Context) ImageFreshnessCheckOutput
}

// An image freshness check, which rejects images that were uploaded before the set number of days ago to the supported repositories.
type ImageFreshnessCheckArgs struct {
	// The max number of days that is allowed since the image was uploaded. Must be greater than zero.
	MaxUploadAgeDays pulumi.IntInput `pulumi:"maxUploadAgeDays"`
}

func (ImageFreshnessCheckArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ImageFreshnessCheck)(nil)).Elem()
}

func (i ImageFreshnessCheckArgs) ToImageFreshnessCheckOutput() ImageFreshnessCheckOutput {
	return i.ToImageFreshnessCheckOutputWithContext(context.Background())
}

func (i ImageFreshnessCheckArgs) ToImageFreshnessCheckOutputWithContext(ctx context.Context) ImageFreshnessCheckOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageFreshnessCheckOutput)
}

func (i ImageFreshnessCheckArgs) ToImageFreshnessCheckPtrOutput() ImageFreshnessCheckPtrOutput {
	return i.ToImageFreshnessCheckPtrOutputWithContext(context.Background())
}

func (i ImageFreshnessCheckArgs) ToImageFreshnessCheckPtrOutputWithContext(ctx context.Context) ImageFreshnessCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageFreshnessCheckOutput).ToImageFreshnessCheckPtrOutputWithContext(ctx)
}

// ImageFreshnessCheckPtrInput is an input type that accepts ImageFreshnessCheckArgs, ImageFreshnessCheckPtr and ImageFreshnessCheckPtrOutput values.
// You can construct a concrete instance of `ImageFreshnessCheckPtrInput` via:
//
//	        ImageFreshnessCheckArgs{...}
//
//	or:
//
//	        nil
type ImageFreshnessCheckPtrInput interface {
	pulumi.Input

	ToImageFreshnessCheckPtrOutput() ImageFreshnessCheckPtrOutput
	ToImageFreshnessCheckPtrOutputWithContext(context.Context) ImageFreshnessCheckPtrOutput
}

type imageFreshnessCheckPtrType ImageFreshnessCheckArgs

func ImageFreshnessCheckPtr(v *ImageFreshnessCheckArgs) ImageFreshnessCheckPtrInput {
	return (*imageFreshnessCheckPtrType)(v)
}

func (*imageFreshnessCheckPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ImageFreshnessCheck)(nil)).Elem()
}

func (i *imageFreshnessCheckPtrType) ToImageFreshnessCheckPtrOutput() ImageFreshnessCheckPtrOutput {
	return i.ToImageFreshnessCheckPtrOutputWithContext(context.Background())
}

func (i *imageFreshnessCheckPtrType) ToImageFreshnessCheckPtrOutputWithContext(ctx context.Context) ImageFreshnessCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageFreshnessCheckPtrOutput)
}

// An image freshness check, which rejects images that were uploaded before the set number of days ago to the supported repositories.
type ImageFreshnessCheckOutput struct{ *pulumi.OutputState }

func (ImageFreshnessCheckOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ImageFreshnessCheck)(nil)).Elem()
}

func (o ImageFreshnessCheckOutput) ToImageFreshnessCheckOutput() ImageFreshnessCheckOutput {
	return o
}

func (o ImageFreshnessCheckOutput) ToImageFreshnessCheckOutputWithContext(ctx context.Context) ImageFreshnessCheckOutput {
	return o
}

func (o ImageFreshnessCheckOutput) ToImageFreshnessCheckPtrOutput() ImageFreshnessCheckPtrOutput {
	return o.ToImageFreshnessCheckPtrOutputWithContext(context.Background())
}

func (o ImageFreshnessCheckOutput) ToImageFreshnessCheckPtrOutputWithContext(ctx context.Context) ImageFreshnessCheckPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ImageFreshnessCheck) *ImageFreshnessCheck {
		return &v
	}).(ImageFreshnessCheckPtrOutput)
}

// The max number of days that is allowed since the image was uploaded. Must be greater than zero.
func (o ImageFreshnessCheckOutput) MaxUploadAgeDays() pulumi.IntOutput {
	return o.ApplyT(func(v ImageFreshnessCheck) int { return v.MaxUploadAgeDays }).(pulumi.IntOutput)
}

type ImageFreshnessCheckPtrOutput struct{ *pulumi.OutputState }

func (ImageFreshnessCheckPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ImageFreshnessCheck)(nil)).Elem()
}

func (o ImageFreshnessCheckPtrOutput) ToImageFreshnessCheckPtrOutput() ImageFreshnessCheckPtrOutput {
	return o
}

func (o ImageFreshnessCheckPtrOutput) ToImageFreshnessCheckPtrOutputWithContext(ctx context.Context) ImageFreshnessCheckPtrOutput {
	return o
}

func (o ImageFreshnessCheckPtrOutput) Elem() ImageFreshnessCheckOutput {
	return o.ApplyT(func(v *ImageFreshnessCheck) ImageFreshnessCheck {
		if v != nil {
			return *v
		}
		var ret ImageFreshnessCheck
		return ret
	}).(ImageFreshnessCheckOutput)
}

// The max number of days that is allowed since the image was uploaded. Must be greater than zero.
func (o ImageFreshnessCheckPtrOutput) MaxUploadAgeDays() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ImageFreshnessCheck) *int {
		if v == nil {
			return nil
		}
		return &v.MaxUploadAgeDays
	}).(pulumi.IntPtrOutput)
}

// An image freshness check, which rejects images that were uploaded before the set number of days ago to the supported repositories.
type ImageFreshnessCheckResponse struct {
	// The max number of days that is allowed since the image was uploaded. Must be greater than zero.
	MaxUploadAgeDays int `pulumi:"maxUploadAgeDays"`
}

// An image freshness check, which rejects images that were uploaded before the set number of days ago to the supported repositories.
type ImageFreshnessCheckResponseOutput struct{ *pulumi.OutputState }

func (ImageFreshnessCheckResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ImageFreshnessCheckResponse)(nil)).Elem()
}

func (o ImageFreshnessCheckResponseOutput) ToImageFreshnessCheckResponseOutput() ImageFreshnessCheckResponseOutput {
	return o
}

func (o ImageFreshnessCheckResponseOutput) ToImageFreshnessCheckResponseOutputWithContext(ctx context.Context) ImageFreshnessCheckResponseOutput {
	return o
}

// The max number of days that is allowed since the image was uploaded. Must be greater than zero.
func (o ImageFreshnessCheckResponseOutput) MaxUploadAgeDays() pulumi.IntOutput {
	return o.ApplyT(func(v ImageFreshnessCheckResponse) int { return v.MaxUploadAgeDays }).(pulumi.IntOutput)
}

// A public key in the PkixPublicKey [format](https://tools.ietf.org/html/rfc5280#section-4.1.2.7). Public keys of this type are typically textually encoded using the PEM format.
type PkixPublicKey struct {
	// Optional. The ID of this public key. Signatures verified by Binary Authorization must include the ID of the public key that can be used to verify them, and that ID must match the contents of this field exactly. This may be explicitly provided by the caller, but it MUST be a valid RFC3986 URI. If `key_id` is left blank and this `PkixPublicKey` is not used in the context of a wrapper (see next paragraph), a default key ID will be computed based on the digest of the DER encoding of the public key. If this `PkixPublicKey` is used in the context of a wrapper that has its own notion of key ID (e.g. `AttestorPublicKey`), then this field can either: * Match that value exactly. * Or be left blank, in which case it behaves exactly as though it is equal to that wrapper value.
	KeyId *string `pulumi:"keyId"`
	// A PEM-encoded public key, as described in https://tools.ietf.org/html/rfc7468#section-13
	PublicKeyPem *string `pulumi:"publicKeyPem"`
	// The signature algorithm used to verify a message against a signature using this key. These signature algorithm must match the structure and any object identifiers encoded in `public_key_pem` (i.e. this algorithm must match that of the public key).
	SignatureAlgorithm *PkixPublicKeySignatureAlgorithm `pulumi:"signatureAlgorithm"`
}

// PkixPublicKeyInput is an input type that accepts PkixPublicKeyArgs and PkixPublicKeyOutput values.
// You can construct a concrete instance of `PkixPublicKeyInput` via:
//
//	PkixPublicKeyArgs{...}
type PkixPublicKeyInput interface {
	pulumi.Input

	ToPkixPublicKeyOutput() PkixPublicKeyOutput
	ToPkixPublicKeyOutputWithContext(context.Context) PkixPublicKeyOutput
}

// A public key in the PkixPublicKey [format](https://tools.ietf.org/html/rfc5280#section-4.1.2.7). Public keys of this type are typically textually encoded using the PEM format.
type PkixPublicKeyArgs struct {
	// Optional. The ID of this public key. Signatures verified by Binary Authorization must include the ID of the public key that can be used to verify them, and that ID must match the contents of this field exactly. This may be explicitly provided by the caller, but it MUST be a valid RFC3986 URI. If `key_id` is left blank and this `PkixPublicKey` is not used in the context of a wrapper (see next paragraph), a default key ID will be computed based on the digest of the DER encoding of the public key. If this `PkixPublicKey` is used in the context of a wrapper that has its own notion of key ID (e.g. `AttestorPublicKey`), then this field can either: * Match that value exactly. * Or be left blank, in which case it behaves exactly as though it is equal to that wrapper value.
	KeyId pulumi.StringPtrInput `pulumi:"keyId"`
	// A PEM-encoded public key, as described in https://tools.ietf.org/html/rfc7468#section-13
	PublicKeyPem pulumi.StringPtrInput `pulumi:"publicKeyPem"`
	// The signature algorithm used to verify a message against a signature using this key. These signature algorithm must match the structure and any object identifiers encoded in `public_key_pem` (i.e. this algorithm must match that of the public key).
	SignatureAlgorithm PkixPublicKeySignatureAlgorithmPtrInput `pulumi:"signatureAlgorithm"`
}

func (PkixPublicKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PkixPublicKey)(nil)).Elem()
}

func (i PkixPublicKeyArgs) ToPkixPublicKeyOutput() PkixPublicKeyOutput {
	return i.ToPkixPublicKeyOutputWithContext(context.Background())
}

func (i PkixPublicKeyArgs) ToPkixPublicKeyOutputWithContext(ctx context.Context) PkixPublicKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PkixPublicKeyOutput)
}

func (i PkixPublicKeyArgs) ToPkixPublicKeyPtrOutput() PkixPublicKeyPtrOutput {
	return i.ToPkixPublicKeyPtrOutputWithContext(context.Background())
}

func (i PkixPublicKeyArgs) ToPkixPublicKeyPtrOutputWithContext(ctx context.Context) PkixPublicKeyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PkixPublicKeyOutput).ToPkixPublicKeyPtrOutputWithContext(ctx)
}

// PkixPublicKeyPtrInput is an input type that accepts PkixPublicKeyArgs, PkixPublicKeyPtr and PkixPublicKeyPtrOutput values.
// You can construct a concrete instance of `PkixPublicKeyPtrInput` via:
//
//	        PkixPublicKeyArgs{...}
//
//	or:
//
//	        nil
type PkixPublicKeyPtrInput interface {
	pulumi.Input

	ToPkixPublicKeyPtrOutput() PkixPublicKeyPtrOutput
	ToPkixPublicKeyPtrOutputWithContext(context.Context) PkixPublicKeyPtrOutput
}

type pkixPublicKeyPtrType PkixPublicKeyArgs

func PkixPublicKeyPtr(v *PkixPublicKeyArgs) PkixPublicKeyPtrInput {
	return (*pkixPublicKeyPtrType)(v)
}

func (*pkixPublicKeyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PkixPublicKey)(nil)).Elem()
}

func (i *pkixPublicKeyPtrType) ToPkixPublicKeyPtrOutput() PkixPublicKeyPtrOutput {
	return i.ToPkixPublicKeyPtrOutputWithContext(context.Background())
}

func (i *pkixPublicKeyPtrType) ToPkixPublicKeyPtrOutputWithContext(ctx context.Context) PkixPublicKeyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PkixPublicKeyPtrOutput)
}

// PkixPublicKeyArrayInput is an input type that accepts PkixPublicKeyArray and PkixPublicKeyArrayOutput values.
// You can construct a concrete instance of `PkixPublicKeyArrayInput` via:
//
//	PkixPublicKeyArray{ PkixPublicKeyArgs{...} }
type PkixPublicKeyArrayInput interface {
	pulumi.Input

	ToPkixPublicKeyArrayOutput() PkixPublicKeyArrayOutput
	ToPkixPublicKeyArrayOutputWithContext(context.Context) PkixPublicKeyArrayOutput
}

type PkixPublicKeyArray []PkixPublicKeyInput

func (PkixPublicKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PkixPublicKey)(nil)).Elem()
}

func (i PkixPublicKeyArray) ToPkixPublicKeyArrayOutput() PkixPublicKeyArrayOutput {
	return i.ToPkixPublicKeyArrayOutputWithContext(context.Background())
}

func (i PkixPublicKeyArray) ToPkixPublicKeyArrayOutputWithContext(ctx context.Context) PkixPublicKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PkixPublicKeyArrayOutput)
}

// A public key in the PkixPublicKey [format](https://tools.ietf.org/html/rfc5280#section-4.1.2.7). Public keys of this type are typically textually encoded using the PEM format.
type PkixPublicKeyOutput struct{ *pulumi.OutputState }

func (PkixPublicKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PkixPublicKey)(nil)).Elem()
}

func (o PkixPublicKeyOutput) ToPkixPublicKeyOutput() PkixPublicKeyOutput {
	return o
}

func (o PkixPublicKeyOutput) ToPkixPublicKeyOutputWithContext(ctx context.Context) PkixPublicKeyOutput {
	return o
}

func (o PkixPublicKeyOutput) ToPkixPublicKeyPtrOutput() PkixPublicKeyPtrOutput {
	return o.ToPkixPublicKeyPtrOutputWithContext(context.Background())
}

func (o PkixPublicKeyOutput) ToPkixPublicKeyPtrOutputWithContext(ctx context.Context) PkixPublicKeyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PkixPublicKey) *PkixPublicKey {
		return &v
	}).(PkixPublicKeyPtrOutput)
}

// Optional. The ID of this public key. Signatures verified by Binary Authorization must include the ID of the public key that can be used to verify them, and that ID must match the contents of this field exactly. This may be explicitly provided by the caller, but it MUST be a valid RFC3986 URI. If `key_id` is left blank and this `PkixPublicKey` is not used in the context of a wrapper (see next paragraph), a default key ID will be computed based on the digest of the DER encoding of the public key. If this `PkixPublicKey` is used in the context of a wrapper that has its own notion of key ID (e.g. `AttestorPublicKey`), then this field can either: * Match that value exactly. * Or be left blank, in which case it behaves exactly as though it is equal to that wrapper value.
func (o PkixPublicKeyOutput) KeyId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PkixPublicKey) *string { return v.KeyId }).(pulumi.StringPtrOutput)
}

// A PEM-encoded public key, as described in https://tools.ietf.org/html/rfc7468#section-13
func (o PkixPublicKeyOutput) PublicKeyPem() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PkixPublicKey) *string { return v.PublicKeyPem }).(pulumi.StringPtrOutput)
}

// The signature algorithm used to verify a message against a signature using this key. These signature algorithm must match the structure and any object identifiers encoded in `public_key_pem` (i.e. this algorithm must match that of the public key).
func (o PkixPublicKeyOutput) SignatureAlgorithm() PkixPublicKeySignatureAlgorithmPtrOutput {
	return o.ApplyT(func(v PkixPublicKey) *PkixPublicKeySignatureAlgorithm { return v.SignatureAlgorithm }).(PkixPublicKeySignatureAlgorithmPtrOutput)
}

type PkixPublicKeyPtrOutput struct{ *pulumi.OutputState }

func (PkixPublicKeyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PkixPublicKey)(nil)).Elem()
}

func (o PkixPublicKeyPtrOutput) ToPkixPublicKeyPtrOutput() PkixPublicKeyPtrOutput {
	return o
}

func (o PkixPublicKeyPtrOutput) ToPkixPublicKeyPtrOutputWithContext(ctx context.Context) PkixPublicKeyPtrOutput {
	return o
}

func (o PkixPublicKeyPtrOutput) Elem() PkixPublicKeyOutput {
	return o.ApplyT(func(v *PkixPublicKey) PkixPublicKey {
		if v != nil {
			return *v
		}
		var ret PkixPublicKey
		return ret
	}).(PkixPublicKeyOutput)
}

// Optional. The ID of this public key. Signatures verified by Binary Authorization must include the ID of the public key that can be used to verify them, and that ID must match the contents of this field exactly. This may be explicitly provided by the caller, but it MUST be a valid RFC3986 URI. If `key_id` is left blank and this `PkixPublicKey` is not used in the context of a wrapper (see next paragraph), a default key ID will be computed based on the digest of the DER encoding of the public key. If this `PkixPublicKey` is used in the context of a wrapper that has its own notion of key ID (e.g. `AttestorPublicKey`), then this field can either: * Match that value exactly. * Or be left blank, in which case it behaves exactly as though it is equal to that wrapper value.
func (o PkixPublicKeyPtrOutput) KeyId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PkixPublicKey) *string {
		if v == nil {
			return nil
		}
		return v.KeyId
	}).(pulumi.StringPtrOutput)
}

// A PEM-encoded public key, as described in https://tools.ietf.org/html/rfc7468#section-13
func (o PkixPublicKeyPtrOutput) PublicKeyPem() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PkixPublicKey) *string {
		if v == nil {
			return nil
		}
		return v.PublicKeyPem
	}).(pulumi.StringPtrOutput)
}

// The signature algorithm used to verify a message against a signature using this key. These signature algorithm must match the structure and any object identifiers encoded in `public_key_pem` (i.e. this algorithm must match that of the public key).
func (o PkixPublicKeyPtrOutput) SignatureAlgorithm() PkixPublicKeySignatureAlgorithmPtrOutput {
	return o.ApplyT(func(v *PkixPublicKey) *PkixPublicKeySignatureAlgorithm {
		if v == nil {
			return nil
		}
		return v.SignatureAlgorithm
	}).(PkixPublicKeySignatureAlgorithmPtrOutput)
}

type PkixPublicKeyArrayOutput struct{ *pulumi.OutputState }

func (PkixPublicKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PkixPublicKey)(nil)).Elem()
}

func (o PkixPublicKeyArrayOutput) ToPkixPublicKeyArrayOutput() PkixPublicKeyArrayOutput {
	return o
}

func (o PkixPublicKeyArrayOutput) ToPkixPublicKeyArrayOutputWithContext(ctx context.Context) PkixPublicKeyArrayOutput {
	return o
}

func (o PkixPublicKeyArrayOutput) Index(i pulumi.IntInput) PkixPublicKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PkixPublicKey {
		return vs[0].([]PkixPublicKey)[vs[1].(int)]
	}).(PkixPublicKeyOutput)
}

// A public key in the PkixPublicKey [format](https://tools.ietf.org/html/rfc5280#section-4.1.2.7). Public keys of this type are typically textually encoded using the PEM format.
type PkixPublicKeyResponse struct {
	// Optional. The ID of this public key. Signatures verified by Binary Authorization must include the ID of the public key that can be used to verify them, and that ID must match the contents of this field exactly. This may be explicitly provided by the caller, but it MUST be a valid RFC3986 URI. If `key_id` is left blank and this `PkixPublicKey` is not used in the context of a wrapper (see next paragraph), a default key ID will be computed based on the digest of the DER encoding of the public key. If this `PkixPublicKey` is used in the context of a wrapper that has its own notion of key ID (e.g. `AttestorPublicKey`), then this field can either: * Match that value exactly. * Or be left blank, in which case it behaves exactly as though it is equal to that wrapper value.
	KeyId string `pulumi:"keyId"`
	// A PEM-encoded public key, as described in https://tools.ietf.org/html/rfc7468#section-13
	PublicKeyPem string `pulumi:"publicKeyPem"`
	// The signature algorithm used to verify a message against a signature using this key. These signature algorithm must match the structure and any object identifiers encoded in `public_key_pem` (i.e. this algorithm must match that of the public key).
	SignatureAlgorithm string `pulumi:"signatureAlgorithm"`
}

// A public key in the PkixPublicKey [format](https://tools.ietf.org/html/rfc5280#section-4.1.2.7). Public keys of this type are typically textually encoded using the PEM format.
type PkixPublicKeyResponseOutput struct{ *pulumi.OutputState }

func (PkixPublicKeyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PkixPublicKeyResponse)(nil)).Elem()
}

func (o PkixPublicKeyResponseOutput) ToPkixPublicKeyResponseOutput() PkixPublicKeyResponseOutput {
	return o
}

func (o PkixPublicKeyResponseOutput) ToPkixPublicKeyResponseOutputWithContext(ctx context.Context) PkixPublicKeyResponseOutput {
	return o
}

// Optional. The ID of this public key. Signatures verified by Binary Authorization must include the ID of the public key that can be used to verify them, and that ID must match the contents of this field exactly. This may be explicitly provided by the caller, but it MUST be a valid RFC3986 URI. If `key_id` is left blank and this `PkixPublicKey` is not used in the context of a wrapper (see next paragraph), a default key ID will be computed based on the digest of the DER encoding of the public key. If this `PkixPublicKey` is used in the context of a wrapper that has its own notion of key ID (e.g. `AttestorPublicKey`), then this field can either: * Match that value exactly. * Or be left blank, in which case it behaves exactly as though it is equal to that wrapper value.
func (o PkixPublicKeyResponseOutput) KeyId() pulumi.StringOutput {
	return o.ApplyT(func(v PkixPublicKeyResponse) string { return v.KeyId }).(pulumi.StringOutput)
}

// A PEM-encoded public key, as described in https://tools.ietf.org/html/rfc7468#section-13
func (o PkixPublicKeyResponseOutput) PublicKeyPem() pulumi.StringOutput {
	return o.ApplyT(func(v PkixPublicKeyResponse) string { return v.PublicKeyPem }).(pulumi.StringOutput)
}

// The signature algorithm used to verify a message against a signature using this key. These signature algorithm must match the structure and any object identifiers encoded in `public_key_pem` (i.e. this algorithm must match that of the public key).
func (o PkixPublicKeyResponseOutput) SignatureAlgorithm() pulumi.StringOutput {
	return o.ApplyT(func(v PkixPublicKeyResponse) string { return v.SignatureAlgorithm }).(pulumi.StringOutput)
}

type PkixPublicKeyResponseArrayOutput struct{ *pulumi.OutputState }

func (PkixPublicKeyResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PkixPublicKeyResponse)(nil)).Elem()
}

func (o PkixPublicKeyResponseArrayOutput) ToPkixPublicKeyResponseArrayOutput() PkixPublicKeyResponseArrayOutput {
	return o
}

func (o PkixPublicKeyResponseArrayOutput) ToPkixPublicKeyResponseArrayOutputWithContext(ctx context.Context) PkixPublicKeyResponseArrayOutput {
	return o
}

func (o PkixPublicKeyResponseArrayOutput) Index(i pulumi.IntInput) PkixPublicKeyResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PkixPublicKeyResponse {
		return vs[0].([]PkixPublicKeyResponse)[vs[1].(int)]
	}).(PkixPublicKeyResponseOutput)
}

// A bundle of PKIX public keys, used to authenticate attestation signatures. Generally, a signature is considered to be authenticated by a `PkixPublicKeySet` if any of the public keys verify it (i.e. it is an "OR" of the keys).
type PkixPublicKeySet struct {
	// `pkix_public_keys` must have at least one entry.
	PkixPublicKeys []PkixPublicKey `pulumi:"pkixPublicKeys"`
}

// PkixPublicKeySetInput is an input type that accepts PkixPublicKeySetArgs and PkixPublicKeySetOutput values.
// You can construct a concrete instance of `PkixPublicKeySetInput` via:
//
//	PkixPublicKeySetArgs{...}
type PkixPublicKeySetInput interface {
	pulumi.Input

	ToPkixPublicKeySetOutput() PkixPublicKeySetOutput
	ToPkixPublicKeySetOutputWithContext(context.Context) PkixPublicKeySetOutput
}

// A bundle of PKIX public keys, used to authenticate attestation signatures. Generally, a signature is considered to be authenticated by a `PkixPublicKeySet` if any of the public keys verify it (i.e. it is an "OR" of the keys).
type PkixPublicKeySetArgs struct {
	// `pkix_public_keys` must have at least one entry.
	PkixPublicKeys PkixPublicKeyArrayInput `pulumi:"pkixPublicKeys"`
}

func (PkixPublicKeySetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PkixPublicKeySet)(nil)).Elem()
}

func (i PkixPublicKeySetArgs) ToPkixPublicKeySetOutput() PkixPublicKeySetOutput {
	return i.ToPkixPublicKeySetOutputWithContext(context.Background())
}

func (i PkixPublicKeySetArgs) ToPkixPublicKeySetOutputWithContext(ctx context.Context) PkixPublicKeySetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PkixPublicKeySetOutput)
}

func (i PkixPublicKeySetArgs) ToPkixPublicKeySetPtrOutput() PkixPublicKeySetPtrOutput {
	return i.ToPkixPublicKeySetPtrOutputWithContext(context.Background())
}

func (i PkixPublicKeySetArgs) ToPkixPublicKeySetPtrOutputWithContext(ctx context.Context) PkixPublicKeySetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PkixPublicKeySetOutput).ToPkixPublicKeySetPtrOutputWithContext(ctx)
}

// PkixPublicKeySetPtrInput is an input type that accepts PkixPublicKeySetArgs, PkixPublicKeySetPtr and PkixPublicKeySetPtrOutput values.
// You can construct a concrete instance of `PkixPublicKeySetPtrInput` via:
//
//	        PkixPublicKeySetArgs{...}
//
//	or:
//
//	        nil
type PkixPublicKeySetPtrInput interface {
	pulumi.Input

	ToPkixPublicKeySetPtrOutput() PkixPublicKeySetPtrOutput
	ToPkixPublicKeySetPtrOutputWithContext(context.Context) PkixPublicKeySetPtrOutput
}

type pkixPublicKeySetPtrType PkixPublicKeySetArgs

func PkixPublicKeySetPtr(v *PkixPublicKeySetArgs) PkixPublicKeySetPtrInput {
	return (*pkixPublicKeySetPtrType)(v)
}

func (*pkixPublicKeySetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PkixPublicKeySet)(nil)).Elem()
}

func (i *pkixPublicKeySetPtrType) ToPkixPublicKeySetPtrOutput() PkixPublicKeySetPtrOutput {
	return i.ToPkixPublicKeySetPtrOutputWithContext(context.Background())
}

func (i *pkixPublicKeySetPtrType) ToPkixPublicKeySetPtrOutputWithContext(ctx context.Context) PkixPublicKeySetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PkixPublicKeySetPtrOutput)
}

// A bundle of PKIX public keys, used to authenticate attestation signatures. Generally, a signature is considered to be authenticated by a `PkixPublicKeySet` if any of the public keys verify it (i.e. it is an "OR" of the keys).
type PkixPublicKeySetOutput struct{ *pulumi.OutputState }

func (PkixPublicKeySetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PkixPublicKeySet)(nil)).Elem()
}

func (o PkixPublicKeySetOutput) ToPkixPublicKeySetOutput() PkixPublicKeySetOutput {
	return o
}

func (o PkixPublicKeySetOutput) ToPkixPublicKeySetOutputWithContext(ctx context.Context) PkixPublicKeySetOutput {
	return o
}

func (o PkixPublicKeySetOutput) ToPkixPublicKeySetPtrOutput() PkixPublicKeySetPtrOutput {
	return o.ToPkixPublicKeySetPtrOutputWithContext(context.Background())
}

func (o PkixPublicKeySetOutput) ToPkixPublicKeySetPtrOutputWithContext(ctx context.Context) PkixPublicKeySetPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PkixPublicKeySet) *PkixPublicKeySet {
		return &v
	}).(PkixPublicKeySetPtrOutput)
}

// `pkix_public_keys` must have at least one entry.
func (o PkixPublicKeySetOutput) PkixPublicKeys() PkixPublicKeyArrayOutput {
	return o.ApplyT(func(v PkixPublicKeySet) []PkixPublicKey { return v.PkixPublicKeys }).(PkixPublicKeyArrayOutput)
}

type PkixPublicKeySetPtrOutput struct{ *pulumi.OutputState }

func (PkixPublicKeySetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PkixPublicKeySet)(nil)).Elem()
}

func (o PkixPublicKeySetPtrOutput) ToPkixPublicKeySetPtrOutput() PkixPublicKeySetPtrOutput {
	return o
}

func (o PkixPublicKeySetPtrOutput) ToPkixPublicKeySetPtrOutputWithContext(ctx context.Context) PkixPublicKeySetPtrOutput {
	return o
}

func (o PkixPublicKeySetPtrOutput) Elem() PkixPublicKeySetOutput {
	return o.ApplyT(func(v *PkixPublicKeySet) PkixPublicKeySet {
		if v != nil {
			return *v
		}
		var ret PkixPublicKeySet
		return ret
	}).(PkixPublicKeySetOutput)
}

// `pkix_public_keys` must have at least one entry.
func (o PkixPublicKeySetPtrOutput) PkixPublicKeys() PkixPublicKeyArrayOutput {
	return o.ApplyT(func(v *PkixPublicKeySet) []PkixPublicKey {
		if v == nil {
			return nil
		}
		return v.PkixPublicKeys
	}).(PkixPublicKeyArrayOutput)
}

// A bundle of PKIX public keys, used to authenticate attestation signatures. Generally, a signature is considered to be authenticated by a `PkixPublicKeySet` if any of the public keys verify it (i.e. it is an "OR" of the keys).
type PkixPublicKeySetResponse struct {
	// `pkix_public_keys` must have at least one entry.
	PkixPublicKeys []PkixPublicKeyResponse `pulumi:"pkixPublicKeys"`
}

// A bundle of PKIX public keys, used to authenticate attestation signatures. Generally, a signature is considered to be authenticated by a `PkixPublicKeySet` if any of the public keys verify it (i.e. it is an "OR" of the keys).
type PkixPublicKeySetResponseOutput struct{ *pulumi.OutputState }

func (PkixPublicKeySetResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PkixPublicKeySetResponse)(nil)).Elem()
}

func (o PkixPublicKeySetResponseOutput) ToPkixPublicKeySetResponseOutput() PkixPublicKeySetResponseOutput {
	return o
}

func (o PkixPublicKeySetResponseOutput) ToPkixPublicKeySetResponseOutputWithContext(ctx context.Context) PkixPublicKeySetResponseOutput {
	return o
}

// `pkix_public_keys` must have at least one entry.
func (o PkixPublicKeySetResponseOutput) PkixPublicKeys() PkixPublicKeyResponseArrayOutput {
	return o.ApplyT(func(v PkixPublicKeySetResponse) []PkixPublicKeyResponse { return v.PkixPublicKeys }).(PkixPublicKeyResponseArrayOutput)
}

// A scope specifier for `CheckSet` objects.
type Scope struct {
	// Optional. Matches all Kubernetes service accounts in the provided namespace, unless a more specific `kubernetes_service_account` scope already matched.
	KubernetesNamespace *string `pulumi:"kubernetesNamespace"`
	// Optional. Matches a single Kubernetes service account, e.g. `my-namespace:my-service-account`. `kubernetes_service_account` scope is always more specific than `kubernetes_namespace` scope for the same namespace.
	KubernetesServiceAccount *string `pulumi:"kubernetesServiceAccount"`
}

// ScopeInput is an input type that accepts ScopeArgs and ScopeOutput values.
// You can construct a concrete instance of `ScopeInput` via:
//
//	ScopeArgs{...}
type ScopeInput interface {
	pulumi.Input

	ToScopeOutput() ScopeOutput
	ToScopeOutputWithContext(context.Context) ScopeOutput
}

// A scope specifier for `CheckSet` objects.
type ScopeArgs struct {
	// Optional. Matches all Kubernetes service accounts in the provided namespace, unless a more specific `kubernetes_service_account` scope already matched.
	KubernetesNamespace pulumi.StringPtrInput `pulumi:"kubernetesNamespace"`
	// Optional. Matches a single Kubernetes service account, e.g. `my-namespace:my-service-account`. `kubernetes_service_account` scope is always more specific than `kubernetes_namespace` scope for the same namespace.
	KubernetesServiceAccount pulumi.StringPtrInput `pulumi:"kubernetesServiceAccount"`
}

func (ScopeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Scope)(nil)).Elem()
}

func (i ScopeArgs) ToScopeOutput() ScopeOutput {
	return i.ToScopeOutputWithContext(context.Background())
}

func (i ScopeArgs) ToScopeOutputWithContext(ctx context.Context) ScopeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScopeOutput)
}

func (i ScopeArgs) ToScopePtrOutput() ScopePtrOutput {
	return i.ToScopePtrOutputWithContext(context.Background())
}

func (i ScopeArgs) ToScopePtrOutputWithContext(ctx context.Context) ScopePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScopeOutput).ToScopePtrOutputWithContext(ctx)
}

// ScopePtrInput is an input type that accepts ScopeArgs, ScopePtr and ScopePtrOutput values.
// You can construct a concrete instance of `ScopePtrInput` via:
//
//	        ScopeArgs{...}
//
//	or:
//
//	        nil
type ScopePtrInput interface {
	pulumi.Input

	ToScopePtrOutput() ScopePtrOutput
	ToScopePtrOutputWithContext(context.Context) ScopePtrOutput
}

type scopePtrType ScopeArgs

func ScopePtr(v *ScopeArgs) ScopePtrInput {
	return (*scopePtrType)(v)
}

func (*scopePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Scope)(nil)).Elem()
}

func (i *scopePtrType) ToScopePtrOutput() ScopePtrOutput {
	return i.ToScopePtrOutputWithContext(context.Background())
}

func (i *scopePtrType) ToScopePtrOutputWithContext(ctx context.Context) ScopePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScopePtrOutput)
}

// A scope specifier for `CheckSet` objects.
type ScopeOutput struct{ *pulumi.OutputState }

func (ScopeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Scope)(nil)).Elem()
}

func (o ScopeOutput) ToScopeOutput() ScopeOutput {
	return o
}

func (o ScopeOutput) ToScopeOutputWithContext(ctx context.Context) ScopeOutput {
	return o
}

func (o ScopeOutput) ToScopePtrOutput() ScopePtrOutput {
	return o.ToScopePtrOutputWithContext(context.Background())
}

func (o ScopeOutput) ToScopePtrOutputWithContext(ctx context.Context) ScopePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Scope) *Scope {
		return &v
	}).(ScopePtrOutput)
}

// Optional. Matches all Kubernetes service accounts in the provided namespace, unless a more specific `kubernetes_service_account` scope already matched.
func (o ScopeOutput) KubernetesNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Scope) *string { return v.KubernetesNamespace }).(pulumi.StringPtrOutput)
}

// Optional. Matches a single Kubernetes service account, e.g. `my-namespace:my-service-account`. `kubernetes_service_account` scope is always more specific than `kubernetes_namespace` scope for the same namespace.
func (o ScopeOutput) KubernetesServiceAccount() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Scope) *string { return v.KubernetesServiceAccount }).(pulumi.StringPtrOutput)
}

type ScopePtrOutput struct{ *pulumi.OutputState }

func (ScopePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Scope)(nil)).Elem()
}

func (o ScopePtrOutput) ToScopePtrOutput() ScopePtrOutput {
	return o
}

func (o ScopePtrOutput) ToScopePtrOutputWithContext(ctx context.Context) ScopePtrOutput {
	return o
}

func (o ScopePtrOutput) Elem() ScopeOutput {
	return o.ApplyT(func(v *Scope) Scope {
		if v != nil {
			return *v
		}
		var ret Scope
		return ret
	}).(ScopeOutput)
}

// Optional. Matches all Kubernetes service accounts in the provided namespace, unless a more specific `kubernetes_service_account` scope already matched.
func (o ScopePtrOutput) KubernetesNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Scope) *string {
		if v == nil {
			return nil
		}
		return v.KubernetesNamespace
	}).(pulumi.StringPtrOutput)
}

// Optional. Matches a single Kubernetes service account, e.g. `my-namespace:my-service-account`. `kubernetes_service_account` scope is always more specific than `kubernetes_namespace` scope for the same namespace.
func (o ScopePtrOutput) KubernetesServiceAccount() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Scope) *string {
		if v == nil {
			return nil
		}
		return v.KubernetesServiceAccount
	}).(pulumi.StringPtrOutput)
}

// A scope specifier for `CheckSet` objects.
type ScopeResponse struct {
	// Optional. Matches all Kubernetes service accounts in the provided namespace, unless a more specific `kubernetes_service_account` scope already matched.
	KubernetesNamespace string `pulumi:"kubernetesNamespace"`
	// Optional. Matches a single Kubernetes service account, e.g. `my-namespace:my-service-account`. `kubernetes_service_account` scope is always more specific than `kubernetes_namespace` scope for the same namespace.
	KubernetesServiceAccount string `pulumi:"kubernetesServiceAccount"`
}

// A scope specifier for `CheckSet` objects.
type ScopeResponseOutput struct{ *pulumi.OutputState }

func (ScopeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ScopeResponse)(nil)).Elem()
}

func (o ScopeResponseOutput) ToScopeResponseOutput() ScopeResponseOutput {
	return o
}

func (o ScopeResponseOutput) ToScopeResponseOutputWithContext(ctx context.Context) ScopeResponseOutput {
	return o
}

// Optional. Matches all Kubernetes service accounts in the provided namespace, unless a more specific `kubernetes_service_account` scope already matched.
func (o ScopeResponseOutput) KubernetesNamespace() pulumi.StringOutput {
	return o.ApplyT(func(v ScopeResponse) string { return v.KubernetesNamespace }).(pulumi.StringOutput)
}

// Optional. Matches a single Kubernetes service account, e.g. `my-namespace:my-service-account`. `kubernetes_service_account` scope is always more specific than `kubernetes_namespace` scope for the same namespace.
func (o ScopeResponseOutput) KubernetesServiceAccount() pulumi.StringOutput {
	return o.ApplyT(func(v ScopeResponse) string { return v.KubernetesServiceAccount }).(pulumi.StringOutput)
}

// A Sigstore authority, used to verify signatures that are created by Sigstore. An authority is analogous to an attestation authenticator, verifying that a signature is valid or invalid.
type SigstoreAuthority struct {
	// Optional. A user-provided name for this `SigstoreAuthority`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
	DisplayName *string `pulumi:"displayName"`
	// A simple set of public keys. A signature is considered valid if any keys in the set validate the signature.
	PublicKeySet SigstorePublicKeySet `pulumi:"publicKeySet"`
}

// SigstoreAuthorityInput is an input type that accepts SigstoreAuthorityArgs and SigstoreAuthorityOutput values.
// You can construct a concrete instance of `SigstoreAuthorityInput` via:
//
//	SigstoreAuthorityArgs{...}
type SigstoreAuthorityInput interface {
	pulumi.Input

	ToSigstoreAuthorityOutput() SigstoreAuthorityOutput
	ToSigstoreAuthorityOutputWithContext(context.Context) SigstoreAuthorityOutput
}

// A Sigstore authority, used to verify signatures that are created by Sigstore. An authority is analogous to an attestation authenticator, verifying that a signature is valid or invalid.
type SigstoreAuthorityArgs struct {
	// Optional. A user-provided name for this `SigstoreAuthority`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
	DisplayName pulumi.StringPtrInput `pulumi:"displayName"`
	// A simple set of public keys. A signature is considered valid if any keys in the set validate the signature.
	PublicKeySet SigstorePublicKeySetInput `pulumi:"publicKeySet"`
}

func (SigstoreAuthorityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SigstoreAuthority)(nil)).Elem()
}

func (i SigstoreAuthorityArgs) ToSigstoreAuthorityOutput() SigstoreAuthorityOutput {
	return i.ToSigstoreAuthorityOutputWithContext(context.Background())
}

func (i SigstoreAuthorityArgs) ToSigstoreAuthorityOutputWithContext(ctx context.Context) SigstoreAuthorityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SigstoreAuthorityOutput)
}

// SigstoreAuthorityArrayInput is an input type that accepts SigstoreAuthorityArray and SigstoreAuthorityArrayOutput values.
// You can construct a concrete instance of `SigstoreAuthorityArrayInput` via:
//
//	SigstoreAuthorityArray{ SigstoreAuthorityArgs{...} }
type SigstoreAuthorityArrayInput interface {
	pulumi.Input

	ToSigstoreAuthorityArrayOutput() SigstoreAuthorityArrayOutput
	ToSigstoreAuthorityArrayOutputWithContext(context.Context) SigstoreAuthorityArrayOutput
}

type SigstoreAuthorityArray []SigstoreAuthorityInput

func (SigstoreAuthorityArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SigstoreAuthority)(nil)).Elem()
}

func (i SigstoreAuthorityArray) ToSigstoreAuthorityArrayOutput() SigstoreAuthorityArrayOutput {
	return i.ToSigstoreAuthorityArrayOutputWithContext(context.Background())
}

func (i SigstoreAuthorityArray) ToSigstoreAuthorityArrayOutputWithContext(ctx context.Context) SigstoreAuthorityArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SigstoreAuthorityArrayOutput)
}

// A Sigstore authority, used to verify signatures that are created by Sigstore. An authority is analogous to an attestation authenticator, verifying that a signature is valid or invalid.
type SigstoreAuthorityOutput struct{ *pulumi.OutputState }

func (SigstoreAuthorityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SigstoreAuthority)(nil)).Elem()
}

func (o SigstoreAuthorityOutput) ToSigstoreAuthorityOutput() SigstoreAuthorityOutput {
	return o
}

func (o SigstoreAuthorityOutput) ToSigstoreAuthorityOutputWithContext(ctx context.Context) SigstoreAuthorityOutput {
	return o
}

// Optional. A user-provided name for this `SigstoreAuthority`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
func (o SigstoreAuthorityOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SigstoreAuthority) *string { return v.DisplayName }).(pulumi.StringPtrOutput)
}

// A simple set of public keys. A signature is considered valid if any keys in the set validate the signature.
func (o SigstoreAuthorityOutput) PublicKeySet() SigstorePublicKeySetOutput {
	return o.ApplyT(func(v SigstoreAuthority) SigstorePublicKeySet { return v.PublicKeySet }).(SigstorePublicKeySetOutput)
}

type SigstoreAuthorityArrayOutput struct{ *pulumi.OutputState }

func (SigstoreAuthorityArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SigstoreAuthority)(nil)).Elem()
}

func (o SigstoreAuthorityArrayOutput) ToSigstoreAuthorityArrayOutput() SigstoreAuthorityArrayOutput {
	return o
}

func (o SigstoreAuthorityArrayOutput) ToSigstoreAuthorityArrayOutputWithContext(ctx context.Context) SigstoreAuthorityArrayOutput {
	return o
}

func (o SigstoreAuthorityArrayOutput) Index(i pulumi.IntInput) SigstoreAuthorityOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SigstoreAuthority {
		return vs[0].([]SigstoreAuthority)[vs[1].(int)]
	}).(SigstoreAuthorityOutput)
}

// A Sigstore authority, used to verify signatures that are created by Sigstore. An authority is analogous to an attestation authenticator, verifying that a signature is valid or invalid.
type SigstoreAuthorityResponse struct {
	// Optional. A user-provided name for this `SigstoreAuthority`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
	DisplayName string `pulumi:"displayName"`
	// A simple set of public keys. A signature is considered valid if any keys in the set validate the signature.
	PublicKeySet SigstorePublicKeySetResponse `pulumi:"publicKeySet"`
}

// A Sigstore authority, used to verify signatures that are created by Sigstore. An authority is analogous to an attestation authenticator, verifying that a signature is valid or invalid.
type SigstoreAuthorityResponseOutput struct{ *pulumi.OutputState }

func (SigstoreAuthorityResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SigstoreAuthorityResponse)(nil)).Elem()
}

func (o SigstoreAuthorityResponseOutput) ToSigstoreAuthorityResponseOutput() SigstoreAuthorityResponseOutput {
	return o
}

func (o SigstoreAuthorityResponseOutput) ToSigstoreAuthorityResponseOutputWithContext(ctx context.Context) SigstoreAuthorityResponseOutput {
	return o
}

// Optional. A user-provided name for this `SigstoreAuthority`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
func (o SigstoreAuthorityResponseOutput) DisplayName() pulumi.StringOutput {
	return o.ApplyT(func(v SigstoreAuthorityResponse) string { return v.DisplayName }).(pulumi.StringOutput)
}

// A simple set of public keys. A signature is considered valid if any keys in the set validate the signature.
func (o SigstoreAuthorityResponseOutput) PublicKeySet() SigstorePublicKeySetResponseOutput {
	return o.ApplyT(func(v SigstoreAuthorityResponse) SigstorePublicKeySetResponse { return v.PublicKeySet }).(SigstorePublicKeySetResponseOutput)
}

type SigstoreAuthorityResponseArrayOutput struct{ *pulumi.OutputState }

func (SigstoreAuthorityResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SigstoreAuthorityResponse)(nil)).Elem()
}

func (o SigstoreAuthorityResponseArrayOutput) ToSigstoreAuthorityResponseArrayOutput() SigstoreAuthorityResponseArrayOutput {
	return o
}

func (o SigstoreAuthorityResponseArrayOutput) ToSigstoreAuthorityResponseArrayOutputWithContext(ctx context.Context) SigstoreAuthorityResponseArrayOutput {
	return o
}

func (o SigstoreAuthorityResponseArrayOutput) Index(i pulumi.IntInput) SigstoreAuthorityResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SigstoreAuthorityResponse {
		return vs[0].([]SigstoreAuthorityResponse)[vs[1].(int)]
	}).(SigstoreAuthorityResponseOutput)
}

// A Sigstore public key. `SigstorePublicKey` is the public key material used to authenticate Sigstore signatures.
type SigstorePublicKey struct {
	// The public key material in PEM format.
	PublicKeyPem *string `pulumi:"publicKeyPem"`
}

// SigstorePublicKeyInput is an input type that accepts SigstorePublicKeyArgs and SigstorePublicKeyOutput values.
// You can construct a concrete instance of `SigstorePublicKeyInput` via:
//
//	SigstorePublicKeyArgs{...}
type SigstorePublicKeyInput interface {
	pulumi.Input

	ToSigstorePublicKeyOutput() SigstorePublicKeyOutput
	ToSigstorePublicKeyOutputWithContext(context.Context) SigstorePublicKeyOutput
}

// A Sigstore public key. `SigstorePublicKey` is the public key material used to authenticate Sigstore signatures.
type SigstorePublicKeyArgs struct {
	// The public key material in PEM format.
	PublicKeyPem pulumi.StringPtrInput `pulumi:"publicKeyPem"`
}

func (SigstorePublicKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SigstorePublicKey)(nil)).Elem()
}

func (i SigstorePublicKeyArgs) ToSigstorePublicKeyOutput() SigstorePublicKeyOutput {
	return i.ToSigstorePublicKeyOutputWithContext(context.Background())
}

func (i SigstorePublicKeyArgs) ToSigstorePublicKeyOutputWithContext(ctx context.Context) SigstorePublicKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SigstorePublicKeyOutput)
}

// SigstorePublicKeyArrayInput is an input type that accepts SigstorePublicKeyArray and SigstorePublicKeyArrayOutput values.
// You can construct a concrete instance of `SigstorePublicKeyArrayInput` via:
//
//	SigstorePublicKeyArray{ SigstorePublicKeyArgs{...} }
type SigstorePublicKeyArrayInput interface {
	pulumi.Input

	ToSigstorePublicKeyArrayOutput() SigstorePublicKeyArrayOutput
	ToSigstorePublicKeyArrayOutputWithContext(context.Context) SigstorePublicKeyArrayOutput
}

type SigstorePublicKeyArray []SigstorePublicKeyInput

func (SigstorePublicKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SigstorePublicKey)(nil)).Elem()
}

func (i SigstorePublicKeyArray) ToSigstorePublicKeyArrayOutput() SigstorePublicKeyArrayOutput {
	return i.ToSigstorePublicKeyArrayOutputWithContext(context.Background())
}

func (i SigstorePublicKeyArray) ToSigstorePublicKeyArrayOutputWithContext(ctx context.Context) SigstorePublicKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SigstorePublicKeyArrayOutput)
}

// A Sigstore public key. `SigstorePublicKey` is the public key material used to authenticate Sigstore signatures.
type SigstorePublicKeyOutput struct{ *pulumi.OutputState }

func (SigstorePublicKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SigstorePublicKey)(nil)).Elem()
}

func (o SigstorePublicKeyOutput) ToSigstorePublicKeyOutput() SigstorePublicKeyOutput {
	return o
}

func (o SigstorePublicKeyOutput) ToSigstorePublicKeyOutputWithContext(ctx context.Context) SigstorePublicKeyOutput {
	return o
}

// The public key material in PEM format.
func (o SigstorePublicKeyOutput) PublicKeyPem() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SigstorePublicKey) *string { return v.PublicKeyPem }).(pulumi.StringPtrOutput)
}

type SigstorePublicKeyArrayOutput struct{ *pulumi.OutputState }

func (SigstorePublicKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SigstorePublicKey)(nil)).Elem()
}

func (o SigstorePublicKeyArrayOutput) ToSigstorePublicKeyArrayOutput() SigstorePublicKeyArrayOutput {
	return o
}

func (o SigstorePublicKeyArrayOutput) ToSigstorePublicKeyArrayOutputWithContext(ctx context.Context) SigstorePublicKeyArrayOutput {
	return o
}

func (o SigstorePublicKeyArrayOutput) Index(i pulumi.IntInput) SigstorePublicKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SigstorePublicKey {
		return vs[0].([]SigstorePublicKey)[vs[1].(int)]
	}).(SigstorePublicKeyOutput)
}

// A Sigstore public key. `SigstorePublicKey` is the public key material used to authenticate Sigstore signatures.
type SigstorePublicKeyResponse struct {
	// The public key material in PEM format.
	PublicKeyPem string `pulumi:"publicKeyPem"`
}

// A Sigstore public key. `SigstorePublicKey` is the public key material used to authenticate Sigstore signatures.
type SigstorePublicKeyResponseOutput struct{ *pulumi.OutputState }

func (SigstorePublicKeyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SigstorePublicKeyResponse)(nil)).Elem()
}

func (o SigstorePublicKeyResponseOutput) ToSigstorePublicKeyResponseOutput() SigstorePublicKeyResponseOutput {
	return o
}

func (o SigstorePublicKeyResponseOutput) ToSigstorePublicKeyResponseOutputWithContext(ctx context.Context) SigstorePublicKeyResponseOutput {
	return o
}

// The public key material in PEM format.
func (o SigstorePublicKeyResponseOutput) PublicKeyPem() pulumi.StringOutput {
	return o.ApplyT(func(v SigstorePublicKeyResponse) string { return v.PublicKeyPem }).(pulumi.StringOutput)
}

type SigstorePublicKeyResponseArrayOutput struct{ *pulumi.OutputState }

func (SigstorePublicKeyResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SigstorePublicKeyResponse)(nil)).Elem()
}

func (o SigstorePublicKeyResponseArrayOutput) ToSigstorePublicKeyResponseArrayOutput() SigstorePublicKeyResponseArrayOutput {
	return o
}

func (o SigstorePublicKeyResponseArrayOutput) ToSigstorePublicKeyResponseArrayOutputWithContext(ctx context.Context) SigstorePublicKeyResponseArrayOutput {
	return o
}

func (o SigstorePublicKeyResponseArrayOutput) Index(i pulumi.IntInput) SigstorePublicKeyResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SigstorePublicKeyResponse {
		return vs[0].([]SigstorePublicKeyResponse)[vs[1].(int)]
	}).(SigstorePublicKeyResponseOutput)
}

// A bundle of Sigstore public keys, used to verify Sigstore signatures. A signature is authenticated by a `SigstorePublicKeySet` if any of the keys verify it.
type SigstorePublicKeySet struct {
	// `public_keys` must have at least one entry.
	PublicKeys []SigstorePublicKey `pulumi:"publicKeys"`
}

// SigstorePublicKeySetInput is an input type that accepts SigstorePublicKeySetArgs and SigstorePublicKeySetOutput values.
// You can construct a concrete instance of `SigstorePublicKeySetInput` via:
//
//	SigstorePublicKeySetArgs{...}
type SigstorePublicKeySetInput interface {
	pulumi.Input

	ToSigstorePublicKeySetOutput() SigstorePublicKeySetOutput
	ToSigstorePublicKeySetOutputWithContext(context.Context) SigstorePublicKeySetOutput
}

// A bundle of Sigstore public keys, used to verify Sigstore signatures. A signature is authenticated by a `SigstorePublicKeySet` if any of the keys verify it.
type SigstorePublicKeySetArgs struct {
	// `public_keys` must have at least one entry.
	PublicKeys SigstorePublicKeyArrayInput `pulumi:"publicKeys"`
}

func (SigstorePublicKeySetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SigstorePublicKeySet)(nil)).Elem()
}

func (i SigstorePublicKeySetArgs) ToSigstorePublicKeySetOutput() SigstorePublicKeySetOutput {
	return i.ToSigstorePublicKeySetOutputWithContext(context.Background())
}

func (i SigstorePublicKeySetArgs) ToSigstorePublicKeySetOutputWithContext(ctx context.Context) SigstorePublicKeySetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SigstorePublicKeySetOutput)
}

// A bundle of Sigstore public keys, used to verify Sigstore signatures. A signature is authenticated by a `SigstorePublicKeySet` if any of the keys verify it.
type SigstorePublicKeySetOutput struct{ *pulumi.OutputState }

func (SigstorePublicKeySetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SigstorePublicKeySet)(nil)).Elem()
}

func (o SigstorePublicKeySetOutput) ToSigstorePublicKeySetOutput() SigstorePublicKeySetOutput {
	return o
}

func (o SigstorePublicKeySetOutput) ToSigstorePublicKeySetOutputWithContext(ctx context.Context) SigstorePublicKeySetOutput {
	return o
}

// `public_keys` must have at least one entry.
func (o SigstorePublicKeySetOutput) PublicKeys() SigstorePublicKeyArrayOutput {
	return o.ApplyT(func(v SigstorePublicKeySet) []SigstorePublicKey { return v.PublicKeys }).(SigstorePublicKeyArrayOutput)
}

// A bundle of Sigstore public keys, used to verify Sigstore signatures. A signature is authenticated by a `SigstorePublicKeySet` if any of the keys verify it.
type SigstorePublicKeySetResponse struct {
	// `public_keys` must have at least one entry.
	PublicKeys []SigstorePublicKeyResponse `pulumi:"publicKeys"`
}

// A bundle of Sigstore public keys, used to verify Sigstore signatures. A signature is authenticated by a `SigstorePublicKeySet` if any of the keys verify it.
type SigstorePublicKeySetResponseOutput struct{ *pulumi.OutputState }

func (SigstorePublicKeySetResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SigstorePublicKeySetResponse)(nil)).Elem()
}

func (o SigstorePublicKeySetResponseOutput) ToSigstorePublicKeySetResponseOutput() SigstorePublicKeySetResponseOutput {
	return o
}

func (o SigstorePublicKeySetResponseOutput) ToSigstorePublicKeySetResponseOutputWithContext(ctx context.Context) SigstorePublicKeySetResponseOutput {
	return o
}

// `public_keys` must have at least one entry.
func (o SigstorePublicKeySetResponseOutput) PublicKeys() SigstorePublicKeyResponseArrayOutput {
	return o.ApplyT(func(v SigstorePublicKeySetResponse) []SigstorePublicKeyResponse { return v.PublicKeys }).(SigstorePublicKeyResponseArrayOutput)
}

// A Sigstore signature check, which verifies the Sigstore signature associated with an image.
type SigstoreSignatureCheck struct {
	// The authorities required by this check to verify the signature. A signature only needs to be verified by one authority to pass the check.
	SigstoreAuthorities []SigstoreAuthority `pulumi:"sigstoreAuthorities"`
}

// SigstoreSignatureCheckInput is an input type that accepts SigstoreSignatureCheckArgs and SigstoreSignatureCheckOutput values.
// You can construct a concrete instance of `SigstoreSignatureCheckInput` via:
//
//	SigstoreSignatureCheckArgs{...}
type SigstoreSignatureCheckInput interface {
	pulumi.Input

	ToSigstoreSignatureCheckOutput() SigstoreSignatureCheckOutput
	ToSigstoreSignatureCheckOutputWithContext(context.Context) SigstoreSignatureCheckOutput
}

// A Sigstore signature check, which verifies the Sigstore signature associated with an image.
type SigstoreSignatureCheckArgs struct {
	// The authorities required by this check to verify the signature. A signature only needs to be verified by one authority to pass the check.
	SigstoreAuthorities SigstoreAuthorityArrayInput `pulumi:"sigstoreAuthorities"`
}

func (SigstoreSignatureCheckArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SigstoreSignatureCheck)(nil)).Elem()
}

func (i SigstoreSignatureCheckArgs) ToSigstoreSignatureCheckOutput() SigstoreSignatureCheckOutput {
	return i.ToSigstoreSignatureCheckOutputWithContext(context.Background())
}

func (i SigstoreSignatureCheckArgs) ToSigstoreSignatureCheckOutputWithContext(ctx context.Context) SigstoreSignatureCheckOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SigstoreSignatureCheckOutput)
}

func (i SigstoreSignatureCheckArgs) ToSigstoreSignatureCheckPtrOutput() SigstoreSignatureCheckPtrOutput {
	return i.ToSigstoreSignatureCheckPtrOutputWithContext(context.Background())
}

func (i SigstoreSignatureCheckArgs) ToSigstoreSignatureCheckPtrOutputWithContext(ctx context.Context) SigstoreSignatureCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SigstoreSignatureCheckOutput).ToSigstoreSignatureCheckPtrOutputWithContext(ctx)
}

// SigstoreSignatureCheckPtrInput is an input type that accepts SigstoreSignatureCheckArgs, SigstoreSignatureCheckPtr and SigstoreSignatureCheckPtrOutput values.
// You can construct a concrete instance of `SigstoreSignatureCheckPtrInput` via:
//
//	        SigstoreSignatureCheckArgs{...}
//
//	or:
//
//	        nil
type SigstoreSignatureCheckPtrInput interface {
	pulumi.Input

	ToSigstoreSignatureCheckPtrOutput() SigstoreSignatureCheckPtrOutput
	ToSigstoreSignatureCheckPtrOutputWithContext(context.Context) SigstoreSignatureCheckPtrOutput
}

type sigstoreSignatureCheckPtrType SigstoreSignatureCheckArgs

func SigstoreSignatureCheckPtr(v *SigstoreSignatureCheckArgs) SigstoreSignatureCheckPtrInput {
	return (*sigstoreSignatureCheckPtrType)(v)
}

func (*sigstoreSignatureCheckPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SigstoreSignatureCheck)(nil)).Elem()
}

func (i *sigstoreSignatureCheckPtrType) ToSigstoreSignatureCheckPtrOutput() SigstoreSignatureCheckPtrOutput {
	return i.ToSigstoreSignatureCheckPtrOutputWithContext(context.Background())
}

func (i *sigstoreSignatureCheckPtrType) ToSigstoreSignatureCheckPtrOutputWithContext(ctx context.Context) SigstoreSignatureCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SigstoreSignatureCheckPtrOutput)
}

// A Sigstore signature check, which verifies the Sigstore signature associated with an image.
type SigstoreSignatureCheckOutput struct{ *pulumi.OutputState }

func (SigstoreSignatureCheckOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SigstoreSignatureCheck)(nil)).Elem()
}

func (o SigstoreSignatureCheckOutput) ToSigstoreSignatureCheckOutput() SigstoreSignatureCheckOutput {
	return o
}

func (o SigstoreSignatureCheckOutput) ToSigstoreSignatureCheckOutputWithContext(ctx context.Context) SigstoreSignatureCheckOutput {
	return o
}

func (o SigstoreSignatureCheckOutput) ToSigstoreSignatureCheckPtrOutput() SigstoreSignatureCheckPtrOutput {
	return o.ToSigstoreSignatureCheckPtrOutputWithContext(context.Background())
}

func (o SigstoreSignatureCheckOutput) ToSigstoreSignatureCheckPtrOutputWithContext(ctx context.Context) SigstoreSignatureCheckPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v SigstoreSignatureCheck) *SigstoreSignatureCheck {
		return &v
	}).(SigstoreSignatureCheckPtrOutput)
}

// The authorities required by this check to verify the signature. A signature only needs to be verified by one authority to pass the check.
func (o SigstoreSignatureCheckOutput) SigstoreAuthorities() SigstoreAuthorityArrayOutput {
	return o.ApplyT(func(v SigstoreSignatureCheck) []SigstoreAuthority { return v.SigstoreAuthorities }).(SigstoreAuthorityArrayOutput)
}

type SigstoreSignatureCheckPtrOutput struct{ *pulumi.OutputState }

func (SigstoreSignatureCheckPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SigstoreSignatureCheck)(nil)).Elem()
}

func (o SigstoreSignatureCheckPtrOutput) ToSigstoreSignatureCheckPtrOutput() SigstoreSignatureCheckPtrOutput {
	return o
}

func (o SigstoreSignatureCheckPtrOutput) ToSigstoreSignatureCheckPtrOutputWithContext(ctx context.Context) SigstoreSignatureCheckPtrOutput {
	return o
}

func (o SigstoreSignatureCheckPtrOutput) Elem() SigstoreSignatureCheckOutput {
	return o.ApplyT(func(v *SigstoreSignatureCheck) SigstoreSignatureCheck {
		if v != nil {
			return *v
		}
		var ret SigstoreSignatureCheck
		return ret
	}).(SigstoreSignatureCheckOutput)
}

// The authorities required by this check to verify the signature. A signature only needs to be verified by one authority to pass the check.
func (o SigstoreSignatureCheckPtrOutput) SigstoreAuthorities() SigstoreAuthorityArrayOutput {
	return o.ApplyT(func(v *SigstoreSignatureCheck) []SigstoreAuthority {
		if v == nil {
			return nil
		}
		return v.SigstoreAuthorities
	}).(SigstoreAuthorityArrayOutput)
}

// A Sigstore signature check, which verifies the Sigstore signature associated with an image.
type SigstoreSignatureCheckResponse struct {
	// The authorities required by this check to verify the signature. A signature only needs to be verified by one authority to pass the check.
	SigstoreAuthorities []SigstoreAuthorityResponse `pulumi:"sigstoreAuthorities"`
}

// A Sigstore signature check, which verifies the Sigstore signature associated with an image.
type SigstoreSignatureCheckResponseOutput struct{ *pulumi.OutputState }

func (SigstoreSignatureCheckResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SigstoreSignatureCheckResponse)(nil)).Elem()
}

func (o SigstoreSignatureCheckResponseOutput) ToSigstoreSignatureCheckResponseOutput() SigstoreSignatureCheckResponseOutput {
	return o
}

func (o SigstoreSignatureCheckResponseOutput) ToSigstoreSignatureCheckResponseOutputWithContext(ctx context.Context) SigstoreSignatureCheckResponseOutput {
	return o
}

// The authorities required by this check to verify the signature. A signature only needs to be verified by one authority to pass the check.
func (o SigstoreSignatureCheckResponseOutput) SigstoreAuthorities() SigstoreAuthorityResponseArrayOutput {
	return o.ApplyT(func(v SigstoreSignatureCheckResponse) []SigstoreAuthorityResponse { return v.SigstoreAuthorities }).(SigstoreAuthorityResponseArrayOutput)
}

// Require a signed [DSSE](https://github.com/secure-systems-lab/dsse) attestation with type SimpleSigning.
type SimpleSigningAttestationCheck struct {
	// The authenticators required by this check to verify an attestation. Typically this is one or more PKIX public keys for signature verification. Only one authenticator needs to consider an attestation verified in order for an attestation to be considered fully authenticated. In otherwords, this list of authenticators is an "OR" of the authenticator results. At least one authenticator is required.
	AttestationAuthenticators []AttestationAuthenticator `pulumi:"attestationAuthenticators"`
	// Optional. The projects where attestations are stored as Container Analysis Occurrences, in the format `projects/[PROJECT_ID]`. Only one attestation needs to successfully verify an image for this check to pass, so a single verified attestation found in any of `container_analysis_attestation_projects` is sufficient for the check to pass. When fetching Occurrences from Container Analysis, only `AttestationOccurrence` kinds are considered. In the future, additional Occurrence kinds may be added to the query. Maximum number of `container_analysis_attestation_projects` allowed in each `SimpleSigningAttestationCheck` is 10.
	ContainerAnalysisAttestationProjects []string `pulumi:"containerAnalysisAttestationProjects"`
}

// SimpleSigningAttestationCheckInput is an input type that accepts SimpleSigningAttestationCheckArgs and SimpleSigningAttestationCheckOutput values.
// You can construct a concrete instance of `SimpleSigningAttestationCheckInput` via:
//
//	SimpleSigningAttestationCheckArgs{...}
type SimpleSigningAttestationCheckInput interface {
	pulumi.Input

	ToSimpleSigningAttestationCheckOutput() SimpleSigningAttestationCheckOutput
	ToSimpleSigningAttestationCheckOutputWithContext(context.Context) SimpleSigningAttestationCheckOutput
}

// Require a signed [DSSE](https://github.com/secure-systems-lab/dsse) attestation with type SimpleSigning.
type SimpleSigningAttestationCheckArgs struct {
	// The authenticators required by this check to verify an attestation. Typically this is one or more PKIX public keys for signature verification. Only one authenticator needs to consider an attestation verified in order for an attestation to be considered fully authenticated. In otherwords, this list of authenticators is an "OR" of the authenticator results. At least one authenticator is required.
	AttestationAuthenticators AttestationAuthenticatorArrayInput `pulumi:"attestationAuthenticators"`
	// Optional. The projects where attestations are stored as Container Analysis Occurrences, in the format `projects/[PROJECT_ID]`. Only one attestation needs to successfully verify an image for this check to pass, so a single verified attestation found in any of `container_analysis_attestation_projects` is sufficient for the check to pass. When fetching Occurrences from Container Analysis, only `AttestationOccurrence` kinds are considered. In the future, additional Occurrence kinds may be added to the query. Maximum number of `container_analysis_attestation_projects` allowed in each `SimpleSigningAttestationCheck` is 10.
	ContainerAnalysisAttestationProjects pulumi.StringArrayInput `pulumi:"containerAnalysisAttestationProjects"`
}

func (SimpleSigningAttestationCheckArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SimpleSigningAttestationCheck)(nil)).Elem()
}

func (i SimpleSigningAttestationCheckArgs) ToSimpleSigningAttestationCheckOutput() SimpleSigningAttestationCheckOutput {
	return i.ToSimpleSigningAttestationCheckOutputWithContext(context.Background())
}

func (i SimpleSigningAttestationCheckArgs) ToSimpleSigningAttestationCheckOutputWithContext(ctx context.Context) SimpleSigningAttestationCheckOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SimpleSigningAttestationCheckOutput)
}

func (i SimpleSigningAttestationCheckArgs) ToSimpleSigningAttestationCheckPtrOutput() SimpleSigningAttestationCheckPtrOutput {
	return i.ToSimpleSigningAttestationCheckPtrOutputWithContext(context.Background())
}

func (i SimpleSigningAttestationCheckArgs) ToSimpleSigningAttestationCheckPtrOutputWithContext(ctx context.Context) SimpleSigningAttestationCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SimpleSigningAttestationCheckOutput).ToSimpleSigningAttestationCheckPtrOutputWithContext(ctx)
}

// SimpleSigningAttestationCheckPtrInput is an input type that accepts SimpleSigningAttestationCheckArgs, SimpleSigningAttestationCheckPtr and SimpleSigningAttestationCheckPtrOutput values.
// You can construct a concrete instance of `SimpleSigningAttestationCheckPtrInput` via:
//
//	        SimpleSigningAttestationCheckArgs{...}
//
//	or:
//
//	        nil
type SimpleSigningAttestationCheckPtrInput interface {
	pulumi.Input

	ToSimpleSigningAttestationCheckPtrOutput() SimpleSigningAttestationCheckPtrOutput
	ToSimpleSigningAttestationCheckPtrOutputWithContext(context.Context) SimpleSigningAttestationCheckPtrOutput
}

type simpleSigningAttestationCheckPtrType SimpleSigningAttestationCheckArgs

func SimpleSigningAttestationCheckPtr(v *SimpleSigningAttestationCheckArgs) SimpleSigningAttestationCheckPtrInput {
	return (*simpleSigningAttestationCheckPtrType)(v)
}

func (*simpleSigningAttestationCheckPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SimpleSigningAttestationCheck)(nil)).Elem()
}

func (i *simpleSigningAttestationCheckPtrType) ToSimpleSigningAttestationCheckPtrOutput() SimpleSigningAttestationCheckPtrOutput {
	return i.ToSimpleSigningAttestationCheckPtrOutputWithContext(context.Background())
}

func (i *simpleSigningAttestationCheckPtrType) ToSimpleSigningAttestationCheckPtrOutputWithContext(ctx context.Context) SimpleSigningAttestationCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SimpleSigningAttestationCheckPtrOutput)
}

// Require a signed [DSSE](https://github.com/secure-systems-lab/dsse) attestation with type SimpleSigning.
type SimpleSigningAttestationCheckOutput struct{ *pulumi.OutputState }

func (SimpleSigningAttestationCheckOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SimpleSigningAttestationCheck)(nil)).Elem()
}

func (o SimpleSigningAttestationCheckOutput) ToSimpleSigningAttestationCheckOutput() SimpleSigningAttestationCheckOutput {
	return o
}

func (o SimpleSigningAttestationCheckOutput) ToSimpleSigningAttestationCheckOutputWithContext(ctx context.Context) SimpleSigningAttestationCheckOutput {
	return o
}

func (o SimpleSigningAttestationCheckOutput) ToSimpleSigningAttestationCheckPtrOutput() SimpleSigningAttestationCheckPtrOutput {
	return o.ToSimpleSigningAttestationCheckPtrOutputWithContext(context.Background())
}

func (o SimpleSigningAttestationCheckOutput) ToSimpleSigningAttestationCheckPtrOutputWithContext(ctx context.Context) SimpleSigningAttestationCheckPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v SimpleSigningAttestationCheck) *SimpleSigningAttestationCheck {
		return &v
	}).(SimpleSigningAttestationCheckPtrOutput)
}

// The authenticators required by this check to verify an attestation. Typically this is one or more PKIX public keys for signature verification. Only one authenticator needs to consider an attestation verified in order for an attestation to be considered fully authenticated. In otherwords, this list of authenticators is an "OR" of the authenticator results. At least one authenticator is required.
func (o SimpleSigningAttestationCheckOutput) AttestationAuthenticators() AttestationAuthenticatorArrayOutput {
	return o.ApplyT(func(v SimpleSigningAttestationCheck) []AttestationAuthenticator { return v.AttestationAuthenticators }).(AttestationAuthenticatorArrayOutput)
}

// Optional. The projects where attestations are stored as Container Analysis Occurrences, in the format `projects/[PROJECT_ID]`. Only one attestation needs to successfully verify an image for this check to pass, so a single verified attestation found in any of `container_analysis_attestation_projects` is sufficient for the check to pass. When fetching Occurrences from Container Analysis, only `AttestationOccurrence` kinds are considered. In the future, additional Occurrence kinds may be added to the query. Maximum number of `container_analysis_attestation_projects` allowed in each `SimpleSigningAttestationCheck` is 10.
func (o SimpleSigningAttestationCheckOutput) ContainerAnalysisAttestationProjects() pulumi.StringArrayOutput {
	return o.ApplyT(func(v SimpleSigningAttestationCheck) []string { return v.ContainerAnalysisAttestationProjects }).(pulumi.StringArrayOutput)
}

type SimpleSigningAttestationCheckPtrOutput struct{ *pulumi.OutputState }

func (SimpleSigningAttestationCheckPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SimpleSigningAttestationCheck)(nil)).Elem()
}

func (o SimpleSigningAttestationCheckPtrOutput) ToSimpleSigningAttestationCheckPtrOutput() SimpleSigningAttestationCheckPtrOutput {
	return o
}

func (o SimpleSigningAttestationCheckPtrOutput) ToSimpleSigningAttestationCheckPtrOutputWithContext(ctx context.Context) SimpleSigningAttestationCheckPtrOutput {
	return o
}

func (o SimpleSigningAttestationCheckPtrOutput) Elem() SimpleSigningAttestationCheckOutput {
	return o.ApplyT(func(v *SimpleSigningAttestationCheck) SimpleSigningAttestationCheck {
		if v != nil {
			return *v
		}
		var ret SimpleSigningAttestationCheck
		return ret
	}).(SimpleSigningAttestationCheckOutput)
}

// The authenticators required by this check to verify an attestation. Typically this is one or more PKIX public keys for signature verification. Only one authenticator needs to consider an attestation verified in order for an attestation to be considered fully authenticated. In otherwords, this list of authenticators is an "OR" of the authenticator results. At least one authenticator is required.
func (o SimpleSigningAttestationCheckPtrOutput) AttestationAuthenticators() AttestationAuthenticatorArrayOutput {
	return o.ApplyT(func(v *SimpleSigningAttestationCheck) []AttestationAuthenticator {
		if v == nil {
			return nil
		}
		return v.AttestationAuthenticators
	}).(AttestationAuthenticatorArrayOutput)
}

// Optional. The projects where attestations are stored as Container Analysis Occurrences, in the format `projects/[PROJECT_ID]`. Only one attestation needs to successfully verify an image for this check to pass, so a single verified attestation found in any of `container_analysis_attestation_projects` is sufficient for the check to pass. When fetching Occurrences from Container Analysis, only `AttestationOccurrence` kinds are considered. In the future, additional Occurrence kinds may be added to the query. Maximum number of `container_analysis_attestation_projects` allowed in each `SimpleSigningAttestationCheck` is 10.
func (o SimpleSigningAttestationCheckPtrOutput) ContainerAnalysisAttestationProjects() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *SimpleSigningAttestationCheck) []string {
		if v == nil {
			return nil
		}
		return v.ContainerAnalysisAttestationProjects
	}).(pulumi.StringArrayOutput)
}

// Require a signed [DSSE](https://github.com/secure-systems-lab/dsse) attestation with type SimpleSigning.
type SimpleSigningAttestationCheckResponse struct {
	// The authenticators required by this check to verify an attestation. Typically this is one or more PKIX public keys for signature verification. Only one authenticator needs to consider an attestation verified in order for an attestation to be considered fully authenticated. In otherwords, this list of authenticators is an "OR" of the authenticator results. At least one authenticator is required.
	AttestationAuthenticators []AttestationAuthenticatorResponse `pulumi:"attestationAuthenticators"`
	// Optional. The projects where attestations are stored as Container Analysis Occurrences, in the format `projects/[PROJECT_ID]`. Only one attestation needs to successfully verify an image for this check to pass, so a single verified attestation found in any of `container_analysis_attestation_projects` is sufficient for the check to pass. When fetching Occurrences from Container Analysis, only `AttestationOccurrence` kinds are considered. In the future, additional Occurrence kinds may be added to the query. Maximum number of `container_analysis_attestation_projects` allowed in each `SimpleSigningAttestationCheck` is 10.
	ContainerAnalysisAttestationProjects []string `pulumi:"containerAnalysisAttestationProjects"`
}

// Require a signed [DSSE](https://github.com/secure-systems-lab/dsse) attestation with type SimpleSigning.
type SimpleSigningAttestationCheckResponseOutput struct{ *pulumi.OutputState }

func (SimpleSigningAttestationCheckResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SimpleSigningAttestationCheckResponse)(nil)).Elem()
}

func (o SimpleSigningAttestationCheckResponseOutput) ToSimpleSigningAttestationCheckResponseOutput() SimpleSigningAttestationCheckResponseOutput {
	return o
}

func (o SimpleSigningAttestationCheckResponseOutput) ToSimpleSigningAttestationCheckResponseOutputWithContext(ctx context.Context) SimpleSigningAttestationCheckResponseOutput {
	return o
}

// The authenticators required by this check to verify an attestation. Typically this is one or more PKIX public keys for signature verification. Only one authenticator needs to consider an attestation verified in order for an attestation to be considered fully authenticated. In otherwords, this list of authenticators is an "OR" of the authenticator results. At least one authenticator is required.
func (o SimpleSigningAttestationCheckResponseOutput) AttestationAuthenticators() AttestationAuthenticatorResponseArrayOutput {
	return o.ApplyT(func(v SimpleSigningAttestationCheckResponse) []AttestationAuthenticatorResponse {
		return v.AttestationAuthenticators
	}).(AttestationAuthenticatorResponseArrayOutput)
}

// Optional. The projects where attestations are stored as Container Analysis Occurrences, in the format `projects/[PROJECT_ID]`. Only one attestation needs to successfully verify an image for this check to pass, so a single verified attestation found in any of `container_analysis_attestation_projects` is sufficient for the check to pass. When fetching Occurrences from Container Analysis, only `AttestationOccurrence` kinds are considered. In the future, additional Occurrence kinds may be added to the query. Maximum number of `container_analysis_attestation_projects` allowed in each `SimpleSigningAttestationCheck` is 10.
func (o SimpleSigningAttestationCheckResponseOutput) ContainerAnalysisAttestationProjects() pulumi.StringArrayOutput {
	return o.ApplyT(func(v SimpleSigningAttestationCheckResponse) []string { return v.ContainerAnalysisAttestationProjects }).(pulumi.StringArrayOutput)
}

// A SLSA provenance attestation check, which ensures that images are built by a trusted builder using source code from its trusted repositories only.
type SlsaCheck struct {
	// Specifies a list of verification rules for the SLSA attestations. An image is considered compliant with the SlsaCheck if any of the rules are satisfied.
	Rules []VerificationRule `pulumi:"rules"`
}

// SlsaCheckInput is an input type that accepts SlsaCheckArgs and SlsaCheckOutput values.
// You can construct a concrete instance of `SlsaCheckInput` via:
//
//	SlsaCheckArgs{...}
type SlsaCheckInput interface {
	pulumi.Input

	ToSlsaCheckOutput() SlsaCheckOutput
	ToSlsaCheckOutputWithContext(context.Context) SlsaCheckOutput
}

// A SLSA provenance attestation check, which ensures that images are built by a trusted builder using source code from its trusted repositories only.
type SlsaCheckArgs struct {
	// Specifies a list of verification rules for the SLSA attestations. An image is considered compliant with the SlsaCheck if any of the rules are satisfied.
	Rules VerificationRuleArrayInput `pulumi:"rules"`
}

func (SlsaCheckArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SlsaCheck)(nil)).Elem()
}

func (i SlsaCheckArgs) ToSlsaCheckOutput() SlsaCheckOutput {
	return i.ToSlsaCheckOutputWithContext(context.Background())
}

func (i SlsaCheckArgs) ToSlsaCheckOutputWithContext(ctx context.Context) SlsaCheckOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SlsaCheckOutput)
}

func (i SlsaCheckArgs) ToSlsaCheckPtrOutput() SlsaCheckPtrOutput {
	return i.ToSlsaCheckPtrOutputWithContext(context.Background())
}

func (i SlsaCheckArgs) ToSlsaCheckPtrOutputWithContext(ctx context.Context) SlsaCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SlsaCheckOutput).ToSlsaCheckPtrOutputWithContext(ctx)
}

// SlsaCheckPtrInput is an input type that accepts SlsaCheckArgs, SlsaCheckPtr and SlsaCheckPtrOutput values.
// You can construct a concrete instance of `SlsaCheckPtrInput` via:
//
//	        SlsaCheckArgs{...}
//
//	or:
//
//	        nil
type SlsaCheckPtrInput interface {
	pulumi.Input

	ToSlsaCheckPtrOutput() SlsaCheckPtrOutput
	ToSlsaCheckPtrOutputWithContext(context.Context) SlsaCheckPtrOutput
}

type slsaCheckPtrType SlsaCheckArgs

func SlsaCheckPtr(v *SlsaCheckArgs) SlsaCheckPtrInput {
	return (*slsaCheckPtrType)(v)
}

func (*slsaCheckPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SlsaCheck)(nil)).Elem()
}

func (i *slsaCheckPtrType) ToSlsaCheckPtrOutput() SlsaCheckPtrOutput {
	return i.ToSlsaCheckPtrOutputWithContext(context.Background())
}

func (i *slsaCheckPtrType) ToSlsaCheckPtrOutputWithContext(ctx context.Context) SlsaCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SlsaCheckPtrOutput)
}

// A SLSA provenance attestation check, which ensures that images are built by a trusted builder using source code from its trusted repositories only.
type SlsaCheckOutput struct{ *pulumi.OutputState }

func (SlsaCheckOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SlsaCheck)(nil)).Elem()
}

func (o SlsaCheckOutput) ToSlsaCheckOutput() SlsaCheckOutput {
	return o
}

func (o SlsaCheckOutput) ToSlsaCheckOutputWithContext(ctx context.Context) SlsaCheckOutput {
	return o
}

func (o SlsaCheckOutput) ToSlsaCheckPtrOutput() SlsaCheckPtrOutput {
	return o.ToSlsaCheckPtrOutputWithContext(context.Background())
}

func (o SlsaCheckOutput) ToSlsaCheckPtrOutputWithContext(ctx context.Context) SlsaCheckPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v SlsaCheck) *SlsaCheck {
		return &v
	}).(SlsaCheckPtrOutput)
}

// Specifies a list of verification rules for the SLSA attestations. An image is considered compliant with the SlsaCheck if any of the rules are satisfied.
func (o SlsaCheckOutput) Rules() VerificationRuleArrayOutput {
	return o.ApplyT(func(v SlsaCheck) []VerificationRule { return v.Rules }).(VerificationRuleArrayOutput)
}

type SlsaCheckPtrOutput struct{ *pulumi.OutputState }

func (SlsaCheckPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SlsaCheck)(nil)).Elem()
}

func (o SlsaCheckPtrOutput) ToSlsaCheckPtrOutput() SlsaCheckPtrOutput {
	return o
}

func (o SlsaCheckPtrOutput) ToSlsaCheckPtrOutputWithContext(ctx context.Context) SlsaCheckPtrOutput {
	return o
}

func (o SlsaCheckPtrOutput) Elem() SlsaCheckOutput {
	return o.ApplyT(func(v *SlsaCheck) SlsaCheck {
		if v != nil {
			return *v
		}
		var ret SlsaCheck
		return ret
	}).(SlsaCheckOutput)
}

// Specifies a list of verification rules for the SLSA attestations. An image is considered compliant with the SlsaCheck if any of the rules are satisfied.
func (o SlsaCheckPtrOutput) Rules() VerificationRuleArrayOutput {
	return o.ApplyT(func(v *SlsaCheck) []VerificationRule {
		if v == nil {
			return nil
		}
		return v.Rules
	}).(VerificationRuleArrayOutput)
}

// A SLSA provenance attestation check, which ensures that images are built by a trusted builder using source code from its trusted repositories only.
type SlsaCheckResponse struct {
	// Specifies a list of verification rules for the SLSA attestations. An image is considered compliant with the SlsaCheck if any of the rules are satisfied.
	Rules []VerificationRuleResponse `pulumi:"rules"`
}

// A SLSA provenance attestation check, which ensures that images are built by a trusted builder using source code from its trusted repositories only.
type SlsaCheckResponseOutput struct{ *pulumi.OutputState }

func (SlsaCheckResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SlsaCheckResponse)(nil)).Elem()
}

func (o SlsaCheckResponseOutput) ToSlsaCheckResponseOutput() SlsaCheckResponseOutput {
	return o
}

func (o SlsaCheckResponseOutput) ToSlsaCheckResponseOutputWithContext(ctx context.Context) SlsaCheckResponseOutput {
	return o
}

// Specifies a list of verification rules for the SLSA attestations. An image is considered compliant with the SlsaCheck if any of the rules are satisfied.
func (o SlsaCheckResponseOutput) Rules() VerificationRuleResponseArrayOutput {
	return o.ApplyT(func(v SlsaCheckResponse) []VerificationRuleResponse { return v.Rules }).(VerificationRuleResponseArrayOutput)
}

// A trusted directory check, which rejects images that do not come from the set of user-configured trusted directories.
type TrustedDirectoryCheck struct {
	// List of trusted directory patterns. A pattern is in the form "registry/path/to/directory". The registry domain part is defined as two or more dot-separated words, e.g., `us.pkg.dev`, or `gcr.io`. Additionally, `*` can be used in three ways as wildcards: 1. leading `*` to match varying prefixes in registry subdomain (useful for location prefixes); 2. trailing `*` after registry/ to match varying endings; 3. trailing `**` after registry/ to match "/" as well. For example: -- `gcr.io/my-project/my-repo` is valid to match a single directory -- `*-docker.pkg.dev/my-project/my-repo` or `*.gcr.io/my-project` are valid to match varying prefixes -- `gcr.io/my-project/*` will match all direct directories in `my-project` -- `gcr.io/my-project/**` would match all directories in `my-project` -- `gcr.i*` is not allowed since the registry is not completely specified -- `sub*domain.gcr.io/nginx` is not valid because only leading `*` or trailing `*` are allowed. -- `*pkg.dev/my-project/my-repo` is not valid because leading `*` can only match subdomain -- `**-docker.pkg.dev` is not valid because one leading `*` is allowed, and that it cannot match `/`
	TrustedDirPatterns []string `pulumi:"trustedDirPatterns"`
}

// TrustedDirectoryCheckInput is an input type that accepts TrustedDirectoryCheckArgs and TrustedDirectoryCheckOutput values.
// You can construct a concrete instance of `TrustedDirectoryCheckInput` via:
//
//	TrustedDirectoryCheckArgs{...}
type TrustedDirectoryCheckInput interface {
	pulumi.Input

	ToTrustedDirectoryCheckOutput() TrustedDirectoryCheckOutput
	ToTrustedDirectoryCheckOutputWithContext(context.Context) TrustedDirectoryCheckOutput
}

// A trusted directory check, which rejects images that do not come from the set of user-configured trusted directories.
type TrustedDirectoryCheckArgs struct {
	// List of trusted directory patterns. A pattern is in the form "registry/path/to/directory". The registry domain part is defined as two or more dot-separated words, e.g., `us.pkg.dev`, or `gcr.io`. Additionally, `*` can be used in three ways as wildcards: 1. leading `*` to match varying prefixes in registry subdomain (useful for location prefixes); 2. trailing `*` after registry/ to match varying endings; 3. trailing `**` after registry/ to match "/" as well. For example: -- `gcr.io/my-project/my-repo` is valid to match a single directory -- `*-docker.pkg.dev/my-project/my-repo` or `*.gcr.io/my-project` are valid to match varying prefixes -- `gcr.io/my-project/*` will match all direct directories in `my-project` -- `gcr.io/my-project/**` would match all directories in `my-project` -- `gcr.i*` is not allowed since the registry is not completely specified -- `sub*domain.gcr.io/nginx` is not valid because only leading `*` or trailing `*` are allowed. -- `*pkg.dev/my-project/my-repo` is not valid because leading `*` can only match subdomain -- `**-docker.pkg.dev` is not valid because one leading `*` is allowed, and that it cannot match `/`
	TrustedDirPatterns pulumi.StringArrayInput `pulumi:"trustedDirPatterns"`
}

func (TrustedDirectoryCheckArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TrustedDirectoryCheck)(nil)).Elem()
}

func (i TrustedDirectoryCheckArgs) ToTrustedDirectoryCheckOutput() TrustedDirectoryCheckOutput {
	return i.ToTrustedDirectoryCheckOutputWithContext(context.Background())
}

func (i TrustedDirectoryCheckArgs) ToTrustedDirectoryCheckOutputWithContext(ctx context.Context) TrustedDirectoryCheckOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TrustedDirectoryCheckOutput)
}

func (i TrustedDirectoryCheckArgs) ToTrustedDirectoryCheckPtrOutput() TrustedDirectoryCheckPtrOutput {
	return i.ToTrustedDirectoryCheckPtrOutputWithContext(context.Background())
}

func (i TrustedDirectoryCheckArgs) ToTrustedDirectoryCheckPtrOutputWithContext(ctx context.Context) TrustedDirectoryCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TrustedDirectoryCheckOutput).ToTrustedDirectoryCheckPtrOutputWithContext(ctx)
}

// TrustedDirectoryCheckPtrInput is an input type that accepts TrustedDirectoryCheckArgs, TrustedDirectoryCheckPtr and TrustedDirectoryCheckPtrOutput values.
// You can construct a concrete instance of `TrustedDirectoryCheckPtrInput` via:
//
//	        TrustedDirectoryCheckArgs{...}
//
//	or:
//
//	        nil
type TrustedDirectoryCheckPtrInput interface {
	pulumi.Input

	ToTrustedDirectoryCheckPtrOutput() TrustedDirectoryCheckPtrOutput
	ToTrustedDirectoryCheckPtrOutputWithContext(context.Context) TrustedDirectoryCheckPtrOutput
}

type trustedDirectoryCheckPtrType TrustedDirectoryCheckArgs

func TrustedDirectoryCheckPtr(v *TrustedDirectoryCheckArgs) TrustedDirectoryCheckPtrInput {
	return (*trustedDirectoryCheckPtrType)(v)
}

func (*trustedDirectoryCheckPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TrustedDirectoryCheck)(nil)).Elem()
}

func (i *trustedDirectoryCheckPtrType) ToTrustedDirectoryCheckPtrOutput() TrustedDirectoryCheckPtrOutput {
	return i.ToTrustedDirectoryCheckPtrOutputWithContext(context.Background())
}

func (i *trustedDirectoryCheckPtrType) ToTrustedDirectoryCheckPtrOutputWithContext(ctx context.Context) TrustedDirectoryCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TrustedDirectoryCheckPtrOutput)
}

// A trusted directory check, which rejects images that do not come from the set of user-configured trusted directories.
type TrustedDirectoryCheckOutput struct{ *pulumi.OutputState }

func (TrustedDirectoryCheckOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TrustedDirectoryCheck)(nil)).Elem()
}

func (o TrustedDirectoryCheckOutput) ToTrustedDirectoryCheckOutput() TrustedDirectoryCheckOutput {
	return o
}

func (o TrustedDirectoryCheckOutput) ToTrustedDirectoryCheckOutputWithContext(ctx context.Context) TrustedDirectoryCheckOutput {
	return o
}

func (o TrustedDirectoryCheckOutput) ToTrustedDirectoryCheckPtrOutput() TrustedDirectoryCheckPtrOutput {
	return o.ToTrustedDirectoryCheckPtrOutputWithContext(context.Background())
}

func (o TrustedDirectoryCheckOutput) ToTrustedDirectoryCheckPtrOutputWithContext(ctx context.Context) TrustedDirectoryCheckPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TrustedDirectoryCheck) *TrustedDirectoryCheck {
		return &v
	}).(TrustedDirectoryCheckPtrOutput)
}

// List of trusted directory patterns. A pattern is in the form "registry/path/to/directory". The registry domain part is defined as two or more dot-separated words, e.g., `us.pkg.dev`, or `gcr.io`. Additionally, `*` can be used in three ways as wildcards: 1. leading `*` to match varying prefixes in registry subdomain (useful for location prefixes); 2. trailing `*` after registry/ to match varying endings; 3. trailing `**` after registry/ to match "/" as well. For example: -- `gcr.io/my-project/my-repo` is valid to match a single directory -- `*-docker.pkg.dev/my-project/my-repo` or `*.gcr.io/my-project` are valid to match varying prefixes -- `gcr.io/my-project/*` will match all direct directories in `my-project` -- `gcr.io/my-project/**` would match all directories in `my-project` -- `gcr.i*` is not allowed since the registry is not completely specified -- `sub*domain.gcr.io/nginx` is not valid because only leading `*` or trailing `*` are allowed. -- `*pkg.dev/my-project/my-repo` is not valid because leading `*` can only match subdomain -- `**-docker.pkg.dev` is not valid because one leading `*` is allowed, and that it cannot match `/`
func (o TrustedDirectoryCheckOutput) TrustedDirPatterns() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TrustedDirectoryCheck) []string { return v.TrustedDirPatterns }).(pulumi.StringArrayOutput)
}

type TrustedDirectoryCheckPtrOutput struct{ *pulumi.OutputState }

func (TrustedDirectoryCheckPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TrustedDirectoryCheck)(nil)).Elem()
}

func (o TrustedDirectoryCheckPtrOutput) ToTrustedDirectoryCheckPtrOutput() TrustedDirectoryCheckPtrOutput {
	return o
}

func (o TrustedDirectoryCheckPtrOutput) ToTrustedDirectoryCheckPtrOutputWithContext(ctx context.Context) TrustedDirectoryCheckPtrOutput {
	return o
}

func (o TrustedDirectoryCheckPtrOutput) Elem() TrustedDirectoryCheckOutput {
	return o.ApplyT(func(v *TrustedDirectoryCheck) TrustedDirectoryCheck {
		if v != nil {
			return *v
		}
		var ret TrustedDirectoryCheck
		return ret
	}).(TrustedDirectoryCheckOutput)
}

// List of trusted directory patterns. A pattern is in the form "registry/path/to/directory". The registry domain part is defined as two or more dot-separated words, e.g., `us.pkg.dev`, or `gcr.io`. Additionally, `*` can be used in three ways as wildcards: 1. leading `*` to match varying prefixes in registry subdomain (useful for location prefixes); 2. trailing `*` after registry/ to match varying endings; 3. trailing `**` after registry/ to match "/" as well. For example: -- `gcr.io/my-project/my-repo` is valid to match a single directory -- `*-docker.pkg.dev/my-project/my-repo` or `*.gcr.io/my-project` are valid to match varying prefixes -- `gcr.io/my-project/*` will match all direct directories in `my-project` -- `gcr.io/my-project/**` would match all directories in `my-project` -- `gcr.i*` is not allowed since the registry is not completely specified -- `sub*domain.gcr.io/nginx` is not valid because only leading `*` or trailing `*` are allowed. -- `*pkg.dev/my-project/my-repo` is not valid because leading `*` can only match subdomain -- `**-docker.pkg.dev` is not valid because one leading `*` is allowed, and that it cannot match `/`
func (o TrustedDirectoryCheckPtrOutput) TrustedDirPatterns() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TrustedDirectoryCheck) []string {
		if v == nil {
			return nil
		}
		return v.TrustedDirPatterns
	}).(pulumi.StringArrayOutput)
}

// A trusted directory check, which rejects images that do not come from the set of user-configured trusted directories.
type TrustedDirectoryCheckResponse struct {
	// List of trusted directory patterns. A pattern is in the form "registry/path/to/directory". The registry domain part is defined as two or more dot-separated words, e.g., `us.pkg.dev`, or `gcr.io`. Additionally, `*` can be used in three ways as wildcards: 1. leading `*` to match varying prefixes in registry subdomain (useful for location prefixes); 2. trailing `*` after registry/ to match varying endings; 3. trailing `**` after registry/ to match "/" as well. For example: -- `gcr.io/my-project/my-repo` is valid to match a single directory -- `*-docker.pkg.dev/my-project/my-repo` or `*.gcr.io/my-project` are valid to match varying prefixes -- `gcr.io/my-project/*` will match all direct directories in `my-project` -- `gcr.io/my-project/**` would match all directories in `my-project` -- `gcr.i*` is not allowed since the registry is not completely specified -- `sub*domain.gcr.io/nginx` is not valid because only leading `*` or trailing `*` are allowed. -- `*pkg.dev/my-project/my-repo` is not valid because leading `*` can only match subdomain -- `**-docker.pkg.dev` is not valid because one leading `*` is allowed, and that it cannot match `/`
	TrustedDirPatterns []string `pulumi:"trustedDirPatterns"`
}

// A trusted directory check, which rejects images that do not come from the set of user-configured trusted directories.
type TrustedDirectoryCheckResponseOutput struct{ *pulumi.OutputState }

func (TrustedDirectoryCheckResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TrustedDirectoryCheckResponse)(nil)).Elem()
}

func (o TrustedDirectoryCheckResponseOutput) ToTrustedDirectoryCheckResponseOutput() TrustedDirectoryCheckResponseOutput {
	return o
}

func (o TrustedDirectoryCheckResponseOutput) ToTrustedDirectoryCheckResponseOutputWithContext(ctx context.Context) TrustedDirectoryCheckResponseOutput {
	return o
}

// List of trusted directory patterns. A pattern is in the form "registry/path/to/directory". The registry domain part is defined as two or more dot-separated words, e.g., `us.pkg.dev`, or `gcr.io`. Additionally, `*` can be used in three ways as wildcards: 1. leading `*` to match varying prefixes in registry subdomain (useful for location prefixes); 2. trailing `*` after registry/ to match varying endings; 3. trailing `**` after registry/ to match "/" as well. For example: -- `gcr.io/my-project/my-repo` is valid to match a single directory -- `*-docker.pkg.dev/my-project/my-repo` or `*.gcr.io/my-project` are valid to match varying prefixes -- `gcr.io/my-project/*` will match all direct directories in `my-project` -- `gcr.io/my-project/**` would match all directories in `my-project` -- `gcr.i*` is not allowed since the registry is not completely specified -- `sub*domain.gcr.io/nginx` is not valid because only leading `*` or trailing `*` are allowed. -- `*pkg.dev/my-project/my-repo` is not valid because leading `*` can only match subdomain -- `**-docker.pkg.dev` is not valid because one leading `*` is allowed, and that it cannot match `/`
func (o TrustedDirectoryCheckResponseOutput) TrustedDirPatterns() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TrustedDirectoryCheckResponse) []string { return v.TrustedDirPatterns }).(pulumi.StringArrayOutput)
}

// An user owned Grafeas note references a Grafeas Attestation.Authority Note created by the user.
type UserOwnedGrafeasNote struct {
	// The Grafeas resource name of a Attestation.Authority Note, created by the user, in the format: `projects/*/notes/*`. This field may not be updated. An attestation by this attestor is stored as a Grafeas Attestation.Authority Occurrence that names a container image and that links to this Note. Grafeas is an external dependency.
	NoteReference string `pulumi:"noteReference"`
	// Optional. Public keys that verify attestations signed by this attestor. This field may be updated. If this field is non-empty, one of the specified public keys must verify that an attestation was signed by this attestor for the image specified in the admission request. If this field is empty, this attestor always returns that no valid attestations exist.
	PublicKeys []AttestorPublicKey `pulumi:"publicKeys"`
}

// UserOwnedGrafeasNoteInput is an input type that accepts UserOwnedGrafeasNoteArgs and UserOwnedGrafeasNoteOutput values.
// You can construct a concrete instance of `UserOwnedGrafeasNoteInput` via:
//
//	UserOwnedGrafeasNoteArgs{...}
type UserOwnedGrafeasNoteInput interface {
	pulumi.Input

	ToUserOwnedGrafeasNoteOutput() UserOwnedGrafeasNoteOutput
	ToUserOwnedGrafeasNoteOutputWithContext(context.Context) UserOwnedGrafeasNoteOutput
}

// An user owned Grafeas note references a Grafeas Attestation.Authority Note created by the user.
type UserOwnedGrafeasNoteArgs struct {
	// The Grafeas resource name of a Attestation.Authority Note, created by the user, in the format: `projects/*/notes/*`. This field may not be updated. An attestation by this attestor is stored as a Grafeas Attestation.Authority Occurrence that names a container image and that links to this Note. Grafeas is an external dependency.
	NoteReference pulumi.StringInput `pulumi:"noteReference"`
	// Optional. Public keys that verify attestations signed by this attestor. This field may be updated. If this field is non-empty, one of the specified public keys must verify that an attestation was signed by this attestor for the image specified in the admission request. If this field is empty, this attestor always returns that no valid attestations exist.
	PublicKeys AttestorPublicKeyArrayInput `pulumi:"publicKeys"`
}

func (UserOwnedGrafeasNoteArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UserOwnedGrafeasNote)(nil)).Elem()
}

func (i UserOwnedGrafeasNoteArgs) ToUserOwnedGrafeasNoteOutput() UserOwnedGrafeasNoteOutput {
	return i.ToUserOwnedGrafeasNoteOutputWithContext(context.Background())
}

func (i UserOwnedGrafeasNoteArgs) ToUserOwnedGrafeasNoteOutputWithContext(ctx context.Context) UserOwnedGrafeasNoteOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserOwnedGrafeasNoteOutput)
}

func (i UserOwnedGrafeasNoteArgs) ToUserOwnedGrafeasNotePtrOutput() UserOwnedGrafeasNotePtrOutput {
	return i.ToUserOwnedGrafeasNotePtrOutputWithContext(context.Background())
}

func (i UserOwnedGrafeasNoteArgs) ToUserOwnedGrafeasNotePtrOutputWithContext(ctx context.Context) UserOwnedGrafeasNotePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserOwnedGrafeasNoteOutput).ToUserOwnedGrafeasNotePtrOutputWithContext(ctx)
}

// UserOwnedGrafeasNotePtrInput is an input type that accepts UserOwnedGrafeasNoteArgs, UserOwnedGrafeasNotePtr and UserOwnedGrafeasNotePtrOutput values.
// You can construct a concrete instance of `UserOwnedGrafeasNotePtrInput` via:
//
//	        UserOwnedGrafeasNoteArgs{...}
//
//	or:
//
//	        nil
type UserOwnedGrafeasNotePtrInput interface {
	pulumi.Input

	ToUserOwnedGrafeasNotePtrOutput() UserOwnedGrafeasNotePtrOutput
	ToUserOwnedGrafeasNotePtrOutputWithContext(context.Context) UserOwnedGrafeasNotePtrOutput
}

type userOwnedGrafeasNotePtrType UserOwnedGrafeasNoteArgs

func UserOwnedGrafeasNotePtr(v *UserOwnedGrafeasNoteArgs) UserOwnedGrafeasNotePtrInput {
	return (*userOwnedGrafeasNotePtrType)(v)
}

func (*userOwnedGrafeasNotePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**UserOwnedGrafeasNote)(nil)).Elem()
}

func (i *userOwnedGrafeasNotePtrType) ToUserOwnedGrafeasNotePtrOutput() UserOwnedGrafeasNotePtrOutput {
	return i.ToUserOwnedGrafeasNotePtrOutputWithContext(context.Background())
}

func (i *userOwnedGrafeasNotePtrType) ToUserOwnedGrafeasNotePtrOutputWithContext(ctx context.Context) UserOwnedGrafeasNotePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserOwnedGrafeasNotePtrOutput)
}

// An user owned Grafeas note references a Grafeas Attestation.Authority Note created by the user.
type UserOwnedGrafeasNoteOutput struct{ *pulumi.OutputState }

func (UserOwnedGrafeasNoteOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserOwnedGrafeasNote)(nil)).Elem()
}

func (o UserOwnedGrafeasNoteOutput) ToUserOwnedGrafeasNoteOutput() UserOwnedGrafeasNoteOutput {
	return o
}

func (o UserOwnedGrafeasNoteOutput) ToUserOwnedGrafeasNoteOutputWithContext(ctx context.Context) UserOwnedGrafeasNoteOutput {
	return o
}

func (o UserOwnedGrafeasNoteOutput) ToUserOwnedGrafeasNotePtrOutput() UserOwnedGrafeasNotePtrOutput {
	return o.ToUserOwnedGrafeasNotePtrOutputWithContext(context.Background())
}

func (o UserOwnedGrafeasNoteOutput) ToUserOwnedGrafeasNotePtrOutputWithContext(ctx context.Context) UserOwnedGrafeasNotePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v UserOwnedGrafeasNote) *UserOwnedGrafeasNote {
		return &v
	}).(UserOwnedGrafeasNotePtrOutput)
}

// The Grafeas resource name of a Attestation.Authority Note, created by the user, in the format: `projects/*/notes/*`. This field may not be updated. An attestation by this attestor is stored as a Grafeas Attestation.Authority Occurrence that names a container image and that links to this Note. Grafeas is an external dependency.
func (o UserOwnedGrafeasNoteOutput) NoteReference() pulumi.StringOutput {
	return o.ApplyT(func(v UserOwnedGrafeasNote) string { return v.NoteReference }).(pulumi.StringOutput)
}

// Optional. Public keys that verify attestations signed by this attestor. This field may be updated. If this field is non-empty, one of the specified public keys must verify that an attestation was signed by this attestor for the image specified in the admission request. If this field is empty, this attestor always returns that no valid attestations exist.
func (o UserOwnedGrafeasNoteOutput) PublicKeys() AttestorPublicKeyArrayOutput {
	return o.ApplyT(func(v UserOwnedGrafeasNote) []AttestorPublicKey { return v.PublicKeys }).(AttestorPublicKeyArrayOutput)
}

type UserOwnedGrafeasNotePtrOutput struct{ *pulumi.OutputState }

func (UserOwnedGrafeasNotePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UserOwnedGrafeasNote)(nil)).Elem()
}

func (o UserOwnedGrafeasNotePtrOutput) ToUserOwnedGrafeasNotePtrOutput() UserOwnedGrafeasNotePtrOutput {
	return o
}

func (o UserOwnedGrafeasNotePtrOutput) ToUserOwnedGrafeasNotePtrOutputWithContext(ctx context.Context) UserOwnedGrafeasNotePtrOutput {
	return o
}

func (o UserOwnedGrafeasNotePtrOutput) Elem() UserOwnedGrafeasNoteOutput {
	return o.ApplyT(func(v *UserOwnedGrafeasNote) UserOwnedGrafeasNote {
		if v != nil {
			return *v
		}
		var ret UserOwnedGrafeasNote
		return ret
	}).(UserOwnedGrafeasNoteOutput)
}

// The Grafeas resource name of a Attestation.Authority Note, created by the user, in the format: `projects/*/notes/*`. This field may not be updated. An attestation by this attestor is stored as a Grafeas Attestation.Authority Occurrence that names a container image and that links to this Note. Grafeas is an external dependency.
func (o UserOwnedGrafeasNotePtrOutput) NoteReference() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UserOwnedGrafeasNote) *string {
		if v == nil {
			return nil
		}
		return &v.NoteReference
	}).(pulumi.StringPtrOutput)
}

// Optional. Public keys that verify attestations signed by this attestor. This field may be updated. If this field is non-empty, one of the specified public keys must verify that an attestation was signed by this attestor for the image specified in the admission request. If this field is empty, this attestor always returns that no valid attestations exist.
func (o UserOwnedGrafeasNotePtrOutput) PublicKeys() AttestorPublicKeyArrayOutput {
	return o.ApplyT(func(v *UserOwnedGrafeasNote) []AttestorPublicKey {
		if v == nil {
			return nil
		}
		return v.PublicKeys
	}).(AttestorPublicKeyArrayOutput)
}

// An user owned Grafeas note references a Grafeas Attestation.Authority Note created by the user.
type UserOwnedGrafeasNoteResponse struct {
	// This field will contain the service account email address that this attestor will use as the principal when querying Container Analysis. Attestor administrators must grant this service account the IAM role needed to read attestations from the note_reference in Container Analysis (`containeranalysis.notes.occurrences.viewer`). This email address is fixed for the lifetime of the attestor, but callers should not make any other assumptions about the service account email; future versions may use an email based on a different naming pattern.
	DelegationServiceAccountEmail string `pulumi:"delegationServiceAccountEmail"`
	// The Grafeas resource name of a Attestation.Authority Note, created by the user, in the format: `projects/*/notes/*`. This field may not be updated. An attestation by this attestor is stored as a Grafeas Attestation.Authority Occurrence that names a container image and that links to this Note. Grafeas is an external dependency.
	NoteReference string `pulumi:"noteReference"`
	// Optional. Public keys that verify attestations signed by this attestor. This field may be updated. If this field is non-empty, one of the specified public keys must verify that an attestation was signed by this attestor for the image specified in the admission request. If this field is empty, this attestor always returns that no valid attestations exist.
	PublicKeys []AttestorPublicKeyResponse `pulumi:"publicKeys"`
}

// An user owned Grafeas note references a Grafeas Attestation.Authority Note created by the user.
type UserOwnedGrafeasNoteResponseOutput struct{ *pulumi.OutputState }

func (UserOwnedGrafeasNoteResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserOwnedGrafeasNoteResponse)(nil)).Elem()
}

func (o UserOwnedGrafeasNoteResponseOutput) ToUserOwnedGrafeasNoteResponseOutput() UserOwnedGrafeasNoteResponseOutput {
	return o
}

func (o UserOwnedGrafeasNoteResponseOutput) ToUserOwnedGrafeasNoteResponseOutputWithContext(ctx context.Context) UserOwnedGrafeasNoteResponseOutput {
	return o
}

// This field will contain the service account email address that this attestor will use as the principal when querying Container Analysis. Attestor administrators must grant this service account the IAM role needed to read attestations from the note_reference in Container Analysis (`containeranalysis.notes.occurrences.viewer`). This email address is fixed for the lifetime of the attestor, but callers should not make any other assumptions about the service account email; future versions may use an email based on a different naming pattern.
func (o UserOwnedGrafeasNoteResponseOutput) DelegationServiceAccountEmail() pulumi.StringOutput {
	return o.ApplyT(func(v UserOwnedGrafeasNoteResponse) string { return v.DelegationServiceAccountEmail }).(pulumi.StringOutput)
}

// The Grafeas resource name of a Attestation.Authority Note, created by the user, in the format: `projects/*/notes/*`. This field may not be updated. An attestation by this attestor is stored as a Grafeas Attestation.Authority Occurrence that names a container image and that links to this Note. Grafeas is an external dependency.
func (o UserOwnedGrafeasNoteResponseOutput) NoteReference() pulumi.StringOutput {
	return o.ApplyT(func(v UserOwnedGrafeasNoteResponse) string { return v.NoteReference }).(pulumi.StringOutput)
}

// Optional. Public keys that verify attestations signed by this attestor. This field may be updated. If this field is non-empty, one of the specified public keys must verify that an attestation was signed by this attestor for the image specified in the admission request. If this field is empty, this attestor always returns that no valid attestations exist.
func (o UserOwnedGrafeasNoteResponseOutput) PublicKeys() AttestorPublicKeyResponseArrayOutput {
	return o.ApplyT(func(v UserOwnedGrafeasNoteResponse) []AttestorPublicKeyResponse { return v.PublicKeys }).(AttestorPublicKeyResponseArrayOutput)
}

// Specifies verification rules for evaluating the SLSA attestations including: which builders to trust, where to fetch the SLSA attestations generated by those builders, and other builder-specific evaluation rules such as which source repositories are trusted. An image is considered verified by the rule if any of the fetched SLSA attestations is verified.
type VerificationRule struct {
	// Specifies where to fetch the provenances attestations generated by the builder (group).
	AttestationSource *AttestationSource `pulumi:"attestationSource"`
	// If true, require the image to be built from a top-level configuration. `trusted_source_repo_patterns` specifies the repositories containing this configuration.
	ConfigBasedBuildRequired *bool `pulumi:"configBasedBuildRequired"`
	// Each verification rule is used for evaluation against provenances generated by a specific builder (group). For some of the builders, such as the Google Cloud Build, users don't need to explicitly specify their roots of trust in the policy since the evaluation service can automatically fetch them based on the builder (group).
	TrustedBuilder *VerificationRuleTrustedBuilder `pulumi:"trustedBuilder"`
	// List of trusted source code repository URL patterns. These patterns match the full repository URL without its scheme (e.g. `https://`). The patterns must not include schemes. For example, the pattern `source.cloud.google.com/my-project/my-repo-name` matches the following URLs: - `source.cloud.google.com/my-project/my-repo-name` - `git+ssh://source.cloud.google.com/my-project/my-repo-name` - `https://source.cloud.google.com/my-project/my-repo-name` A pattern matches a URL either exactly or with `*` wildcards. `*` can be used in only two ways: 1. trailing `*` after hosturi/ to match varying endings; 2. trailing `**` after hosturi/ to match `/` as well. `*` and `**` can only be used as wildcards and can only occur at the end of the pattern after a `/`. (So it's not possible to match a URL that contains literal `*`.) For example: - `github.com/my-project/my-repo` is valid to match a single repo - `github.com/my-project/*` will match all direct repos in `my-project` - `github.com/**` matches all repos in GitHub
	TrustedSourceRepoPatterns []string `pulumi:"trustedSourceRepoPatterns"`
}

// VerificationRuleInput is an input type that accepts VerificationRuleArgs and VerificationRuleOutput values.
// You can construct a concrete instance of `VerificationRuleInput` via:
//
//	VerificationRuleArgs{...}
type VerificationRuleInput interface {
	pulumi.Input

	ToVerificationRuleOutput() VerificationRuleOutput
	ToVerificationRuleOutputWithContext(context.Context) VerificationRuleOutput
}

// Specifies verification rules for evaluating the SLSA attestations including: which builders to trust, where to fetch the SLSA attestations generated by those builders, and other builder-specific evaluation rules such as which source repositories are trusted. An image is considered verified by the rule if any of the fetched SLSA attestations is verified.
type VerificationRuleArgs struct {
	// Specifies where to fetch the provenances attestations generated by the builder (group).
	AttestationSource AttestationSourcePtrInput `pulumi:"attestationSource"`
	// If true, require the image to be built from a top-level configuration. `trusted_source_repo_patterns` specifies the repositories containing this configuration.
	ConfigBasedBuildRequired pulumi.BoolPtrInput `pulumi:"configBasedBuildRequired"`
	// Each verification rule is used for evaluation against provenances generated by a specific builder (group). For some of the builders, such as the Google Cloud Build, users don't need to explicitly specify their roots of trust in the policy since the evaluation service can automatically fetch them based on the builder (group).
	TrustedBuilder VerificationRuleTrustedBuilderPtrInput `pulumi:"trustedBuilder"`
	// List of trusted source code repository URL patterns. These patterns match the full repository URL without its scheme (e.g. `https://`). The patterns must not include schemes. For example, the pattern `source.cloud.google.com/my-project/my-repo-name` matches the following URLs: - `source.cloud.google.com/my-project/my-repo-name` - `git+ssh://source.cloud.google.com/my-project/my-repo-name` - `https://source.cloud.google.com/my-project/my-repo-name` A pattern matches a URL either exactly or with `*` wildcards. `*` can be used in only two ways: 1. trailing `*` after hosturi/ to match varying endings; 2. trailing `**` after hosturi/ to match `/` as well. `*` and `**` can only be used as wildcards and can only occur at the end of the pattern after a `/`. (So it's not possible to match a URL that contains literal `*`.) For example: - `github.com/my-project/my-repo` is valid to match a single repo - `github.com/my-project/*` will match all direct repos in `my-project` - `github.com/**` matches all repos in GitHub
	TrustedSourceRepoPatterns pulumi.StringArrayInput `pulumi:"trustedSourceRepoPatterns"`
}

func (VerificationRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VerificationRule)(nil)).Elem()
}

func (i VerificationRuleArgs) ToVerificationRuleOutput() VerificationRuleOutput {
	return i.ToVerificationRuleOutputWithContext(context.Background())
}

func (i VerificationRuleArgs) ToVerificationRuleOutputWithContext(ctx context.Context) VerificationRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VerificationRuleOutput)
}

// VerificationRuleArrayInput is an input type that accepts VerificationRuleArray and VerificationRuleArrayOutput values.
// You can construct a concrete instance of `VerificationRuleArrayInput` via:
//
//	VerificationRuleArray{ VerificationRuleArgs{...} }
type VerificationRuleArrayInput interface {
	pulumi.Input

	ToVerificationRuleArrayOutput() VerificationRuleArrayOutput
	ToVerificationRuleArrayOutputWithContext(context.Context) VerificationRuleArrayOutput
}

type VerificationRuleArray []VerificationRuleInput

func (VerificationRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VerificationRule)(nil)).Elem()
}

func (i VerificationRuleArray) ToVerificationRuleArrayOutput() VerificationRuleArrayOutput {
	return i.ToVerificationRuleArrayOutputWithContext(context.Background())
}

func (i VerificationRuleArray) ToVerificationRuleArrayOutputWithContext(ctx context.Context) VerificationRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VerificationRuleArrayOutput)
}

// Specifies verification rules for evaluating the SLSA attestations including: which builders to trust, where to fetch the SLSA attestations generated by those builders, and other builder-specific evaluation rules such as which source repositories are trusted. An image is considered verified by the rule if any of the fetched SLSA attestations is verified.
type VerificationRuleOutput struct{ *pulumi.OutputState }

func (VerificationRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VerificationRule)(nil)).Elem()
}

func (o VerificationRuleOutput) ToVerificationRuleOutput() VerificationRuleOutput {
	return o
}

func (o VerificationRuleOutput) ToVerificationRuleOutputWithContext(ctx context.Context) VerificationRuleOutput {
	return o
}

// Specifies where to fetch the provenances attestations generated by the builder (group).
func (o VerificationRuleOutput) AttestationSource() AttestationSourcePtrOutput {
	return o.ApplyT(func(v VerificationRule) *AttestationSource { return v.AttestationSource }).(AttestationSourcePtrOutput)
}

// If true, require the image to be built from a top-level configuration. `trusted_source_repo_patterns` specifies the repositories containing this configuration.
func (o VerificationRuleOutput) ConfigBasedBuildRequired() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VerificationRule) *bool { return v.ConfigBasedBuildRequired }).(pulumi.BoolPtrOutput)
}

// Each verification rule is used for evaluation against provenances generated by a specific builder (group). For some of the builders, such as the Google Cloud Build, users don't need to explicitly specify their roots of trust in the policy since the evaluation service can automatically fetch them based on the builder (group).
func (o VerificationRuleOutput) TrustedBuilder() VerificationRuleTrustedBuilderPtrOutput {
	return o.ApplyT(func(v VerificationRule) *VerificationRuleTrustedBuilder { return v.TrustedBuilder }).(VerificationRuleTrustedBuilderPtrOutput)
}

// List of trusted source code repository URL patterns. These patterns match the full repository URL without its scheme (e.g. `https://`). The patterns must not include schemes. For example, the pattern `source.cloud.google.com/my-project/my-repo-name` matches the following URLs: - `source.cloud.google.com/my-project/my-repo-name` - `git+ssh://source.cloud.google.com/my-project/my-repo-name` - `https://source.cloud.google.com/my-project/my-repo-name` A pattern matches a URL either exactly or with `*` wildcards. `*` can be used in only two ways: 1. trailing `*` after hosturi/ to match varying endings; 2. trailing `**` after hosturi/ to match `/` as well. `*` and `**` can only be used as wildcards and can only occur at the end of the pattern after a `/`. (So it's not possible to match a URL that contains literal `*`.) For example: - `github.com/my-project/my-repo` is valid to match a single repo - `github.com/my-project/*` will match all direct repos in `my-project` - `github.com/**` matches all repos in GitHub
func (o VerificationRuleOutput) TrustedSourceRepoPatterns() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VerificationRule) []string { return v.TrustedSourceRepoPatterns }).(pulumi.StringArrayOutput)
}

type VerificationRuleArrayOutput struct{ *pulumi.OutputState }

func (VerificationRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VerificationRule)(nil)).Elem()
}

func (o VerificationRuleArrayOutput) ToVerificationRuleArrayOutput() VerificationRuleArrayOutput {
	return o
}

func (o VerificationRuleArrayOutput) ToVerificationRuleArrayOutputWithContext(ctx context.Context) VerificationRuleArrayOutput {
	return o
}

func (o VerificationRuleArrayOutput) Index(i pulumi.IntInput) VerificationRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VerificationRule {
		return vs[0].([]VerificationRule)[vs[1].(int)]
	}).(VerificationRuleOutput)
}

// Specifies verification rules for evaluating the SLSA attestations including: which builders to trust, where to fetch the SLSA attestations generated by those builders, and other builder-specific evaluation rules such as which source repositories are trusted. An image is considered verified by the rule if any of the fetched SLSA attestations is verified.
type VerificationRuleResponse struct {
	// Specifies where to fetch the provenances attestations generated by the builder (group).
	AttestationSource AttestationSourceResponse `pulumi:"attestationSource"`
	// If true, require the image to be built from a top-level configuration. `trusted_source_repo_patterns` specifies the repositories containing this configuration.
	ConfigBasedBuildRequired bool `pulumi:"configBasedBuildRequired"`
	// Each verification rule is used for evaluation against provenances generated by a specific builder (group). For some of the builders, such as the Google Cloud Build, users don't need to explicitly specify their roots of trust in the policy since the evaluation service can automatically fetch them based on the builder (group).
	TrustedBuilder string `pulumi:"trustedBuilder"`
	// List of trusted source code repository URL patterns. These patterns match the full repository URL without its scheme (e.g. `https://`). The patterns must not include schemes. For example, the pattern `source.cloud.google.com/my-project/my-repo-name` matches the following URLs: - `source.cloud.google.com/my-project/my-repo-name` - `git+ssh://source.cloud.google.com/my-project/my-repo-name` - `https://source.cloud.google.com/my-project/my-repo-name` A pattern matches a URL either exactly or with `*` wildcards. `*` can be used in only two ways: 1. trailing `*` after hosturi/ to match varying endings; 2. trailing `**` after hosturi/ to match `/` as well. `*` and `**` can only be used as wildcards and can only occur at the end of the pattern after a `/`. (So it's not possible to match a URL that contains literal `*`.) For example: - `github.com/my-project/my-repo` is valid to match a single repo - `github.com/my-project/*` will match all direct repos in `my-project` - `github.com/**` matches all repos in GitHub
	TrustedSourceRepoPatterns []string `pulumi:"trustedSourceRepoPatterns"`
}

// Specifies verification rules for evaluating the SLSA attestations including: which builders to trust, where to fetch the SLSA attestations generated by those builders, and other builder-specific evaluation rules such as which source repositories are trusted. An image is considered verified by the rule if any of the fetched SLSA attestations is verified.
type VerificationRuleResponseOutput struct{ *pulumi.OutputState }

func (VerificationRuleResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VerificationRuleResponse)(nil)).Elem()
}

func (o VerificationRuleResponseOutput) ToVerificationRuleResponseOutput() VerificationRuleResponseOutput {
	return o
}

func (o VerificationRuleResponseOutput) ToVerificationRuleResponseOutputWithContext(ctx context.Context) VerificationRuleResponseOutput {
	return o
}

// Specifies where to fetch the provenances attestations generated by the builder (group).
func (o VerificationRuleResponseOutput) AttestationSource() AttestationSourceResponseOutput {
	return o.ApplyT(func(v VerificationRuleResponse) AttestationSourceResponse { return v.AttestationSource }).(AttestationSourceResponseOutput)
}

// If true, require the image to be built from a top-level configuration. `trusted_source_repo_patterns` specifies the repositories containing this configuration.
func (o VerificationRuleResponseOutput) ConfigBasedBuildRequired() pulumi.BoolOutput {
	return o.ApplyT(func(v VerificationRuleResponse) bool { return v.ConfigBasedBuildRequired }).(pulumi.BoolOutput)
}

// Each verification rule is used for evaluation against provenances generated by a specific builder (group). For some of the builders, such as the Google Cloud Build, users don't need to explicitly specify their roots of trust in the policy since the evaluation service can automatically fetch them based on the builder (group).
func (o VerificationRuleResponseOutput) TrustedBuilder() pulumi.StringOutput {
	return o.ApplyT(func(v VerificationRuleResponse) string { return v.TrustedBuilder }).(pulumi.StringOutput)
}

// List of trusted source code repository URL patterns. These patterns match the full repository URL without its scheme (e.g. `https://`). The patterns must not include schemes. For example, the pattern `source.cloud.google.com/my-project/my-repo-name` matches the following URLs: - `source.cloud.google.com/my-project/my-repo-name` - `git+ssh://source.cloud.google.com/my-project/my-repo-name` - `https://source.cloud.google.com/my-project/my-repo-name` A pattern matches a URL either exactly or with `*` wildcards. `*` can be used in only two ways: 1. trailing `*` after hosturi/ to match varying endings; 2. trailing `**` after hosturi/ to match `/` as well. `*` and `**` can only be used as wildcards and can only occur at the end of the pattern after a `/`. (So it's not possible to match a URL that contains literal `*`.) For example: - `github.com/my-project/my-repo` is valid to match a single repo - `github.com/my-project/*` will match all direct repos in `my-project` - `github.com/**` matches all repos in GitHub
func (o VerificationRuleResponseOutput) TrustedSourceRepoPatterns() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VerificationRuleResponse) []string { return v.TrustedSourceRepoPatterns }).(pulumi.StringArrayOutput)
}

type VerificationRuleResponseArrayOutput struct{ *pulumi.OutputState }

func (VerificationRuleResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VerificationRuleResponse)(nil)).Elem()
}

func (o VerificationRuleResponseArrayOutput) ToVerificationRuleResponseArrayOutput() VerificationRuleResponseArrayOutput {
	return o
}

func (o VerificationRuleResponseArrayOutput) ToVerificationRuleResponseArrayOutputWithContext(ctx context.Context) VerificationRuleResponseArrayOutput {
	return o
}

func (o VerificationRuleResponseArrayOutput) Index(i pulumi.IntInput) VerificationRuleResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VerificationRuleResponse {
		return vs[0].([]VerificationRuleResponse)[vs[1].(int)]
	}).(VerificationRuleResponseOutput)
}

// An image vulnerability check, which rejects images that violate the configured vulnerability rules.
type VulnerabilityCheck struct {
	// Optional. A list of specific CVEs to ignore even if the vulnerability level violates `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will allow vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
	AllowedCves []string `pulumi:"allowedCves"`
	// Optional. A list of specific CVEs to always raise warnings about even if the vulnerability level meets `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will block vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
	BlockedCves []string `pulumi:"blockedCves"`
	// Optional. The projects where vulnerabilities are stored as Container Analysis Occurrences. Each project is expressed in the resource format of `projects/[PROJECT_ID]`, e.g., `projects/my-gcp-project`. An attempt will be made for each project to fetch vulnerabilities, and all valid vulnerabilities will be used to check against the vulnerability policy. If no valid scan is found in all projects configured here, an error will be returned for the check. Maximum number of `container_analysis_vulnerability_projects` allowed in each `VulnerabilityCheck` is 10.
	ContainerAnalysisVulnerabilityProjects []string `pulumi:"containerAnalysisVulnerabilityProjects"`
	// The threshold for severity for which a fix is currently available. This field is required and must be set.
	MaximumFixableSeverity VulnerabilityCheckMaximumFixableSeverity `pulumi:"maximumFixableSeverity"`
	// The threshold for severity for which a fix isn't currently available. This field is required and must be set.
	MaximumUnfixableSeverity VulnerabilityCheckMaximumUnfixableSeverity `pulumi:"maximumUnfixableSeverity"`
}

// VulnerabilityCheckInput is an input type that accepts VulnerabilityCheckArgs and VulnerabilityCheckOutput values.
// You can construct a concrete instance of `VulnerabilityCheckInput` via:
//
//	VulnerabilityCheckArgs{...}
type VulnerabilityCheckInput interface {
	pulumi.Input

	ToVulnerabilityCheckOutput() VulnerabilityCheckOutput
	ToVulnerabilityCheckOutputWithContext(context.Context) VulnerabilityCheckOutput
}

// An image vulnerability check, which rejects images that violate the configured vulnerability rules.
type VulnerabilityCheckArgs struct {
	// Optional. A list of specific CVEs to ignore even if the vulnerability level violates `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will allow vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
	AllowedCves pulumi.StringArrayInput `pulumi:"allowedCves"`
	// Optional. A list of specific CVEs to always raise warnings about even if the vulnerability level meets `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will block vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
	BlockedCves pulumi.StringArrayInput `pulumi:"blockedCves"`
	// Optional. The projects where vulnerabilities are stored as Container Analysis Occurrences. Each project is expressed in the resource format of `projects/[PROJECT_ID]`, e.g., `projects/my-gcp-project`. An attempt will be made for each project to fetch vulnerabilities, and all valid vulnerabilities will be used to check against the vulnerability policy. If no valid scan is found in all projects configured here, an error will be returned for the check. Maximum number of `container_analysis_vulnerability_projects` allowed in each `VulnerabilityCheck` is 10.
	ContainerAnalysisVulnerabilityProjects pulumi.StringArrayInput `pulumi:"containerAnalysisVulnerabilityProjects"`
	// The threshold for severity for which a fix is currently available. This field is required and must be set.
	MaximumFixableSeverity VulnerabilityCheckMaximumFixableSeverityInput `pulumi:"maximumFixableSeverity"`
	// The threshold for severity for which a fix isn't currently available. This field is required and must be set.
	MaximumUnfixableSeverity VulnerabilityCheckMaximumUnfixableSeverityInput `pulumi:"maximumUnfixableSeverity"`
}

func (VulnerabilityCheckArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VulnerabilityCheck)(nil)).Elem()
}

func (i VulnerabilityCheckArgs) ToVulnerabilityCheckOutput() VulnerabilityCheckOutput {
	return i.ToVulnerabilityCheckOutputWithContext(context.Background())
}

func (i VulnerabilityCheckArgs) ToVulnerabilityCheckOutputWithContext(ctx context.Context) VulnerabilityCheckOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VulnerabilityCheckOutput)
}

func (i VulnerabilityCheckArgs) ToVulnerabilityCheckPtrOutput() VulnerabilityCheckPtrOutput {
	return i.ToVulnerabilityCheckPtrOutputWithContext(context.Background())
}

func (i VulnerabilityCheckArgs) ToVulnerabilityCheckPtrOutputWithContext(ctx context.Context) VulnerabilityCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VulnerabilityCheckOutput).ToVulnerabilityCheckPtrOutputWithContext(ctx)
}

// VulnerabilityCheckPtrInput is an input type that accepts VulnerabilityCheckArgs, VulnerabilityCheckPtr and VulnerabilityCheckPtrOutput values.
// You can construct a concrete instance of `VulnerabilityCheckPtrInput` via:
//
//	        VulnerabilityCheckArgs{...}
//
//	or:
//
//	        nil
type VulnerabilityCheckPtrInput interface {
	pulumi.Input

	ToVulnerabilityCheckPtrOutput() VulnerabilityCheckPtrOutput
	ToVulnerabilityCheckPtrOutputWithContext(context.Context) VulnerabilityCheckPtrOutput
}

type vulnerabilityCheckPtrType VulnerabilityCheckArgs

func VulnerabilityCheckPtr(v *VulnerabilityCheckArgs) VulnerabilityCheckPtrInput {
	return (*vulnerabilityCheckPtrType)(v)
}

func (*vulnerabilityCheckPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**VulnerabilityCheck)(nil)).Elem()
}

func (i *vulnerabilityCheckPtrType) ToVulnerabilityCheckPtrOutput() VulnerabilityCheckPtrOutput {
	return i.ToVulnerabilityCheckPtrOutputWithContext(context.Background())
}

func (i *vulnerabilityCheckPtrType) ToVulnerabilityCheckPtrOutputWithContext(ctx context.Context) VulnerabilityCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VulnerabilityCheckPtrOutput)
}

// An image vulnerability check, which rejects images that violate the configured vulnerability rules.
type VulnerabilityCheckOutput struct{ *pulumi.OutputState }

func (VulnerabilityCheckOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VulnerabilityCheck)(nil)).Elem()
}

func (o VulnerabilityCheckOutput) ToVulnerabilityCheckOutput() VulnerabilityCheckOutput {
	return o
}

func (o VulnerabilityCheckOutput) ToVulnerabilityCheckOutputWithContext(ctx context.Context) VulnerabilityCheckOutput {
	return o
}

func (o VulnerabilityCheckOutput) ToVulnerabilityCheckPtrOutput() VulnerabilityCheckPtrOutput {
	return o.ToVulnerabilityCheckPtrOutputWithContext(context.Background())
}

func (o VulnerabilityCheckOutput) ToVulnerabilityCheckPtrOutputWithContext(ctx context.Context) VulnerabilityCheckPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v VulnerabilityCheck) *VulnerabilityCheck {
		return &v
	}).(VulnerabilityCheckPtrOutput)
}

// Optional. A list of specific CVEs to ignore even if the vulnerability level violates `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will allow vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
func (o VulnerabilityCheckOutput) AllowedCves() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VulnerabilityCheck) []string { return v.AllowedCves }).(pulumi.StringArrayOutput)
}

// Optional. A list of specific CVEs to always raise warnings about even if the vulnerability level meets `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will block vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
func (o VulnerabilityCheckOutput) BlockedCves() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VulnerabilityCheck) []string { return v.BlockedCves }).(pulumi.StringArrayOutput)
}

// Optional. The projects where vulnerabilities are stored as Container Analysis Occurrences. Each project is expressed in the resource format of `projects/[PROJECT_ID]`, e.g., `projects/my-gcp-project`. An attempt will be made for each project to fetch vulnerabilities, and all valid vulnerabilities will be used to check against the vulnerability policy. If no valid scan is found in all projects configured here, an error will be returned for the check. Maximum number of `container_analysis_vulnerability_projects` allowed in each `VulnerabilityCheck` is 10.
func (o VulnerabilityCheckOutput) ContainerAnalysisVulnerabilityProjects() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VulnerabilityCheck) []string { return v.ContainerAnalysisVulnerabilityProjects }).(pulumi.StringArrayOutput)
}

// The threshold for severity for which a fix is currently available. This field is required and must be set.
func (o VulnerabilityCheckOutput) MaximumFixableSeverity() VulnerabilityCheckMaximumFixableSeverityOutput {
	return o.ApplyT(func(v VulnerabilityCheck) VulnerabilityCheckMaximumFixableSeverity { return v.MaximumFixableSeverity }).(VulnerabilityCheckMaximumFixableSeverityOutput)
}

// The threshold for severity for which a fix isn't currently available. This field is required and must be set.
func (o VulnerabilityCheckOutput) MaximumUnfixableSeverity() VulnerabilityCheckMaximumUnfixableSeverityOutput {
	return o.ApplyT(func(v VulnerabilityCheck) VulnerabilityCheckMaximumUnfixableSeverity {
		return v.MaximumUnfixableSeverity
	}).(VulnerabilityCheckMaximumUnfixableSeverityOutput)
}

type VulnerabilityCheckPtrOutput struct{ *pulumi.OutputState }

func (VulnerabilityCheckPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VulnerabilityCheck)(nil)).Elem()
}

func (o VulnerabilityCheckPtrOutput) ToVulnerabilityCheckPtrOutput() VulnerabilityCheckPtrOutput {
	return o
}

func (o VulnerabilityCheckPtrOutput) ToVulnerabilityCheckPtrOutputWithContext(ctx context.Context) VulnerabilityCheckPtrOutput {
	return o
}

func (o VulnerabilityCheckPtrOutput) Elem() VulnerabilityCheckOutput {
	return o.ApplyT(func(v *VulnerabilityCheck) VulnerabilityCheck {
		if v != nil {
			return *v
		}
		var ret VulnerabilityCheck
		return ret
	}).(VulnerabilityCheckOutput)
}

// Optional. A list of specific CVEs to ignore even if the vulnerability level violates `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will allow vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
func (o VulnerabilityCheckPtrOutput) AllowedCves() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *VulnerabilityCheck) []string {
		if v == nil {
			return nil
		}
		return v.AllowedCves
	}).(pulumi.StringArrayOutput)
}

// Optional. A list of specific CVEs to always raise warnings about even if the vulnerability level meets `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will block vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
func (o VulnerabilityCheckPtrOutput) BlockedCves() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *VulnerabilityCheck) []string {
		if v == nil {
			return nil
		}
		return v.BlockedCves
	}).(pulumi.StringArrayOutput)
}

// Optional. The projects where vulnerabilities are stored as Container Analysis Occurrences. Each project is expressed in the resource format of `projects/[PROJECT_ID]`, e.g., `projects/my-gcp-project`. An attempt will be made for each project to fetch vulnerabilities, and all valid vulnerabilities will be used to check against the vulnerability policy. If no valid scan is found in all projects configured here, an error will be returned for the check. Maximum number of `container_analysis_vulnerability_projects` allowed in each `VulnerabilityCheck` is 10.
func (o VulnerabilityCheckPtrOutput) ContainerAnalysisVulnerabilityProjects() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *VulnerabilityCheck) []string {
		if v == nil {
			return nil
		}
		return v.ContainerAnalysisVulnerabilityProjects
	}).(pulumi.StringArrayOutput)
}

// The threshold for severity for which a fix is currently available. This field is required and must be set.
func (o VulnerabilityCheckPtrOutput) MaximumFixableSeverity() VulnerabilityCheckMaximumFixableSeverityPtrOutput {
	return o.ApplyT(func(v *VulnerabilityCheck) *VulnerabilityCheckMaximumFixableSeverity {
		if v == nil {
			return nil
		}
		return &v.MaximumFixableSeverity
	}).(VulnerabilityCheckMaximumFixableSeverityPtrOutput)
}

// The threshold for severity for which a fix isn't currently available. This field is required and must be set.
func (o VulnerabilityCheckPtrOutput) MaximumUnfixableSeverity() VulnerabilityCheckMaximumUnfixableSeverityPtrOutput {
	return o.ApplyT(func(v *VulnerabilityCheck) *VulnerabilityCheckMaximumUnfixableSeverity {
		if v == nil {
			return nil
		}
		return &v.MaximumUnfixableSeverity
	}).(VulnerabilityCheckMaximumUnfixableSeverityPtrOutput)
}

// An image vulnerability check, which rejects images that violate the configured vulnerability rules.
type VulnerabilityCheckResponse struct {
	// Optional. A list of specific CVEs to ignore even if the vulnerability level violates `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will allow vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
	AllowedCves []string `pulumi:"allowedCves"`
	// Optional. A list of specific CVEs to always raise warnings about even if the vulnerability level meets `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will block vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
	BlockedCves []string `pulumi:"blockedCves"`
	// Optional. The projects where vulnerabilities are stored as Container Analysis Occurrences. Each project is expressed in the resource format of `projects/[PROJECT_ID]`, e.g., `projects/my-gcp-project`. An attempt will be made for each project to fetch vulnerabilities, and all valid vulnerabilities will be used to check against the vulnerability policy. If no valid scan is found in all projects configured here, an error will be returned for the check. Maximum number of `container_analysis_vulnerability_projects` allowed in each `VulnerabilityCheck` is 10.
	ContainerAnalysisVulnerabilityProjects []string `pulumi:"containerAnalysisVulnerabilityProjects"`
	// The threshold for severity for which a fix is currently available. This field is required and must be set.
	MaximumFixableSeverity string `pulumi:"maximumFixableSeverity"`
	// The threshold for severity for which a fix isn't currently available. This field is required and must be set.
	MaximumUnfixableSeverity string `pulumi:"maximumUnfixableSeverity"`
}

// An image vulnerability check, which rejects images that violate the configured vulnerability rules.
type VulnerabilityCheckResponseOutput struct{ *pulumi.OutputState }

func (VulnerabilityCheckResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VulnerabilityCheckResponse)(nil)).Elem()
}

func (o VulnerabilityCheckResponseOutput) ToVulnerabilityCheckResponseOutput() VulnerabilityCheckResponseOutput {
	return o
}

func (o VulnerabilityCheckResponseOutput) ToVulnerabilityCheckResponseOutputWithContext(ctx context.Context) VulnerabilityCheckResponseOutput {
	return o
}

// Optional. A list of specific CVEs to ignore even if the vulnerability level violates `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will allow vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
func (o VulnerabilityCheckResponseOutput) AllowedCves() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VulnerabilityCheckResponse) []string { return v.AllowedCves }).(pulumi.StringArrayOutput)
}

// Optional. A list of specific CVEs to always raise warnings about even if the vulnerability level meets `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will block vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
func (o VulnerabilityCheckResponseOutput) BlockedCves() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VulnerabilityCheckResponse) []string { return v.BlockedCves }).(pulumi.StringArrayOutput)
}

// Optional. The projects where vulnerabilities are stored as Container Analysis Occurrences. Each project is expressed in the resource format of `projects/[PROJECT_ID]`, e.g., `projects/my-gcp-project`. An attempt will be made for each project to fetch vulnerabilities, and all valid vulnerabilities will be used to check against the vulnerability policy. If no valid scan is found in all projects configured here, an error will be returned for the check. Maximum number of `container_analysis_vulnerability_projects` allowed in each `VulnerabilityCheck` is 10.
func (o VulnerabilityCheckResponseOutput) ContainerAnalysisVulnerabilityProjects() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VulnerabilityCheckResponse) []string { return v.ContainerAnalysisVulnerabilityProjects }).(pulumi.StringArrayOutput)
}

// The threshold for severity for which a fix is currently available. This field is required and must be set.
func (o VulnerabilityCheckResponseOutput) MaximumFixableSeverity() pulumi.StringOutput {
	return o.ApplyT(func(v VulnerabilityCheckResponse) string { return v.MaximumFixableSeverity }).(pulumi.StringOutput)
}

// The threshold for severity for which a fix isn't currently available. This field is required and must be set.
func (o VulnerabilityCheckResponseOutput) MaximumUnfixableSeverity() pulumi.StringOutput {
	return o.ApplyT(func(v VulnerabilityCheckResponse) string { return v.MaximumUnfixableSeverity }).(pulumi.StringOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AttestationAuthenticatorInput)(nil)).Elem(), AttestationAuthenticatorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AttestationAuthenticatorArrayInput)(nil)).Elem(), AttestationAuthenticatorArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AttestationSourceInput)(nil)).Elem(), AttestationSourceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AttestationSourcePtrInput)(nil)).Elem(), AttestationSourceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AttestorPublicKeyInput)(nil)).Elem(), AttestorPublicKeyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AttestorPublicKeyArrayInput)(nil)).Elem(), AttestorPublicKeyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*BindingInput)(nil)).Elem(), BindingArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BindingArrayInput)(nil)).Elem(), BindingArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CheckInput)(nil)).Elem(), CheckArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CheckArrayInput)(nil)).Elem(), CheckArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CheckSetInput)(nil)).Elem(), CheckSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CheckSetArrayInput)(nil)).Elem(), CheckSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ExprInput)(nil)).Elem(), ExprArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ExprPtrInput)(nil)).Elem(), ExprArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GkePolicyInput)(nil)).Elem(), GkePolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GkePolicyPtrInput)(nil)).Elem(), GkePolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ImageAllowlistInput)(nil)).Elem(), ImageAllowlistArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ImageAllowlistPtrInput)(nil)).Elem(), ImageAllowlistArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ImageFreshnessCheckInput)(nil)).Elem(), ImageFreshnessCheckArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ImageFreshnessCheckPtrInput)(nil)).Elem(), ImageFreshnessCheckArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PkixPublicKeyInput)(nil)).Elem(), PkixPublicKeyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PkixPublicKeyPtrInput)(nil)).Elem(), PkixPublicKeyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PkixPublicKeyArrayInput)(nil)).Elem(), PkixPublicKeyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PkixPublicKeySetInput)(nil)).Elem(), PkixPublicKeySetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PkixPublicKeySetPtrInput)(nil)).Elem(), PkixPublicKeySetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ScopeInput)(nil)).Elem(), ScopeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ScopePtrInput)(nil)).Elem(), ScopeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SigstoreAuthorityInput)(nil)).Elem(), SigstoreAuthorityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SigstoreAuthorityArrayInput)(nil)).Elem(), SigstoreAuthorityArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SigstorePublicKeyInput)(nil)).Elem(), SigstorePublicKeyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SigstorePublicKeyArrayInput)(nil)).Elem(), SigstorePublicKeyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SigstorePublicKeySetInput)(nil)).Elem(), SigstorePublicKeySetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SigstoreSignatureCheckInput)(nil)).Elem(), SigstoreSignatureCheckArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SigstoreSignatureCheckPtrInput)(nil)).Elem(), SigstoreSignatureCheckArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SimpleSigningAttestationCheckInput)(nil)).Elem(), SimpleSigningAttestationCheckArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SimpleSigningAttestationCheckPtrInput)(nil)).Elem(), SimpleSigningAttestationCheckArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SlsaCheckInput)(nil)).Elem(), SlsaCheckArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SlsaCheckPtrInput)(nil)).Elem(), SlsaCheckArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TrustedDirectoryCheckInput)(nil)).Elem(), TrustedDirectoryCheckArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TrustedDirectoryCheckPtrInput)(nil)).Elem(), TrustedDirectoryCheckArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UserOwnedGrafeasNoteInput)(nil)).Elem(), UserOwnedGrafeasNoteArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UserOwnedGrafeasNotePtrInput)(nil)).Elem(), UserOwnedGrafeasNoteArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VerificationRuleInput)(nil)).Elem(), VerificationRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VerificationRuleArrayInput)(nil)).Elem(), VerificationRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VulnerabilityCheckInput)(nil)).Elem(), VulnerabilityCheckArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VulnerabilityCheckPtrInput)(nil)).Elem(), VulnerabilityCheckArgs{})
	pulumi.RegisterOutputType(AttestationAuthenticatorOutput{})
	pulumi.RegisterOutputType(AttestationAuthenticatorArrayOutput{})
	pulumi.RegisterOutputType(AttestationAuthenticatorResponseOutput{})
	pulumi.RegisterOutputType(AttestationAuthenticatorResponseArrayOutput{})
	pulumi.RegisterOutputType(AttestationSourceOutput{})
	pulumi.RegisterOutputType(AttestationSourcePtrOutput{})
	pulumi.RegisterOutputType(AttestationSourceResponseOutput{})
	pulumi.RegisterOutputType(AttestorPublicKeyOutput{})
	pulumi.RegisterOutputType(AttestorPublicKeyArrayOutput{})
	pulumi.RegisterOutputType(AttestorPublicKeyResponseOutput{})
	pulumi.RegisterOutputType(AttestorPublicKeyResponseArrayOutput{})
	pulumi.RegisterOutputType(BindingOutput{})
	pulumi.RegisterOutputType(BindingArrayOutput{})
	pulumi.RegisterOutputType(BindingResponseOutput{})
	pulumi.RegisterOutputType(BindingResponseArrayOutput{})
	pulumi.RegisterOutputType(CheckOutput{})
	pulumi.RegisterOutputType(CheckArrayOutput{})
	pulumi.RegisterOutputType(CheckResponseOutput{})
	pulumi.RegisterOutputType(CheckResponseArrayOutput{})
	pulumi.RegisterOutputType(CheckSetOutput{})
	pulumi.RegisterOutputType(CheckSetArrayOutput{})
	pulumi.RegisterOutputType(CheckSetResponseOutput{})
	pulumi.RegisterOutputType(CheckSetResponseArrayOutput{})
	pulumi.RegisterOutputType(ExprOutput{})
	pulumi.RegisterOutputType(ExprPtrOutput{})
	pulumi.RegisterOutputType(ExprResponseOutput{})
	pulumi.RegisterOutputType(GkePolicyOutput{})
	pulumi.RegisterOutputType(GkePolicyPtrOutput{})
	pulumi.RegisterOutputType(GkePolicyResponseOutput{})
	pulumi.RegisterOutputType(ImageAllowlistOutput{})
	pulumi.RegisterOutputType(ImageAllowlistPtrOutput{})
	pulumi.RegisterOutputType(ImageAllowlistResponseOutput{})
	pulumi.RegisterOutputType(ImageFreshnessCheckOutput{})
	pulumi.RegisterOutputType(ImageFreshnessCheckPtrOutput{})
	pulumi.RegisterOutputType(ImageFreshnessCheckResponseOutput{})
	pulumi.RegisterOutputType(PkixPublicKeyOutput{})
	pulumi.RegisterOutputType(PkixPublicKeyPtrOutput{})
	pulumi.RegisterOutputType(PkixPublicKeyArrayOutput{})
	pulumi.RegisterOutputType(PkixPublicKeyResponseOutput{})
	pulumi.RegisterOutputType(PkixPublicKeyResponseArrayOutput{})
	pulumi.RegisterOutputType(PkixPublicKeySetOutput{})
	pulumi.RegisterOutputType(PkixPublicKeySetPtrOutput{})
	pulumi.RegisterOutputType(PkixPublicKeySetResponseOutput{})
	pulumi.RegisterOutputType(ScopeOutput{})
	pulumi.RegisterOutputType(ScopePtrOutput{})
	pulumi.RegisterOutputType(ScopeResponseOutput{})
	pulumi.RegisterOutputType(SigstoreAuthorityOutput{})
	pulumi.RegisterOutputType(SigstoreAuthorityArrayOutput{})
	pulumi.RegisterOutputType(SigstoreAuthorityResponseOutput{})
	pulumi.RegisterOutputType(SigstoreAuthorityResponseArrayOutput{})
	pulumi.RegisterOutputType(SigstorePublicKeyOutput{})
	pulumi.RegisterOutputType(SigstorePublicKeyArrayOutput{})
	pulumi.RegisterOutputType(SigstorePublicKeyResponseOutput{})
	pulumi.RegisterOutputType(SigstorePublicKeyResponseArrayOutput{})
	pulumi.RegisterOutputType(SigstorePublicKeySetOutput{})
	pulumi.RegisterOutputType(SigstorePublicKeySetResponseOutput{})
	pulumi.RegisterOutputType(SigstoreSignatureCheckOutput{})
	pulumi.RegisterOutputType(SigstoreSignatureCheckPtrOutput{})
	pulumi.RegisterOutputType(SigstoreSignatureCheckResponseOutput{})
	pulumi.RegisterOutputType(SimpleSigningAttestationCheckOutput{})
	pulumi.RegisterOutputType(SimpleSigningAttestationCheckPtrOutput{})
	pulumi.RegisterOutputType(SimpleSigningAttestationCheckResponseOutput{})
	pulumi.RegisterOutputType(SlsaCheckOutput{})
	pulumi.RegisterOutputType(SlsaCheckPtrOutput{})
	pulumi.RegisterOutputType(SlsaCheckResponseOutput{})
	pulumi.RegisterOutputType(TrustedDirectoryCheckOutput{})
	pulumi.RegisterOutputType(TrustedDirectoryCheckPtrOutput{})
	pulumi.RegisterOutputType(TrustedDirectoryCheckResponseOutput{})
	pulumi.RegisterOutputType(UserOwnedGrafeasNoteOutput{})
	pulumi.RegisterOutputType(UserOwnedGrafeasNotePtrOutput{})
	pulumi.RegisterOutputType(UserOwnedGrafeasNoteResponseOutput{})
	pulumi.RegisterOutputType(VerificationRuleOutput{})
	pulumi.RegisterOutputType(VerificationRuleArrayOutput{})
	pulumi.RegisterOutputType(VerificationRuleResponseOutput{})
	pulumi.RegisterOutputType(VerificationRuleResponseArrayOutput{})
	pulumi.RegisterOutputType(VulnerabilityCheckOutput{})
	pulumi.RegisterOutputType(VulnerabilityCheckPtrOutput{})
	pulumi.RegisterOutputType(VulnerabilityCheckResponseOutput{})
}
