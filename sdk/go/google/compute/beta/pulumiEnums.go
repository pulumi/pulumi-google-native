// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package beta

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This signifies the networking tier used for configuring this access configuration and can only take the following values: PREMIUM, STANDARD. If an AccessConfig is specified without a valid external IP address, an ephemeral IP will be created with this networkTier. If an AccessConfig with a valid external IP address is specified, it must match that of the networkTier associated with the Address resource owning that IP.
type AccessConfigNetworkTier pulumi.String

const (
	// High quality, Google-grade network tier, support for all networking products.
	AccessConfigNetworkTierPremium = AccessConfigNetworkTier("PREMIUM")
	// Public internet quality, only limited support for other networking products.
	AccessConfigNetworkTierStandard = AccessConfigNetworkTier("STANDARD")
)

func (AccessConfigNetworkTier) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e AccessConfigNetworkTier) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e AccessConfigNetworkTier) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e AccessConfigNetworkTier) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e AccessConfigNetworkTier) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The type of configuration. The default and only option is ONE_TO_ONE_NAT.
type AccessConfigType pulumi.String

const (
	AccessConfigTypeDirectIpv6  = AccessConfigType("DIRECT_IPV6")
	AccessConfigTypeOneToOneNat = AccessConfigType("ONE_TO_ONE_NAT")
)

func (AccessConfigType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e AccessConfigType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e AccessConfigType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e AccessConfigType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e AccessConfigType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The type of address to reserve, either INTERNAL or EXTERNAL. If unspecified, defaults to EXTERNAL.
type AddressAddressType pulumi.String

const (
	// A publicly visible external IP address.
	AddressAddressTypeExternal = AddressAddressType("EXTERNAL")
	// A private network IP address, for use with an Instance or Internal Load Balancer forwarding rule.
	AddressAddressTypeInternal        = AddressAddressType("INTERNAL")
	AddressAddressTypeUnspecifiedType = AddressAddressType("UNSPECIFIED_TYPE")
)

func (AddressAddressType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e AddressAddressType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e AddressAddressType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e AddressAddressType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e AddressAddressType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The IP version that will be used by this address. Valid options are IPV4 or IPV6. This can only be specified for a global address.
type AddressIpVersion pulumi.String

const (
	AddressIpVersionIpv4               = AddressIpVersion("IPV4")
	AddressIpVersionIpv6               = AddressIpVersion("IPV6")
	AddressIpVersionUnspecifiedVersion = AddressIpVersion("UNSPECIFIED_VERSION")
)

func (AddressIpVersion) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e AddressIpVersion) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e AddressIpVersion) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e AddressIpVersion) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e AddressIpVersion) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// This signifies the networking tier used for configuring this address and can only take the following values: PREMIUM or STANDARD. Global forwarding rules can only be Premium Tier. Regional forwarding rules can be either Premium or Standard Tier. Standard Tier addresses applied to regional forwarding rules can be used with any external load balancer. Regional forwarding rules in Premium Tier can only be used with a network load balancer. If this field is not specified, it is assumed to be PREMIUM.
type AddressNetworkTier pulumi.String

const (
	// High quality, Google-grade network tier, support for all networking products.
	AddressNetworkTierPremium = AddressNetworkTier("PREMIUM")
	// Public internet quality, only limited support for other networking products.
	AddressNetworkTierStandard = AddressNetworkTier("STANDARD")
)

func (AddressNetworkTier) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e AddressNetworkTier) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e AddressNetworkTier) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e AddressNetworkTier) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e AddressNetworkTier) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The purpose of this resource, which can be one of the following values: - `GCE_ENDPOINT` for addresses that are used by VM instances, alias IP ranges, internal load balancers, and similar resources. - `DNS_RESOLVER` for a DNS resolver address in a subnetwork - `VPC_PEERING` for addresses that are reserved for VPC peer networks. - `NAT_AUTO` for addresses that are external IP addresses automatically reserved for Cloud NAT. - `IPSEC_INTERCONNECT` for addresses created from a private IP range that are reserved for a VLAN attachment in an *IPsec-encrypted Cloud Interconnect* configuration. These addresses are regional resources. Not currently available publicly.
type AddressPurpose pulumi.String

const (
	// DNS resolver address in the subnetwork.
	AddressPurposeDnsResolver = AddressPurpose("DNS_RESOLVER")
	// VM internal/alias IP, Internal LB service IP, etc.
	AddressPurposeGceEndpoint = AddressPurpose("GCE_ENDPOINT")
	// A regional internal IP address range reserved for the VLAN attachment that is used in IPsec-encrypted Cloud Interconnect. This regional internal IP address range must not overlap with any IP address range of subnet/route in the VPC network and its peering networks. After the VLAN attachment is created with the reserved IP address range, when creating a new VPN gateway, its interface IP address is allocated from the associated VLAN attachment’s IP address range.
	AddressPurposeIpsecInterconnect = AddressPurpose("IPSEC_INTERCONNECT")
	// External IP automatically reserved for Cloud NAT.
	AddressPurposeNatAuto = AddressPurpose("NAT_AUTO")
	// A private network IP address that can be used to configure Private Service Connect. This purpose can be specified only for GLOBAL addresses of Type INTERNAL
	AddressPurposePrivateServiceConnect = AddressPurpose("PRIVATE_SERVICE_CONNECT")
	// A private network IP address that can be shared by multiple Internal Load Balancer forwarding rules.
	AddressPurposeSharedLoadbalancerVip = AddressPurpose("SHARED_LOADBALANCER_VIP")
	// IP range for peer networks.
	AddressPurposeVpcPeering = AddressPurpose("VPC_PEERING")
)

func (AddressPurpose) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e AddressPurpose) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e AddressPurpose) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e AddressPurpose) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e AddressPurpose) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] The status of the address, which can be one of RESERVING, RESERVED, or IN_USE. An address that is RESERVING is currently in the process of being reserved. A RESERVED address is currently reserved and available to use. An IN_USE address is currently being used by another resource and is not available.
type AddressStatus pulumi.String

const (
	// Address is being used by another resource and is not available.
	AddressStatusInUse = AddressStatus("IN_USE")
	// Address is reserved and available to use.
	AddressStatusReserved = AddressStatus("RESERVED")
	// Address is being reserved.
	AddressStatusReserving = AddressStatus("RESERVING")
)

func (AddressStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e AddressStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e AddressStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e AddressStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e AddressStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME. The default is SCSI. For performance characteristics of SCSI over NVMe, see Local SSD performance.
type AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface pulumi.String

const (
	AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterfaceNvme = AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface("NVME")
	AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterfaceScsi = AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface("SCSI")
)

func (AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// For more information about maintenance intervals, see Setting maintenance intervals.
type AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval pulumi.String

const (
	// VMs receive infrastructure and hypervisor updates on a periodic basis, minimizing the number of maintenance operations (live migrations or terminations) on an individual VM. This may mean a VM will take longer to receive an update than if it was configured for AS_NEEDED. Security updates will still be applied as soon as they are available.
	AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceIntervalPeriodic = AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval("PERIODIC")
)

func (AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e AllocationSpecificSKUAllocationReservedInstancePropertiesMaintenanceInterval) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies which action to take on instance update with this disk. Default is to use the existing disk.
type AttachedDiskInitializeParamsOnUpdateAction pulumi.String

const (
	// Always recreate the disk.
	AttachedDiskInitializeParamsOnUpdateActionRecreateDisk = AttachedDiskInitializeParamsOnUpdateAction("RECREATE_DISK")
	// Recreate the disk if source (image, snapshot) of this disk is different from source of existing disk.
	AttachedDiskInitializeParamsOnUpdateActionRecreateDiskIfSourceChanged = AttachedDiskInitializeParamsOnUpdateAction("RECREATE_DISK_IF_SOURCE_CHANGED")
	// Use the existing disk, this is the default behaviour.
	AttachedDiskInitializeParamsOnUpdateActionUseExistingDisk = AttachedDiskInitializeParamsOnUpdateAction("USE_EXISTING_DISK")
)

func (AttachedDiskInitializeParamsOnUpdateAction) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e AttachedDiskInitializeParamsOnUpdateAction) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e AttachedDiskInitializeParamsOnUpdateAction) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e AttachedDiskInitializeParamsOnUpdateAction) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e AttachedDiskInitializeParamsOnUpdateAction) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME. The default is SCSI. Persistent disks must always use SCSI and the request will fail if you attempt to attach a persistent disk in any other format than SCSI. Local SSDs can use either NVME or SCSI. For performance characteristics of SCSI over NVMe, see Local SSD performance.
type AttachedDiskInterface pulumi.String

const (
	AttachedDiskInterfaceNvme = AttachedDiskInterface("NVME")
	AttachedDiskInterfaceScsi = AttachedDiskInterface("SCSI")
)

func (AttachedDiskInterface) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e AttachedDiskInterface) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e AttachedDiskInterface) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e AttachedDiskInterface) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e AttachedDiskInterface) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If not specified, the default is to attach the disk in READ_WRITE mode.
type AttachedDiskMode pulumi.String

const (
	// Attaches this disk in read-only mode. Multiple virtual machines can use a disk in read-only mode at a time.
	AttachedDiskModeReadOnly = AttachedDiskMode("READ_ONLY")
	// *[Default]* Attaches this disk in read-write mode. Only one virtual machine at a time can be attached to a disk in read-write mode.
	AttachedDiskModeReadWrite = AttachedDiskMode("READ_WRITE")
)

func (AttachedDiskMode) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e AttachedDiskMode) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e AttachedDiskMode) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e AttachedDiskMode) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e AttachedDiskMode) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies the type of the disk, either SCRATCH or PERSISTENT. If not specified, the default is PERSISTENT.
type AttachedDiskType pulumi.String

const (
	AttachedDiskTypePersistent = AttachedDiskType("PERSISTENT")
	AttachedDiskTypeScratch    = AttachedDiskType("SCRATCH")
)

func (AttachedDiskType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e AttachedDiskType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e AttachedDiskType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e AttachedDiskType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e AttachedDiskType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The log type that this config enables.
type AuditLogConfigLogType pulumi.String

const (
	// Admin reads. Example: CloudIAM getIamPolicy
	AuditLogConfigLogTypeAdminRead = AuditLogConfigLogType("ADMIN_READ")
	// Data reads. Example: CloudSQL Users list
	AuditLogConfigLogTypeDataRead = AuditLogConfigLogType("DATA_READ")
	// Data writes. Example: CloudSQL Users create
	AuditLogConfigLogTypeDataWrite = AuditLogConfigLogType("DATA_WRITE")
	// Default case. Should never be this.
	AuditLogConfigLogTypeLogTypeUnspecified = AuditLogConfigLogType("LOG_TYPE_UNSPECIFIED")
)

func (AuditLogConfigLogType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e AuditLogConfigLogType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e AuditLogConfigLogType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e AuditLogConfigLogType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e AuditLogConfigLogType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// This is deprecated and has no effect. Do not use.
type AuthorizationLoggingOptionsPermissionType pulumi.String

const (
	// This is deprecated and has no effect. Do not use.
	AuthorizationLoggingOptionsPermissionTypeAdminRead = AuthorizationLoggingOptionsPermissionType("ADMIN_READ")
	// This is deprecated and has no effect. Do not use.
	AuthorizationLoggingOptionsPermissionTypeAdminWrite = AuthorizationLoggingOptionsPermissionType("ADMIN_WRITE")
	// This is deprecated and has no effect. Do not use.
	AuthorizationLoggingOptionsPermissionTypeDataRead = AuthorizationLoggingOptionsPermissionType("DATA_READ")
	// This is deprecated and has no effect. Do not use.
	AuthorizationLoggingOptionsPermissionTypeDataWrite = AuthorizationLoggingOptionsPermissionType("DATA_WRITE")
	// This is deprecated and has no effect. Do not use.
	AuthorizationLoggingOptionsPermissionTypePermissionTypeUnspecified = AuthorizationLoggingOptionsPermissionType("PERMISSION_TYPE_UNSPECIFIED")
)

func (AuthorizationLoggingOptionsPermissionType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e AuthorizationLoggingOptionsPermissionType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e AuthorizationLoggingOptionsPermissionType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e AuthorizationLoggingOptionsPermissionType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e AuthorizationLoggingOptionsPermissionType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] The status of the autoscaler configuration. Current set of possible values: - PENDING: Autoscaler backend hasn't read new/updated configuration. - DELETING: Configuration is being deleted. - ACTIVE: Configuration is acknowledged to be effective. Some warnings might be present in the statusDetails field. - ERROR: Configuration has errors. Actionable for users. Details are present in the statusDetails field. New values might be added in the future.
type AutoscalerStatus pulumi.String

const (
	// Configuration is acknowledged to be effective
	AutoscalerStatusActive = AutoscalerStatus("ACTIVE")
	// Configuration is being deleted
	AutoscalerStatusDeleting = AutoscalerStatus("DELETING")
	// Configuration has errors. Actionable for users.
	AutoscalerStatusError = AutoscalerStatus("ERROR")
	// Autoscaler backend hasn't read new/updated configuration
	AutoscalerStatusPending = AutoscalerStatus("PENDING")
)

func (AutoscalerStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e AutoscalerStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e AutoscalerStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e AutoscalerStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e AutoscalerStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The type of error, warning, or notice returned. Current set of possible values: - ALL_INSTANCES_UNHEALTHY (WARNING): All instances in the instance group are unhealthy (not in RUNNING state). - BACKEND_SERVICE_DOES_NOT_EXIST (ERROR): There is no backend service attached to the instance group. - CAPPED_AT_MAX_NUM_REPLICAS (WARNING): Autoscaler recommends a size greater than maxNumReplicas. - CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE (WARNING): The custom metric samples are not exported often enough to be a credible base for autoscaling. - CUSTOM_METRIC_INVALID (ERROR): The custom metric that was specified does not exist or does not have the necessary labels. - MIN_EQUALS_MAX (WARNING): The minNumReplicas is equal to maxNumReplicas. This means the autoscaler cannot add or remove instances from the instance group. - MISSING_CUSTOM_METRIC_DATA_POINTS (WARNING): The autoscaler did not receive any data from the custom metric configured for autoscaling. - MISSING_LOAD_BALANCING_DATA_POINTS (WARNING): The autoscaler is configured to scale based on a load balancing signal but the instance group has not received any requests from the load balancer. - MODE_OFF (WARNING): Autoscaling is turned off. The number of instances in the group won't change automatically. The autoscaling configuration is preserved. - MODE_ONLY_UP (WARNING): Autoscaling is in the "Autoscale only out" mode. The autoscaler can add instances but not remove any. - MORE_THAN_ONE_BACKEND_SERVICE (ERROR): The instance group cannot be autoscaled because it has more than one backend service attached to it. - NOT_ENOUGH_QUOTA_AVAILABLE (ERROR): There is insufficient quota for the necessary resources, such as CPU or number of instances. - REGION_RESOURCE_STOCKOUT (ERROR): Shown only for regional autoscalers: there is a resource stockout in the chosen region. - SCALING_TARGET_DOES_NOT_EXIST (ERROR): The target to be scaled does not exist. - UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION (ERROR): Autoscaling does not work with an HTTP/S load balancer that has been configured for maxRate. - ZONE_RESOURCE_STOCKOUT (ERROR): For zonal autoscalers: there is a resource stockout in the chosen zone. For regional autoscalers: in at least one of the zones you're using there is a resource stockout. New values might be added in the future. Some of the values might not be available in all API versions.
type AutoscalerStatusDetailsType pulumi.String

const (
	// All instances in the instance group are unhealthy (not in RUNNING state).
	AutoscalerStatusDetailsTypeAllInstancesUnhealthy = AutoscalerStatusDetailsType("ALL_INSTANCES_UNHEALTHY")
	// There is no backend service attached to the instance group.
	AutoscalerStatusDetailsTypeBackendServiceDoesNotExist = AutoscalerStatusDetailsType("BACKEND_SERVICE_DOES_NOT_EXIST")
	// Autoscaler recommends a size greater than maxNumReplicas.
	AutoscalerStatusDetailsTypeCappedAtMaxNumReplicas = AutoscalerStatusDetailsType("CAPPED_AT_MAX_NUM_REPLICAS")
	// The custom metric samples are not exported often enough to be a credible base for autoscaling.
	AutoscalerStatusDetailsTypeCustomMetricDataPointsTooSparse = AutoscalerStatusDetailsType("CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE")
	// The custom metric that was specified does not exist or does not have the necessary labels.
	AutoscalerStatusDetailsTypeCustomMetricInvalid = AutoscalerStatusDetailsType("CUSTOM_METRIC_INVALID")
	// The minNumReplicas is equal to maxNumReplicas. This means the autoscaler cannot add or remove instances from the instance group.
	AutoscalerStatusDetailsTypeMinEqualsMax = AutoscalerStatusDetailsType("MIN_EQUALS_MAX")
	// The autoscaler did not receive any data from the custom metric configured for autoscaling.
	AutoscalerStatusDetailsTypeMissingCustomMetricDataPoints = AutoscalerStatusDetailsType("MISSING_CUSTOM_METRIC_DATA_POINTS")
	// The autoscaler is configured to scale based on a load balancing signal but the instance group has not received any requests from the load balancer.
	AutoscalerStatusDetailsTypeMissingLoadBalancingDataPoints = AutoscalerStatusDetailsType("MISSING_LOAD_BALANCING_DATA_POINTS")
	// Autoscaling is turned off. The number of instances in the group won't change automatically. The autoscaling configuration is preserved.
	AutoscalerStatusDetailsTypeModeOff = AutoscalerStatusDetailsType("MODE_OFF")
	// Autoscaling is in the "Autoscale only scale out" mode. Instances in the group will be only added.
	AutoscalerStatusDetailsTypeModeOnlyScaleOut = AutoscalerStatusDetailsType("MODE_ONLY_SCALE_OUT")
	// Autoscaling is in the "Autoscale only out" mode. Instances in the group will be only added.
	AutoscalerStatusDetailsTypeModeOnlyUp = AutoscalerStatusDetailsType("MODE_ONLY_UP")
	// The instance group cannot be autoscaled because it has more than one backend service attached to it.
	AutoscalerStatusDetailsTypeMoreThanOneBackendService = AutoscalerStatusDetailsType("MORE_THAN_ONE_BACKEND_SERVICE")
	// There is insufficient quota for the necessary resources, such as CPU or number of instances.
	AutoscalerStatusDetailsTypeNotEnoughQuotaAvailable = AutoscalerStatusDetailsType("NOT_ENOUGH_QUOTA_AVAILABLE")
	// Showed only for regional autoscalers: there is a resource stockout in the chosen region.
	AutoscalerStatusDetailsTypeRegionResourceStockout = AutoscalerStatusDetailsType("REGION_RESOURCE_STOCKOUT")
	// The target to be scaled does not exist.
	AutoscalerStatusDetailsTypeScalingTargetDoesNotExist = AutoscalerStatusDetailsType("SCALING_TARGET_DOES_NOT_EXIST")
	// For some scaling schedules minRequiredReplicas is greater than maxNumReplicas. Autoscaler always recommends at most maxNumReplicas instances.
	AutoscalerStatusDetailsTypeScheduledInstancesGreaterThanAutoscalerMax = AutoscalerStatusDetailsType("SCHEDULED_INSTANCES_GREATER_THAN_AUTOSCALER_MAX")
	// For some scaling schedules minRequiredReplicas is less than minNumReplicas. Autoscaler always recommends at least minNumReplicas instances.
	AutoscalerStatusDetailsTypeScheduledInstancesLessThanAutoscalerMin = AutoscalerStatusDetailsType("SCHEDULED_INSTANCES_LESS_THAN_AUTOSCALER_MIN")
	AutoscalerStatusDetailsTypeUnknown                                 = AutoscalerStatusDetailsType("UNKNOWN")
	// Autoscaling does not work with an HTTP/S load balancer that has been configured for maxRate.
	AutoscalerStatusDetailsTypeUnsupportedMaxRateLoadBalancingConfiguration = AutoscalerStatusDetailsType("UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION")
	// For zonal autoscalers: there is a resource stockout in the chosen zone. For regional autoscalers: in at least one of the zones you're using there is a resource stockout.
	AutoscalerStatusDetailsTypeZoneResourceStockout = AutoscalerStatusDetailsType("ZONE_RESOURCE_STOCKOUT")
)

func (AutoscalerStatusDetailsType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e AutoscalerStatusDetailsType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e AutoscalerStatusDetailsType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e AutoscalerStatusDetailsType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e AutoscalerStatusDetailsType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Indicates whether predictive autoscaling based on CPU metric is enabled. Valid values are: * NONE (default). No predictive method is used. The autoscaler scales the group to meet current demand based on real-time metrics. * OPTIMIZE_AVAILABILITY. Predictive autoscaling improves availability by monitoring daily and weekly load patterns and scaling out ahead of anticipated demand.
type AutoscalingPolicyCpuUtilizationPredictiveMethod pulumi.String

const (
	// No predictive method is used. The autoscaler scales the group to meet current demand based on real-time metrics
	AutoscalingPolicyCpuUtilizationPredictiveMethodNone = AutoscalingPolicyCpuUtilizationPredictiveMethod("NONE")
	// Predictive autoscaling improves availability by monitoring daily and weekly load patterns and scaling out ahead of anticipated demand.
	AutoscalingPolicyCpuUtilizationPredictiveMethodOptimizeAvailability        = AutoscalingPolicyCpuUtilizationPredictiveMethod("OPTIMIZE_AVAILABILITY")
	AutoscalingPolicyCpuUtilizationPredictiveMethodPredictiveMethodUnspecified = AutoscalingPolicyCpuUtilizationPredictiveMethod("PREDICTIVE_METHOD_UNSPECIFIED")
)

func (AutoscalingPolicyCpuUtilizationPredictiveMethod) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e AutoscalingPolicyCpuUtilizationPredictiveMethod) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e AutoscalingPolicyCpuUtilizationPredictiveMethod) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e AutoscalingPolicyCpuUtilizationPredictiveMethod) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e AutoscalingPolicyCpuUtilizationPredictiveMethod) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Defines how target utilization value is expressed for a Stackdriver Monitoring metric. Either GAUGE, DELTA_PER_SECOND, or DELTA_PER_MINUTE.
type AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType pulumi.String

const (
	// Sets the utilization target value for a cumulative or delta metric, expressed as the rate of growth per minute.
	AutoscalingPolicyCustomMetricUtilizationUtilizationTargetTypeDeltaPerMinute = AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType("DELTA_PER_MINUTE")
	// Sets the utilization target value for a cumulative or delta metric, expressed as the rate of growth per second.
	AutoscalingPolicyCustomMetricUtilizationUtilizationTargetTypeDeltaPerSecond = AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType("DELTA_PER_SECOND")
	// Sets the utilization target value for a gauge metric. The autoscaler will collect the average utilization of the virtual machines from the last couple of minutes, and compare the value to the utilization target value to perform autoscaling.
	AutoscalingPolicyCustomMetricUtilizationUtilizationTargetTypeGauge = AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType("GAUGE")
)

func (AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Defines operating mode for this policy.
type AutoscalingPolicyMode pulumi.String

const (
	// Do not automatically scale the MIG in or out. The recommended_size field contains the size of MIG that would be set if the actuation mode was enabled.
	AutoscalingPolicyModeOff = AutoscalingPolicyMode("OFF")
	// Automatically scale the MIG in and out according to the policy.
	AutoscalingPolicyModeOn = AutoscalingPolicyMode("ON")
	// Automatically create VMs according to the policy, but do not scale the MIG in.
	AutoscalingPolicyModeOnlyScaleOut = AutoscalingPolicyMode("ONLY_SCALE_OUT")
	// Automatically create VMs according to the policy, but do not scale the MIG in.
	AutoscalingPolicyModeOnlyUp = AutoscalingPolicyMode("ONLY_UP")
)

func (AutoscalingPolicyMode) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e AutoscalingPolicyMode) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e AutoscalingPolicyMode) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e AutoscalingPolicyMode) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e AutoscalingPolicyMode) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies how to determine whether the backend of a load balancer can handle additional traffic or is fully loaded. For usage guidelines, see Connection balancing mode.
type BackendBalancingMode pulumi.String

const (
	// Balance based on the number of simultaneous connections.
	BackendBalancingModeConnection = BackendBalancingMode("CONNECTION")
	// Balance based on requests per second (RPS).
	BackendBalancingModeRate = BackendBalancingMode("RATE")
	// Balance based on the backend utilization.
	BackendBalancingModeUtilization = BackendBalancingMode("UTILIZATION")
)

func (BackendBalancingMode) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e BackendBalancingMode) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e BackendBalancingMode) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e BackendBalancingMode) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e BackendBalancingMode) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies the cache setting for all responses from this backend. The possible values are: USE_ORIGIN_HEADERS Requires the origin to set valid caching headers to cache content. Responses without these headers will not be cached at Google's edge, and will require a full trip to the origin on every request, potentially impacting performance and increasing load on the origin server. FORCE_CACHE_ALL Cache all content, ignoring any "private", "no-store" or "no-cache" directives in Cache-Control response headers. Warning: this may result in Cloud CDN caching private, per-user (user identifiable) content. CACHE_ALL_STATIC Automatically cache static content, including common image formats, media (video and audio), and web assets (JavaScript and CSS). Requests and responses that are marked as uncacheable, as well as dynamic content (including HTML), will not be cached.
type BackendBucketCdnPolicyCacheMode pulumi.String

const (
	// Automatically cache static content, including common image formats, media (video and audio), and web assets (JavaScript and CSS). Requests and responses that are marked as uncacheable, as well as dynamic content (including HTML), will not be cached.
	BackendBucketCdnPolicyCacheModeCacheAllStatic = BackendBucketCdnPolicyCacheMode("CACHE_ALL_STATIC")
	// Cache all content, ignoring any "private", "no-store" or "no-cache" directives in Cache-Control response headers. Warning: this may result in Cloud CDN caching private, per-user (user identifiable) content.
	BackendBucketCdnPolicyCacheModeForceCacheAll    = BackendBucketCdnPolicyCacheMode("FORCE_CACHE_ALL")
	BackendBucketCdnPolicyCacheModeInvalidCacheMode = BackendBucketCdnPolicyCacheMode("INVALID_CACHE_MODE")
	// Requires the origin to set valid caching headers to cache content. Responses without these headers will not be cached at Google's edge, and will require a full trip to the origin on every request, potentially impacting performance and increasing load on the origin server.
	BackendBucketCdnPolicyCacheModeUseOriginHeaders = BackendBucketCdnPolicyCacheMode("USE_ORIGIN_HEADERS")
)

func (BackendBucketCdnPolicyCacheMode) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e BackendBucketCdnPolicyCacheMode) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e BackendBucketCdnPolicyCacheMode) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e BackendBucketCdnPolicyCacheMode) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e BackendBucketCdnPolicyCacheMode) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Compress text responses using Brotli or gzip compression, based on the client’s Accept-Encoding header.
type BackendBucketCompressionMode pulumi.String

const (
	// Automatically uses the best compression based on the Accept-Encoding header sent by the client.
	BackendBucketCompressionModeAutomatic = BackendBucketCompressionMode("AUTOMATIC")
	// Disables compression. Existing compressed responses cached by Cloud CDN will not be served to clients.
	BackendBucketCompressionModeDisabled = BackendBucketCompressionMode("DISABLED")
)

func (BackendBucketCompressionMode) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e BackendBucketCompressionMode) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e BackendBucketCompressionMode) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e BackendBucketCompressionMode) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e BackendBucketCompressionMode) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies the cache setting for all responses from this backend. The possible values are: USE_ORIGIN_HEADERS Requires the origin to set valid caching headers to cache content. Responses without these headers will not be cached at Google's edge, and will require a full trip to the origin on every request, potentially impacting performance and increasing load on the origin server. FORCE_CACHE_ALL Cache all content, ignoring any "private", "no-store" or "no-cache" directives in Cache-Control response headers. Warning: this may result in Cloud CDN caching private, per-user (user identifiable) content. CACHE_ALL_STATIC Automatically cache static content, including common image formats, media (video and audio), and web assets (JavaScript and CSS). Requests and responses that are marked as uncacheable, as well as dynamic content (including HTML), will not be cached.
type BackendServiceCdnPolicyCacheMode pulumi.String

const (
	// Automatically cache static content, including common image formats, media (video and audio), and web assets (JavaScript and CSS). Requests and responses that are marked as uncacheable, as well as dynamic content (including HTML), will not be cached.
	BackendServiceCdnPolicyCacheModeCacheAllStatic = BackendServiceCdnPolicyCacheMode("CACHE_ALL_STATIC")
	// Cache all content, ignoring any "private", "no-store" or "no-cache" directives in Cache-Control response headers. Warning: this may result in Cloud CDN caching private, per-user (user identifiable) content.
	BackendServiceCdnPolicyCacheModeForceCacheAll    = BackendServiceCdnPolicyCacheMode("FORCE_CACHE_ALL")
	BackendServiceCdnPolicyCacheModeInvalidCacheMode = BackendServiceCdnPolicyCacheMode("INVALID_CACHE_MODE")
	// Requires the origin to set valid caching headers to cache content. Responses without these headers will not be cached at Google's edge, and will require a full trip to the origin on every request, potentially impacting performance and increasing load on the origin server.
	BackendServiceCdnPolicyCacheModeUseOriginHeaders = BackendServiceCdnPolicyCacheMode("USE_ORIGIN_HEADERS")
)

func (BackendServiceCdnPolicyCacheMode) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e BackendServiceCdnPolicyCacheMode) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e BackendServiceCdnPolicyCacheMode) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e BackendServiceCdnPolicyCacheMode) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e BackendServiceCdnPolicyCacheMode) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Compress text responses using Brotli or gzip compression, based on the client’s Accept-Encoding header.
type BackendServiceCompressionMode pulumi.String

const (
	// Automatically uses the best compression based on the Accept-Encoding header sent by the client.
	BackendServiceCompressionModeAutomatic = BackendServiceCompressionMode("AUTOMATIC")
	// Disables compression. Existing compressed responses cached by Cloud CDN will not be served to clients.
	BackendServiceCompressionModeDisabled = BackendServiceCompressionMode("DISABLED")
)

func (BackendServiceCompressionMode) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e BackendServiceCompressionMode) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e BackendServiceCompressionMode) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e BackendServiceCompressionMode) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e BackendServiceCompressionMode) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies connection persistence when backends are unhealthy. The default value is DEFAULT_FOR_PROTOCOL. If set to DEFAULT_FOR_PROTOCOL, the existing connections persist on unhealthy backends only for connection-oriented protocols (TCP and SCTP) and only if the Tracking Mode is PER_CONNECTION (default tracking mode) or the Session Affinity is configured for 5-tuple. They do not persist for UDP. If set to NEVER_PERSIST, after a backend becomes unhealthy, the existing connections on the unhealthy backend are never persisted on the unhealthy backend. They are always diverted to newly selected healthy backends (unless all backends are unhealthy). If set to ALWAYS_PERSIST, existing connections always persist on unhealthy backends regardless of protocol and session affinity. It is generally not recommended to use this mode overriding the default.
type BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends pulumi.String

const (
	BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackendsAlwaysPersist      = BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends("ALWAYS_PERSIST")
	BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackendsDefaultForProtocol = BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends("DEFAULT_FOR_PROTOCOL")
	BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackendsNeverPersist       = BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends("NEVER_PERSIST")
)

func (BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies the key used for connection tracking. There are two options: PER_CONNECTION: This is the default mode. The Connection Tracking is performed as per the Connection Key (default Hash Method) for the specific protocol. PER_SESSION: The Connection Tracking is performed as per the configured Session Affinity. It matches the configured Session Affinity.
type BackendServiceConnectionTrackingPolicyTrackingMode pulumi.String

const (
	BackendServiceConnectionTrackingPolicyTrackingModeInvalidTrackingMode = BackendServiceConnectionTrackingPolicyTrackingMode("INVALID_TRACKING_MODE")
	BackendServiceConnectionTrackingPolicyTrackingModePerConnection       = BackendServiceConnectionTrackingPolicyTrackingMode("PER_CONNECTION")
	BackendServiceConnectionTrackingPolicyTrackingModePerSession          = BackendServiceConnectionTrackingPolicyTrackingMode("PER_SESSION")
)

func (BackendServiceConnectionTrackingPolicyTrackingMode) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e BackendServiceConnectionTrackingPolicyTrackingMode) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e BackendServiceConnectionTrackingPolicyTrackingMode) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e BackendServiceConnectionTrackingPolicyTrackingMode) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e BackendServiceConnectionTrackingPolicyTrackingMode) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies the load balancer type. Choose EXTERNAL for external HTTP(S), SSL Proxy, TCP Proxy and Network Load Balancing. Choose INTERNAL for Internal TCP/UDP Load Balancing. Choose INTERNAL_MANAGED for Internal HTTP(S) Load Balancing. INTERNAL_SELF_MANAGED for Traffic Director. A backend service created for one type of load balancer cannot be used with another. For more information, refer to Choosing a load balancer.
type BackendServiceLoadBalancingScheme pulumi.String

const (
	// Signifies that this will be used for HTTP(S), SSL Proxy, TCP Proxy or Network Load Balancing
	BackendServiceLoadBalancingSchemeExternal = BackendServiceLoadBalancingScheme("EXTERNAL")
	// Signifies that this will be used for Internal TCP/UDP Load Balancing.
	BackendServiceLoadBalancingSchemeInternal = BackendServiceLoadBalancingScheme("INTERNAL")
	// Signifies that this will be used for Internal HTTP(S) Load Balancing.
	BackendServiceLoadBalancingSchemeInternalManaged = BackendServiceLoadBalancingScheme("INTERNAL_MANAGED")
	// Signifies that this will be used by Traffic Director.
	BackendServiceLoadBalancingSchemeInternalSelfManaged        = BackendServiceLoadBalancingScheme("INTERNAL_SELF_MANAGED")
	BackendServiceLoadBalancingSchemeInvalidLoadBalancingScheme = BackendServiceLoadBalancingScheme("INVALID_LOAD_BALANCING_SCHEME")
)

func (BackendServiceLoadBalancingScheme) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e BackendServiceLoadBalancingScheme) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e BackendServiceLoadBalancingScheme) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e BackendServiceLoadBalancingScheme) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e BackendServiceLoadBalancingScheme) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The load balancing algorithm used within the scope of the locality. The possible values are: - ROUND_ROBIN: This is a simple policy in which each healthy backend is selected in round robin order. This is the default. - LEAST_REQUEST: An O(1) algorithm which selects two random healthy hosts and picks the host which has fewer active requests. - RING_HASH: The ring/modulo hash load balancer implements consistent hashing to backends. The algorithm has the property that the addition/removal of a host from a set of N hosts only affects 1/N of the requests. - RANDOM: The load balancer selects a random healthy host. - ORIGINAL_DESTINATION: Backend host is selected based on the client connection metadata, i.e., connections are opened to the same address as the destination address of the incoming connection before the connection was redirected to the load balancer. - MAGLEV: used as a drop in replacement for the ring hash load balancer. Maglev is not as stable as ring hash but has faster table lookup build times and host selection times. For more information about Maglev, see https://ai.google/research/pubs/pub44824 This field is applicable to either: - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED. - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED. If sessionAffinity is not NONE, and this field is not set to MAGLEV or RING_HASH, session affinity settings will not take effect. Only the default ROUND_ROBIN policy is supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
type BackendServiceLocalityLbPolicy pulumi.String

const (
	BackendServiceLocalityLbPolicyInvalidLbPolicy = BackendServiceLocalityLbPolicy("INVALID_LB_POLICY")
	// An O(1) algorithm which selects two random healthy hosts and picks the host which has fewer active requests.
	BackendServiceLocalityLbPolicyLeastRequest = BackendServiceLocalityLbPolicy("LEAST_REQUEST")
	// This algorithm implements consistent hashing to backends. Maglev can be used as a drop in replacement for the ring hash load balancer. Maglev is not as stable as ring hash but has faster table lookup build times and host selection times. For more information about Maglev, see https://ai.google/research/pubs/pub44824
	BackendServiceLocalityLbPolicyMaglev = BackendServiceLocalityLbPolicy("MAGLEV")
	// Backend host is selected based on the client connection metadata, i.e., connections are opened to the same address as the destination address of the incoming connection before the connection was redirected to the load balancer.
	BackendServiceLocalityLbPolicyOriginalDestination = BackendServiceLocalityLbPolicy("ORIGINAL_DESTINATION")
	// The load balancer selects a random healthy host.
	BackendServiceLocalityLbPolicyRandom = BackendServiceLocalityLbPolicy("RANDOM")
	// The ring/modulo hash load balancer implements consistent hashing to backends. The algorithm has the property that the addition/removal of a host from a set of N hosts only affects 1/N of the requests.
	BackendServiceLocalityLbPolicyRingHash = BackendServiceLocalityLbPolicy("RING_HASH")
	// This is a simple policy in which each healthy backend is selected in round robin order. This is the default.
	BackendServiceLocalityLbPolicyRoundRobin = BackendServiceLocalityLbPolicy("ROUND_ROBIN")
)

func (BackendServiceLocalityLbPolicy) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e BackendServiceLocalityLbPolicy) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e BackendServiceLocalityLbPolicy) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e BackendServiceLocalityLbPolicy) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e BackendServiceLocalityLbPolicy) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The protocol this BackendService uses to communicate with backends. Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, UDP or GRPC. depending on the chosen load balancer or Traffic Director configuration. Refer to the documentation for the load balancer or for Traffic Director for more information. Must be set to GRPC when the backend service is referenced by a URL map that is bound to target gRPC proxy.
type BackendServiceProtocol pulumi.String

const (
	// gRPC (available for Traffic Director).
	BackendServiceProtocolGrpc = BackendServiceProtocol("GRPC")
	BackendServiceProtocolHttp = BackendServiceProtocol("HTTP")
	// HTTP/2 with SSL.
	BackendServiceProtocolHttp2 = BackendServiceProtocol("HTTP2")
	BackendServiceProtocolHttps = BackendServiceProtocol("HTTPS")
	// TCP proxying with SSL.
	BackendServiceProtocolSsl = BackendServiceProtocol("SSL")
	// TCP proxying or TCP pass-through (Internal TCP/UDP Load Balancing and Network Load Balancing).
	BackendServiceProtocolTcp = BackendServiceProtocol("TCP")
	// UDP (available for Internal TCP/UDP Load Balancing and Network Load Balancing).
	BackendServiceProtocolUdp = BackendServiceProtocol("UDP")
	// If a Backend Service has UNSPECIFIED as its protocol, it can be used with any L3/L4 Forwarding Rules.
	BackendServiceProtocolUnspecified = BackendServiceProtocol("UNSPECIFIED")
)

func (BackendServiceProtocol) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e BackendServiceProtocol) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e BackendServiceProtocol) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e BackendServiceProtocol) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e BackendServiceProtocol) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Type of session affinity to use. The default is NONE. When the loadBalancingScheme is EXTERNAL: * For Network Load Balancing, the possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO. * For all other load balancers that use loadBalancingScheme=EXTERNAL, the possible values are NONE, CLIENT_IP, or GENERATED_COOKIE. * You can use GENERATED_COOKIE if the protocol is HTTP, HTTP2, or HTTPS. When the loadBalancingScheme is INTERNAL, possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO. When the loadBalancingScheme is INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED, possible values are NONE, CLIENT_IP, GENERATED_COOKIE, HEADER_FIELD, or HTTP_COOKIE. Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
type BackendServiceSessionAffinity pulumi.String

const (
	// 2-tuple hash on packet's source and destination IP addresses. Connections from the same source IP address to the same destination IP address will be served by the same backend VM while that VM remains healthy.
	BackendServiceSessionAffinityClientIp = BackendServiceSessionAffinity("CLIENT_IP")
	// 1-tuple hash only on packet's source IP address. Connections from the same source IP address will be served by the same backend VM while that VM remains healthy. This option can only be used for Internal TCP/UDP Load Balancing.
	BackendServiceSessionAffinityClientIpNoDestination = BackendServiceSessionAffinity("CLIENT_IP_NO_DESTINATION")
	// 5-tuple hash on packet's source and destination IP addresses, IP protocol, and source and destination ports. Connections for the same IP protocol from the same source IP address and port to the same destination IP address and port will be served by the same backend VM while that VM remains healthy. This option cannot be used for HTTP(S) load balancing.
	BackendServiceSessionAffinityClientIpPortProto = BackendServiceSessionAffinity("CLIENT_IP_PORT_PROTO")
	// 3-tuple hash on packet's source and destination IP addresses, and IP protocol. Connections for the same IP protocol from the same source IP address to the same destination IP address will be served by the same backend VM while that VM remains healthy. This option cannot be used for HTTP(S) load balancing.
	BackendServiceSessionAffinityClientIpProto = BackendServiceSessionAffinity("CLIENT_IP_PROTO")
	// Hash based on a cookie generated by the L7 loadbalancer. Only valid for HTTP(S) load balancing.
	BackendServiceSessionAffinityGeneratedCookie = BackendServiceSessionAffinity("GENERATED_COOKIE")
	// The hash is based on a user specified header field.
	BackendServiceSessionAffinityHeaderField = BackendServiceSessionAffinity("HEADER_FIELD")
	// The hash is based on a user provided cookie.
	BackendServiceSessionAffinityHttpCookie = BackendServiceSessionAffinity("HTTP_COOKIE")
	// No session affinity. Connections from the same client IP may go to any instance in the pool.
	BackendServiceSessionAffinityNone = BackendServiceSessionAffinity("NONE")
)

func (BackendServiceSessionAffinity) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e BackendServiceSessionAffinity) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e BackendServiceSessionAffinity) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e BackendServiceSessionAffinity) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e BackendServiceSessionAffinity) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// This is deprecated and has no effect. Do not use.
type ConditionIam pulumi.String

const (
	// This is deprecated and has no effect. Do not use.
	ConditionIamApprover = ConditionIam("APPROVER")
	// This is deprecated and has no effect. Do not use.
	ConditionIamAttribution = ConditionIam("ATTRIBUTION")
	// This is deprecated and has no effect. Do not use.
	ConditionIamAuthority = ConditionIam("AUTHORITY")
	// This is deprecated and has no effect. Do not use.
	ConditionIamCredentialsType = ConditionIam("CREDENTIALS_TYPE")
	// This is deprecated and has no effect. Do not use.
	ConditionIamCredsAssertion = ConditionIam("CREDS_ASSERTION")
	// This is deprecated and has no effect. Do not use.
	ConditionIamJustificationType = ConditionIam("JUSTIFICATION_TYPE")
	// This is deprecated and has no effect. Do not use.
	ConditionIamNoAttr = ConditionIam("NO_ATTR")
	// This is deprecated and has no effect. Do not use.
	ConditionIamSecurityRealm = ConditionIam("SECURITY_REALM")
)

func (ConditionIam) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e ConditionIam) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e ConditionIam) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e ConditionIam) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e ConditionIam) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// This is deprecated and has no effect. Do not use.
type ConditionOp pulumi.String

const (
	// This is deprecated and has no effect. Do not use.
	ConditionOpDischarged = ConditionOp("DISCHARGED")
	// This is deprecated and has no effect. Do not use.
	ConditionOpEquals = ConditionOp("EQUALS")
	// This is deprecated and has no effect. Do not use.
	ConditionOpIn = ConditionOp("IN")
	// This is deprecated and has no effect. Do not use.
	ConditionOpNotEquals = ConditionOp("NOT_EQUALS")
	// This is deprecated and has no effect. Do not use.
	ConditionOpNotIn = ConditionOp("NOT_IN")
	// This is deprecated and has no effect. Do not use.
	ConditionOpNoOp = ConditionOp("NO_OP")
)

func (ConditionOp) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e ConditionOp) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e ConditionOp) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e ConditionOp) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e ConditionOp) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// This is deprecated and has no effect. Do not use.
type ConditionSys pulumi.String

const (
	// This is deprecated and has no effect. Do not use.
	ConditionSysIp = ConditionSys("IP")
	// This is deprecated and has no effect. Do not use.
	ConditionSysName = ConditionSys("NAME")
	// This is deprecated and has no effect. Do not use.
	ConditionSysNoAttr = ConditionSys("NO_ATTR")
	// This is deprecated and has no effect. Do not use.
	ConditionSysRegion = ConditionSys("REGION")
	// This is deprecated and has no effect. Do not use.
	ConditionSysService = ConditionSys("SERVICE")
)

func (ConditionSys) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e ConditionSys) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e ConditionSys) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e ConditionSys) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e ConditionSys) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The deprecation state of this resource. This can be ACTIVE, DEPRECATED, OBSOLETE, or DELETED. Operations which communicate the end of life date for an image, can use ACTIVE. Operations which create a new resource using a DEPRECATED resource will return successfully, but with a warning indicating the deprecated resource and recommending its replacement. Operations which use OBSOLETE or DELETED resources will be rejected and result in an error.
type DeprecationStatusState pulumi.String

const (
	DeprecationStatusStateActive     = DeprecationStatusState("ACTIVE")
	DeprecationStatusStateDeleted    = DeprecationStatusState("DELETED")
	DeprecationStatusStateDeprecated = DeprecationStatusState("DEPRECATED")
	DeprecationStatusStateObsolete   = DeprecationStatusState("OBSOLETE")
)

func (DeprecationStatusState) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e DeprecationStatusState) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e DeprecationStatusState) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e DeprecationStatusState) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e DeprecationStatusState) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies whether to include the disk and what image to use. Possible values are: - source-image: to use the same image that was used to create the source instance's corresponding disk. Applicable to the boot disk and additional read-write disks. - source-image-family: to use the same image family that was used to create the source instance's corresponding disk. Applicable to the boot disk and additional read-write disks. - custom-image: to use a user-provided image url for disk creation. Applicable to the boot disk and additional read-write disks. - attach-read-only: to attach a read-only disk. Applicable to read-only disks. - do-not-include: to exclude a disk from the template. Applicable to additional read-write disks, local SSDs, and read-only disks.
type DiskInstantiationConfigInstantiateFrom pulumi.String

const (
	// Attach the existing disk in read-only mode. The request will fail if the disk was attached in read-write mode on the source instance. Applicable to: read-only disks.
	DiskInstantiationConfigInstantiateFromAttachReadOnly = DiskInstantiationConfigInstantiateFrom("ATTACH_READ_ONLY")
	// Create a blank disk. The disk will be created unformatted. Applicable to: additional read-write disks, local SSDs.
	DiskInstantiationConfigInstantiateFromBlank = DiskInstantiationConfigInstantiateFrom("BLANK")
	// Use the custom image specified in the custom_image field. Applicable to: boot disk, additional read-write disks.
	DiskInstantiationConfigInstantiateFromCustomImage = DiskInstantiationConfigInstantiateFrom("CUSTOM_IMAGE")
	// Use the default instantiation option for the corresponding type of disk. For boot disk and any other R/W disks, new custom images will be created from each disk. For read-only disks, they will be attached in read-only mode. Local SSD disks will be created as blank volumes.
	DiskInstantiationConfigInstantiateFromDefault = DiskInstantiationConfigInstantiateFrom("DEFAULT")
	// Do not include the disk in the instance template. Applicable to: additional read-write disks, local SSDs, read-only disks.
	DiskInstantiationConfigInstantiateFromDoNotInclude = DiskInstantiationConfigInstantiateFrom("DO_NOT_INCLUDE")
	// Use the same source image used for creation of the source instance's corresponding disk. The request will fail if the source VM's disk was created from a snapshot. Applicable to: boot disk, additional read-write disks.
	DiskInstantiationConfigInstantiateFromSourceImage = DiskInstantiationConfigInstantiateFrom("SOURCE_IMAGE")
	// Use the same source image family used for creation of the source instance's corresponding disk. The request will fail if the source image of the source disk does not belong to any image family. Applicable to: boot disk, additional read-write disks.
	DiskInstantiationConfigInstantiateFromSourceImageFamily = DiskInstantiationConfigInstantiateFrom("SOURCE_IMAGE_FAMILY")
)

func (DiskInstantiationConfigInstantiateFrom) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e DiskInstantiationConfigInstantiateFrom) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e DiskInstantiationConfigInstantiateFrom) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e DiskInstantiationConfigInstantiateFrom) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e DiskInstantiationConfigInstantiateFrom) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME. The default is SCSI.
type DiskInterface pulumi.String

const (
	DiskInterfaceNvme        = DiskInterface("NVME")
	DiskInterfaceScsi        = DiskInterface("SCSI")
	DiskInterfaceUnspecified = DiskInterface("UNSPECIFIED")
)

func (DiskInterface) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e DiskInterface) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e DiskInterface) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e DiskInterface) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e DiskInterface) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] The status of disk creation. - CREATING: Disk is provisioning. - RESTORING: Source data is being copied into the disk. - FAILED: Disk creation failed. - READY: Disk is ready for use. - DELETING: Disk is deleting.
type DiskStatus pulumi.String

const (
	// Disk is provisioning
	DiskStatusCreating = DiskStatus("CREATING")
	// Disk is deleting.
	DiskStatusDeleting = DiskStatus("DELETING")
	// Disk creation failed.
	DiskStatusFailed = DiskStatus("FAILED")
	// Disk is ready for use.
	DiskStatusReady = DiskStatus("READY")
	// Source data is being copied into the disk.
	DiskStatusRestoring = DiskStatus("RESTORING")
)

func (DiskStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e DiskStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e DiskStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e DiskStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e DiskStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The distribution shape to which the group converges either proactively or on resize events (depending on the value set in updatePolicy.instanceRedistributionType).
type DistributionPolicyTargetShape pulumi.String

const (
	// The group picks zones for creating VM instances to fulfill the requested number of VMs within present resource constraints and to maximize utilization of unused zonal reservations. Recommended for batch workloads that do not require high availability.
	DistributionPolicyTargetShapeAny = DistributionPolicyTargetShape("ANY")
	// The group prioritizes acquisition of resources, scheduling VMs in zones where resources are available while distributing VMs as evenly as possible across selected zones to minimize the impact of zonal failure. Recommended for highly available serving workloads.
	DistributionPolicyTargetShapeBalanced = DistributionPolicyTargetShape("BALANCED")
	// The group schedules VM instance creation and deletion to achieve and maintain an even number of managed instances across the selected zones. The distribution is even when the number of managed instances does not differ by more than 1 between any two zones. Recommended for highly available serving workloads.
	DistributionPolicyTargetShapeEven = DistributionPolicyTargetShape("EVEN")
)

func (DistributionPolicyTargetShape) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e DistributionPolicyTargetShape) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e DistributionPolicyTargetShape) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e DistributionPolicyTargetShape) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e DistributionPolicyTargetShape) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Indicates the user-supplied redundancy type of this external VPN gateway.
type ExternalVpnGatewayRedundancyType pulumi.String

const (
	// The external VPN gateway has four public IP addresses; at the time of writing this API, the AWS virtual private gateway is an example which has four public IP addresses for high availability connections; there should be two VPN connections in the AWS virtual private gateway , each AWS VPN connection has two public IP addresses; please make sure to put two public IP addresses from one AWS VPN connection into interfaces 0 and 1 of this external VPN gateway, and put the other two public IP addresses from another AWS VPN connection into interfaces 2 and 3 of this external VPN gateway. When displaying highly available configuration status for the VPN tunnels connected to FOUR_IPS_REDUNDANCY external VPN gateway, Google will always detect whether interfaces 0 and 1 are connected on one interface of HA Cloud VPN gateway, and detect whether interfaces 2 and 3 are connected to another interface of the HA Cloud VPN gateway.
	ExternalVpnGatewayRedundancyTypeFourIpsRedundancy = ExternalVpnGatewayRedundancyType("FOUR_IPS_REDUNDANCY")
	// The external VPN gateway has only one public IP address which internally provide redundancy or failover.
	ExternalVpnGatewayRedundancyTypeSingleIpInternallyRedundant = ExternalVpnGatewayRedundancyType("SINGLE_IP_INTERNALLY_REDUNDANT")
	// The external VPN gateway has two public IP addresses which are redundant with each other, the following two types of setup on your on-premises side would have this type of redundancy: (1) Two separate on-premises gateways, each with one public IP address, the two on-premises gateways are redundant with each other. (2) A single on-premise gateway with two public IP addresses that are redundant with eatch other.
	ExternalVpnGatewayRedundancyTypeTwoIpsRedundancy = ExternalVpnGatewayRedundancyType("TWO_IPS_REDUNDANCY")
)

func (ExternalVpnGatewayRedundancyType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e ExternalVpnGatewayRedundancyType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e ExternalVpnGatewayRedundancyType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e ExternalVpnGatewayRedundancyType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e ExternalVpnGatewayRedundancyType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The file type of source file.
type FileContentBufferFileType pulumi.String

const (
	FileContentBufferFileTypeBin       = FileContentBufferFileType("BIN")
	FileContentBufferFileTypeUndefined = FileContentBufferFileType("UNDEFINED")
	FileContentBufferFileTypeX509      = FileContentBufferFileType("X509")
)

func (FileContentBufferFileType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e FileContentBufferFileType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e FileContentBufferFileType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e FileContentBufferFileType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e FileContentBufferFileType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Direction of traffic to which this firewall applies, either `INGRESS` or `EGRESS`. The default is `INGRESS`. For `INGRESS` traffic, you cannot specify the destinationRanges field, and for `EGRESS` traffic, you cannot specify the sourceRanges or sourceTags fields.
type FirewallDirection pulumi.String

const (
	// Indicates that firewall should apply to outgoing traffic.
	FirewallDirectionEgress = FirewallDirection("EGRESS")
	// Indicates that firewall should apply to incoming traffic.
	FirewallDirectionIngress = FirewallDirection("INGRESS")
)

func (FirewallDirection) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e FirewallDirection) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e FirewallDirection) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e FirewallDirection) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e FirewallDirection) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// This field can only be specified for a particular firewall rule if logging is enabled for that rule. This field denotes whether to include or exclude metadata for firewall logs.
type FirewallLogConfigMetadata pulumi.String

const (
	FirewallLogConfigMetadataExcludeAllMetadata = FirewallLogConfigMetadata("EXCLUDE_ALL_METADATA")
	FirewallLogConfigMetadataIncludeAllMetadata = FirewallLogConfigMetadata("INCLUDE_ALL_METADATA")
)

func (FirewallLogConfigMetadata) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e FirewallLogConfigMetadata) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e FirewallLogConfigMetadata) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e FirewallLogConfigMetadata) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e FirewallLogConfigMetadata) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The direction in which this rule applies.
type FirewallPolicyRuleDirection pulumi.String

const (
	FirewallPolicyRuleDirectionEgress  = FirewallPolicyRuleDirection("EGRESS")
	FirewallPolicyRuleDirectionIngress = FirewallPolicyRuleDirection("INGRESS")
)

func (FirewallPolicyRuleDirection) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e FirewallPolicyRuleDirection) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e FirewallPolicyRuleDirection) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e FirewallPolicyRuleDirection) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e FirewallPolicyRuleDirection) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The IP protocol to which this rule applies. For protocol forwarding, valid options are TCP, UDP, ESP, AH, SCTP, ICMP and L3_DEFAULT. The valid IP protocols are different for different load balancing products: - Internal TCP/UDP Load Balancing: The load balancing scheme is INTERNAL, and one of TCP, UDP or L3_DEFAULT is valid. - Traffic Director: The load balancing scheme is INTERNAL_SELF_MANAGED, and only TCP is valid. - Internal HTTP(S) Load Balancing: The load balancing scheme is INTERNAL_MANAGED, and only TCP is valid. - HTTP(S), SSL Proxy, and TCP Proxy Load Balancing: The load balancing scheme is EXTERNAL and only TCP is valid. - Network Load Balancing: The load balancing scheme is EXTERNAL, and one of TCP, UDP or L3_DEFAULT is valid.
type ForwardingRuleIPProtocol pulumi.String

const (
	ForwardingRuleIPProtocolAh        = ForwardingRuleIPProtocol("AH")
	ForwardingRuleIPProtocolEsp       = ForwardingRuleIPProtocol("ESP")
	ForwardingRuleIPProtocolIcmp      = ForwardingRuleIPProtocol("ICMP")
	ForwardingRuleIPProtocolL3Default = ForwardingRuleIPProtocol("L3_DEFAULT")
	ForwardingRuleIPProtocolSctp      = ForwardingRuleIPProtocol("SCTP")
	ForwardingRuleIPProtocolTcp       = ForwardingRuleIPProtocol("TCP")
	ForwardingRuleIPProtocolUdp       = ForwardingRuleIPProtocol("UDP")
)

func (ForwardingRuleIPProtocol) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e ForwardingRuleIPProtocol) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e ForwardingRuleIPProtocol) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e ForwardingRuleIPProtocol) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e ForwardingRuleIPProtocol) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The IP Version that will be used by this forwarding rule. Valid options are IPV4 or IPV6. This can only be specified for an external global forwarding rule.
type ForwardingRuleIpVersion pulumi.String

const (
	ForwardingRuleIpVersionIpv4               = ForwardingRuleIpVersion("IPV4")
	ForwardingRuleIpVersionIpv6               = ForwardingRuleIpVersion("IPV6")
	ForwardingRuleIpVersionUnspecifiedVersion = ForwardingRuleIpVersion("UNSPECIFIED_VERSION")
)

func (ForwardingRuleIpVersion) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e ForwardingRuleIpVersion) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e ForwardingRuleIpVersion) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e ForwardingRuleIpVersion) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e ForwardingRuleIpVersion) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies the forwarding rule type. - EXTERNAL is used for: - Classic Cloud VPN gateways - Protocol forwarding to VMs from an external IP address - HTTP(S), SSL Proxy, TCP Proxy, and Network Load Balancing - INTERNAL is used for: - Protocol forwarding to VMs from an internal IP address - Internal TCP/UDP Load Balancing - INTERNAL_MANAGED is used for: - Internal HTTP(S) Load Balancing - INTERNAL_SELF_MANAGED is used for: - Traffic Director For more information about forwarding rules, refer to Forwarding rule concepts.
type ForwardingRuleLoadBalancingScheme pulumi.String

const (
	ForwardingRuleLoadBalancingSchemeExternal            = ForwardingRuleLoadBalancingScheme("EXTERNAL")
	ForwardingRuleLoadBalancingSchemeInternal            = ForwardingRuleLoadBalancingScheme("INTERNAL")
	ForwardingRuleLoadBalancingSchemeInternalManaged     = ForwardingRuleLoadBalancingScheme("INTERNAL_MANAGED")
	ForwardingRuleLoadBalancingSchemeInternalSelfManaged = ForwardingRuleLoadBalancingScheme("INTERNAL_SELF_MANAGED")
	ForwardingRuleLoadBalancingSchemeInvalid             = ForwardingRuleLoadBalancingScheme("INVALID")
)

func (ForwardingRuleLoadBalancingScheme) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e ForwardingRuleLoadBalancingScheme) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e ForwardingRuleLoadBalancingScheme) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e ForwardingRuleLoadBalancingScheme) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e ForwardingRuleLoadBalancingScheme) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// This signifies the networking tier used for configuring this load balancer and can only take the following values: PREMIUM, STANDARD. For regional ForwardingRule, the valid values are PREMIUM and STANDARD. For GlobalForwardingRule, the valid value is PREMIUM. If this field is not specified, it is assumed to be PREMIUM. If IPAddress is specified, this value must be equal to the networkTier of the Address.
type ForwardingRuleNetworkTier pulumi.String

const (
	// High quality, Google-grade network tier, support for all networking products.
	ForwardingRuleNetworkTierPremium = ForwardingRuleNetworkTier("PREMIUM")
	// Public internet quality, only limited support for other networking products.
	ForwardingRuleNetworkTierStandard = ForwardingRuleNetworkTier("STANDARD")
)

func (ForwardingRuleNetworkTier) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e ForwardingRuleNetworkTier) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e ForwardingRuleNetworkTier) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e ForwardingRuleNetworkTier) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e ForwardingRuleNetworkTier) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

type ForwardingRulePscConnectionStatus pulumi.String

const (
	// The connection has been accepted by the producer.
	ForwardingRulePscConnectionStatusAccepted = ForwardingRulePscConnectionStatus("ACCEPTED")
	// The connection has been closed by the producer and will not serve traffic going forward.
	ForwardingRulePscConnectionStatusClosed = ForwardingRulePscConnectionStatus("CLOSED")
	// The connection is pending acceptance by the producer.
	ForwardingRulePscConnectionStatusPending = ForwardingRulePscConnectionStatus("PENDING")
	// The connection has been rejected by the producer.
	ForwardingRulePscConnectionStatusRejected          = ForwardingRulePscConnectionStatus("REJECTED")
	ForwardingRulePscConnectionStatusStatusUnspecified = ForwardingRulePscConnectionStatus("STATUS_UNSPECIFIED")
)

func (ForwardingRulePscConnectionStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e ForwardingRulePscConnectionStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e ForwardingRulePscConnectionStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e ForwardingRulePscConnectionStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e ForwardingRulePscConnectionStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies how port is selected for health checking, can be one of following values: USE_FIXED_PORT: The port number in port is used for health checking. USE_NAMED_PORT: The portName is used for health checking. USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking. If not specified, gRPC health check follows behavior specified in port and portName fields.
type GRPCHealthCheckPortSpecification pulumi.String

const (
	// The port number in port is used for health checking.
	GRPCHealthCheckPortSpecificationUseFixedPort = GRPCHealthCheckPortSpecification("USE_FIXED_PORT")
	// The portName is used for health checking.
	GRPCHealthCheckPortSpecificationUseNamedPort = GRPCHealthCheckPortSpecification("USE_NAMED_PORT")
	// For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking.
	GRPCHealthCheckPortSpecificationUseServingPort = GRPCHealthCheckPortSpecification("USE_SERVING_PORT")
)

func (GRPCHealthCheckPortSpecification) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e GRPCHealthCheckPortSpecification) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e GRPCHealthCheckPortSpecification) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e GRPCHealthCheckPortSpecification) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e GRPCHealthCheckPortSpecification) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The type of address to reserve, either INTERNAL or EXTERNAL. If unspecified, defaults to EXTERNAL.
type GlobalAddressAddressType pulumi.String

const (
	// A publicly visible external IP address.
	GlobalAddressAddressTypeExternal = GlobalAddressAddressType("EXTERNAL")
	// A private network IP address, for use with an Instance or Internal Load Balancer forwarding rule.
	GlobalAddressAddressTypeInternal        = GlobalAddressAddressType("INTERNAL")
	GlobalAddressAddressTypeUnspecifiedType = GlobalAddressAddressType("UNSPECIFIED_TYPE")
)

func (GlobalAddressAddressType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e GlobalAddressAddressType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e GlobalAddressAddressType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e GlobalAddressAddressType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e GlobalAddressAddressType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The IP version that will be used by this address. Valid options are IPV4 or IPV6. This can only be specified for a global address.
type GlobalAddressIpVersion pulumi.String

const (
	GlobalAddressIpVersionIpv4               = GlobalAddressIpVersion("IPV4")
	GlobalAddressIpVersionIpv6               = GlobalAddressIpVersion("IPV6")
	GlobalAddressIpVersionUnspecifiedVersion = GlobalAddressIpVersion("UNSPECIFIED_VERSION")
)

func (GlobalAddressIpVersion) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e GlobalAddressIpVersion) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e GlobalAddressIpVersion) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e GlobalAddressIpVersion) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e GlobalAddressIpVersion) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// This signifies the networking tier used for configuring this address and can only take the following values: PREMIUM or STANDARD. Global forwarding rules can only be Premium Tier. Regional forwarding rules can be either Premium or Standard Tier. Standard Tier addresses applied to regional forwarding rules can be used with any external load balancer. Regional forwarding rules in Premium Tier can only be used with a network load balancer. If this field is not specified, it is assumed to be PREMIUM.
type GlobalAddressNetworkTier pulumi.String

const (
	// High quality, Google-grade network tier, support for all networking products.
	GlobalAddressNetworkTierPremium = GlobalAddressNetworkTier("PREMIUM")
	// Public internet quality, only limited support for other networking products.
	GlobalAddressNetworkTierStandard = GlobalAddressNetworkTier("STANDARD")
)

func (GlobalAddressNetworkTier) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e GlobalAddressNetworkTier) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e GlobalAddressNetworkTier) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e GlobalAddressNetworkTier) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e GlobalAddressNetworkTier) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The purpose of this resource, which can be one of the following values: - `GCE_ENDPOINT` for addresses that are used by VM instances, alias IP ranges, internal load balancers, and similar resources. - `DNS_RESOLVER` for a DNS resolver address in a subnetwork - `VPC_PEERING` for addresses that are reserved for VPC peer networks. - `NAT_AUTO` for addresses that are external IP addresses automatically reserved for Cloud NAT. - `IPSEC_INTERCONNECT` for addresses created from a private IP range that are reserved for a VLAN attachment in an *IPsec-encrypted Cloud Interconnect* configuration. These addresses are regional resources. Not currently available publicly.
type GlobalAddressPurpose pulumi.String

const (
	// DNS resolver address in the subnetwork.
	GlobalAddressPurposeDnsResolver = GlobalAddressPurpose("DNS_RESOLVER")
	// VM internal/alias IP, Internal LB service IP, etc.
	GlobalAddressPurposeGceEndpoint = GlobalAddressPurpose("GCE_ENDPOINT")
	// A regional internal IP address range reserved for the VLAN attachment that is used in IPsec-encrypted Cloud Interconnect. This regional internal IP address range must not overlap with any IP address range of subnet/route in the VPC network and its peering networks. After the VLAN attachment is created with the reserved IP address range, when creating a new VPN gateway, its interface IP address is allocated from the associated VLAN attachment’s IP address range.
	GlobalAddressPurposeIpsecInterconnect = GlobalAddressPurpose("IPSEC_INTERCONNECT")
	// External IP automatically reserved for Cloud NAT.
	GlobalAddressPurposeNatAuto = GlobalAddressPurpose("NAT_AUTO")
	// A private network IP address that can be used to configure Private Service Connect. This purpose can be specified only for GLOBAL addresses of Type INTERNAL
	GlobalAddressPurposePrivateServiceConnect = GlobalAddressPurpose("PRIVATE_SERVICE_CONNECT")
	// A private network IP address that can be shared by multiple Internal Load Balancer forwarding rules.
	GlobalAddressPurposeSharedLoadbalancerVip = GlobalAddressPurpose("SHARED_LOADBALANCER_VIP")
	// IP range for peer networks.
	GlobalAddressPurposeVpcPeering = GlobalAddressPurpose("VPC_PEERING")
)

func (GlobalAddressPurpose) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e GlobalAddressPurpose) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e GlobalAddressPurpose) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e GlobalAddressPurpose) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e GlobalAddressPurpose) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] The status of the address, which can be one of RESERVING, RESERVED, or IN_USE. An address that is RESERVING is currently in the process of being reserved. A RESERVED address is currently reserved and available to use. An IN_USE address is currently being used by another resource and is not available.
type GlobalAddressStatus pulumi.String

const (
	// Address is being used by another resource and is not available.
	GlobalAddressStatusInUse = GlobalAddressStatus("IN_USE")
	// Address is reserved and available to use.
	GlobalAddressStatusReserved = GlobalAddressStatus("RESERVED")
	// Address is being reserved.
	GlobalAddressStatusReserving = GlobalAddressStatus("RESERVING")
)

func (GlobalAddressStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e GlobalAddressStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e GlobalAddressStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e GlobalAddressStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e GlobalAddressStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The IP protocol to which this rule applies. For protocol forwarding, valid options are TCP, UDP, ESP, AH, SCTP, ICMP and L3_DEFAULT. The valid IP protocols are different for different load balancing products: - Internal TCP/UDP Load Balancing: The load balancing scheme is INTERNAL, and one of TCP, UDP or L3_DEFAULT is valid. - Traffic Director: The load balancing scheme is INTERNAL_SELF_MANAGED, and only TCP is valid. - Internal HTTP(S) Load Balancing: The load balancing scheme is INTERNAL_MANAGED, and only TCP is valid. - HTTP(S), SSL Proxy, and TCP Proxy Load Balancing: The load balancing scheme is EXTERNAL and only TCP is valid. - Network Load Balancing: The load balancing scheme is EXTERNAL, and one of TCP, UDP or L3_DEFAULT is valid.
type GlobalForwardingRuleIPProtocol pulumi.String

const (
	GlobalForwardingRuleIPProtocolAh        = GlobalForwardingRuleIPProtocol("AH")
	GlobalForwardingRuleIPProtocolEsp       = GlobalForwardingRuleIPProtocol("ESP")
	GlobalForwardingRuleIPProtocolIcmp      = GlobalForwardingRuleIPProtocol("ICMP")
	GlobalForwardingRuleIPProtocolL3Default = GlobalForwardingRuleIPProtocol("L3_DEFAULT")
	GlobalForwardingRuleIPProtocolSctp      = GlobalForwardingRuleIPProtocol("SCTP")
	GlobalForwardingRuleIPProtocolTcp       = GlobalForwardingRuleIPProtocol("TCP")
	GlobalForwardingRuleIPProtocolUdp       = GlobalForwardingRuleIPProtocol("UDP")
)

func (GlobalForwardingRuleIPProtocol) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e GlobalForwardingRuleIPProtocol) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e GlobalForwardingRuleIPProtocol) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e GlobalForwardingRuleIPProtocol) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e GlobalForwardingRuleIPProtocol) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The IP Version that will be used by this forwarding rule. Valid options are IPV4 or IPV6. This can only be specified for an external global forwarding rule.
type GlobalForwardingRuleIpVersion pulumi.String

const (
	GlobalForwardingRuleIpVersionIpv4               = GlobalForwardingRuleIpVersion("IPV4")
	GlobalForwardingRuleIpVersionIpv6               = GlobalForwardingRuleIpVersion("IPV6")
	GlobalForwardingRuleIpVersionUnspecifiedVersion = GlobalForwardingRuleIpVersion("UNSPECIFIED_VERSION")
)

func (GlobalForwardingRuleIpVersion) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e GlobalForwardingRuleIpVersion) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e GlobalForwardingRuleIpVersion) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e GlobalForwardingRuleIpVersion) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e GlobalForwardingRuleIpVersion) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies the forwarding rule type. - EXTERNAL is used for: - Classic Cloud VPN gateways - Protocol forwarding to VMs from an external IP address - HTTP(S), SSL Proxy, TCP Proxy, and Network Load Balancing - INTERNAL is used for: - Protocol forwarding to VMs from an internal IP address - Internal TCP/UDP Load Balancing - INTERNAL_MANAGED is used for: - Internal HTTP(S) Load Balancing - INTERNAL_SELF_MANAGED is used for: - Traffic Director For more information about forwarding rules, refer to Forwarding rule concepts.
type GlobalForwardingRuleLoadBalancingScheme pulumi.String

const (
	GlobalForwardingRuleLoadBalancingSchemeExternal            = GlobalForwardingRuleLoadBalancingScheme("EXTERNAL")
	GlobalForwardingRuleLoadBalancingSchemeInternal            = GlobalForwardingRuleLoadBalancingScheme("INTERNAL")
	GlobalForwardingRuleLoadBalancingSchemeInternalManaged     = GlobalForwardingRuleLoadBalancingScheme("INTERNAL_MANAGED")
	GlobalForwardingRuleLoadBalancingSchemeInternalSelfManaged = GlobalForwardingRuleLoadBalancingScheme("INTERNAL_SELF_MANAGED")
	GlobalForwardingRuleLoadBalancingSchemeInvalid             = GlobalForwardingRuleLoadBalancingScheme("INVALID")
)

func (GlobalForwardingRuleLoadBalancingScheme) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e GlobalForwardingRuleLoadBalancingScheme) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e GlobalForwardingRuleLoadBalancingScheme) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e GlobalForwardingRuleLoadBalancingScheme) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e GlobalForwardingRuleLoadBalancingScheme) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// This signifies the networking tier used for configuring this load balancer and can only take the following values: PREMIUM, STANDARD. For regional ForwardingRule, the valid values are PREMIUM and STANDARD. For GlobalForwardingRule, the valid value is PREMIUM. If this field is not specified, it is assumed to be PREMIUM. If IPAddress is specified, this value must be equal to the networkTier of the Address.
type GlobalForwardingRuleNetworkTier pulumi.String

const (
	// High quality, Google-grade network tier, support for all networking products.
	GlobalForwardingRuleNetworkTierPremium = GlobalForwardingRuleNetworkTier("PREMIUM")
	// Public internet quality, only limited support for other networking products.
	GlobalForwardingRuleNetworkTierStandard = GlobalForwardingRuleNetworkTier("STANDARD")
)

func (GlobalForwardingRuleNetworkTier) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e GlobalForwardingRuleNetworkTier) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e GlobalForwardingRuleNetworkTier) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e GlobalForwardingRuleNetworkTier) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e GlobalForwardingRuleNetworkTier) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

type GlobalForwardingRulePscConnectionStatus pulumi.String

const (
	// The connection has been accepted by the producer.
	GlobalForwardingRulePscConnectionStatusAccepted = GlobalForwardingRulePscConnectionStatus("ACCEPTED")
	// The connection has been closed by the producer and will not serve traffic going forward.
	GlobalForwardingRulePscConnectionStatusClosed = GlobalForwardingRulePscConnectionStatus("CLOSED")
	// The connection is pending acceptance by the producer.
	GlobalForwardingRulePscConnectionStatusPending = GlobalForwardingRulePscConnectionStatus("PENDING")
	// The connection has been rejected by the producer.
	GlobalForwardingRulePscConnectionStatusRejected          = GlobalForwardingRulePscConnectionStatus("REJECTED")
	GlobalForwardingRulePscConnectionStatusStatusUnspecified = GlobalForwardingRulePscConnectionStatus("STATUS_UNSPECIFIED")
)

func (GlobalForwardingRulePscConnectionStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e GlobalForwardingRulePscConnectionStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e GlobalForwardingRulePscConnectionStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e GlobalForwardingRulePscConnectionStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e GlobalForwardingRulePscConnectionStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Type of network endpoints in this network endpoint group. Can be one of GCE_VM_IP_PORT, NON_GCP_PRIVATE_IP_PORT, INTERNET_FQDN_PORT, INTERNET_IP_PORT, or SERVERLESS.
type GlobalNetworkEndpointGroupNetworkEndpointType pulumi.String

const (
	// The network endpoint is represented by an IP address.
	GlobalNetworkEndpointGroupNetworkEndpointTypeGceVmIp = GlobalNetworkEndpointGroupNetworkEndpointType("GCE_VM_IP")
	// The network endpoint is represented by IP address and port pair.
	GlobalNetworkEndpointGroupNetworkEndpointTypeGceVmIpPort = GlobalNetworkEndpointGroupNetworkEndpointType("GCE_VM_IP_PORT")
	// The network endpoint is represented by fully qualified domain name and port.
	GlobalNetworkEndpointGroupNetworkEndpointTypeInternetFqdnPort = GlobalNetworkEndpointGroupNetworkEndpointType("INTERNET_FQDN_PORT")
	// The network endpoint is represented by an internet IP address and port.
	GlobalNetworkEndpointGroupNetworkEndpointTypeInternetIpPort = GlobalNetworkEndpointGroupNetworkEndpointType("INTERNET_IP_PORT")
	// The network endpoint is represented by an IP address and port. The endpoint belongs to a VM or pod running in a customer's on-premises.
	GlobalNetworkEndpointGroupNetworkEndpointTypeNonGcpPrivateIpPort = GlobalNetworkEndpointGroupNetworkEndpointType("NON_GCP_PRIVATE_IP_PORT")
	// The network endpoint is handled by specified serverless infrastructure.
	GlobalNetworkEndpointGroupNetworkEndpointTypeServerless = GlobalNetworkEndpointGroupNetworkEndpointType("SERVERLESS")
)

func (GlobalNetworkEndpointGroupNetworkEndpointType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e GlobalNetworkEndpointGroupNetworkEndpointType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e GlobalNetworkEndpointGroupNetworkEndpointType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e GlobalNetworkEndpointGroupNetworkEndpointType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e GlobalNetworkEndpointGroupNetworkEndpointType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] The status of the public delegated prefix.
type GlobalPublicDelegatedPrefixStatus pulumi.String

const (
	GlobalPublicDelegatedPrefixStatusAnnounced    = GlobalPublicDelegatedPrefixStatus("ANNOUNCED")
	GlobalPublicDelegatedPrefixStatusDeleting     = GlobalPublicDelegatedPrefixStatus("DELETING")
	GlobalPublicDelegatedPrefixStatusInitializing = GlobalPublicDelegatedPrefixStatus("INITIALIZING")
)

func (GlobalPublicDelegatedPrefixStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e GlobalPublicDelegatedPrefixStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e GlobalPublicDelegatedPrefixStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e GlobalPublicDelegatedPrefixStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e GlobalPublicDelegatedPrefixStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The ID of a supported feature. Read Enabling guest operating system features to see a list of available options.
type GuestOsFeatureType pulumi.String

const (
	GuestOsFeatureTypeFeatureTypeUnspecified = GuestOsFeatureType("FEATURE_TYPE_UNSPECIFIED")
	GuestOsFeatureTypeGvnic                  = GuestOsFeatureType("GVNIC")
	GuestOsFeatureTypeMultiIpSubnet          = GuestOsFeatureType("MULTI_IP_SUBNET")
	GuestOsFeatureTypeSecureBoot             = GuestOsFeatureType("SECURE_BOOT")
	GuestOsFeatureTypeSevCapable             = GuestOsFeatureType("SEV_CAPABLE")
	GuestOsFeatureTypeUefiCompatible         = GuestOsFeatureType("UEFI_COMPATIBLE")
	GuestOsFeatureTypeVirtioScsiMultiqueue   = GuestOsFeatureType("VIRTIO_SCSI_MULTIQUEUE")
	GuestOsFeatureTypeWindows                = GuestOsFeatureType("WINDOWS")
)

func (GuestOsFeatureType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e GuestOsFeatureType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e GuestOsFeatureType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e GuestOsFeatureType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e GuestOsFeatureType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies how port is selected for health checking, can be one of following values: USE_FIXED_PORT: The port number in port is used for health checking. USE_NAMED_PORT: The portName is used for health checking. USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking. If not specified, HTTP2 health check follows behavior specified in port and portName fields.
type HTTP2HealthCheckPortSpecification pulumi.String

const (
	// The port number in port is used for health checking.
	HTTP2HealthCheckPortSpecificationUseFixedPort = HTTP2HealthCheckPortSpecification("USE_FIXED_PORT")
	// The portName is used for health checking.
	HTTP2HealthCheckPortSpecificationUseNamedPort = HTTP2HealthCheckPortSpecification("USE_NAMED_PORT")
	// For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking.
	HTTP2HealthCheckPortSpecificationUseServingPort = HTTP2HealthCheckPortSpecification("USE_SERVING_PORT")
)

func (HTTP2HealthCheckPortSpecification) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e HTTP2HealthCheckPortSpecification) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e HTTP2HealthCheckPortSpecification) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e HTTP2HealthCheckPortSpecification) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e HTTP2HealthCheckPortSpecification) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
type HTTP2HealthCheckProxyHeader pulumi.String

const (
	HTTP2HealthCheckProxyHeaderNone    = HTTP2HealthCheckProxyHeader("NONE")
	HTTP2HealthCheckProxyHeaderProxyV1 = HTTP2HealthCheckProxyHeader("PROXY_V1")
)

func (HTTP2HealthCheckProxyHeader) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e HTTP2HealthCheckProxyHeader) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e HTTP2HealthCheckProxyHeader) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e HTTP2HealthCheckProxyHeader) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e HTTP2HealthCheckProxyHeader) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies how port is selected for health checking, can be one of following values: USE_FIXED_PORT: The port number in port is used for health checking. USE_NAMED_PORT: The portName is used for health checking. USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking. If not specified, HTTP health check follows behavior specified in port and portName fields.
type HTTPHealthCheckPortSpecification pulumi.String

const (
	// The port number in port is used for health checking.
	HTTPHealthCheckPortSpecificationUseFixedPort = HTTPHealthCheckPortSpecification("USE_FIXED_PORT")
	// The portName is used for health checking.
	HTTPHealthCheckPortSpecificationUseNamedPort = HTTPHealthCheckPortSpecification("USE_NAMED_PORT")
	// For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking.
	HTTPHealthCheckPortSpecificationUseServingPort = HTTPHealthCheckPortSpecification("USE_SERVING_PORT")
)

func (HTTPHealthCheckPortSpecification) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e HTTPHealthCheckPortSpecification) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e HTTPHealthCheckPortSpecification) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e HTTPHealthCheckPortSpecification) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e HTTPHealthCheckPortSpecification) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
type HTTPHealthCheckProxyHeader pulumi.String

const (
	HTTPHealthCheckProxyHeaderNone    = HTTPHealthCheckProxyHeader("NONE")
	HTTPHealthCheckProxyHeaderProxyV1 = HTTPHealthCheckProxyHeader("PROXY_V1")
)

func (HTTPHealthCheckProxyHeader) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e HTTPHealthCheckProxyHeader) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e HTTPHealthCheckProxyHeader) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e HTTPHealthCheckProxyHeader) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e HTTPHealthCheckProxyHeader) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies how port is selected for health checking, can be one of following values: USE_FIXED_PORT: The port number in port is used for health checking. USE_NAMED_PORT: The portName is used for health checking. USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking. If not specified, HTTPS health check follows behavior specified in port and portName fields.
type HTTPSHealthCheckPortSpecification pulumi.String

const (
	// The port number in port is used for health checking.
	HTTPSHealthCheckPortSpecificationUseFixedPort = HTTPSHealthCheckPortSpecification("USE_FIXED_PORT")
	// The portName is used for health checking.
	HTTPSHealthCheckPortSpecificationUseNamedPort = HTTPSHealthCheckPortSpecification("USE_NAMED_PORT")
	// For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking.
	HTTPSHealthCheckPortSpecificationUseServingPort = HTTPSHealthCheckPortSpecification("USE_SERVING_PORT")
)

func (HTTPSHealthCheckPortSpecification) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e HTTPSHealthCheckPortSpecification) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e HTTPSHealthCheckPortSpecification) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e HTTPSHealthCheckPortSpecification) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e HTTPSHealthCheckPortSpecification) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
type HTTPSHealthCheckProxyHeader pulumi.String

const (
	HTTPSHealthCheckProxyHeaderNone    = HTTPSHealthCheckProxyHeader("NONE")
	HTTPSHealthCheckProxyHeaderProxyV1 = HTTPSHealthCheckProxyHeader("PROXY_V1")
)

func (HTTPSHealthCheckProxyHeader) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e HTTPSHealthCheckProxyHeader) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e HTTPSHealthCheckProxyHeader) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e HTTPSHealthCheckProxyHeader) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e HTTPSHealthCheckProxyHeader) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies the type of the healthCheck, either TCP, SSL, HTTP, HTTPS or HTTP2. If not specified, the default is TCP. Exactly one of the protocol-specific health check field must be specified, which must match type field.
type HealthCheckType pulumi.String

const (
	HealthCheckTypeGrpc    = HealthCheckType("GRPC")
	HealthCheckTypeHttp    = HealthCheckType("HTTP")
	HealthCheckTypeHttp2   = HealthCheckType("HTTP2")
	HealthCheckTypeHttps   = HealthCheckType("HTTPS")
	HealthCheckTypeInvalid = HealthCheckType("INVALID")
	HealthCheckTypeSsl     = HealthCheckType("SSL")
	HealthCheckTypeTcp     = HealthCheckType("TCP")
)

func (HealthCheckType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e HealthCheckType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e HealthCheckType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e HealthCheckType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e HealthCheckType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The HTTP Status code to use for this RedirectAction. Supported values are: - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301. - FOUND, which corresponds to 302. - SEE_OTHER which corresponds to 303. - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method will be retained. - PERMANENT_REDIRECT, which corresponds to 308. In this case, the request method will be retained.
type HttpRedirectActionRedirectResponseCode pulumi.String

const (
	// Http Status Code 302 - Found.
	HttpRedirectActionRedirectResponseCodeFound = HttpRedirectActionRedirectResponseCode("FOUND")
	// Http Status Code 301 - Moved Permanently.
	HttpRedirectActionRedirectResponseCodeMovedPermanentlyDefault = HttpRedirectActionRedirectResponseCode("MOVED_PERMANENTLY_DEFAULT")
	// Http Status Code 308 - Permanent Redirect maintaining HTTP method.
	HttpRedirectActionRedirectResponseCodePermanentRedirect = HttpRedirectActionRedirectResponseCode("PERMANENT_REDIRECT")
	// Http Status Code 303 - See Other.
	HttpRedirectActionRedirectResponseCodeSeeOther = HttpRedirectActionRedirectResponseCode("SEE_OTHER")
	// Http Status Code 307 - Temporary Redirect maintaining HTTP method.
	HttpRedirectActionRedirectResponseCodeTemporaryRedirect = HttpRedirectActionRedirectResponseCode("TEMPORARY_REDIRECT")
)

func (HttpRedirectActionRedirectResponseCode) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e HttpRedirectActionRedirectResponseCode) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e HttpRedirectActionRedirectResponseCode) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e HttpRedirectActionRedirectResponseCode) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e HttpRedirectActionRedirectResponseCode) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The format used to encode and transmit the block device, which should be TAR. This is just a container and transmission format and not a runtime format. Provided by the client when the disk image is created.
type ImageRawDiskContainerType pulumi.String

const (
	ImageRawDiskContainerTypeTar = ImageRawDiskContainerType("TAR")
)

func (ImageRawDiskContainerType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e ImageRawDiskContainerType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e ImageRawDiskContainerType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e ImageRawDiskContainerType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e ImageRawDiskContainerType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The type of the image used to create this disk. The default and only value is RAW
type ImageSourceType pulumi.String

const (
	ImageSourceTypeRaw = ImageSourceType("RAW")
)

func (ImageSourceType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e ImageSourceType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e ImageSourceType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e ImageSourceType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e ImageSourceType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] The status of the image. An image can be used to create other resources, such as instances, only after the image has been successfully created and the status is set to READY. Possible values are FAILED, PENDING, or READY.
type ImageStatus pulumi.String

const (
	// Image is deleting.
	ImageStatusDeleting = ImageStatus("DELETING")
	// Image creation failed due to an error.
	ImageStatusFailed = ImageStatus("FAILED")
	// Image hasn't been created as yet.
	ImageStatusPending = ImageStatus("PENDING")
	// Image has been successfully created.
	ImageStatusReady = ImageStatus("READY")
)

func (ImageStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e ImageStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e ImageStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e ImageStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e ImageStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The action to perform in case of zone failure. Only one value is supported, NO_FAILOVER. The default is NO_FAILOVER.
type InstanceGroupManagerFailoverAction pulumi.String

const (
	InstanceGroupManagerFailoverActionNoFailover = InstanceGroupManagerFailoverAction("NO_FAILOVER")
	InstanceGroupManagerFailoverActionUnknown    = InstanceGroupManagerFailoverAction("UNKNOWN")
)

func (InstanceGroupManagerFailoverAction) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e InstanceGroupManagerFailoverAction) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e InstanceGroupManagerFailoverAction) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e InstanceGroupManagerFailoverAction) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e InstanceGroupManagerFailoverAction) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The instance redistribution policy for regional managed instance groups. Valid values are: - PROACTIVE (default): The group attempts to maintain an even distribution of VM instances across zones in the region. - NONE: For non-autoscaled groups, proactive redistribution is disabled.
type InstanceGroupManagerUpdatePolicyInstanceRedistributionType pulumi.String

const (
	// No action is being proactively performed in order to bring this IGM to its target instance distribution.
	InstanceGroupManagerUpdatePolicyInstanceRedistributionTypeNone = InstanceGroupManagerUpdatePolicyInstanceRedistributionType("NONE")
	// This IGM will actively converge to its target instance distribution.
	InstanceGroupManagerUpdatePolicyInstanceRedistributionTypeProactive = InstanceGroupManagerUpdatePolicyInstanceRedistributionType("PROACTIVE")
)

func (InstanceGroupManagerUpdatePolicyInstanceRedistributionType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e InstanceGroupManagerUpdatePolicyInstanceRedistributionType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e InstanceGroupManagerUpdatePolicyInstanceRedistributionType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e InstanceGroupManagerUpdatePolicyInstanceRedistributionType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e InstanceGroupManagerUpdatePolicyInstanceRedistributionType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Minimal action to be taken on an instance. You can specify either RESTART to restart existing instances or REPLACE to delete and create new instances from the target template. If you specify a RESTART, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
type InstanceGroupManagerUpdatePolicyMinimalAction pulumi.String

const (
	// Do not perform any action.
	InstanceGroupManagerUpdatePolicyMinimalActionNone = InstanceGroupManagerUpdatePolicyMinimalAction("NONE")
	// Updates applied in runtime, instances will not be disrupted.
	InstanceGroupManagerUpdatePolicyMinimalActionRefresh = InstanceGroupManagerUpdatePolicyMinimalAction("REFRESH")
	// Old instances will be deleted. New instances will be created from the target template.
	InstanceGroupManagerUpdatePolicyMinimalActionReplace = InstanceGroupManagerUpdatePolicyMinimalAction("REPLACE")
	// Every instance will be restarted.
	InstanceGroupManagerUpdatePolicyMinimalActionRestart = InstanceGroupManagerUpdatePolicyMinimalAction("RESTART")
)

func (InstanceGroupManagerUpdatePolicyMinimalAction) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e InstanceGroupManagerUpdatePolicyMinimalAction) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e InstanceGroupManagerUpdatePolicyMinimalAction) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e InstanceGroupManagerUpdatePolicyMinimalAction) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e InstanceGroupManagerUpdatePolicyMinimalAction) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Most disruptive action that is allowed to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to allow actions that do not need instance restart, RESTART to allow actions that can be applied without instance replacing or REPLACE to allow all possible actions. If the Updater determines that the minimal update action needed is more disruptive than most disruptive allowed action you specify it will not perform the update at all.
type InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction pulumi.String

const (
	// Do not perform any action.
	InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedActionNone = InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction("NONE")
	// Updates applied in runtime, instances will not be disrupted.
	InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedActionRefresh = InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction("REFRESH")
	// Old instances will be deleted. New instances will be created from the target template.
	InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedActionReplace = InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction("REPLACE")
	// Every instance will be restarted.
	InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedActionRestart = InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction("RESTART")
)

func (InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e InstanceGroupManagerUpdatePolicyMostDisruptiveAllowedAction) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// What action should be used to replace instances. See minimal_action.REPLACE
type InstanceGroupManagerUpdatePolicyReplacementMethod pulumi.String

const (
	// Instances will be recreated (with the same name)
	InstanceGroupManagerUpdatePolicyReplacementMethodRecreate = InstanceGroupManagerUpdatePolicyReplacementMethod("RECREATE")
	// Default option: instances will be deleted and created (with a new name)
	InstanceGroupManagerUpdatePolicyReplacementMethodSubstitute = InstanceGroupManagerUpdatePolicyReplacementMethod("SUBSTITUTE")
)

func (InstanceGroupManagerUpdatePolicyReplacementMethod) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e InstanceGroupManagerUpdatePolicyReplacementMethod) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e InstanceGroupManagerUpdatePolicyReplacementMethod) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e InstanceGroupManagerUpdatePolicyReplacementMethod) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e InstanceGroupManagerUpdatePolicyReplacementMethod) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The type of update process. You can specify either PROACTIVE so that the instance group manager proactively executes actions in order to bring instances to their target versions or OPPORTUNISTIC so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
type InstanceGroupManagerUpdatePolicyType pulumi.String

const (
	// No action is being proactively performed in order to bring this IGM to its target version distribution (regardless of whether this distribution is expressed using instanceTemplate or versions field).
	InstanceGroupManagerUpdatePolicyTypeOpportunistic = InstanceGroupManagerUpdatePolicyType("OPPORTUNISTIC")
	// This IGM will actively converge to its target version distribution (regardless of whether this distribution is expressed using instanceTemplate or versions field).
	InstanceGroupManagerUpdatePolicyTypeProactive = InstanceGroupManagerUpdatePolicyType("PROACTIVE")
)

func (InstanceGroupManagerUpdatePolicyType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e InstanceGroupManagerUpdatePolicyType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e InstanceGroupManagerUpdatePolicyType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e InstanceGroupManagerUpdatePolicyType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e InstanceGroupManagerUpdatePolicyType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// PostKeyRevocationActionType of the instance.
type InstancePostKeyRevocationActionType pulumi.String

const (
	// Indicates user chose no operation.
	InstancePostKeyRevocationActionTypeNoop = InstancePostKeyRevocationActionType("NOOP")
	// Default value. This value is unused.
	InstancePostKeyRevocationActionTypePostKeyRevocationActionTypeUnspecified = InstancePostKeyRevocationActionType("POST_KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED")
	// Indicates user chose to opt for VM shutdown on key revocation.
	InstancePostKeyRevocationActionTypeShutdown = InstancePostKeyRevocationActionType("SHUTDOWN")
)

func (InstancePostKeyRevocationActionType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e InstancePostKeyRevocationActionType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e InstancePostKeyRevocationActionType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e InstancePostKeyRevocationActionType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e InstancePostKeyRevocationActionType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The private IPv6 google access type for the VM. If not specified, use INHERIT_FROM_SUBNETWORK as default.
type InstancePrivateIpv6GoogleAccess pulumi.String

const (
	// Bidirectional private IPv6 access to/from Google services. If specified, the subnetwork who is attached to the instance's default network interface will be assigned an internal IPv6 prefix if it doesn't have before.
	InstancePrivateIpv6GoogleAccessEnableBidirectionalAccessToGoogle = InstancePrivateIpv6GoogleAccess("ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE")
	// Outbound private IPv6 access from VMs in this subnet to Google services. If specified, the subnetwork who is attached to the instance's default network interface will be assigned an internal IPv6 prefix if it doesn't have before.
	InstancePrivateIpv6GoogleAccessEnableOutboundVmAccessToGoogle = InstancePrivateIpv6GoogleAccess("ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE")
	// Each network interface inherits PrivateIpv6GoogleAccess from its subnetwork.
	InstancePrivateIpv6GoogleAccessInheritFromSubnetwork = InstancePrivateIpv6GoogleAccess("INHERIT_FROM_SUBNETWORK")
)

func (InstancePrivateIpv6GoogleAccess) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e InstancePrivateIpv6GoogleAccess) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e InstancePrivateIpv6GoogleAccess) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e InstancePrivateIpv6GoogleAccess) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e InstancePrivateIpv6GoogleAccess) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// PostKeyRevocationActionType of the instance.
type InstancePropertiesPostKeyRevocationActionType pulumi.String

const (
	// Indicates user chose no operation.
	InstancePropertiesPostKeyRevocationActionTypeNoop = InstancePropertiesPostKeyRevocationActionType("NOOP")
	// Default value. This value is unused.
	InstancePropertiesPostKeyRevocationActionTypePostKeyRevocationActionTypeUnspecified = InstancePropertiesPostKeyRevocationActionType("POST_KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED")
	// Indicates user chose to opt for VM shutdown on key revocation.
	InstancePropertiesPostKeyRevocationActionTypeShutdown = InstancePropertiesPostKeyRevocationActionType("SHUTDOWN")
)

func (InstancePropertiesPostKeyRevocationActionType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e InstancePropertiesPostKeyRevocationActionType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e InstancePropertiesPostKeyRevocationActionType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e InstancePropertiesPostKeyRevocationActionType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e InstancePropertiesPostKeyRevocationActionType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The private IPv6 google access type for VMs. If not specified, use INHERIT_FROM_SUBNETWORK as default.
type InstancePropertiesPrivateIpv6GoogleAccess pulumi.String

const (
	// Bidirectional private IPv6 access to/from Google services. If specified, the subnetwork who is attached to the instance's default network interface will be assigned an internal IPv6 prefix if it doesn't have before.
	InstancePropertiesPrivateIpv6GoogleAccessEnableBidirectionalAccessToGoogle = InstancePropertiesPrivateIpv6GoogleAccess("ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE")
	// Outbound private IPv6 access from VMs in this subnet to Google services. If specified, the subnetwork who is attached to the instance's default network interface will be assigned an internal IPv6 prefix if it doesn't have before.
	InstancePropertiesPrivateIpv6GoogleAccessEnableOutboundVmAccessToGoogle = InstancePropertiesPrivateIpv6GoogleAccess("ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE")
	// Each network interface inherits PrivateIpv6GoogleAccess from its subnetwork.
	InstancePropertiesPrivateIpv6GoogleAccessInheritFromSubnetwork = InstancePropertiesPrivateIpv6GoogleAccess("INHERIT_FROM_SUBNETWORK")
)

func (InstancePropertiesPrivateIpv6GoogleAccess) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e InstancePropertiesPrivateIpv6GoogleAccess) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e InstancePropertiesPrivateIpv6GoogleAccess) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e InstancePropertiesPrivateIpv6GoogleAccess) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e InstancePropertiesPrivateIpv6GoogleAccess) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] The status of the instance. One of the following values: PROVISIONING, STAGING, RUNNING, STOPPING, SUSPENDING, SUSPENDED, REPAIRING, and TERMINATED. For more information about the status of the instance, see Instance life cycle.
type InstanceStatus pulumi.String

const (
	// The Nanny is halted and we are performing tear down tasks like network deprogramming, releasing quota, IP, tearing down disks etc.
	InstanceStatusDeprovisioning = InstanceStatus("DEPROVISIONING")
	// Resources are being allocated for the instance.
	InstanceStatusProvisioning = InstanceStatus("PROVISIONING")
	// The instance is in repair.
	InstanceStatusRepairing = InstanceStatus("REPAIRING")
	// The instance is running.
	InstanceStatusRunning = InstanceStatus("RUNNING")
	// All required resources have been allocated and the instance is being started.
	InstanceStatusStaging = InstanceStatus("STAGING")
	// The instance has stopped successfully.
	InstanceStatusStopped = InstanceStatus("STOPPED")
	// The instance is currently stopping (either being deleted or killed).
	InstanceStatusStopping = InstanceStatus("STOPPING")
	// The instance has suspended.
	InstanceStatusSuspended = InstanceStatus("SUSPENDED")
	// The instance is suspending.
	InstanceStatusSuspending = InstanceStatus("SUSPENDING")
	// The instance has stopped (either by explicit action or underlying failure).
	InstanceStatusTerminated = InstanceStatus("TERMINATED")
)

func (InstanceStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e InstanceStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e InstanceStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e InstanceStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e InstanceStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Provisioned bandwidth capacity for the interconnect attachment. For attachments of type DEDICATED, the user can set the bandwidth. For attachments of type PARTNER, the Google Partner that is operating the interconnect must set the bandwidth. Output only for PARTNER type, mutable for PARTNER_PROVIDER and DEDICATED, and can take one of the following values: - BPS_50M: 50 Mbit/s - BPS_100M: 100 Mbit/s - BPS_200M: 200 Mbit/s - BPS_300M: 300 Mbit/s - BPS_400M: 400 Mbit/s - BPS_500M: 500 Mbit/s - BPS_1G: 1 Gbit/s - BPS_2G: 2 Gbit/s - BPS_5G: 5 Gbit/s - BPS_10G: 10 Gbit/s - BPS_20G: 20 Gbit/s - BPS_50G: 50 Gbit/s
type InterconnectAttachmentBandwidth pulumi.String

const (
	// 100 Mbit/s
	InterconnectAttachmentBandwidthBps100m = InterconnectAttachmentBandwidth("BPS_100M")
	// 10 Gbit/s
	InterconnectAttachmentBandwidthBps10g = InterconnectAttachmentBandwidth("BPS_10G")
	// 1 Gbit/s
	InterconnectAttachmentBandwidthBps1g = InterconnectAttachmentBandwidth("BPS_1G")
	// 200 Mbit/s
	InterconnectAttachmentBandwidthBps200m = InterconnectAttachmentBandwidth("BPS_200M")
	// 20 Gbit/s
	InterconnectAttachmentBandwidthBps20g = InterconnectAttachmentBandwidth("BPS_20G")
	// 2 Gbit/s
	InterconnectAttachmentBandwidthBps2g = InterconnectAttachmentBandwidth("BPS_2G")
	// 300 Mbit/s
	InterconnectAttachmentBandwidthBps300m = InterconnectAttachmentBandwidth("BPS_300M")
	// 400 Mbit/s
	InterconnectAttachmentBandwidthBps400m = InterconnectAttachmentBandwidth("BPS_400M")
	// 500 Mbit/s
	InterconnectAttachmentBandwidthBps500m = InterconnectAttachmentBandwidth("BPS_500M")
	// 50 Gbit/s
	InterconnectAttachmentBandwidthBps50g = InterconnectAttachmentBandwidth("BPS_50G")
	// 50 Mbit/s
	InterconnectAttachmentBandwidthBps50m = InterconnectAttachmentBandwidth("BPS_50M")
	// 5 Gbit/s
	InterconnectAttachmentBandwidthBps5g = InterconnectAttachmentBandwidth("BPS_5G")
)

func (InterconnectAttachmentBandwidth) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e InterconnectAttachmentBandwidth) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e InterconnectAttachmentBandwidth) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e InterconnectAttachmentBandwidth) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e InterconnectAttachmentBandwidth) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Desired availability domain for the attachment. Only available for type PARTNER, at creation time, and can take one of the following values: - AVAILABILITY_DOMAIN_ANY - AVAILABILITY_DOMAIN_1 - AVAILABILITY_DOMAIN_2 For improved reliability, customers should configure a pair of attachments, one per availability domain. The selected availability domain will be provided to the Partner via the pairing key, so that the provisioned circuit will lie in the specified domain. If not specified, the value will default to AVAILABILITY_DOMAIN_ANY.
type InterconnectAttachmentEdgeAvailabilityDomain pulumi.String

const (
	InterconnectAttachmentEdgeAvailabilityDomainAvailabilityDomain1   = InterconnectAttachmentEdgeAvailabilityDomain("AVAILABILITY_DOMAIN_1")
	InterconnectAttachmentEdgeAvailabilityDomainAvailabilityDomain2   = InterconnectAttachmentEdgeAvailabilityDomain("AVAILABILITY_DOMAIN_2")
	InterconnectAttachmentEdgeAvailabilityDomainAvailabilityDomainAny = InterconnectAttachmentEdgeAvailabilityDomain("AVAILABILITY_DOMAIN_ANY")
)

func (InterconnectAttachmentEdgeAvailabilityDomain) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e InterconnectAttachmentEdgeAvailabilityDomain) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e InterconnectAttachmentEdgeAvailabilityDomain) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e InterconnectAttachmentEdgeAvailabilityDomain) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e InterconnectAttachmentEdgeAvailabilityDomain) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Indicates the user-supplied encryption option of this VLAN attachment (interconnectAttachment). Can only be specified at attachment creation for PARTNER or DEDICATED attachments. Possible values are: - NONE - This is the default value, which means that the VLAN attachment carries unencrypted traffic. VMs are able to send traffic to, or receive traffic from, such a VLAN attachment. - IPSEC - The VLAN attachment carries only encrypted traffic that is encrypted by an IPsec device, such as an HA VPN gateway or third-party IPsec VPN. VMs cannot directly send traffic to, or receive traffic from, such a VLAN attachment. To use *IPsec-encrypted Cloud Interconnect*, the VLAN attachment must be created with this option. Not currently available publicly.
type InterconnectAttachmentEncryption pulumi.String

const (
	// The interconnect attachment will carry only encrypted traffic that is encrypted by an IPsec device such as HA VPN gateway; VMs cannot directly send traffic to or receive traffic from such an interconnect attachment. To use IPsec-encrypted Cloud Interconnect, the interconnect attachment must be created with this option.
	InterconnectAttachmentEncryptionIpsec = InterconnectAttachmentEncryption("IPSEC")
	// This is the default value, which means the Interconnect Attachment will carry unencrypted traffic. VMs will be able to send traffic to or receive traffic from such interconnect attachment.
	InterconnectAttachmentEncryptionNone = InterconnectAttachmentEncryption("NONE")
)

func (InterconnectAttachmentEncryption) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e InterconnectAttachmentEncryption) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e InterconnectAttachmentEncryption) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e InterconnectAttachmentEncryption) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e InterconnectAttachmentEncryption) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] The current status of whether or not this interconnect attachment is functional, which can take one of the following values: - OS_ACTIVE: The attachment has been turned up and is ready to use. - OS_UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete.
type InterconnectAttachmentOperationalStatus pulumi.String

const (
	// Indicates that attachment has been turned up and is ready to use.
	InterconnectAttachmentOperationalStatusOsActive = InterconnectAttachmentOperationalStatus("OS_ACTIVE")
	// Indicates that attachment is not ready to use yet, because turnup is not complete.
	InterconnectAttachmentOperationalStatusOsUnprovisioned = InterconnectAttachmentOperationalStatus("OS_UNPROVISIONED")
)

func (InterconnectAttachmentOperationalStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e InterconnectAttachmentOperationalStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e InterconnectAttachmentOperationalStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e InterconnectAttachmentOperationalStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e InterconnectAttachmentOperationalStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] The current state of this attachment's functionality. Enum values ACTIVE and UNPROVISIONED are shared by DEDICATED/PRIVATE, PARTNER, and PARTNER_PROVIDER interconnect attachments, while enum values PENDING_PARTNER, PARTNER_REQUEST_RECEIVED, and PENDING_CUSTOMER are used for only PARTNER and PARTNER_PROVIDER interconnect attachments. This state can take one of the following values: - ACTIVE: The attachment has been turned up and is ready to use. - UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete. - PENDING_PARTNER: A newly-created PARTNER attachment that has not yet been configured on the Partner side. - PARTNER_REQUEST_RECEIVED: A PARTNER attachment is in the process of provisioning after a PARTNER_PROVIDER attachment was created that references it. - PENDING_CUSTOMER: A PARTNER or PARTNER_PROVIDER attachment that is waiting for a customer to activate it. - DEFUNCT: The attachment was deleted externally and is no longer functional. This could be because the associated Interconnect was removed, or because the other side of a Partner attachment was deleted.
type InterconnectAttachmentStateEnum pulumi.String

const (
	// Indicates that attachment has been turned up and is ready to use.
	InterconnectAttachmentStateEnumActive = InterconnectAttachmentStateEnum("ACTIVE")
	// The attachment was deleted externally and is no longer functional. This could be because the associated Interconnect was wiped out, or because the other side of a Partner attachment was deleted.
	InterconnectAttachmentStateEnumDefunct = InterconnectAttachmentStateEnum("DEFUNCT")
	// A PARTNER attachment is in the process of provisioning after a PARTNER_PROVIDER attachment was created that references it.
	InterconnectAttachmentStateEnumPartnerRequestReceived = InterconnectAttachmentStateEnum("PARTNER_REQUEST_RECEIVED")
	// PARTNER or PARTNER_PROVIDER attachment that is waiting for the customer to activate.
	InterconnectAttachmentStateEnumPendingCustomer = InterconnectAttachmentStateEnum("PENDING_CUSTOMER")
	// A newly created PARTNER attachment that has not yet been configured on the Partner side.
	InterconnectAttachmentStateEnumPendingPartner   = InterconnectAttachmentStateEnum("PENDING_PARTNER")
	InterconnectAttachmentStateEnumStateUnspecified = InterconnectAttachmentStateEnum("STATE_UNSPECIFIED")
	// Indicates that attachment is not ready to use yet, because turnup is not complete.
	InterconnectAttachmentStateEnumUnprovisioned = InterconnectAttachmentStateEnum("UNPROVISIONED")
)

func (InterconnectAttachmentStateEnum) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e InterconnectAttachmentStateEnum) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e InterconnectAttachmentStateEnum) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e InterconnectAttachmentStateEnum) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e InterconnectAttachmentStateEnum) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The type of interconnect attachment this is, which can take one of the following values: - DEDICATED: an attachment to a Dedicated Interconnect. - PARTNER: an attachment to a Partner Interconnect, created by the customer. - PARTNER_PROVIDER: an attachment to a Partner Interconnect, created by the partner.
type InterconnectAttachmentType pulumi.String

const (
	// Attachment to a dedicated interconnect.
	InterconnectAttachmentTypeDedicated = InterconnectAttachmentType("DEDICATED")
	// Attachment to a partner interconnect, created by the customer.
	InterconnectAttachmentTypePartner = InterconnectAttachmentType("PARTNER")
	// Attachment to a partner interconnect, created by the partner.
	InterconnectAttachmentTypePartnerProvider = InterconnectAttachmentType("PARTNER_PROVIDER")
)

func (InterconnectAttachmentType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e InterconnectAttachmentType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e InterconnectAttachmentType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e InterconnectAttachmentType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e InterconnectAttachmentType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Type of interconnect, which can take one of the following values: - PARTNER: A partner-managed interconnection shared between customers though a partner. - DEDICATED: A dedicated physical interconnection with the customer. Note that a value IT_PRIVATE has been deprecated in favor of DEDICATED.
type InterconnectInterconnectType pulumi.String

const (
	// A dedicated physical interconnection with the customer.
	InterconnectInterconnectTypeDedicated = InterconnectInterconnectType("DEDICATED")
	// [Deprecated] A private, physical interconnection with the customer.
	InterconnectInterconnectTypeItPrivate = InterconnectInterconnectType("IT_PRIVATE")
	// A partner-managed interconnection shared between customers via partner.
	InterconnectInterconnectTypePartner = InterconnectInterconnectType("PARTNER")
)

func (InterconnectInterconnectType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e InterconnectInterconnectType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e InterconnectInterconnectType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e InterconnectInterconnectType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e InterconnectInterconnectType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Type of link requested, which can take one of the following values: - LINK_TYPE_ETHERNET_10G_LR: A 10G Ethernet with LR optics - LINK_TYPE_ETHERNET_100G_LR: A 100G Ethernet with LR optics. Note that this field indicates the speed of each of the links in the bundle, not the speed of the entire bundle.
type InterconnectLinkType pulumi.String

const (
	// 100G Ethernet, LR Optics.
	InterconnectLinkTypeLinkTypeEthernet100gLr = InterconnectLinkType("LINK_TYPE_ETHERNET_100G_LR")
	// 10G Ethernet, LR Optics. [(rate_bps) = 10000000000];
	InterconnectLinkTypeLinkTypeEthernet10gLr = InterconnectLinkType("LINK_TYPE_ETHERNET_10G_LR")
)

func (InterconnectLinkType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e InterconnectLinkType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e InterconnectLinkType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e InterconnectLinkType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e InterconnectLinkType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] The current status of this Interconnect's functionality, which can take one of the following values: - OS_ACTIVE: A valid Interconnect, which is turned up and is ready to use. Attachments may be provisioned on this Interconnect. - OS_UNPROVISIONED: An Interconnect that has not completed turnup. No attachments may be provisioned on this Interconnect. - OS_UNDER_MAINTENANCE: An Interconnect that is undergoing internal maintenance. No attachments may be provisioned or updated on this Interconnect.
type InterconnectOperationalStatus pulumi.String

const (
	// The interconnect is valid, turned up, and ready to use. Attachments may be provisioned on this interconnect.
	InterconnectOperationalStatusOsActive = InterconnectOperationalStatus("OS_ACTIVE")
	// The interconnect has not completed turnup. No attachments may be provisioned on this interconnect.
	InterconnectOperationalStatusOsUnprovisioned = InterconnectOperationalStatus("OS_UNPROVISIONED")
)

func (InterconnectOperationalStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e InterconnectOperationalStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e InterconnectOperationalStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e InterconnectOperationalStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e InterconnectOperationalStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Form this outage is expected to take, which can take one of the following values: - OUTAGE: The Interconnect may be completely out of service for some or all of the specified window. - PARTIAL_OUTAGE: Some circuits comprising the Interconnect as a whole should remain up, but with reduced bandwidth. Note that the versions of this enum prefixed with "IT_" have been deprecated in favor of the unprefixed values.
type InterconnectOutageNotificationIssueType pulumi.String

const (
	// [Deprecated] The Interconnect may be completely out of service for some or all of the specified window.
	InterconnectOutageNotificationIssueTypeItOutage = InterconnectOutageNotificationIssueType("IT_OUTAGE")
	// [Deprecated] Some circuits comprising the Interconnect will be out of service during the expected window. The interconnect as a whole should remain up, albeit with reduced bandwidth.
	InterconnectOutageNotificationIssueTypeItPartialOutage = InterconnectOutageNotificationIssueType("IT_PARTIAL_OUTAGE")
	// The Interconnect may be completely out of service for some or all of the specified window.
	InterconnectOutageNotificationIssueTypeOutage = InterconnectOutageNotificationIssueType("OUTAGE")
	// Some circuits comprising the Interconnect will be out of service during the expected window. The interconnect as a whole should remain up, albeit with reduced bandwidth.
	InterconnectOutageNotificationIssueTypePartialOutage = InterconnectOutageNotificationIssueType("PARTIAL_OUTAGE")
)

func (InterconnectOutageNotificationIssueType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e InterconnectOutageNotificationIssueType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e InterconnectOutageNotificationIssueType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e InterconnectOutageNotificationIssueType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e InterconnectOutageNotificationIssueType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The party that generated this notification, which can take the following value: - GOOGLE: this notification as generated by Google. Note that the value of NSRC_GOOGLE has been deprecated in favor of GOOGLE.
type InterconnectOutageNotificationSource pulumi.String

const (
	// This notification was generated by Google.
	InterconnectOutageNotificationSourceGoogle = InterconnectOutageNotificationSource("GOOGLE")
	// [Deprecated] This notification was generated by Google.
	InterconnectOutageNotificationSourceNsrcGoogle = InterconnectOutageNotificationSource("NSRC_GOOGLE")
)

func (InterconnectOutageNotificationSource) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e InterconnectOutageNotificationSource) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e InterconnectOutageNotificationSource) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e InterconnectOutageNotificationSource) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e InterconnectOutageNotificationSource) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// State of this notification, which can take one of the following values: - ACTIVE: This outage notification is active. The event could be in the past, present, or future. See start_time and end_time for scheduling. - CANCELLED: The outage associated with this notification was cancelled before the outage was due to start. - COMPLETED: The outage associated with this notification is complete. Note that the versions of this enum prefixed with "NS_" have been deprecated in favor of the unprefixed values.
type InterconnectOutageNotificationState pulumi.String

const (
	// This outage notification is active. The event could be in the future, present, or past. See start_time and end_time for scheduling.
	InterconnectOutageNotificationStateActive = InterconnectOutageNotificationState("ACTIVE")
	// The outage associated with this notification was cancelled before the outage was due to start.
	InterconnectOutageNotificationStateCancelled = InterconnectOutageNotificationState("CANCELLED")
	// The outage associated with this notification is complete.
	InterconnectOutageNotificationStateCompleted = InterconnectOutageNotificationState("COMPLETED")
	// [Deprecated] This outage notification is active. The event could be in the future, present, or past. See start_time and end_time for scheduling.
	InterconnectOutageNotificationStateNsActive = InterconnectOutageNotificationState("NS_ACTIVE")
	// [Deprecated] The outage associated with this notification was canceled before the outage was due to start.
	InterconnectOutageNotificationStateNsCanceled = InterconnectOutageNotificationState("NS_CANCELED")
)

func (InterconnectOutageNotificationState) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e InterconnectOutageNotificationState) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e InterconnectOutageNotificationState) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e InterconnectOutageNotificationState) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e InterconnectOutageNotificationState) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] The current state of Interconnect functionality, which can take one of the following values: - ACTIVE: The Interconnect is valid, turned up and ready to use. Attachments may be provisioned on this Interconnect. - UNPROVISIONED: The Interconnect has not completed turnup. No attachments may be provisioned on this Interconnect. - UNDER_MAINTENANCE: The Interconnect is undergoing internal maintenance. No attachments may be provisioned or updated on this Interconnect.
type InterconnectStateEnum pulumi.String

const (
	// The interconnect is valid, turned up, and ready to use. Attachments may be provisioned on this interconnect.
	InterconnectStateEnumActive = InterconnectStateEnum("ACTIVE")
	// The interconnect has not completed turnup. No attachments may be provisioned on this interconnect.
	InterconnectStateEnumUnprovisioned = InterconnectStateEnum("UNPROVISIONED")
)

func (InterconnectStateEnum) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e InterconnectStateEnum) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e InterconnectStateEnum) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e InterconnectStateEnum) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e InterconnectStateEnum) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// This is deprecated and has no effect. Do not use.
type LogConfigCloudAuditOptionsLogName pulumi.String

const (
	// This is deprecated and has no effect. Do not use.
	LogConfigCloudAuditOptionsLogNameAdminActivity = LogConfigCloudAuditOptionsLogName("ADMIN_ACTIVITY")
	// This is deprecated and has no effect. Do not use.
	LogConfigCloudAuditOptionsLogNameDataAccess = LogConfigCloudAuditOptionsLogName("DATA_ACCESS")
	// This is deprecated and has no effect. Do not use.
	LogConfigCloudAuditOptionsLogNameUnspecifiedLogName = LogConfigCloudAuditOptionsLogName("UNSPECIFIED_LOG_NAME")
)

func (LogConfigCloudAuditOptionsLogName) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e LogConfigCloudAuditOptionsLogName) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e LogConfigCloudAuditOptionsLogName) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e LogConfigCloudAuditOptionsLogName) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e LogConfigCloudAuditOptionsLogName) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// This is deprecated and has no effect. Do not use.
type LogConfigDataAccessOptionsLogMode pulumi.String

const (
	// This is deprecated and has no effect. Do not use.
	LogConfigDataAccessOptionsLogModeLogFailClosed = LogConfigDataAccessOptionsLogMode("LOG_FAIL_CLOSED")
	// This is deprecated and has no effect. Do not use.
	LogConfigDataAccessOptionsLogModeLogModeUnspecified = LogConfigDataAccessOptionsLogMode("LOG_MODE_UNSPECIFIED")
)

func (LogConfigDataAccessOptionsLogMode) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e LogConfigDataAccessOptionsLogMode) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e LogConfigDataAccessOptionsLogMode) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e LogConfigDataAccessOptionsLogMode) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e LogConfigDataAccessOptionsLogMode) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] The status of the machine image. One of the following values: INVALID, CREATING, READY, DELETING, and UPLOADING.
type MachineImageStatus pulumi.String

const (
	MachineImageStatusCreating  = MachineImageStatus("CREATING")
	MachineImageStatusDeleting  = MachineImageStatus("DELETING")
	MachineImageStatusInvalid   = MachineImageStatus("INVALID")
	MachineImageStatusReady     = MachineImageStatus("READY")
	MachineImageStatusUploading = MachineImageStatus("UPLOADING")
)

func (MachineImageStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e MachineImageStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e MachineImageStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e MachineImageStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e MachineImageStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies how individual filterLabel matches within the list of filterLabels contribute towards the overall metadataFilter match. Supported values are: - MATCH_ANY: At least one of the filterLabels must have a matching label in the provided metadata. - MATCH_ALL: All filterLabels must have matching labels in the provided metadata.
type MetadataFilterFilterMatchCriteria pulumi.String

const (
	// Specifies that all filterLabels must match for the metadataFilter to be considered a match.
	MetadataFilterFilterMatchCriteriaMatchAll = MetadataFilterFilterMatchCriteria("MATCH_ALL")
	// Specifies that any filterLabel must match for the metadataFilter to be considered a match.
	MetadataFilterFilterMatchCriteriaMatchAny = MetadataFilterFilterMatchCriteria("MATCH_ANY")
	// Indicates that the match criteria was not set. A metadataFilter must never be created with this value.
	MetadataFilterFilterMatchCriteriaNotSet = MetadataFilterFilterMatchCriteria("NOT_SET")
)

func (MetadataFilterFilterMatchCriteria) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e MetadataFilterFilterMatchCriteria) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e MetadataFilterFilterMatchCriteria) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e MetadataFilterFilterMatchCriteria) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e MetadataFilterFilterMatchCriteria) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Type of network endpoints in this network endpoint group. Can be one of GCE_VM_IP_PORT, NON_GCP_PRIVATE_IP_PORT, INTERNET_FQDN_PORT, INTERNET_IP_PORT, or SERVERLESS.
type NetworkEndpointGroupNetworkEndpointType pulumi.String

const (
	// The network endpoint is represented by an IP address.
	NetworkEndpointGroupNetworkEndpointTypeGceVmIp = NetworkEndpointGroupNetworkEndpointType("GCE_VM_IP")
	// The network endpoint is represented by IP address and port pair.
	NetworkEndpointGroupNetworkEndpointTypeGceVmIpPort = NetworkEndpointGroupNetworkEndpointType("GCE_VM_IP_PORT")
	// The network endpoint is represented by fully qualified domain name and port.
	NetworkEndpointGroupNetworkEndpointTypeInternetFqdnPort = NetworkEndpointGroupNetworkEndpointType("INTERNET_FQDN_PORT")
	// The network endpoint is represented by an internet IP address and port.
	NetworkEndpointGroupNetworkEndpointTypeInternetIpPort = NetworkEndpointGroupNetworkEndpointType("INTERNET_IP_PORT")
	// The network endpoint is represented by an IP address and port. The endpoint belongs to a VM or pod running in a customer's on-premises.
	NetworkEndpointGroupNetworkEndpointTypeNonGcpPrivateIpPort = NetworkEndpointGroupNetworkEndpointType("NON_GCP_PRIVATE_IP_PORT")
	// The network endpoint is handled by specified serverless infrastructure.
	NetworkEndpointGroupNetworkEndpointTypeServerless = NetworkEndpointGroupNetworkEndpointType("SERVERLESS")
)

func (NetworkEndpointGroupNetworkEndpointType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e NetworkEndpointGroupNetworkEndpointType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e NetworkEndpointGroupNetworkEndpointType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e NetworkEndpointGroupNetworkEndpointType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e NetworkEndpointGroupNetworkEndpointType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet. This field is always inherited from its subnetwork. Valid only if stackType is IPV4_IPV6.
type NetworkInterfaceIpv6AccessType pulumi.String

const (
	// This network interface can have external IPv6.
	NetworkInterfaceIpv6AccessTypeExternal = NetworkInterfaceIpv6AccessType("EXTERNAL")
	// IPv6 access type not set. Means this network interface hasn't been turned on IPv6 yet.
	NetworkInterfaceIpv6AccessTypeUnspecifiedIpv6AccessType = NetworkInterfaceIpv6AccessType("UNSPECIFIED_IPV6_ACCESS_TYPE")
)

func (NetworkInterfaceIpv6AccessType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e NetworkInterfaceIpv6AccessType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e NetworkInterfaceIpv6AccessType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e NetworkInterfaceIpv6AccessType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e NetworkInterfaceIpv6AccessType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The type of vNIC to be used on this interface. This may be gVNIC or VirtioNet.
type NetworkInterfaceNicType pulumi.String

const (
	// GVNIC
	NetworkInterfaceNicTypeGvnic = NetworkInterfaceNicType("GVNIC")
	// No type specified.
	NetworkInterfaceNicTypeUnspecifiedNicType = NetworkInterfaceNicType("UNSPECIFIED_NIC_TYPE")
	// VIRTIO
	NetworkInterfaceNicTypeVirtioNet = NetworkInterfaceNicType("VIRTIO_NET")
)

func (NetworkInterfaceNicType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e NetworkInterfaceNicType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e NetworkInterfaceNicType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e NetworkInterfaceNicType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e NetworkInterfaceNicType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The stack type for this network interface to identify whether the IPv6 feature is enabled or not. If not specified, IPV4_ONLY will be used. This field can be both set at instance creation and update network interface operations.
type NetworkInterfaceStackType pulumi.String

const (
	// The network interface can have both IPv4 and IPv6 addresses.
	NetworkInterfaceStackTypeIpv4Ipv6 = NetworkInterfaceStackType("IPV4_IPV6")
	// The network interface will be assigned IPv4 address.
	NetworkInterfaceStackTypeIpv4Only             = NetworkInterfaceStackType("IPV4_ONLY")
	NetworkInterfaceStackTypeUnspecifiedStackType = NetworkInterfaceStackType("UNSPECIFIED_STACK_TYPE")
)

func (NetworkInterfaceStackType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e NetworkInterfaceStackType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e NetworkInterfaceStackType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e NetworkInterfaceStackType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e NetworkInterfaceStackType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] State for the peering, either `ACTIVE` or `INACTIVE`. The peering is `ACTIVE` when there's a matching configuration in the peer network.
type NetworkPeeringState pulumi.String

const (
	// Matching configuration exists on the peer.
	NetworkPeeringStateActive = NetworkPeeringState("ACTIVE")
	// There is no matching configuration on the peer, including the case when peer does not exist.
	NetworkPeeringStateInactive = NetworkPeeringState("INACTIVE")
)

func (NetworkPeeringState) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e NetworkPeeringState) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e NetworkPeeringState) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e NetworkPeeringState) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e NetworkPeeringState) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

type NetworkPerformanceConfigTotalEgressBandwidthTier pulumi.String

const (
	NetworkPerformanceConfigTotalEgressBandwidthTierDefault = NetworkPerformanceConfigTotalEgressBandwidthTier("DEFAULT")
	NetworkPerformanceConfigTotalEgressBandwidthTierTier1   = NetworkPerformanceConfigTotalEgressBandwidthTier("TIER_1")
)

func (NetworkPerformanceConfigTotalEgressBandwidthTier) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e NetworkPerformanceConfigTotalEgressBandwidthTier) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e NetworkPerformanceConfigTotalEgressBandwidthTier) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e NetworkPerformanceConfigTotalEgressBandwidthTier) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e NetworkPerformanceConfigTotalEgressBandwidthTier) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The network-wide routing mode to use. If set to REGIONAL, this network's Cloud Routers will only advertise routes with subnets of this network in the same region as the router. If set to GLOBAL, this network's Cloud Routers will advertise routes with all subnets of this network, across regions.
type NetworkRoutingConfigRoutingMode pulumi.String

const (
	NetworkRoutingConfigRoutingModeGlobal   = NetworkRoutingConfigRoutingMode("GLOBAL")
	NetworkRoutingConfigRoutingModeRegional = NetworkRoutingConfigRoutingMode("REGIONAL")
)

func (NetworkRoutingConfigRoutingMode) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e NetworkRoutingConfigRoutingMode) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e NetworkRoutingConfigRoutingMode) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e NetworkRoutingConfigRoutingMode) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e NetworkRoutingConfigRoutingMode) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The autoscaling mode. Set to one of: ON, OFF, or ONLY_SCALE_OUT. For more information, see Autoscaler modes.
type NodeGroupAutoscalingPolicyMode pulumi.String

const (
	NodeGroupAutoscalingPolicyModeModeUnspecified = NodeGroupAutoscalingPolicyMode("MODE_UNSPECIFIED")
	// Autoscaling is disabled.
	NodeGroupAutoscalingPolicyModeOff = NodeGroupAutoscalingPolicyMode("OFF")
	// Autocaling is fully enabled.
	NodeGroupAutoscalingPolicyModeOn = NodeGroupAutoscalingPolicyMode("ON")
	// Autoscaling will only scale out and will not remove nodes.
	NodeGroupAutoscalingPolicyModeOnlyScaleOut = NodeGroupAutoscalingPolicyMode("ONLY_SCALE_OUT")
)

func (NodeGroupAutoscalingPolicyMode) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e NodeGroupAutoscalingPolicyMode) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e NodeGroupAutoscalingPolicyMode) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e NodeGroupAutoscalingPolicyMode) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e NodeGroupAutoscalingPolicyMode) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies how to handle instances when a node in the group undergoes maintenance. Set to one of: DEFAULT, RESTART_IN_PLACE, or MIGRATE_WITHIN_NODE_GROUP. The default value is DEFAULT. For more information, see Maintenance policies.
type NodeGroupMaintenancePolicy pulumi.String

const (
	// Allow the node and corresponding instances to retain default maintenance behavior.
	NodeGroupMaintenancePolicyDefault                      = NodeGroupMaintenancePolicy("DEFAULT")
	NodeGroupMaintenancePolicyMaintenancePolicyUnspecified = NodeGroupMaintenancePolicy("MAINTENANCE_POLICY_UNSPECIFIED")
	// When maintenance must be done on a node, the instances on that node will be moved to other nodes in the group. Instances with onHostMaintenance = MIGRATE will live migrate to their destinations while instances with onHostMaintenance = TERMINATE will terminate and then restart on their destination nodes if automaticRestart = true.
	NodeGroupMaintenancePolicyMigrateWithinNodeGroup = NodeGroupMaintenancePolicy("MIGRATE_WITHIN_NODE_GROUP")
	// Instances in this group will restart on the same node when maintenance has completed. Instances must have onHostMaintenance = TERMINATE, and they will only restart if automaticRestart = true.
	NodeGroupMaintenancePolicyRestartInPlace = NodeGroupMaintenancePolicy("RESTART_IN_PLACE")
)

func (NodeGroupMaintenancePolicy) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e NodeGroupMaintenancePolicy) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e NodeGroupMaintenancePolicy) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e NodeGroupMaintenancePolicy) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e NodeGroupMaintenancePolicy) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

type NodeGroupStatus pulumi.String

const (
	NodeGroupStatusCreating = NodeGroupStatus("CREATING")
	NodeGroupStatusDeleting = NodeGroupStatus("DELETING")
	NodeGroupStatusInvalid  = NodeGroupStatus("INVALID")
	NodeGroupStatusReady    = NodeGroupStatus("READY")
)

func (NodeGroupStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e NodeGroupStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e NodeGroupStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e NodeGroupStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e NodeGroupStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// CPU overcommit.
type NodeTemplateCpuOvercommitType pulumi.String

const (
	NodeTemplateCpuOvercommitTypeCpuOvercommitTypeUnspecified = NodeTemplateCpuOvercommitType("CPU_OVERCOMMIT_TYPE_UNSPECIFIED")
	NodeTemplateCpuOvercommitTypeEnabled                      = NodeTemplateCpuOvercommitType("ENABLED")
	NodeTemplateCpuOvercommitTypeNone                         = NodeTemplateCpuOvercommitType("NONE")
)

func (NodeTemplateCpuOvercommitType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e NodeTemplateCpuOvercommitType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e NodeTemplateCpuOvercommitType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e NodeTemplateCpuOvercommitType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e NodeTemplateCpuOvercommitType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] The status of the node template. One of the following values: CREATING, READY, and DELETING.
type NodeTemplateStatus pulumi.String

const (
	// Resources are being allocated.
	NodeTemplateStatusCreating = NodeTemplateStatus("CREATING")
	// The node template is currently being deleted.
	NodeTemplateStatusDeleting = NodeTemplateStatus("DELETING")
	// Invalid status.
	NodeTemplateStatusInvalid = NodeTemplateStatus("INVALID")
	// The node template is ready.
	NodeTemplateStatusReady = NodeTemplateStatus("READY")
)

func (NodeTemplateStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e NodeTemplateStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e NodeTemplateStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e NodeTemplateStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e NodeTemplateStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The type indicates the intended use of the security policy. CLOUD_ARMOR policies apply to backend services. FIREWALL policies apply to organizations.
type OrganizationSecurityPolicyType pulumi.String

const (
	OrganizationSecurityPolicyTypeCloudArmor     = OrganizationSecurityPolicyType("CLOUD_ARMOR")
	OrganizationSecurityPolicyTypeCloudArmorEdge = OrganizationSecurityPolicyType("CLOUD_ARMOR_EDGE")
	OrganizationSecurityPolicyTypeFirewall       = OrganizationSecurityPolicyType("FIREWALL")
)

func (OrganizationSecurityPolicyType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e OrganizationSecurityPolicyType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e OrganizationSecurityPolicyType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e OrganizationSecurityPolicyType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e OrganizationSecurityPolicyType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Indicates whether or not this packet mirroring takes effect. If set to FALSE, this packet mirroring policy will not be enforced on the network. The default is TRUE.
type PacketMirroringEnable pulumi.String

const (
	PacketMirroringEnableFalse = PacketMirroringEnable("FALSE")
	PacketMirroringEnableTrue  = PacketMirroringEnable("TRUE")
)

func (PacketMirroringEnable) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e PacketMirroringEnable) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e PacketMirroringEnable) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e PacketMirroringEnable) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e PacketMirroringEnable) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Direction of traffic to mirror, either INGRESS, EGRESS, or BOTH. The default is BOTH.
type PacketMirroringFilterDirection pulumi.String

const (
	// Default, both directions are mirrored.
	PacketMirroringFilterDirectionBoth = PacketMirroringFilterDirection("BOTH")
	// Only egress traffic is mirrored.
	PacketMirroringFilterDirectionEgress = PacketMirroringFilterDirection("EGRESS")
	// Only ingress traffic is mirrored.
	PacketMirroringFilterDirectionIngress = PacketMirroringFilterDirection("INGRESS")
)

func (PacketMirroringFilterDirection) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e PacketMirroringFilterDirection) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e PacketMirroringFilterDirection) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e PacketMirroringFilterDirection) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e PacketMirroringFilterDirection) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The status of the public advertised prefix.
type PublicAdvertisedPrefixStatus pulumi.String

const (
	PublicAdvertisedPrefixStatusInitial                       = PublicAdvertisedPrefixStatus("INITIAL")
	PublicAdvertisedPrefixStatusPrefixConfigurationComplete   = PublicAdvertisedPrefixStatus("PREFIX_CONFIGURATION_COMPLETE")
	PublicAdvertisedPrefixStatusPrefixConfigurationInProgress = PublicAdvertisedPrefixStatus("PREFIX_CONFIGURATION_IN_PROGRESS")
	PublicAdvertisedPrefixStatusPrefixRemovalInProgress       = PublicAdvertisedPrefixStatus("PREFIX_REMOVAL_IN_PROGRESS")
	PublicAdvertisedPrefixStatusPtrConfigured                 = PublicAdvertisedPrefixStatus("PTR_CONFIGURED")
	PublicAdvertisedPrefixStatusReverseDnsLookupFailed        = PublicAdvertisedPrefixStatus("REVERSE_DNS_LOOKUP_FAILED")
	PublicAdvertisedPrefixStatusValidated                     = PublicAdvertisedPrefixStatus("VALIDATED")
)

func (PublicAdvertisedPrefixStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e PublicAdvertisedPrefixStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e PublicAdvertisedPrefixStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e PublicAdvertisedPrefixStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e PublicAdvertisedPrefixStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] The status of the sub public delegated prefix.
type PublicDelegatedPrefixPublicDelegatedSubPrefixStatus pulumi.String

const (
	PublicDelegatedPrefixPublicDelegatedSubPrefixStatusActive   = PublicDelegatedPrefixPublicDelegatedSubPrefixStatus("ACTIVE")
	PublicDelegatedPrefixPublicDelegatedSubPrefixStatusInactive = PublicDelegatedPrefixPublicDelegatedSubPrefixStatus("INACTIVE")
)

func (PublicDelegatedPrefixPublicDelegatedSubPrefixStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e PublicDelegatedPrefixPublicDelegatedSubPrefixStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e PublicDelegatedPrefixPublicDelegatedSubPrefixStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e PublicDelegatedPrefixPublicDelegatedSubPrefixStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e PublicDelegatedPrefixPublicDelegatedSubPrefixStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] The status of the public delegated prefix.
type PublicDelegatedPrefixStatus pulumi.String

const (
	PublicDelegatedPrefixStatusAnnounced    = PublicDelegatedPrefixStatus("ANNOUNCED")
	PublicDelegatedPrefixStatusDeleting     = PublicDelegatedPrefixStatus("DELETING")
	PublicDelegatedPrefixStatusInitializing = PublicDelegatedPrefixStatus("INITIALIZING")
)

func (PublicDelegatedPrefixStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e PublicDelegatedPrefixStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e PublicDelegatedPrefixStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e PublicDelegatedPrefixStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e PublicDelegatedPrefixStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] The status of the autoscaler configuration. Current set of possible values: - PENDING: Autoscaler backend hasn't read new/updated configuration. - DELETING: Configuration is being deleted. - ACTIVE: Configuration is acknowledged to be effective. Some warnings might be present in the statusDetails field. - ERROR: Configuration has errors. Actionable for users. Details are present in the statusDetails field. New values might be added in the future.
type RegionAutoscalerStatus pulumi.String

const (
	// Configuration is acknowledged to be effective
	RegionAutoscalerStatusActive = RegionAutoscalerStatus("ACTIVE")
	// Configuration is being deleted
	RegionAutoscalerStatusDeleting = RegionAutoscalerStatus("DELETING")
	// Configuration has errors. Actionable for users.
	RegionAutoscalerStatusError = RegionAutoscalerStatus("ERROR")
	// Autoscaler backend hasn't read new/updated configuration
	RegionAutoscalerStatusPending = RegionAutoscalerStatus("PENDING")
)

func (RegionAutoscalerStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RegionAutoscalerStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionAutoscalerStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionAutoscalerStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RegionAutoscalerStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Compress text responses using Brotli or gzip compression, based on the client’s Accept-Encoding header.
type RegionBackendServiceCompressionMode pulumi.String

const (
	// Automatically uses the best compression based on the Accept-Encoding header sent by the client.
	RegionBackendServiceCompressionModeAutomatic = RegionBackendServiceCompressionMode("AUTOMATIC")
	// Disables compression. Existing compressed responses cached by Cloud CDN will not be served to clients.
	RegionBackendServiceCompressionModeDisabled = RegionBackendServiceCompressionMode("DISABLED")
)

func (RegionBackendServiceCompressionMode) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RegionBackendServiceCompressionMode) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionBackendServiceCompressionMode) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionBackendServiceCompressionMode) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RegionBackendServiceCompressionMode) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies the load balancer type. Choose EXTERNAL for external HTTP(S), SSL Proxy, TCP Proxy and Network Load Balancing. Choose INTERNAL for Internal TCP/UDP Load Balancing. Choose INTERNAL_MANAGED for Internal HTTP(S) Load Balancing. INTERNAL_SELF_MANAGED for Traffic Director. A backend service created for one type of load balancer cannot be used with another. For more information, refer to Choosing a load balancer.
type RegionBackendServiceLoadBalancingScheme pulumi.String

const (
	// Signifies that this will be used for HTTP(S), SSL Proxy, TCP Proxy or Network Load Balancing
	RegionBackendServiceLoadBalancingSchemeExternal = RegionBackendServiceLoadBalancingScheme("EXTERNAL")
	// Signifies that this will be used for Internal TCP/UDP Load Balancing.
	RegionBackendServiceLoadBalancingSchemeInternal = RegionBackendServiceLoadBalancingScheme("INTERNAL")
	// Signifies that this will be used for Internal HTTP(S) Load Balancing.
	RegionBackendServiceLoadBalancingSchemeInternalManaged = RegionBackendServiceLoadBalancingScheme("INTERNAL_MANAGED")
	// Signifies that this will be used by Traffic Director.
	RegionBackendServiceLoadBalancingSchemeInternalSelfManaged        = RegionBackendServiceLoadBalancingScheme("INTERNAL_SELF_MANAGED")
	RegionBackendServiceLoadBalancingSchemeInvalidLoadBalancingScheme = RegionBackendServiceLoadBalancingScheme("INVALID_LOAD_BALANCING_SCHEME")
)

func (RegionBackendServiceLoadBalancingScheme) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RegionBackendServiceLoadBalancingScheme) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionBackendServiceLoadBalancingScheme) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionBackendServiceLoadBalancingScheme) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RegionBackendServiceLoadBalancingScheme) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The load balancing algorithm used within the scope of the locality. The possible values are: - ROUND_ROBIN: This is a simple policy in which each healthy backend is selected in round robin order. This is the default. - LEAST_REQUEST: An O(1) algorithm which selects two random healthy hosts and picks the host which has fewer active requests. - RING_HASH: The ring/modulo hash load balancer implements consistent hashing to backends. The algorithm has the property that the addition/removal of a host from a set of N hosts only affects 1/N of the requests. - RANDOM: The load balancer selects a random healthy host. - ORIGINAL_DESTINATION: Backend host is selected based on the client connection metadata, i.e., connections are opened to the same address as the destination address of the incoming connection before the connection was redirected to the load balancer. - MAGLEV: used as a drop in replacement for the ring hash load balancer. Maglev is not as stable as ring hash but has faster table lookup build times and host selection times. For more information about Maglev, see https://ai.google/research/pubs/pub44824 This field is applicable to either: - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED. - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED. If sessionAffinity is not NONE, and this field is not set to MAGLEV or RING_HASH, session affinity settings will not take effect. Only the default ROUND_ROBIN policy is supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
type RegionBackendServiceLocalityLbPolicy pulumi.String

const (
	RegionBackendServiceLocalityLbPolicyInvalidLbPolicy = RegionBackendServiceLocalityLbPolicy("INVALID_LB_POLICY")
	// An O(1) algorithm which selects two random healthy hosts and picks the host which has fewer active requests.
	RegionBackendServiceLocalityLbPolicyLeastRequest = RegionBackendServiceLocalityLbPolicy("LEAST_REQUEST")
	// This algorithm implements consistent hashing to backends. Maglev can be used as a drop in replacement for the ring hash load balancer. Maglev is not as stable as ring hash but has faster table lookup build times and host selection times. For more information about Maglev, see https://ai.google/research/pubs/pub44824
	RegionBackendServiceLocalityLbPolicyMaglev = RegionBackendServiceLocalityLbPolicy("MAGLEV")
	// Backend host is selected based on the client connection metadata, i.e., connections are opened to the same address as the destination address of the incoming connection before the connection was redirected to the load balancer.
	RegionBackendServiceLocalityLbPolicyOriginalDestination = RegionBackendServiceLocalityLbPolicy("ORIGINAL_DESTINATION")
	// The load balancer selects a random healthy host.
	RegionBackendServiceLocalityLbPolicyRandom = RegionBackendServiceLocalityLbPolicy("RANDOM")
	// The ring/modulo hash load balancer implements consistent hashing to backends. The algorithm has the property that the addition/removal of a host from a set of N hosts only affects 1/N of the requests.
	RegionBackendServiceLocalityLbPolicyRingHash = RegionBackendServiceLocalityLbPolicy("RING_HASH")
	// This is a simple policy in which each healthy backend is selected in round robin order. This is the default.
	RegionBackendServiceLocalityLbPolicyRoundRobin = RegionBackendServiceLocalityLbPolicy("ROUND_ROBIN")
)

func (RegionBackendServiceLocalityLbPolicy) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RegionBackendServiceLocalityLbPolicy) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionBackendServiceLocalityLbPolicy) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionBackendServiceLocalityLbPolicy) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RegionBackendServiceLocalityLbPolicy) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The protocol this BackendService uses to communicate with backends. Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, UDP or GRPC. depending on the chosen load balancer or Traffic Director configuration. Refer to the documentation for the load balancer or for Traffic Director for more information. Must be set to GRPC when the backend service is referenced by a URL map that is bound to target gRPC proxy.
type RegionBackendServiceProtocol pulumi.String

const (
	// gRPC (available for Traffic Director).
	RegionBackendServiceProtocolGrpc = RegionBackendServiceProtocol("GRPC")
	RegionBackendServiceProtocolHttp = RegionBackendServiceProtocol("HTTP")
	// HTTP/2 with SSL.
	RegionBackendServiceProtocolHttp2 = RegionBackendServiceProtocol("HTTP2")
	RegionBackendServiceProtocolHttps = RegionBackendServiceProtocol("HTTPS")
	// TCP proxying with SSL.
	RegionBackendServiceProtocolSsl = RegionBackendServiceProtocol("SSL")
	// TCP proxying or TCP pass-through (Internal TCP/UDP Load Balancing and Network Load Balancing).
	RegionBackendServiceProtocolTcp = RegionBackendServiceProtocol("TCP")
	// UDP (available for Internal TCP/UDP Load Balancing and Network Load Balancing).
	RegionBackendServiceProtocolUdp = RegionBackendServiceProtocol("UDP")
	// If a Backend Service has UNSPECIFIED as its protocol, it can be used with any L3/L4 Forwarding Rules.
	RegionBackendServiceProtocolUnspecified = RegionBackendServiceProtocol("UNSPECIFIED")
)

func (RegionBackendServiceProtocol) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RegionBackendServiceProtocol) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionBackendServiceProtocol) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionBackendServiceProtocol) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RegionBackendServiceProtocol) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Type of session affinity to use. The default is NONE. When the loadBalancingScheme is EXTERNAL: * For Network Load Balancing, the possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO. * For all other load balancers that use loadBalancingScheme=EXTERNAL, the possible values are NONE, CLIENT_IP, or GENERATED_COOKIE. * You can use GENERATED_COOKIE if the protocol is HTTP, HTTP2, or HTTPS. When the loadBalancingScheme is INTERNAL, possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO. When the loadBalancingScheme is INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED, possible values are NONE, CLIENT_IP, GENERATED_COOKIE, HEADER_FIELD, or HTTP_COOKIE. Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
type RegionBackendServiceSessionAffinity pulumi.String

const (
	// 2-tuple hash on packet's source and destination IP addresses. Connections from the same source IP address to the same destination IP address will be served by the same backend VM while that VM remains healthy.
	RegionBackendServiceSessionAffinityClientIp = RegionBackendServiceSessionAffinity("CLIENT_IP")
	// 1-tuple hash only on packet's source IP address. Connections from the same source IP address will be served by the same backend VM while that VM remains healthy. This option can only be used for Internal TCP/UDP Load Balancing.
	RegionBackendServiceSessionAffinityClientIpNoDestination = RegionBackendServiceSessionAffinity("CLIENT_IP_NO_DESTINATION")
	// 5-tuple hash on packet's source and destination IP addresses, IP protocol, and source and destination ports. Connections for the same IP protocol from the same source IP address and port to the same destination IP address and port will be served by the same backend VM while that VM remains healthy. This option cannot be used for HTTP(S) load balancing.
	RegionBackendServiceSessionAffinityClientIpPortProto = RegionBackendServiceSessionAffinity("CLIENT_IP_PORT_PROTO")
	// 3-tuple hash on packet's source and destination IP addresses, and IP protocol. Connections for the same IP protocol from the same source IP address to the same destination IP address will be served by the same backend VM while that VM remains healthy. This option cannot be used for HTTP(S) load balancing.
	RegionBackendServiceSessionAffinityClientIpProto = RegionBackendServiceSessionAffinity("CLIENT_IP_PROTO")
	// Hash based on a cookie generated by the L7 loadbalancer. Only valid for HTTP(S) load balancing.
	RegionBackendServiceSessionAffinityGeneratedCookie = RegionBackendServiceSessionAffinity("GENERATED_COOKIE")
	// The hash is based on a user specified header field.
	RegionBackendServiceSessionAffinityHeaderField = RegionBackendServiceSessionAffinity("HEADER_FIELD")
	// The hash is based on a user provided cookie.
	RegionBackendServiceSessionAffinityHttpCookie = RegionBackendServiceSessionAffinity("HTTP_COOKIE")
	// No session affinity. Connections from the same client IP may go to any instance in the pool.
	RegionBackendServiceSessionAffinityNone = RegionBackendServiceSessionAffinity("NONE")
)

func (RegionBackendServiceSessionAffinity) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RegionBackendServiceSessionAffinity) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionBackendServiceSessionAffinity) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionBackendServiceSessionAffinity) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RegionBackendServiceSessionAffinity) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The category of the commitment. Category MACHINE specifies commitments composed of machine resources such as VCPU or MEMORY, listed in resources. Category LICENSE specifies commitments composed of software licenses, listed in licenseResources. Note that only MACHINE commitments should have a Type specified.
type RegionCommitmentCategory pulumi.String

const (
	RegionCommitmentCategoryCategoryUnspecified = RegionCommitmentCategory("CATEGORY_UNSPECIFIED")
	RegionCommitmentCategoryLicense             = RegionCommitmentCategory("LICENSE")
	RegionCommitmentCategoryMachine             = RegionCommitmentCategory("MACHINE")
)

func (RegionCommitmentCategory) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RegionCommitmentCategory) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionCommitmentCategory) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionCommitmentCategory) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RegionCommitmentCategory) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The plan for this commitment, which determines duration and discount rate. The currently supported plans are TWELVE_MONTH (1 year), and THIRTY_SIX_MONTH (3 years).
type RegionCommitmentPlan pulumi.String

const (
	RegionCommitmentPlanInvalid        = RegionCommitmentPlan("INVALID")
	RegionCommitmentPlanThirtySixMonth = RegionCommitmentPlan("THIRTY_SIX_MONTH")
	RegionCommitmentPlanTwelveMonth    = RegionCommitmentPlan("TWELVE_MONTH")
)

func (RegionCommitmentPlan) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RegionCommitmentPlan) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionCommitmentPlan) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionCommitmentPlan) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RegionCommitmentPlan) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] Status of the commitment with regards to eventual expiration (each commitment has an end date defined). One of the following values: NOT_YET_ACTIVE, ACTIVE, EXPIRED.
type RegionCommitmentStatus pulumi.String

const (
	RegionCommitmentStatusActive       = RegionCommitmentStatus("ACTIVE")
	RegionCommitmentStatusCreating     = RegionCommitmentStatus("CREATING")
	RegionCommitmentStatusExpired      = RegionCommitmentStatus("EXPIRED")
	RegionCommitmentStatusNotYetActive = RegionCommitmentStatus("NOT_YET_ACTIVE")
)

func (RegionCommitmentStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RegionCommitmentStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionCommitmentStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionCommitmentStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RegionCommitmentStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The type of commitment, which affects the discount rate and the eligible resources. Type MEMORY_OPTIMIZED specifies a commitment that will only apply to memory optimized machines. Type ACCELERATOR_OPTIMIZED specifies a commitment that will only apply to accelerator optimized machines.
type RegionCommitmentType pulumi.String

const (
	RegionCommitmentTypeAcceleratorOptimized = RegionCommitmentType("ACCELERATOR_OPTIMIZED")
	RegionCommitmentTypeComputeOptimized     = RegionCommitmentType("COMPUTE_OPTIMIZED")
	RegionCommitmentTypeGeneralPurpose       = RegionCommitmentType("GENERAL_PURPOSE")
	RegionCommitmentTypeGeneralPurposeE2     = RegionCommitmentType("GENERAL_PURPOSE_E2")
	RegionCommitmentTypeGeneralPurposeN2     = RegionCommitmentType("GENERAL_PURPOSE_N2")
	RegionCommitmentTypeGeneralPurposeN2d    = RegionCommitmentType("GENERAL_PURPOSE_N2D")
	RegionCommitmentTypeMemoryOptimized      = RegionCommitmentType("MEMORY_OPTIMIZED")
	RegionCommitmentTypeTypeUnspecified      = RegionCommitmentType("TYPE_UNSPECIFIED")
)

func (RegionCommitmentType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RegionCommitmentType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionCommitmentType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionCommitmentType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RegionCommitmentType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME. The default is SCSI.
type RegionDiskInterface pulumi.String

const (
	RegionDiskInterfaceNvme        = RegionDiskInterface("NVME")
	RegionDiskInterfaceScsi        = RegionDiskInterface("SCSI")
	RegionDiskInterfaceUnspecified = RegionDiskInterface("UNSPECIFIED")
)

func (RegionDiskInterface) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RegionDiskInterface) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionDiskInterface) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionDiskInterface) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RegionDiskInterface) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] The status of disk creation. - CREATING: Disk is provisioning. - RESTORING: Source data is being copied into the disk. - FAILED: Disk creation failed. - READY: Disk is ready for use. - DELETING: Disk is deleting.
type RegionDiskStatus pulumi.String

const (
	// Disk is provisioning
	RegionDiskStatusCreating = RegionDiskStatus("CREATING")
	// Disk is deleting.
	RegionDiskStatusDeleting = RegionDiskStatus("DELETING")
	// Disk creation failed.
	RegionDiskStatusFailed = RegionDiskStatus("FAILED")
	// Disk is ready for use.
	RegionDiskStatusReady = RegionDiskStatus("READY")
	// Source data is being copied into the disk.
	RegionDiskStatusRestoring = RegionDiskStatus("RESTORING")
)

func (RegionDiskStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RegionDiskStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionDiskStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionDiskStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RegionDiskStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Optional. Policy for how the results from multiple health checks for the same endpoint are aggregated. Defaults to NO_AGGREGATION if unspecified. - NO_AGGREGATION. An EndpointHealth message is returned for each backend in the health check service. - AND. If any backend's health check reports UNHEALTHY, then UNHEALTHY is the HealthState of the entire health check service. If all backend's are healthy, the HealthState of the health check service is HEALTHY. .
type RegionHealthCheckServiceHealthStatusAggregationPolicy pulumi.String

const (
	// If any backend's health check reports UNHEALTHY, then UNHEALTHY is the HealthState of the entire health check service. If all backend's are healthy, the HealthState of the health check service is HEALTHY.
	RegionHealthCheckServiceHealthStatusAggregationPolicyAnd = RegionHealthCheckServiceHealthStatusAggregationPolicy("AND")
	// An EndpointHealth message is returned for each backend in the health check service.
	RegionHealthCheckServiceHealthStatusAggregationPolicyNoAggregation = RegionHealthCheckServiceHealthStatusAggregationPolicy("NO_AGGREGATION")
)

func (RegionHealthCheckServiceHealthStatusAggregationPolicy) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RegionHealthCheckServiceHealthStatusAggregationPolicy) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionHealthCheckServiceHealthStatusAggregationPolicy) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionHealthCheckServiceHealthStatusAggregationPolicy) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RegionHealthCheckServiceHealthStatusAggregationPolicy) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies the type of the healthCheck, either TCP, SSL, HTTP, HTTPS or HTTP2. If not specified, the default is TCP. Exactly one of the protocol-specific health check field must be specified, which must match type field.
type RegionHealthCheckType pulumi.String

const (
	RegionHealthCheckTypeGrpc    = RegionHealthCheckType("GRPC")
	RegionHealthCheckTypeHttp    = RegionHealthCheckType("HTTP")
	RegionHealthCheckTypeHttp2   = RegionHealthCheckType("HTTP2")
	RegionHealthCheckTypeHttps   = RegionHealthCheckType("HTTPS")
	RegionHealthCheckTypeInvalid = RegionHealthCheckType("INVALID")
	RegionHealthCheckTypeSsl     = RegionHealthCheckType("SSL")
	RegionHealthCheckTypeTcp     = RegionHealthCheckType("TCP")
)

func (RegionHealthCheckType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RegionHealthCheckType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionHealthCheckType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionHealthCheckType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RegionHealthCheckType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The action to perform in case of zone failure. Only one value is supported, NO_FAILOVER. The default is NO_FAILOVER.
type RegionInstanceGroupManagerFailoverAction pulumi.String

const (
	RegionInstanceGroupManagerFailoverActionNoFailover = RegionInstanceGroupManagerFailoverAction("NO_FAILOVER")
	RegionInstanceGroupManagerFailoverActionUnknown    = RegionInstanceGroupManagerFailoverAction("UNKNOWN")
)

func (RegionInstanceGroupManagerFailoverAction) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RegionInstanceGroupManagerFailoverAction) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionInstanceGroupManagerFailoverAction) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionInstanceGroupManagerFailoverAction) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RegionInstanceGroupManagerFailoverAction) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Type of network endpoints in this network endpoint group. Can be one of GCE_VM_IP_PORT, NON_GCP_PRIVATE_IP_PORT, INTERNET_FQDN_PORT, INTERNET_IP_PORT, or SERVERLESS.
type RegionNetworkEndpointGroupNetworkEndpointType pulumi.String

const (
	// The network endpoint is represented by an IP address.
	RegionNetworkEndpointGroupNetworkEndpointTypeGceVmIp = RegionNetworkEndpointGroupNetworkEndpointType("GCE_VM_IP")
	// The network endpoint is represented by IP address and port pair.
	RegionNetworkEndpointGroupNetworkEndpointTypeGceVmIpPort = RegionNetworkEndpointGroupNetworkEndpointType("GCE_VM_IP_PORT")
	// The network endpoint is represented by fully qualified domain name and port.
	RegionNetworkEndpointGroupNetworkEndpointTypeInternetFqdnPort = RegionNetworkEndpointGroupNetworkEndpointType("INTERNET_FQDN_PORT")
	// The network endpoint is represented by an internet IP address and port.
	RegionNetworkEndpointGroupNetworkEndpointTypeInternetIpPort = RegionNetworkEndpointGroupNetworkEndpointType("INTERNET_IP_PORT")
	// The network endpoint is represented by an IP address and port. The endpoint belongs to a VM or pod running in a customer's on-premises.
	RegionNetworkEndpointGroupNetworkEndpointTypeNonGcpPrivateIpPort = RegionNetworkEndpointGroupNetworkEndpointType("NON_GCP_PRIVATE_IP_PORT")
	// The network endpoint is handled by specified serverless infrastructure.
	RegionNetworkEndpointGroupNetworkEndpointTypeServerless = RegionNetworkEndpointGroupNetworkEndpointType("SERVERLESS")
)

func (RegionNetworkEndpointGroupNetworkEndpointType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RegionNetworkEndpointGroupNetworkEndpointType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionNetworkEndpointGroupNetworkEndpointType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionNetworkEndpointGroupNetworkEndpointType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RegionNetworkEndpointGroupNetworkEndpointType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// (Optional) Specifies the type of SSL certificate, either "SELF_MANAGED" or "MANAGED". If not specified, the certificate is self-managed and the fields certificate and private_key are used.
type RegionSslCertificateType pulumi.String

const (
	// Google-managed SSLCertificate.
	RegionSslCertificateTypeManaged = RegionSslCertificateType("MANAGED")
	// Certificate uploaded by user.
	RegionSslCertificateTypeSelfManaged     = RegionSslCertificateType("SELF_MANAGED")
	RegionSslCertificateTypeTypeUnspecified = RegionSslCertificateType("TYPE_UNSPECIFIED")
)

func (RegionSslCertificateType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RegionSslCertificateType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionSslCertificateType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionSslCertificateType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RegionSslCertificateType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies the QUIC override policy for this TargetHttpsProxy resource. This setting determines whether the load balancer attempts to negotiate QUIC with clients. You can specify NONE, ENABLE, or DISABLE. - When quic-override is set to NONE, Google manages whether QUIC is used. - When quic-override is set to ENABLE, the load balancer uses QUIC when possible. - When quic-override is set to DISABLE, the load balancer doesn't use QUIC. - If the quic-override flag is not specified, NONE is implied.
type RegionTargetHttpsProxyQuicOverride pulumi.String

const (
	// The load balancer will not attempt to negotiate QUIC with clients.
	RegionTargetHttpsProxyQuicOverrideDisable = RegionTargetHttpsProxyQuicOverride("DISABLE")
	// The load balancer will attempt to negotiate QUIC with clients.
	RegionTargetHttpsProxyQuicOverrideEnable = RegionTargetHttpsProxyQuicOverride("ENABLE")
	// No overrides to the default QUIC policy. This option is implicit if no QUIC override has been specified in the request.
	RegionTargetHttpsProxyQuicOverrideNone = RegionTargetHttpsProxyQuicOverride("NONE")
)

func (RegionTargetHttpsProxyQuicOverride) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RegionTargetHttpsProxyQuicOverride) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionTargetHttpsProxyQuicOverride) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RegionTargetHttpsProxyQuicOverride) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RegionTargetHttpsProxyQuicOverride) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies the type of reservation from which this instance can consume resources: ANY_RESERVATION (default), SPECIFIC_RESERVATION, or NO_RESERVATION. See Consuming reserved instances for examples.
type ReservationAffinityConsumeReservationType pulumi.String

const (
	// Consume any allocation available.
	ReservationAffinityConsumeReservationTypeAnyReservation = ReservationAffinityConsumeReservationType("ANY_RESERVATION")
	// Do not consume from any allocated capacity.
	ReservationAffinityConsumeReservationTypeNoReservation = ReservationAffinityConsumeReservationType("NO_RESERVATION")
	// Must consume from a specific reservation. Must specify key value fields for specifying the reservations.
	ReservationAffinityConsumeReservationTypeSpecificReservation = ReservationAffinityConsumeReservationType("SPECIFIC_RESERVATION")
	// Prefer to consume from a specific reservation, but still consume any reservation available if the specified reservation is not available or exhausted. Must specify key value fields for specifying the reservations.
	ReservationAffinityConsumeReservationTypeSpecificThenAnyReservation = ReservationAffinityConsumeReservationType("SPECIFIC_THEN_ANY_RESERVATION")
	ReservationAffinityConsumeReservationTypeUnspecified                = ReservationAffinityConsumeReservationType("UNSPECIFIED")
)

func (ReservationAffinityConsumeReservationType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e ReservationAffinityConsumeReservationType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e ReservationAffinityConsumeReservationType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e ReservationAffinityConsumeReservationType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e ReservationAffinityConsumeReservationType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] The status of the reservation.
type ReservationStatus pulumi.String

const (
	// Resources are being allocated for the reservation.
	ReservationStatusCreating = ReservationStatus("CREATING")
	// Reservation is currently being deleted.
	ReservationStatusDeleting = ReservationStatus("DELETING")
	ReservationStatusInvalid  = ReservationStatus("INVALID")
	// Reservation has allocated all its resources.
	ReservationStatusReady = ReservationStatus("READY")
	// Reservation is currently being resized.
	ReservationStatusUpdating = ReservationStatus("UPDATING")
)

func (ReservationStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e ReservationStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e ReservationStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e ReservationStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e ReservationStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Type of resource for which this commitment applies. Possible values are VCPU and MEMORY
type ResourceCommitmentType pulumi.String

const (
	ResourceCommitmentTypeAccelerator = ResourceCommitmentType("ACCELERATOR")
	ResourceCommitmentTypeLocalSsd    = ResourceCommitmentType("LOCAL_SSD")
	ResourceCommitmentTypeMemory      = ResourceCommitmentType("MEMORY")
	ResourceCommitmentTypeUnspecified = ResourceCommitmentType("UNSPECIFIED")
	ResourceCommitmentTypeVcpu        = ResourceCommitmentType("VCPU")
)

func (ResourceCommitmentType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e ResourceCommitmentType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e ResourceCommitmentType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e ResourceCommitmentType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e ResourceCommitmentType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies network collocation
type ResourcePolicyGroupPlacementPolicyCollocation pulumi.String

const (
	ResourcePolicyGroupPlacementPolicyCollocationCollocated             = ResourcePolicyGroupPlacementPolicyCollocation("COLLOCATED")
	ResourcePolicyGroupPlacementPolicyCollocationUnspecifiedCollocation = ResourcePolicyGroupPlacementPolicyCollocation("UNSPECIFIED_COLLOCATION")
)

func (ResourcePolicyGroupPlacementPolicyCollocation) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e ResourcePolicyGroupPlacementPolicyCollocation) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e ResourcePolicyGroupPlacementPolicyCollocation) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e ResourcePolicyGroupPlacementPolicyCollocation) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e ResourcePolicyGroupPlacementPolicyCollocation) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies the behavior to apply to scheduled snapshots when the source disk is deleted.
type ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete pulumi.String

const (
	ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDeleteApplyRetentionPolicy          = ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete("APPLY_RETENTION_POLICY")
	ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDeleteKeepAutoSnapshots             = ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete("KEEP_AUTO_SNAPSHOTS")
	ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDeleteUnspecifiedOnSourceDiskDelete = ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete("UNSPECIFIED_ON_SOURCE_DISK_DELETE")
)

func (ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] The status of resource policy creation.
type ResourcePolicyStatus pulumi.String

const (
	// Resource policy is being created.
	ResourcePolicyStatusCreating = ResourcePolicyStatus("CREATING")
	// Resource policy is being deleted.
	ResourcePolicyStatusDeleting = ResourcePolicyStatus("DELETING")
	// Resource policy is expired and will not run again.
	ResourcePolicyStatusExpired = ResourcePolicyStatus("EXPIRED")
	ResourcePolicyStatusInvalid = ResourcePolicyStatus("INVALID")
	// Resource policy is ready to be used.
	ResourcePolicyStatusReady = ResourcePolicyStatus("READY")
)

func (ResourcePolicyStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e ResourcePolicyStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e ResourcePolicyStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e ResourcePolicyStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e ResourcePolicyStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Defines a schedule that runs on specific days of the week. Specify one or more days. The following options are available: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
type ResourcePolicyWeeklyCycleDayOfWeekDay pulumi.String

const (
	ResourcePolicyWeeklyCycleDayOfWeekDayFriday    = ResourcePolicyWeeklyCycleDayOfWeekDay("FRIDAY")
	ResourcePolicyWeeklyCycleDayOfWeekDayInvalid   = ResourcePolicyWeeklyCycleDayOfWeekDay("INVALID")
	ResourcePolicyWeeklyCycleDayOfWeekDayMonday    = ResourcePolicyWeeklyCycleDayOfWeekDay("MONDAY")
	ResourcePolicyWeeklyCycleDayOfWeekDaySaturday  = ResourcePolicyWeeklyCycleDayOfWeekDay("SATURDAY")
	ResourcePolicyWeeklyCycleDayOfWeekDaySunday    = ResourcePolicyWeeklyCycleDayOfWeekDay("SUNDAY")
	ResourcePolicyWeeklyCycleDayOfWeekDayThursday  = ResourcePolicyWeeklyCycleDayOfWeekDay("THURSDAY")
	ResourcePolicyWeeklyCycleDayOfWeekDayTuesday   = ResourcePolicyWeeklyCycleDayOfWeekDay("TUESDAY")
	ResourcePolicyWeeklyCycleDayOfWeekDayWednesday = ResourcePolicyWeeklyCycleDayOfWeekDay("WEDNESDAY")
)

func (ResourcePolicyWeeklyCycleDayOfWeekDay) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e ResourcePolicyWeeklyCycleDayOfWeekDay) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e ResourcePolicyWeeklyCycleDayOfWeekDay) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e ResourcePolicyWeeklyCycleDayOfWeekDay) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e ResourcePolicyWeeklyCycleDayOfWeekDay) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
type RouteWarningsItemCode pulumi.String

const (
	// Warning about failed cleanup of transient changes made by a failed operation.
	RouteWarningsItemCodeCleanupFailed = RouteWarningsItemCode("CLEANUP_FAILED")
	// A link to a deprecated resource was created.
	RouteWarningsItemCodeDeprecatedResourceUsed = RouteWarningsItemCode("DEPRECATED_RESOURCE_USED")
	// When deploying and at least one of the resources has a type marked as deprecated
	RouteWarningsItemCodeDeprecatedTypeUsed = RouteWarningsItemCode("DEPRECATED_TYPE_USED")
	// The user created a boot disk that is larger than image size.
	RouteWarningsItemCodeDiskSizeLargerThanImageSize = RouteWarningsItemCode("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
	// When deploying and at least one of the resources has a type marked as experimental
	RouteWarningsItemCodeExperimentalTypeUsed = RouteWarningsItemCode("EXPERIMENTAL_TYPE_USED")
	// Warning that is present in an external api call
	RouteWarningsItemCodeExternalApiWarning = RouteWarningsItemCode("EXTERNAL_API_WARNING")
	// Warning that value of a field has been overridden. Deprecated unused field.
	RouteWarningsItemCodeFieldValueOverriden = RouteWarningsItemCode("FIELD_VALUE_OVERRIDEN")
	// The operation involved use of an injected kernel, which is deprecated.
	RouteWarningsItemCodeInjectedKernelsDeprecated = RouteWarningsItemCode("INJECTED_KERNELS_DEPRECATED")
	// When deploying a deployment with a exceedingly large number of resources
	RouteWarningsItemCodeLargeDeploymentWarning = RouteWarningsItemCode("LARGE_DEPLOYMENT_WARNING")
	// A resource depends on a missing type
	RouteWarningsItemCodeMissingTypeDependency = RouteWarningsItemCode("MISSING_TYPE_DEPENDENCY")
	// The route's nextHopIp address is not assigned to an instance on the network.
	RouteWarningsItemCodeNextHopAddressNotAssigned = RouteWarningsItemCode("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
	// The route's next hop instance cannot ip forward.
	RouteWarningsItemCodeNextHopCannotIpForward = RouteWarningsItemCode("NEXT_HOP_CANNOT_IP_FORWARD")
	// The route's nextHopInstance URL refers to an instance that does not exist.
	RouteWarningsItemCodeNextHopInstanceNotFound = RouteWarningsItemCode("NEXT_HOP_INSTANCE_NOT_FOUND")
	// The route's nextHopInstance URL refers to an instance that is not on the same network as the route.
	RouteWarningsItemCodeNextHopInstanceNotOnNetwork = RouteWarningsItemCode("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
	// The route's next hop instance does not have a status of RUNNING.
	RouteWarningsItemCodeNextHopNotRunning = RouteWarningsItemCode("NEXT_HOP_NOT_RUNNING")
	// Error which is not critical. We decided to continue the process despite the mentioned error.
	RouteWarningsItemCodeNotCriticalError = RouteWarningsItemCode("NOT_CRITICAL_ERROR")
	// No results are present on a particular list page.
	RouteWarningsItemCodeNoResultsOnPage = RouteWarningsItemCode("NO_RESULTS_ON_PAGE")
	// Success is reported, but some results may be missing due to errors
	RouteWarningsItemCodePartialSuccess = RouteWarningsItemCode("PARTIAL_SUCCESS")
	// The user attempted to use a resource that requires a TOS they have not accepted.
	RouteWarningsItemCodeRequiredTosAgreement = RouteWarningsItemCode("REQUIRED_TOS_AGREEMENT")
	// Warning that a resource is in use.
	RouteWarningsItemCodeResourceInUseByOtherResourceWarning = RouteWarningsItemCode("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
	// One or more of the resources set to auto-delete could not be deleted because they were in use.
	RouteWarningsItemCodeResourceNotDeleted = RouteWarningsItemCode("RESOURCE_NOT_DELETED")
	// When a resource schema validation is ignored.
	RouteWarningsItemCodeSchemaValidationIgnored = RouteWarningsItemCode("SCHEMA_VALIDATION_IGNORED")
	// Instance template used in instance group manager is valid as such, but its application does not make a lot of sense, because it allows only single instance in instance group.
	RouteWarningsItemCodeSingleInstancePropertyTemplate = RouteWarningsItemCode("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
	// When undeclared properties in the schema are present
	RouteWarningsItemCodeUndeclaredProperties = RouteWarningsItemCode("UNDECLARED_PROPERTIES")
	// A given scope cannot be reached.
	RouteWarningsItemCodeUnreachable = RouteWarningsItemCode("UNREACHABLE")
)

func (RouteWarningsItemCode) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RouteWarningsItemCode) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RouteWarningsItemCode) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RouteWarningsItemCode) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RouteWarningsItemCode) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// User-specified flag to indicate which mode to use for advertisement. The options are DEFAULT or CUSTOM.
type RouterBgpAdvertiseMode pulumi.String

const (
	RouterBgpAdvertiseModeCustom  = RouterBgpAdvertiseMode("CUSTOM")
	RouterBgpAdvertiseModeDefault = RouterBgpAdvertiseMode("DEFAULT")
)

func (RouterBgpAdvertiseMode) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RouterBgpAdvertiseMode) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RouterBgpAdvertiseMode) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RouterBgpAdvertiseMode) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RouterBgpAdvertiseMode) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

type RouterBgpAdvertisedGroupsItem pulumi.String

const (
	// Advertise all available subnets (including peer VPC subnets).
	RouterBgpAdvertisedGroupsItemAllSubnets = RouterBgpAdvertisedGroupsItem("ALL_SUBNETS")
)

func (RouterBgpAdvertisedGroupsItem) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RouterBgpAdvertisedGroupsItem) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RouterBgpAdvertisedGroupsItem) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RouterBgpAdvertisedGroupsItem) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RouterBgpAdvertisedGroupsItem) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// RouterBgpAdvertisedGroupsItemArrayInput is an input type that accepts RouterBgpAdvertisedGroupsItemArray and RouterBgpAdvertisedGroupsItemArrayOutput values.
// You can construct a concrete instance of `RouterBgpAdvertisedGroupsItemArrayInput` via:
//
//          RouterBgpAdvertisedGroupsItemArray{ RouterBgpAdvertisedGroupsItemArgs{...} }
type RouterBgpAdvertisedGroupsItemArrayInput interface {
	pulumi.Input

	ToRouterBgpAdvertisedGroupsItemArrayOutput() RouterBgpAdvertisedGroupsItemArrayOutput
	ToRouterBgpAdvertisedGroupsItemArrayOutputWithContext(context.Context) RouterBgpAdvertisedGroupsItemArrayOutput
}

type RouterBgpAdvertisedGroupsItemArray []RouterBgpAdvertisedGroupsItem

func (RouterBgpAdvertisedGroupsItemArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RouterBgpAdvertisedGroupsItem)(nil)).Elem()
}

func (i RouterBgpAdvertisedGroupsItemArray) ToRouterBgpAdvertisedGroupsItemArrayOutput() RouterBgpAdvertisedGroupsItemArrayOutput {
	return i.ToRouterBgpAdvertisedGroupsItemArrayOutputWithContext(context.Background())
}

func (i RouterBgpAdvertisedGroupsItemArray) ToRouterBgpAdvertisedGroupsItemArrayOutputWithContext(ctx context.Context) RouterBgpAdvertisedGroupsItemArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RouterBgpAdvertisedGroupsItemArrayOutput)
}

type RouterBgpAdvertisedGroupsItemArrayOutput struct{ *pulumi.OutputState }

func (RouterBgpAdvertisedGroupsItemArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RouterBgpAdvertisedGroupsItem)(nil)).Elem()
}

func (o RouterBgpAdvertisedGroupsItemArrayOutput) ToRouterBgpAdvertisedGroupsItemArrayOutput() RouterBgpAdvertisedGroupsItemArrayOutput {
	return o
}

func (o RouterBgpAdvertisedGroupsItemArrayOutput) ToRouterBgpAdvertisedGroupsItemArrayOutputWithContext(ctx context.Context) RouterBgpAdvertisedGroupsItemArrayOutput {
	return o
}

func (o RouterBgpAdvertisedGroupsItemArrayOutput) Index(i pulumi.IntInput) pulumi.StringOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) pulumi.StringOutput {
		return vs[0].([]RouterBgpAdvertisedGroupsItem)[vs[1].(int)].ToStringOutput()
	}).(pulumi.StringOutput)
}

// User-specified flag to indicate which mode to use for advertisement.
type RouterBgpPeerAdvertiseMode pulumi.String

const (
	RouterBgpPeerAdvertiseModeCustom  = RouterBgpPeerAdvertiseMode("CUSTOM")
	RouterBgpPeerAdvertiseModeDefault = RouterBgpPeerAdvertiseMode("DEFAULT")
)

func (RouterBgpPeerAdvertiseMode) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RouterBgpPeerAdvertiseMode) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RouterBgpPeerAdvertiseMode) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RouterBgpPeerAdvertiseMode) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RouterBgpPeerAdvertiseMode) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

type RouterBgpPeerAdvertisedGroupsItem pulumi.String

const (
	// Advertise all available subnets (including peer VPC subnets).
	RouterBgpPeerAdvertisedGroupsItemAllSubnets = RouterBgpPeerAdvertisedGroupsItem("ALL_SUBNETS")
)

func (RouterBgpPeerAdvertisedGroupsItem) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RouterBgpPeerAdvertisedGroupsItem) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RouterBgpPeerAdvertisedGroupsItem) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RouterBgpPeerAdvertisedGroupsItem) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RouterBgpPeerAdvertisedGroupsItem) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// RouterBgpPeerAdvertisedGroupsItemArrayInput is an input type that accepts RouterBgpPeerAdvertisedGroupsItemArray and RouterBgpPeerAdvertisedGroupsItemArrayOutput values.
// You can construct a concrete instance of `RouterBgpPeerAdvertisedGroupsItemArrayInput` via:
//
//          RouterBgpPeerAdvertisedGroupsItemArray{ RouterBgpPeerAdvertisedGroupsItemArgs{...} }
type RouterBgpPeerAdvertisedGroupsItemArrayInput interface {
	pulumi.Input

	ToRouterBgpPeerAdvertisedGroupsItemArrayOutput() RouterBgpPeerAdvertisedGroupsItemArrayOutput
	ToRouterBgpPeerAdvertisedGroupsItemArrayOutputWithContext(context.Context) RouterBgpPeerAdvertisedGroupsItemArrayOutput
}

type RouterBgpPeerAdvertisedGroupsItemArray []RouterBgpPeerAdvertisedGroupsItem

func (RouterBgpPeerAdvertisedGroupsItemArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RouterBgpPeerAdvertisedGroupsItem)(nil)).Elem()
}

func (i RouterBgpPeerAdvertisedGroupsItemArray) ToRouterBgpPeerAdvertisedGroupsItemArrayOutput() RouterBgpPeerAdvertisedGroupsItemArrayOutput {
	return i.ToRouterBgpPeerAdvertisedGroupsItemArrayOutputWithContext(context.Background())
}

func (i RouterBgpPeerAdvertisedGroupsItemArray) ToRouterBgpPeerAdvertisedGroupsItemArrayOutputWithContext(ctx context.Context) RouterBgpPeerAdvertisedGroupsItemArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RouterBgpPeerAdvertisedGroupsItemArrayOutput)
}

type RouterBgpPeerAdvertisedGroupsItemArrayOutput struct{ *pulumi.OutputState }

func (RouterBgpPeerAdvertisedGroupsItemArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RouterBgpPeerAdvertisedGroupsItem)(nil)).Elem()
}

func (o RouterBgpPeerAdvertisedGroupsItemArrayOutput) ToRouterBgpPeerAdvertisedGroupsItemArrayOutput() RouterBgpPeerAdvertisedGroupsItemArrayOutput {
	return o
}

func (o RouterBgpPeerAdvertisedGroupsItemArrayOutput) ToRouterBgpPeerAdvertisedGroupsItemArrayOutputWithContext(ctx context.Context) RouterBgpPeerAdvertisedGroupsItemArrayOutput {
	return o
}

func (o RouterBgpPeerAdvertisedGroupsItemArrayOutput) Index(i pulumi.IntInput) pulumi.StringOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) pulumi.StringOutput {
		return vs[0].([]RouterBgpPeerAdvertisedGroupsItem)[vs[1].(int)].ToStringOutput()
	}).(pulumi.StringOutput)
}

// The BFD session initialization mode for this BGP peer. Not currently available publicly. If set to ACTIVE, the Cloud Router will initiate the BFD session for this BGP peer. If set to PASSIVE, the Cloud Router will wait for the peer router to initiate the BFD session for this BGP peer. If set to DISABLED, BFD is disabled for this BGP peer. The default is PASSIVE.
type RouterBgpPeerBfdSessionInitializationMode pulumi.String

const (
	RouterBgpPeerBfdSessionInitializationModeActive   = RouterBgpPeerBfdSessionInitializationMode("ACTIVE")
	RouterBgpPeerBfdSessionInitializationModeDisabled = RouterBgpPeerBfdSessionInitializationMode("DISABLED")
	RouterBgpPeerBfdSessionInitializationModePassive  = RouterBgpPeerBfdSessionInitializationMode("PASSIVE")
)

func (RouterBgpPeerBfdSessionInitializationMode) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RouterBgpPeerBfdSessionInitializationMode) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RouterBgpPeerBfdSessionInitializationMode) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RouterBgpPeerBfdSessionInitializationMode) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RouterBgpPeerBfdSessionInitializationMode) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The status of the BGP peer connection. If set to FALSE, any active session with the peer is terminated and all associated routing information is removed. If set to TRUE, the peer connection can be established with routing information. The default is TRUE.
type RouterBgpPeerEnable pulumi.String

const (
	RouterBgpPeerEnableFalse = RouterBgpPeerEnable("FALSE")
	RouterBgpPeerEnableTrue  = RouterBgpPeerEnable("TRUE")
)

func (RouterBgpPeerEnable) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RouterBgpPeerEnable) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RouterBgpPeerEnable) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RouterBgpPeerEnable) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RouterBgpPeerEnable) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] The resource that configures and manages this BGP peer. - MANAGED_BY_USER is the default value and can be managed by you or other users - MANAGED_BY_ATTACHMENT is a BGP peer that is configured and managed by Cloud Interconnect, specifically by an InterconnectAttachment of type PARTNER. Google automatically creates, updates, and deletes this type of BGP peer when the PARTNER InterconnectAttachment is created, updated, or deleted.
type RouterBgpPeerManagementType pulumi.String

const (
	// The BGP peer is automatically created for PARTNER type InterconnectAttachment; Google will automatically create/delete this BGP peer when the PARTNER InterconnectAttachment is created/deleted, and Google will update the ipAddress and peerIpAddress when the PARTNER InterconnectAttachment is provisioned. This type of BGP peer cannot be created or deleted, but can be modified for all fields except for name, ipAddress and peerIpAddress.
	RouterBgpPeerManagementTypeManagedByAttachment = RouterBgpPeerManagementType("MANAGED_BY_ATTACHMENT")
	// Default value, the BGP peer is manually created and managed by user.
	RouterBgpPeerManagementTypeManagedByUser = RouterBgpPeerManagementType("MANAGED_BY_USER")
)

func (RouterBgpPeerManagementType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RouterBgpPeerManagementType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RouterBgpPeerManagementType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RouterBgpPeerManagementType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RouterBgpPeerManagementType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] The resource that configures and manages this interface. - MANAGED_BY_USER is the default value and can be managed directly by users. - MANAGED_BY_ATTACHMENT is an interface that is configured and managed by Cloud Interconnect, specifically, by an InterconnectAttachment of type PARTNER. Google automatically creates, updates, and deletes this type of interface when the PARTNER InterconnectAttachment is created, updated, or deleted.
type RouterInterfaceManagementType pulumi.String

const (
	// The interface is automatically created for PARTNER type InterconnectAttachment, Google will automatically create/update/delete this interface when the PARTNER InterconnectAttachment is created/provisioned/deleted. This type of interface cannot be manually managed by user.
	RouterInterfaceManagementTypeManagedByAttachment = RouterInterfaceManagementType("MANAGED_BY_ATTACHMENT")
	// Default value, the interface is manually created and managed by user.
	RouterInterfaceManagementTypeManagedByUser = RouterInterfaceManagementType("MANAGED_BY_USER")
)

func (RouterInterfaceManagementType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RouterInterfaceManagementType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RouterInterfaceManagementType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RouterInterfaceManagementType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RouterInterfaceManagementType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specify the desired filtering of logs on this NAT. If unspecified, logs are exported for all connections handled by this NAT. This option can take one of the following values: - ERRORS_ONLY: Export logs only for connection failures. - TRANSLATIONS_ONLY: Export logs only for successful connections. - ALL: Export logs for all connections, successful and unsuccessful.
type RouterNatLogConfigFilter pulumi.String

const (
	// Export logs for all (successful and unsuccessful) connections.
	RouterNatLogConfigFilterAll = RouterNatLogConfigFilter("ALL")
	// Export logs for connection failures only.
	RouterNatLogConfigFilterErrorsOnly = RouterNatLogConfigFilter("ERRORS_ONLY")
	// Export logs for successful connections only.
	RouterNatLogConfigFilterTranslationsOnly = RouterNatLogConfigFilter("TRANSLATIONS_ONLY")
)

func (RouterNatLogConfigFilter) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RouterNatLogConfigFilter) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RouterNatLogConfigFilter) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RouterNatLogConfigFilter) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RouterNatLogConfigFilter) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specify the NatIpAllocateOption, which can take one of the following values: - MANUAL_ONLY: Uses only Nat IP addresses provided by customers. When there are not enough specified Nat IPs, the Nat service fails for new VMs. - AUTO_ONLY: Nat IPs are allocated by Google Cloud Platform; customers can't specify any Nat IPs. When choosing AUTO_ONLY, then nat_ip should be empty.
type RouterNatNatIpAllocateOption pulumi.String

const (
	// Nat IPs are allocated by GCP; customers can not specify any Nat IPs.
	RouterNatNatIpAllocateOptionAutoOnly = RouterNatNatIpAllocateOption("AUTO_ONLY")
	// Only use Nat IPs provided by customers. When specified Nat IPs are not enough then the Nat service fails for new VMs.
	RouterNatNatIpAllocateOptionManualOnly = RouterNatNatIpAllocateOption("MANUAL_ONLY")
)

func (RouterNatNatIpAllocateOption) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RouterNatNatIpAllocateOption) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RouterNatNatIpAllocateOption) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RouterNatNatIpAllocateOption) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RouterNatNatIpAllocateOption) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specify the Nat option, which can take one of the following values: - ALL_SUBNETWORKS_ALL_IP_RANGES: All of the IP ranges in every Subnetwork are allowed to Nat. - ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES: All of the primary IP ranges in every Subnetwork are allowed to Nat. - LIST_OF_SUBNETWORKS: A list of Subnetworks are allowed to Nat (specified in the field subnetwork below) The default is SUBNETWORK_IP_RANGE_TO_NAT_OPTION_UNSPECIFIED. Note that if this field contains ALL_SUBNETWORKS_ALL_IP_RANGES or ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES, then there should not be any other Router.Nat section in any Router for this network in this region.
type RouterNatSourceSubnetworkIpRangesToNat pulumi.String

const (
	// All the IP ranges in every Subnetwork are allowed to Nat.
	RouterNatSourceSubnetworkIpRangesToNatAllSubnetworksAllIpRanges = RouterNatSourceSubnetworkIpRangesToNat("ALL_SUBNETWORKS_ALL_IP_RANGES")
	// All the primary IP ranges in every Subnetwork are allowed to Nat.
	RouterNatSourceSubnetworkIpRangesToNatAllSubnetworksAllPrimaryIpRanges = RouterNatSourceSubnetworkIpRangesToNat("ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES")
	// A list of Subnetworks are allowed to Nat (specified in the field subnetwork below)
	RouterNatSourceSubnetworkIpRangesToNatListOfSubnetworks = RouterNatSourceSubnetworkIpRangesToNat("LIST_OF_SUBNETWORKS")
)

func (RouterNatSourceSubnetworkIpRangesToNat) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RouterNatSourceSubnetworkIpRangesToNat) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RouterNatSourceSubnetworkIpRangesToNat) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RouterNatSourceSubnetworkIpRangesToNat) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RouterNatSourceSubnetworkIpRangesToNat) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

type RouterNatSubnetworkToNatSourceIpRangesToNatItem pulumi.String

const (
	// The primary and all the secondary ranges are allowed to Nat.
	RouterNatSubnetworkToNatSourceIpRangesToNatItemAllIpRanges = RouterNatSubnetworkToNatSourceIpRangesToNatItem("ALL_IP_RANGES")
	// A list of secondary ranges are allowed to Nat.
	RouterNatSubnetworkToNatSourceIpRangesToNatItemListOfSecondaryIpRanges = RouterNatSubnetworkToNatSourceIpRangesToNatItem("LIST_OF_SECONDARY_IP_RANGES")
	// The primary range is allowed to Nat.
	RouterNatSubnetworkToNatSourceIpRangesToNatItemPrimaryIpRange = RouterNatSubnetworkToNatSourceIpRangesToNatItem("PRIMARY_IP_RANGE")
)

func (RouterNatSubnetworkToNatSourceIpRangesToNatItem) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RouterNatSubnetworkToNatSourceIpRangesToNatItem) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RouterNatSubnetworkToNatSourceIpRangesToNatItem) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RouterNatSubnetworkToNatSourceIpRangesToNatItem) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RouterNatSubnetworkToNatSourceIpRangesToNatItem) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// RouterNatSubnetworkToNatSourceIpRangesToNatItemArrayInput is an input type that accepts RouterNatSubnetworkToNatSourceIpRangesToNatItemArray and RouterNatSubnetworkToNatSourceIpRangesToNatItemArrayOutput values.
// You can construct a concrete instance of `RouterNatSubnetworkToNatSourceIpRangesToNatItemArrayInput` via:
//
//          RouterNatSubnetworkToNatSourceIpRangesToNatItemArray{ RouterNatSubnetworkToNatSourceIpRangesToNatItemArgs{...} }
type RouterNatSubnetworkToNatSourceIpRangesToNatItemArrayInput interface {
	pulumi.Input

	ToRouterNatSubnetworkToNatSourceIpRangesToNatItemArrayOutput() RouterNatSubnetworkToNatSourceIpRangesToNatItemArrayOutput
	ToRouterNatSubnetworkToNatSourceIpRangesToNatItemArrayOutputWithContext(context.Context) RouterNatSubnetworkToNatSourceIpRangesToNatItemArrayOutput
}

type RouterNatSubnetworkToNatSourceIpRangesToNatItemArray []RouterNatSubnetworkToNatSourceIpRangesToNatItem

func (RouterNatSubnetworkToNatSourceIpRangesToNatItemArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RouterNatSubnetworkToNatSourceIpRangesToNatItem)(nil)).Elem()
}

func (i RouterNatSubnetworkToNatSourceIpRangesToNatItemArray) ToRouterNatSubnetworkToNatSourceIpRangesToNatItemArrayOutput() RouterNatSubnetworkToNatSourceIpRangesToNatItemArrayOutput {
	return i.ToRouterNatSubnetworkToNatSourceIpRangesToNatItemArrayOutputWithContext(context.Background())
}

func (i RouterNatSubnetworkToNatSourceIpRangesToNatItemArray) ToRouterNatSubnetworkToNatSourceIpRangesToNatItemArrayOutputWithContext(ctx context.Context) RouterNatSubnetworkToNatSourceIpRangesToNatItemArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RouterNatSubnetworkToNatSourceIpRangesToNatItemArrayOutput)
}

type RouterNatSubnetworkToNatSourceIpRangesToNatItemArrayOutput struct{ *pulumi.OutputState }

func (RouterNatSubnetworkToNatSourceIpRangesToNatItemArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RouterNatSubnetworkToNatSourceIpRangesToNatItem)(nil)).Elem()
}

func (o RouterNatSubnetworkToNatSourceIpRangesToNatItemArrayOutput) ToRouterNatSubnetworkToNatSourceIpRangesToNatItemArrayOutput() RouterNatSubnetworkToNatSourceIpRangesToNatItemArrayOutput {
	return o
}

func (o RouterNatSubnetworkToNatSourceIpRangesToNatItemArrayOutput) ToRouterNatSubnetworkToNatSourceIpRangesToNatItemArrayOutputWithContext(ctx context.Context) RouterNatSubnetworkToNatSourceIpRangesToNatItemArrayOutput {
	return o
}

func (o RouterNatSubnetworkToNatSourceIpRangesToNatItemArrayOutput) Index(i pulumi.IntInput) pulumi.StringOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) pulumi.StringOutput {
		return vs[0].([]RouterNatSubnetworkToNatSourceIpRangesToNatItem)[vs[1].(int)].ToStringOutput()
	}).(pulumi.StringOutput)
}

// This is deprecated and has no effect. Do not use.
type RuleAction pulumi.String

const (
	// This is deprecated and has no effect. Do not use.
	RuleActionAllow = RuleAction("ALLOW")
	// This is deprecated and has no effect. Do not use.
	RuleActionAllowWithLog = RuleAction("ALLOW_WITH_LOG")
	// This is deprecated and has no effect. Do not use.
	RuleActionDeny = RuleAction("DENY")
	// This is deprecated and has no effect. Do not use.
	RuleActionDenyWithLog = RuleAction("DENY_WITH_LOG")
	// This is deprecated and has no effect. Do not use.
	RuleActionLog = RuleAction("LOG")
	// This is deprecated and has no effect. Do not use.
	RuleActionNoAction = RuleAction("NO_ACTION")
)

func (RuleAction) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e RuleAction) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e RuleAction) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e RuleAction) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e RuleAction) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies how port is selected for health checking, can be one of following values: USE_FIXED_PORT: The port number in port is used for health checking. USE_NAMED_PORT: The portName is used for health checking. USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking. If not specified, SSL health check follows behavior specified in port and portName fields.
type SSLHealthCheckPortSpecification pulumi.String

const (
	// The port number in port is used for health checking.
	SSLHealthCheckPortSpecificationUseFixedPort = SSLHealthCheckPortSpecification("USE_FIXED_PORT")
	// The portName is used for health checking.
	SSLHealthCheckPortSpecificationUseNamedPort = SSLHealthCheckPortSpecification("USE_NAMED_PORT")
	// For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking.
	SSLHealthCheckPortSpecificationUseServingPort = SSLHealthCheckPortSpecification("USE_SERVING_PORT")
)

func (SSLHealthCheckPortSpecification) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SSLHealthCheckPortSpecification) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SSLHealthCheckPortSpecification) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SSLHealthCheckPortSpecification) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SSLHealthCheckPortSpecification) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
type SSLHealthCheckProxyHeader pulumi.String

const (
	SSLHealthCheckProxyHeaderNone    = SSLHealthCheckProxyHeader("NONE")
	SSLHealthCheckProxyHeaderProxyV1 = SSLHealthCheckProxyHeader("PROXY_V1")
)

func (SSLHealthCheckProxyHeader) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SSLHealthCheckProxyHeader) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SSLHealthCheckProxyHeader) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SSLHealthCheckProxyHeader) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SSLHealthCheckProxyHeader) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME.
type SavedAttachedDiskInterface pulumi.String

const (
	SavedAttachedDiskInterfaceNvme = SavedAttachedDiskInterface("NVME")
	SavedAttachedDiskInterfaceScsi = SavedAttachedDiskInterface("SCSI")
)

func (SavedAttachedDiskInterface) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SavedAttachedDiskInterface) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SavedAttachedDiskInterface) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SavedAttachedDiskInterface) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SavedAttachedDiskInterface) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The mode in which this disk is attached to the source instance, either READ_WRITE or READ_ONLY.
type SavedAttachedDiskMode pulumi.String

const (
	// Attaches this disk in read-only mode. Multiple virtual machines can use a disk in read-only mode at a time.
	SavedAttachedDiskModeReadOnly = SavedAttachedDiskMode("READ_ONLY")
	// *[Default]* Attaches this disk in read-write mode. Only one virtual machine at a time can be attached to a disk in read-write mode.
	SavedAttachedDiskModeReadWrite = SavedAttachedDiskMode("READ_WRITE")
)

func (SavedAttachedDiskMode) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SavedAttachedDiskMode) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SavedAttachedDiskMode) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SavedAttachedDiskMode) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SavedAttachedDiskMode) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] An indicator whether storageBytes is in a stable state or it is being adjusted as a result of shared storage reallocation. This status can either be UPDATING, meaning the size of the snapshot is being updated, or UP_TO_DATE, meaning the size of the snapshot is up-to-date.
type SavedAttachedDiskStorageBytesStatus pulumi.String

const (
	SavedAttachedDiskStorageBytesStatusUpdating = SavedAttachedDiskStorageBytesStatus("UPDATING")
	SavedAttachedDiskStorageBytesStatusUpToDate = SavedAttachedDiskStorageBytesStatus("UP_TO_DATE")
)

func (SavedAttachedDiskStorageBytesStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SavedAttachedDiskStorageBytesStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SavedAttachedDiskStorageBytesStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SavedAttachedDiskStorageBytesStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SavedAttachedDiskStorageBytesStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies the type of the attached disk, either SCRATCH or PERSISTENT.
type SavedAttachedDiskType pulumi.String

const (
	SavedAttachedDiskTypePersistent = SavedAttachedDiskType("PERSISTENT")
	SavedAttachedDiskTypeScratch    = SavedAttachedDiskType("SCRATCH")
)

func (SavedAttachedDiskType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SavedAttachedDiskType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SavedAttachedDiskType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SavedAttachedDiskType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SavedAttachedDiskType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// For more information about maintenance intervals, see Setting maintenance intervals.
type SchedulingMaintenanceInterval pulumi.String

const (
	// VMs receive infrastructure and hypervisor updates on a periodic basis, minimizing the number of maintenance operations (live migrations or terminations) on an individual VM. This may mean a VM will take longer to receive an update than if it was configured for AS_NEEDED. Security updates will still be applied as soon as they are available.
	SchedulingMaintenanceIntervalPeriodic = SchedulingMaintenanceInterval("PERIODIC")
)

func (SchedulingMaintenanceInterval) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SchedulingMaintenanceInterval) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SchedulingMaintenanceInterval) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SchedulingMaintenanceInterval) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SchedulingMaintenanceInterval) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Defines the operation of node selection. Valid operators are IN for affinity and NOT_IN for anti-affinity.
type SchedulingNodeAffinityOperator pulumi.String

const (
	// Requires Compute Engine to seek for matched nodes.
	SchedulingNodeAffinityOperatorIn = SchedulingNodeAffinityOperator("IN")
	// Requires Compute Engine to avoid certain nodes.
	SchedulingNodeAffinityOperatorNotIn               = SchedulingNodeAffinityOperator("NOT_IN")
	SchedulingNodeAffinityOperatorOperatorUnspecified = SchedulingNodeAffinityOperator("OPERATOR_UNSPECIFIED")
)

func (SchedulingNodeAffinityOperator) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SchedulingNodeAffinityOperator) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SchedulingNodeAffinityOperator) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SchedulingNodeAffinityOperator) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SchedulingNodeAffinityOperator) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Defines the maintenance behavior for this instance. For standard instances, the default behavior is MIGRATE. For preemptible instances, the default and only possible behavior is TERMINATE. For more information, see Setting Instance Scheduling Options.
type SchedulingOnHostMaintenance pulumi.String

const (
	// *[Default]* Allows Compute Engine to automatically migrate instances out of the way of maintenance events.
	SchedulingOnHostMaintenanceMigrate = SchedulingOnHostMaintenance("MIGRATE")
	// Tells Compute Engine to terminate and (optionally) restart the instance away from the maintenance activity. If you would like your instance to be restarted, set the automaticRestart flag to true. Your instance may be restarted more than once, and it may be restarted outside the window of maintenance events.
	SchedulingOnHostMaintenanceTerminate = SchedulingOnHostMaintenance("TERMINATE")
)

func (SchedulingOnHostMaintenance) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SchedulingOnHostMaintenance) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SchedulingOnHostMaintenance) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SchedulingOnHostMaintenance) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SchedulingOnHostMaintenance) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Rule visibility can be one of the following: STANDARD - opaque rules. (default) PREMIUM - transparent rules.
type SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility pulumi.String

const (
	SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibilityPremium  = SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility("PREMIUM")
	SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibilityStandard = SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility("STANDARD")
)

func (SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

type SecurityPolicyAdvancedOptionsConfigJsonParsing pulumi.String

const (
	SecurityPolicyAdvancedOptionsConfigJsonParsingDisabled = SecurityPolicyAdvancedOptionsConfigJsonParsing("DISABLED")
	SecurityPolicyAdvancedOptionsConfigJsonParsingStandard = SecurityPolicyAdvancedOptionsConfigJsonParsing("STANDARD")
)

func (SecurityPolicyAdvancedOptionsConfigJsonParsing) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SecurityPolicyAdvancedOptionsConfigJsonParsing) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SecurityPolicyAdvancedOptionsConfigJsonParsing) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SecurityPolicyAdvancedOptionsConfigJsonParsing) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SecurityPolicyAdvancedOptionsConfigJsonParsing) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

type SecurityPolicyAdvancedOptionsConfigLogLevel pulumi.String

const (
	SecurityPolicyAdvancedOptionsConfigLogLevelNormal  = SecurityPolicyAdvancedOptionsConfigLogLevel("NORMAL")
	SecurityPolicyAdvancedOptionsConfigLogLevelVerbose = SecurityPolicyAdvancedOptionsConfigLogLevel("VERBOSE")
)

func (SecurityPolicyAdvancedOptionsConfigLogLevel) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SecurityPolicyAdvancedOptionsConfigLogLevel) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SecurityPolicyAdvancedOptionsConfigLogLevel) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SecurityPolicyAdvancedOptionsConfigLogLevel) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SecurityPolicyAdvancedOptionsConfigLogLevel) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The direction in which this rule applies. This field may only be specified when versioned_expr is set to FIREWALL.
type SecurityPolicyRuleDirection pulumi.String

const (
	SecurityPolicyRuleDirectionEgress  = SecurityPolicyRuleDirection("EGRESS")
	SecurityPolicyRuleDirectionIngress = SecurityPolicyRuleDirection("INGRESS")
)

func (SecurityPolicyRuleDirection) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SecurityPolicyRuleDirection) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SecurityPolicyRuleDirection) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SecurityPolicyRuleDirection) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SecurityPolicyRuleDirection) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Preconfigured versioned expression. If this field is specified, config must also be specified. Available preconfigured expressions along with their requirements are: SRC_IPS_V1 - must specify the corresponding src_ip_range field in config.
type SecurityPolicyRuleMatcherVersionedExpr pulumi.String

const (
	SecurityPolicyRuleMatcherVersionedExprFirewall = SecurityPolicyRuleMatcherVersionedExpr("FIREWALL")
	// Matches the source IP address of a request to the IP ranges supplied in config.
	SecurityPolicyRuleMatcherVersionedExprSrcIpsV1 = SecurityPolicyRuleMatcherVersionedExpr("SRC_IPS_V1")
)

func (SecurityPolicyRuleMatcherVersionedExpr) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SecurityPolicyRuleMatcherVersionedExpr) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SecurityPolicyRuleMatcherVersionedExpr) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SecurityPolicyRuleMatcherVersionedExpr) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SecurityPolicyRuleMatcherVersionedExpr) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The type indicates the intended use of the security policy. CLOUD_ARMOR policies apply to backend services. FIREWALL policies apply to organizations.
type SecurityPolicyType pulumi.String

const (
	SecurityPolicyTypeCloudArmor     = SecurityPolicyType("CLOUD_ARMOR")
	SecurityPolicyTypeCloudArmorEdge = SecurityPolicyType("CLOUD_ARMOR_EDGE")
	SecurityPolicyTypeFirewall       = SecurityPolicyType("FIREWALL")
)

func (SecurityPolicyType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SecurityPolicyType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SecurityPolicyType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SecurityPolicyType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SecurityPolicyType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

type ServerBindingType pulumi.String

const (
	// Node may associate with any physical server over its lifetime.
	ServerBindingTypeRestartNodeOnAnyServer = ServerBindingType("RESTART_NODE_ON_ANY_SERVER")
	// Node may associate with minimal physical servers over its lifetime.
	ServerBindingTypeRestartNodeOnMinimalServers  = ServerBindingType("RESTART_NODE_ON_MINIMAL_SERVERS")
	ServerBindingTypeServerBindingTypeUnspecified = ServerBindingType("SERVER_BINDING_TYPE_UNSPECIFIED")
)

func (ServerBindingType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e ServerBindingType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e ServerBindingType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e ServerBindingType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e ServerBindingType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The status of a connected endpoint to this service attachment.
type ServiceAttachmentConnectedEndpointStatus pulumi.String

const (
	// The connection has been accepted by the producer.
	ServiceAttachmentConnectedEndpointStatusAccepted = ServiceAttachmentConnectedEndpointStatus("ACCEPTED")
	// The connection has been closed by the producer.
	ServiceAttachmentConnectedEndpointStatusClosed = ServiceAttachmentConnectedEndpointStatus("CLOSED")
	// The connection is pending acceptance by the producer.
	ServiceAttachmentConnectedEndpointStatusPending = ServiceAttachmentConnectedEndpointStatus("PENDING")
	// The consumer is still connected but not using the connection.
	ServiceAttachmentConnectedEndpointStatusRejected          = ServiceAttachmentConnectedEndpointStatus("REJECTED")
	ServiceAttachmentConnectedEndpointStatusStatusUnspecified = ServiceAttachmentConnectedEndpointStatus("STATUS_UNSPECIFIED")
)

func (ServiceAttachmentConnectedEndpointStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e ServiceAttachmentConnectedEndpointStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e ServiceAttachmentConnectedEndpointStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e ServiceAttachmentConnectedEndpointStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e ServiceAttachmentConnectedEndpointStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The connection preference of service attachment. The value can be set to ACCEPT_AUTOMATIC. An ACCEPT_AUTOMATIC service attachment is one that always accepts the connection from consumer forwarding rules.
type ServiceAttachmentConnectionPreference pulumi.String

const (
	ServiceAttachmentConnectionPreferenceAcceptAutomatic                 = ServiceAttachmentConnectionPreference("ACCEPT_AUTOMATIC")
	ServiceAttachmentConnectionPreferenceAcceptManual                    = ServiceAttachmentConnectionPreference("ACCEPT_MANUAL")
	ServiceAttachmentConnectionPreferenceConnectionPreferenceUnspecified = ServiceAttachmentConnectionPreference("CONNECTION_PREFERENCE_UNSPECIFIED")
)

func (ServiceAttachmentConnectionPreference) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e ServiceAttachmentConnectionPreference) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e ServiceAttachmentConnectionPreference) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e ServiceAttachmentConnectionPreference) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e ServiceAttachmentConnectionPreference) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The status of the forwarding rule.
type ServiceAttachmentConsumerForwardingRuleStatus pulumi.String

const (
	// The connection has been accepted by the producer.
	ServiceAttachmentConsumerForwardingRuleStatusAccepted = ServiceAttachmentConsumerForwardingRuleStatus("ACCEPTED")
	// The connection has been closed by the producer.
	ServiceAttachmentConsumerForwardingRuleStatusClosed = ServiceAttachmentConsumerForwardingRuleStatus("CLOSED")
	// The connection is pending acceptance by the producer.
	ServiceAttachmentConsumerForwardingRuleStatusPending = ServiceAttachmentConsumerForwardingRuleStatus("PENDING")
	// The consumer is still connected but not using the connection.
	ServiceAttachmentConsumerForwardingRuleStatusRejected          = ServiceAttachmentConsumerForwardingRuleStatus("REJECTED")
	ServiceAttachmentConsumerForwardingRuleStatusStatusUnspecified = ServiceAttachmentConsumerForwardingRuleStatus("STATUS_UNSPECIFIED")
)

func (ServiceAttachmentConsumerForwardingRuleStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e ServiceAttachmentConsumerForwardingRuleStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e ServiceAttachmentConsumerForwardingRuleStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e ServiceAttachmentConsumerForwardingRuleStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e ServiceAttachmentConsumerForwardingRuleStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] The status of the snapshot. This can be CREATING, DELETING, FAILED, READY, or UPLOADING.
type SnapshotStatus pulumi.String

const (
	// Snapshot creation is in progress.
	SnapshotStatusCreating = SnapshotStatus("CREATING")
	// Snapshot is currently being deleted.
	SnapshotStatusDeleting = SnapshotStatus("DELETING")
	// Snapshot creation failed.
	SnapshotStatusFailed = SnapshotStatus("FAILED")
	// Snapshot has been created successfully.
	SnapshotStatusReady = SnapshotStatus("READY")
	// Snapshot is being uploaded.
	SnapshotStatusUploading = SnapshotStatus("UPLOADING")
)

func (SnapshotStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SnapshotStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SnapshotStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SnapshotStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SnapshotStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] An indicator whether storageBytes is in a stable state or it is being adjusted as a result of shared storage reallocation. This status can either be UPDATING, meaning the size of the snapshot is being updated, or UP_TO_DATE, meaning the size of the snapshot is up-to-date.
type SnapshotStorageBytesStatus pulumi.String

const (
	SnapshotStorageBytesStatusUpdating = SnapshotStorageBytesStatus("UPDATING")
	SnapshotStorageBytesStatusUpToDate = SnapshotStorageBytesStatus("UP_TO_DATE")
)

func (SnapshotStorageBytesStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SnapshotStorageBytesStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SnapshotStorageBytesStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SnapshotStorageBytesStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SnapshotStorageBytesStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// PostKeyRevocationActionType of the instance.
type SourceInstancePropertiesPostKeyRevocationActionType pulumi.String

const (
	// Indicates user chose no operation.
	SourceInstancePropertiesPostKeyRevocationActionTypeNoop = SourceInstancePropertiesPostKeyRevocationActionType("NOOP")
	// Default value. This value is unused.
	SourceInstancePropertiesPostKeyRevocationActionTypePostKeyRevocationActionTypeUnspecified = SourceInstancePropertiesPostKeyRevocationActionType("POST_KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED")
	// Indicates user chose to opt for VM shutdown on key revocation.
	SourceInstancePropertiesPostKeyRevocationActionTypeShutdown = SourceInstancePropertiesPostKeyRevocationActionType("SHUTDOWN")
)

func (SourceInstancePropertiesPostKeyRevocationActionType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SourceInstancePropertiesPostKeyRevocationActionType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SourceInstancePropertiesPostKeyRevocationActionType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SourceInstancePropertiesPostKeyRevocationActionType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SourceInstancePropertiesPostKeyRevocationActionType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output only] Status of the managed certificate resource.
type SslCertificateManagedSslCertificateStatus pulumi.String

const (
	// The certificate management is working, and a certificate has been provisioned.
	SslCertificateManagedSslCertificateStatusActive                              = SslCertificateManagedSslCertificateStatus("ACTIVE")
	SslCertificateManagedSslCertificateStatusManagedCertificateStatusUnspecified = SslCertificateManagedSslCertificateStatus("MANAGED_CERTIFICATE_STATUS_UNSPECIFIED")
	// The certificate management is working. GCP will attempt to provision the first certificate.
	SslCertificateManagedSslCertificateStatusProvisioning = SslCertificateManagedSslCertificateStatus("PROVISIONING")
	// Certificate provisioning failed due to an issue with the DNS or load balancing configuration. For details of which domain failed, consult domain_status field.
	SslCertificateManagedSslCertificateStatusProvisioningFailed = SslCertificateManagedSslCertificateStatus("PROVISIONING_FAILED")
	// Certificate provisioning failed due to an issue with the DNS or load balancing configuration. It won't be retried. To try again delete and create a new managed SslCertificate resource. For details of which domain failed, consult domain_status field.
	SslCertificateManagedSslCertificateStatusProvisioningFailedPermanently = SslCertificateManagedSslCertificateStatus("PROVISIONING_FAILED_PERMANENTLY")
	// Renewal of the certificate has failed due to an issue with the DNS or load balancing configuration. The existing cert is still serving; however, it will expire shortly. To provision a renewed certificate, delete and create a new managed SslCertificate resource. For details on which domain failed, consult domain_status field.
	SslCertificateManagedSslCertificateStatusRenewalFailed = SslCertificateManagedSslCertificateStatus("RENEWAL_FAILED")
)

func (SslCertificateManagedSslCertificateStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SslCertificateManagedSslCertificateStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SslCertificateManagedSslCertificateStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SslCertificateManagedSslCertificateStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SslCertificateManagedSslCertificateStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// (Optional) Specifies the type of SSL certificate, either "SELF_MANAGED" or "MANAGED". If not specified, the certificate is self-managed and the fields certificate and private_key are used.
type SslCertificateType pulumi.String

const (
	// Google-managed SSLCertificate.
	SslCertificateTypeManaged = SslCertificateType("MANAGED")
	// Certificate uploaded by user.
	SslCertificateTypeSelfManaged     = SslCertificateType("SELF_MANAGED")
	SslCertificateTypeTypeUnspecified = SslCertificateType("TYPE_UNSPECIFIED")
)

func (SslCertificateType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SslCertificateType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SslCertificateType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SslCertificateType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SslCertificateType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The minimum version of SSL protocol that can be used by the clients to establish a connection with the load balancer. This can be one of TLS_1_0, TLS_1_1, TLS_1_2.
type SslPolicyMinTlsVersion pulumi.String

const (
	// TLS 1.0
	SslPolicyMinTlsVersionTls10 = SslPolicyMinTlsVersion("TLS_1_0")
	// TLS 1.1
	SslPolicyMinTlsVersionTls11 = SslPolicyMinTlsVersion("TLS_1_1")
	// TLS 1.2
	SslPolicyMinTlsVersionTls12 = SslPolicyMinTlsVersion("TLS_1_2")
)

func (SslPolicyMinTlsVersion) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SslPolicyMinTlsVersion) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SslPolicyMinTlsVersion) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SslPolicyMinTlsVersion) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SslPolicyMinTlsVersion) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Profile specifies the set of SSL features that can be used by the load balancer when negotiating SSL with clients. This can be one of COMPATIBLE, MODERN, RESTRICTED, or CUSTOM. If using CUSTOM, the set of SSL features to enable must be specified in the customFeatures field.
type SslPolicyProfile pulumi.String

const (
	// Compatible profile. Allows the broadset set of clients, even those which support only out-of-date SSL features to negotiate with the load balancer.
	SslPolicyProfileCompatible = SslPolicyProfile("COMPATIBLE")
	// Custom profile. Allow only the set of allowed SSL features specified in the customFeatures field.
	SslPolicyProfileCustom = SslPolicyProfile("CUSTOM")
	// Modern profile. Supports a wide set of SSL features, allowing modern clients to negotiate SSL with the load balancer.
	SslPolicyProfileModern = SslPolicyProfile("MODERN")
	// Restricted profile. Supports a reduced set of SSL features, intended to meet stricter compliance requirements.
	SslPolicyProfileRestricted = SslPolicyProfile("RESTRICTED")
)

func (SslPolicyProfile) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SslPolicyProfile) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SslPolicyProfile) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SslPolicyProfile) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SslPolicyProfile) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
type SslPolicyWarningsItemCode pulumi.String

const (
	// Warning about failed cleanup of transient changes made by a failed operation.
	SslPolicyWarningsItemCodeCleanupFailed = SslPolicyWarningsItemCode("CLEANUP_FAILED")
	// A link to a deprecated resource was created.
	SslPolicyWarningsItemCodeDeprecatedResourceUsed = SslPolicyWarningsItemCode("DEPRECATED_RESOURCE_USED")
	// When deploying and at least one of the resources has a type marked as deprecated
	SslPolicyWarningsItemCodeDeprecatedTypeUsed = SslPolicyWarningsItemCode("DEPRECATED_TYPE_USED")
	// The user created a boot disk that is larger than image size.
	SslPolicyWarningsItemCodeDiskSizeLargerThanImageSize = SslPolicyWarningsItemCode("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
	// When deploying and at least one of the resources has a type marked as experimental
	SslPolicyWarningsItemCodeExperimentalTypeUsed = SslPolicyWarningsItemCode("EXPERIMENTAL_TYPE_USED")
	// Warning that is present in an external api call
	SslPolicyWarningsItemCodeExternalApiWarning = SslPolicyWarningsItemCode("EXTERNAL_API_WARNING")
	// Warning that value of a field has been overridden. Deprecated unused field.
	SslPolicyWarningsItemCodeFieldValueOverriden = SslPolicyWarningsItemCode("FIELD_VALUE_OVERRIDEN")
	// The operation involved use of an injected kernel, which is deprecated.
	SslPolicyWarningsItemCodeInjectedKernelsDeprecated = SslPolicyWarningsItemCode("INJECTED_KERNELS_DEPRECATED")
	// When deploying a deployment with a exceedingly large number of resources
	SslPolicyWarningsItemCodeLargeDeploymentWarning = SslPolicyWarningsItemCode("LARGE_DEPLOYMENT_WARNING")
	// A resource depends on a missing type
	SslPolicyWarningsItemCodeMissingTypeDependency = SslPolicyWarningsItemCode("MISSING_TYPE_DEPENDENCY")
	// The route's nextHopIp address is not assigned to an instance on the network.
	SslPolicyWarningsItemCodeNextHopAddressNotAssigned = SslPolicyWarningsItemCode("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
	// The route's next hop instance cannot ip forward.
	SslPolicyWarningsItemCodeNextHopCannotIpForward = SslPolicyWarningsItemCode("NEXT_HOP_CANNOT_IP_FORWARD")
	// The route's nextHopInstance URL refers to an instance that does not exist.
	SslPolicyWarningsItemCodeNextHopInstanceNotFound = SslPolicyWarningsItemCode("NEXT_HOP_INSTANCE_NOT_FOUND")
	// The route's nextHopInstance URL refers to an instance that is not on the same network as the route.
	SslPolicyWarningsItemCodeNextHopInstanceNotOnNetwork = SslPolicyWarningsItemCode("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
	// The route's next hop instance does not have a status of RUNNING.
	SslPolicyWarningsItemCodeNextHopNotRunning = SslPolicyWarningsItemCode("NEXT_HOP_NOT_RUNNING")
	// Error which is not critical. We decided to continue the process despite the mentioned error.
	SslPolicyWarningsItemCodeNotCriticalError = SslPolicyWarningsItemCode("NOT_CRITICAL_ERROR")
	// No results are present on a particular list page.
	SslPolicyWarningsItemCodeNoResultsOnPage = SslPolicyWarningsItemCode("NO_RESULTS_ON_PAGE")
	// Success is reported, but some results may be missing due to errors
	SslPolicyWarningsItemCodePartialSuccess = SslPolicyWarningsItemCode("PARTIAL_SUCCESS")
	// The user attempted to use a resource that requires a TOS they have not accepted.
	SslPolicyWarningsItemCodeRequiredTosAgreement = SslPolicyWarningsItemCode("REQUIRED_TOS_AGREEMENT")
	// Warning that a resource is in use.
	SslPolicyWarningsItemCodeResourceInUseByOtherResourceWarning = SslPolicyWarningsItemCode("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
	// One or more of the resources set to auto-delete could not be deleted because they were in use.
	SslPolicyWarningsItemCodeResourceNotDeleted = SslPolicyWarningsItemCode("RESOURCE_NOT_DELETED")
	// When a resource schema validation is ignored.
	SslPolicyWarningsItemCodeSchemaValidationIgnored = SslPolicyWarningsItemCode("SCHEMA_VALIDATION_IGNORED")
	// Instance template used in instance group manager is valid as such, but its application does not make a lot of sense, because it allows only single instance in instance group.
	SslPolicyWarningsItemCodeSingleInstancePropertyTemplate = SslPolicyWarningsItemCode("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
	// When undeclared properties in the schema are present
	SslPolicyWarningsItemCodeUndeclaredProperties = SslPolicyWarningsItemCode("UNDECLARED_PROPERTIES")
	// A given scope cannot be reached.
	SslPolicyWarningsItemCodeUnreachable = SslPolicyWarningsItemCode("UNREACHABLE")
)

func (SslPolicyWarningsItemCode) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SslPolicyWarningsItemCode) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SslPolicyWarningsItemCode) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SslPolicyWarningsItemCode) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SslPolicyWarningsItemCode) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The access type of IPv6 address this subnet holds. It's immutable and can only be specified during creation or the first time the subnet is updated into IPV4_IPV6 dual stack. If the ipv6_type is EXTERNAL then this subnet cannot enable direct path.
type SubnetworkIpv6AccessType pulumi.String

const (
	// VMs in this subnet can have external IPv6.
	SubnetworkIpv6AccessTypeExternal = SubnetworkIpv6AccessType("EXTERNAL")
	// IPv6 access type not set. Means this subnet hasn't been turned on IPv6 yet.
	SubnetworkIpv6AccessTypeUnspecifiedIpv6AccessType = SubnetworkIpv6AccessType("UNSPECIFIED_IPV6_ACCESS_TYPE")
)

func (SubnetworkIpv6AccessType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SubnetworkIpv6AccessType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SubnetworkIpv6AccessType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SubnetworkIpv6AccessType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SubnetworkIpv6AccessType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Can only be specified if VPC flow logging for this subnetwork is enabled. Toggles the aggregation interval for collecting flow logs. Increasing the interval time will reduce the amount of generated flow logs for long lasting connections. Default is an interval of 5 seconds per connection.
type SubnetworkLogConfigAggregationInterval pulumi.String

const (
	SubnetworkLogConfigAggregationIntervalInterval10Min = SubnetworkLogConfigAggregationInterval("INTERVAL_10_MIN")
	SubnetworkLogConfigAggregationIntervalInterval15Min = SubnetworkLogConfigAggregationInterval("INTERVAL_15_MIN")
	SubnetworkLogConfigAggregationIntervalInterval1Min  = SubnetworkLogConfigAggregationInterval("INTERVAL_1_MIN")
	SubnetworkLogConfigAggregationIntervalInterval30Sec = SubnetworkLogConfigAggregationInterval("INTERVAL_30_SEC")
	SubnetworkLogConfigAggregationIntervalInterval5Min  = SubnetworkLogConfigAggregationInterval("INTERVAL_5_MIN")
	SubnetworkLogConfigAggregationIntervalInterval5Sec  = SubnetworkLogConfigAggregationInterval("INTERVAL_5_SEC")
)

func (SubnetworkLogConfigAggregationInterval) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SubnetworkLogConfigAggregationInterval) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SubnetworkLogConfigAggregationInterval) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SubnetworkLogConfigAggregationInterval) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SubnetworkLogConfigAggregationInterval) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Can only be specified if VPC flow logs for this subnetwork is enabled. Configures whether all, none or a subset of metadata fields should be added to the reported VPC flow logs. Default is EXCLUDE_ALL_METADATA.
type SubnetworkLogConfigMetadata pulumi.String

const (
	SubnetworkLogConfigMetadataCustomMetadata     = SubnetworkLogConfigMetadata("CUSTOM_METADATA")
	SubnetworkLogConfigMetadataExcludeAllMetadata = SubnetworkLogConfigMetadata("EXCLUDE_ALL_METADATA")
	SubnetworkLogConfigMetadataIncludeAllMetadata = SubnetworkLogConfigMetadata("INCLUDE_ALL_METADATA")
)

func (SubnetworkLogConfigMetadata) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SubnetworkLogConfigMetadata) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SubnetworkLogConfigMetadata) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SubnetworkLogConfigMetadata) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SubnetworkLogConfigMetadata) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The private IPv6 google access type for the VMs in this subnet. This is an expanded field of enablePrivateV6Access. If both fields are set, privateIpv6GoogleAccess will take priority. This field can be both set at resource creation time and updated using patch.
type SubnetworkPrivateIpv6GoogleAccess pulumi.String

const (
	// Disable private IPv6 access to/from Google services.
	SubnetworkPrivateIpv6GoogleAccessDisableGoogleAccess = SubnetworkPrivateIpv6GoogleAccess("DISABLE_GOOGLE_ACCESS")
	// Bidirectional private IPv6 access to/from Google services.
	SubnetworkPrivateIpv6GoogleAccessEnableBidirectionalAccessToGoogle = SubnetworkPrivateIpv6GoogleAccess("ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE")
	// Outbound private IPv6 access from VMs in this subnet to Google services.
	SubnetworkPrivateIpv6GoogleAccessEnableOutboundVmAccessToGoogle = SubnetworkPrivateIpv6GoogleAccess("ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE")
)

func (SubnetworkPrivateIpv6GoogleAccess) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SubnetworkPrivateIpv6GoogleAccess) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SubnetworkPrivateIpv6GoogleAccess) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SubnetworkPrivateIpv6GoogleAccess) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SubnetworkPrivateIpv6GoogleAccess) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The purpose of the resource. This field can be either PRIVATE_RFC_1918 or INTERNAL_HTTPS_LOAD_BALANCER. A subnetwork with purpose set to INTERNAL_HTTPS_LOAD_BALANCER is a user-created subnetwork that is reserved for Internal HTTP(S) Load Balancing. If unspecified, the purpose defaults to PRIVATE_RFC_1918. The enableFlowLogs field isn't supported with the purpose field set to INTERNAL_HTTPS_LOAD_BALANCER.
type SubnetworkPurpose pulumi.String

const (
	// Subnet reserved for Internal HTTP(S) Load Balancing.
	SubnetworkPurposeInternalHttpsLoadBalancer = SubnetworkPurpose("INTERNAL_HTTPS_LOAD_BALANCER")
	// Regular user created or automatically created subnet.
	SubnetworkPurposePrivate = SubnetworkPurpose("PRIVATE")
	// Regular user created or automatically created subnet.
	SubnetworkPurposePrivateRfc1918 = SubnetworkPurpose("PRIVATE_RFC_1918")
	// Subnetworks created for Private Service Connect in the producer network.
	SubnetworkPurposePrivateServiceConnect = SubnetworkPurpose("PRIVATE_SERVICE_CONNECT")
	// Subnetwork used for Regional Internal/External HTTP(S) Load Balancing.
	SubnetworkPurposeRegionalManagedProxy = SubnetworkPurpose("REGIONAL_MANAGED_PROXY")
)

func (SubnetworkPurpose) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SubnetworkPurpose) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SubnetworkPurpose) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SubnetworkPurpose) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SubnetworkPurpose) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The role of subnetwork. Currently, this field is only used when purpose = INTERNAL_HTTPS_LOAD_BALANCER. The value can be set to ACTIVE or BACKUP. An ACTIVE subnetwork is one that is currently being used for Internal HTTP(S) Load Balancing. A BACKUP subnetwork is one that is ready to be promoted to ACTIVE or is currently draining. This field can be updated with a patch request.
type SubnetworkRole pulumi.String

const (
	// The ACTIVE subnet that is currently used.
	SubnetworkRoleActive = SubnetworkRole("ACTIVE")
	// The BACKUP subnet that could be promoted to ACTIVE.
	SubnetworkRoleBackup = SubnetworkRole("BACKUP")
)

func (SubnetworkRole) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SubnetworkRole) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SubnetworkRole) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SubnetworkRole) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SubnetworkRole) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// The stack type for this subnet to identify whether the IPv6 feature is enabled or not. If not specified IPV4_ONLY will be used. This field can be both set at resource creation time and updated using patch.
type SubnetworkStackType pulumi.String

const (
	// New VMs in this subnet can have both IPv4 and IPv6 addresses.
	SubnetworkStackTypeIpv4Ipv6 = SubnetworkStackType("IPV4_IPV6")
	// New VMs in this subnet will only be assigned IPv4 addresses.
	SubnetworkStackTypeIpv4Only             = SubnetworkStackType("IPV4_ONLY")
	SubnetworkStackTypeUnspecifiedStackType = SubnetworkStackType("UNSPECIFIED_STACK_TYPE")
)

func (SubnetworkStackType) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SubnetworkStackType) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SubnetworkStackType) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SubnetworkStackType) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SubnetworkStackType) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] The state of the subnetwork, which can be one of the following values: READY: Subnetwork is created and ready to use DRAINING: only applicable to subnetworks that have the purpose set to INTERNAL_HTTPS_LOAD_BALANCER and indicates that connections to the load balancer are being drained. A subnetwork that is draining cannot be used or modified until it reaches a status of READY
type SubnetworkStateEnum pulumi.String

const (
	// Subnetwork is being drained.
	SubnetworkStateEnumDraining = SubnetworkStateEnum("DRAINING")
	// Subnetwork is ready for use.
	SubnetworkStateEnumReady = SubnetworkStateEnum("READY")
)

func (SubnetworkStateEnum) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SubnetworkStateEnum) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SubnetworkStateEnum) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SubnetworkStateEnum) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SubnetworkStateEnum) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

type SubsettingPolicy pulumi.String

const (
	// Subsetting based on consistent hashing. For Traffic Director, the number of backends per backend group (the subset size) is adjusted based on the `subset_size` parameter. For Internal HTTP(S) load balancing, the number of backends per backend group (the subset size) is dynamically adjusted in two cases: - As the number of proxy instances participating in Internal HTTP(S) load balancing increases, the subset size decreases. - When the total number of backends in a network exceeds the capacity of a single proxy instance, subset sizes are reduced automatically for each service that has backend subsetting enabled.
	SubsettingPolicyConsistentHashSubsetting = SubsettingPolicy("CONSISTENT_HASH_SUBSETTING")
	// No Subsetting. Clients may open connections and send traffic to all backends of this backend service. This can lead to performance issues if there is substantial imbalance in the count of clients and backends.
	SubsettingPolicyNone = SubsettingPolicy("NONE")
)

func (SubsettingPolicy) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e SubsettingPolicy) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e SubsettingPolicy) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e SubsettingPolicy) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e SubsettingPolicy) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies how port is selected for health checking, can be one of following values: USE_FIXED_PORT: The port number in port is used for health checking. USE_NAMED_PORT: The portName is used for health checking. USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking. If not specified, TCP health check follows behavior specified in port and portName fields.
type TCPHealthCheckPortSpecification pulumi.String

const (
	// The port number in port is used for health checking.
	TCPHealthCheckPortSpecificationUseFixedPort = TCPHealthCheckPortSpecification("USE_FIXED_PORT")
	// The portName is used for health checking.
	TCPHealthCheckPortSpecificationUseNamedPort = TCPHealthCheckPortSpecification("USE_NAMED_PORT")
	// For NetworkEndpointGroup, the port specified for each network endpoint is used for health checking. For other backends, the port or named port specified in the Backend Service is used for health checking.
	TCPHealthCheckPortSpecificationUseServingPort = TCPHealthCheckPortSpecification("USE_SERVING_PORT")
)

func (TCPHealthCheckPortSpecification) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e TCPHealthCheckPortSpecification) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e TCPHealthCheckPortSpecification) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e TCPHealthCheckPortSpecification) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e TCPHealthCheckPortSpecification) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
type TCPHealthCheckProxyHeader pulumi.String

const (
	TCPHealthCheckProxyHeaderNone    = TCPHealthCheckProxyHeader("NONE")
	TCPHealthCheckProxyHeaderProxyV1 = TCPHealthCheckProxyHeader("PROXY_V1")
)

func (TCPHealthCheckProxyHeader) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e TCPHealthCheckProxyHeader) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e TCPHealthCheckProxyHeader) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e TCPHealthCheckProxyHeader) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e TCPHealthCheckProxyHeader) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies the QUIC override policy for this TargetHttpsProxy resource. This setting determines whether the load balancer attempts to negotiate QUIC with clients. You can specify NONE, ENABLE, or DISABLE. - When quic-override is set to NONE, Google manages whether QUIC is used. - When quic-override is set to ENABLE, the load balancer uses QUIC when possible. - When quic-override is set to DISABLE, the load balancer doesn't use QUIC. - If the quic-override flag is not specified, NONE is implied.
type TargetHttpsProxyQuicOverride pulumi.String

const (
	// The load balancer will not attempt to negotiate QUIC with clients.
	TargetHttpsProxyQuicOverrideDisable = TargetHttpsProxyQuicOverride("DISABLE")
	// The load balancer will attempt to negotiate QUIC with clients.
	TargetHttpsProxyQuicOverrideEnable = TargetHttpsProxyQuicOverride("ENABLE")
	// No overrides to the default QUIC policy. This option is implicit if no QUIC override has been specified in the request.
	TargetHttpsProxyQuicOverrideNone = TargetHttpsProxyQuicOverride("NONE")
)

func (TargetHttpsProxyQuicOverride) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e TargetHttpsProxyQuicOverride) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e TargetHttpsProxyQuicOverride) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e TargetHttpsProxyQuicOverride) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e TargetHttpsProxyQuicOverride) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// NAT option controlling how IPs are NAT'ed to the instance. Currently only NO_NAT (default value) is supported.
type TargetInstanceNatPolicy pulumi.String

const (
	// No NAT performed.
	TargetInstanceNatPolicyNoNat = TargetInstanceNatPolicy("NO_NAT")
)

func (TargetInstanceNatPolicy) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e TargetInstanceNatPolicy) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e TargetInstanceNatPolicy) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e TargetInstanceNatPolicy) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e TargetInstanceNatPolicy) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Session affinity option, must be one of the following values: NONE: Connections from the same client IP may go to any instance in the pool. CLIENT_IP: Connections from the same client IP will go to the same instance in the pool while that instance remains healthy. CLIENT_IP_PROTO: Connections from the same client IP with the same IP protocol will go to the same instance in the pool while that instance remains healthy.
type TargetPoolSessionAffinity pulumi.String

const (
	// 2-tuple hash on packet's source and destination IP addresses. Connections from the same source IP address to the same destination IP address will be served by the same backend VM while that VM remains healthy.
	TargetPoolSessionAffinityClientIp = TargetPoolSessionAffinity("CLIENT_IP")
	// 1-tuple hash only on packet's source IP address. Connections from the same source IP address will be served by the same backend VM while that VM remains healthy. This option can only be used for Internal TCP/UDP Load Balancing.
	TargetPoolSessionAffinityClientIpNoDestination = TargetPoolSessionAffinity("CLIENT_IP_NO_DESTINATION")
	// 5-tuple hash on packet's source and destination IP addresses, IP protocol, and source and destination ports. Connections for the same IP protocol from the same source IP address and port to the same destination IP address and port will be served by the same backend VM while that VM remains healthy. This option cannot be used for HTTP(S) load balancing.
	TargetPoolSessionAffinityClientIpPortProto = TargetPoolSessionAffinity("CLIENT_IP_PORT_PROTO")
	// 3-tuple hash on packet's source and destination IP addresses, and IP protocol. Connections for the same IP protocol from the same source IP address to the same destination IP address will be served by the same backend VM while that VM remains healthy. This option cannot be used for HTTP(S) load balancing.
	TargetPoolSessionAffinityClientIpProto = TargetPoolSessionAffinity("CLIENT_IP_PROTO")
	// Hash based on a cookie generated by the L7 loadbalancer. Only valid for HTTP(S) load balancing.
	TargetPoolSessionAffinityGeneratedCookie = TargetPoolSessionAffinity("GENERATED_COOKIE")
	// The hash is based on a user specified header field.
	TargetPoolSessionAffinityHeaderField = TargetPoolSessionAffinity("HEADER_FIELD")
	// The hash is based on a user provided cookie.
	TargetPoolSessionAffinityHttpCookie = TargetPoolSessionAffinity("HTTP_COOKIE")
	// No session affinity. Connections from the same client IP may go to any instance in the pool.
	TargetPoolSessionAffinityNone = TargetPoolSessionAffinity("NONE")
)

func (TargetPoolSessionAffinity) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e TargetPoolSessionAffinity) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e TargetPoolSessionAffinity) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e TargetPoolSessionAffinity) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e TargetPoolSessionAffinity) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
type TargetSslProxyProxyHeader pulumi.String

const (
	TargetSslProxyProxyHeaderNone    = TargetSslProxyProxyHeader("NONE")
	TargetSslProxyProxyHeaderProxyV1 = TargetSslProxyProxyHeader("PROXY_V1")
)

func (TargetSslProxyProxyHeader) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e TargetSslProxyProxyHeader) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e TargetSslProxyProxyHeader) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e TargetSslProxyProxyHeader) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e TargetSslProxyProxyHeader) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
type TargetTcpProxyProxyHeader pulumi.String

const (
	TargetTcpProxyProxyHeaderNone    = TargetTcpProxyProxyHeader("NONE")
	TargetTcpProxyProxyHeaderProxyV1 = TargetTcpProxyProxyHeader("PROXY_V1")
)

func (TargetTcpProxyProxyHeader) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e TargetTcpProxyProxyHeader) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e TargetTcpProxyProxyHeader) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e TargetTcpProxyProxyHeader) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e TargetTcpProxyProxyHeader) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] The status of the VPN gateway, which can be one of the following: CREATING, READY, FAILED, or DELETING.
type TargetVpnGatewayStatus pulumi.String

const (
	TargetVpnGatewayStatusCreating = TargetVpnGatewayStatus("CREATING")
	TargetVpnGatewayStatusDeleting = TargetVpnGatewayStatus("DELETING")
	TargetVpnGatewayStatusFailed   = TargetVpnGatewayStatus("FAILED")
	TargetVpnGatewayStatusReady    = TargetVpnGatewayStatus("READY")
)

func (TargetVpnGatewayStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e TargetVpnGatewayStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e TargetVpnGatewayStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e TargetVpnGatewayStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e TargetVpnGatewayStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}

// [Output Only] The status of the VPN tunnel, which can be one of the following: - PROVISIONING: Resource is being allocated for the VPN tunnel. - WAITING_FOR_FULL_CONFIG: Waiting to receive all VPN-related configs from the user. Network, TargetVpnGateway, VpnTunnel, ForwardingRule, and Route resources are needed to setup the VPN tunnel. - FIRST_HANDSHAKE: Successful first handshake with the peer VPN. - ESTABLISHED: Secure session is successfully established with the peer VPN. - NETWORK_ERROR: Deprecated, replaced by NO_INCOMING_PACKETS - AUTHORIZATION_ERROR: Auth error (for example, bad shared secret). - NEGOTIATION_FAILURE: Handshake failed. - DEPROVISIONING: Resources are being deallocated for the VPN tunnel. - FAILED: Tunnel creation has failed and the tunnel is not ready to be used. - NO_INCOMING_PACKETS: No incoming packets from peer. - REJECTED: Tunnel configuration was rejected, can be result of being denied access. - ALLOCATING_RESOURCES: Cloud VPN is in the process of allocating all required resources. - STOPPED: Tunnel is stopped due to its Forwarding Rules being deleted for Classic VPN tunnels or the project is in frozen state. - PEER_IDENTITY_MISMATCH: Peer identity does not match peer IP, probably behind NAT. - TS_NARROWING_NOT_ALLOWED: Traffic selector narrowing not allowed for an HA-VPN tunnel.
type VpnTunnelStatus pulumi.String

const (
	// Cloud VPN is in the process of allocating all required resources (specifically, a borg task).
	VpnTunnelStatusAllocatingResources = VpnTunnelStatus("ALLOCATING_RESOURCES")
	// Auth error (e.g. bad shared secret).
	VpnTunnelStatusAuthorizationError = VpnTunnelStatus("AUTHORIZATION_ERROR")
	// Resources is being deallocated for the VPN tunnel.
	VpnTunnelStatusDeprovisioning = VpnTunnelStatus("DEPROVISIONING")
	// Secure session is successfully established with peer VPN.
	VpnTunnelStatusEstablished = VpnTunnelStatus("ESTABLISHED")
	// Tunnel creation has failed and the tunnel is not ready to be used.
	VpnTunnelStatusFailed = VpnTunnelStatus("FAILED")
	// Successful first handshake with peer VPN.
	VpnTunnelStatusFirstHandshake = VpnTunnelStatus("FIRST_HANDSHAKE")
	// Handshake failed.
	VpnTunnelStatusNegotiationFailure = VpnTunnelStatus("NEGOTIATION_FAILURE")
	// Deprecated, replaced by NO_INCOMING_PACKETS
	VpnTunnelStatusNetworkError = VpnTunnelStatus("NETWORK_ERROR")
	// No incoming packets from peer
	VpnTunnelStatusNoIncomingPackets = VpnTunnelStatus("NO_INCOMING_PACKETS")
	// Resource is being allocated for the VPN tunnel.
	VpnTunnelStatusProvisioning = VpnTunnelStatus("PROVISIONING")
	// Tunnel configuration was rejected, can be result of being denylisted.
	VpnTunnelStatusRejected = VpnTunnelStatus("REJECTED")
	// Tunnel is stopped due to its Forwarding Rules being deleted.
	VpnTunnelStatusStopped = VpnTunnelStatus("STOPPED")
	// Waiting to receive all VPN-related configs from user. Network, TargetVpnGateway, VpnTunnel, ForwardingRule and Route resources are needed to setup VPN tunnel.
	VpnTunnelStatusWaitingForFullConfig = VpnTunnelStatus("WAITING_FOR_FULL_CONFIG")
)

func (VpnTunnelStatus) ElementType() reflect.Type {
	return reflect.TypeOf((*pulumi.String)(nil)).Elem()
}

func (e VpnTunnelStatus) ToStringOutput() pulumi.StringOutput {
	return pulumi.ToOutput(pulumi.String(e)).(pulumi.StringOutput)
}

func (e VpnTunnelStatus) ToStringOutputWithContext(ctx context.Context) pulumi.StringOutput {
	return pulumi.ToOutputWithContext(ctx, pulumi.String(e)).(pulumi.StringOutput)
}

func (e VpnTunnelStatus) ToStringPtrOutput() pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringPtrOutputWithContext(context.Background())
}

func (e VpnTunnelStatus) ToStringPtrOutputWithContext(ctx context.Context) pulumi.StringPtrOutput {
	return pulumi.String(e).ToStringOutputWithContext(ctx).ToStringPtrOutputWithContext(ctx)
}
