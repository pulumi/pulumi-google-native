// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1beta1

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-google-native/sdk/go/google/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = internal.GetEnvOrDefault

// Configures consent audit log config for FHIR create, read, update, and delete (CRUD) operations. Cloud audit log for healthcare API must be [enabled](https://cloud.google.com/logging/docs/audit/configure-data-access#config-console-enable). The consent-related logs are included as part of `protoPayload.metadata`.
type AccessDeterminationLogConfig struct {
	// Optional. Controls the amount of detail to include as part of the audit logs.
	LogLevel *AccessDeterminationLogConfigLogLevel `pulumi:"logLevel"`
}

// AccessDeterminationLogConfigInput is an input type that accepts AccessDeterminationLogConfigArgs and AccessDeterminationLogConfigOutput values.
// You can construct a concrete instance of `AccessDeterminationLogConfigInput` via:
//
//	AccessDeterminationLogConfigArgs{...}
type AccessDeterminationLogConfigInput interface {
	pulumi.Input

	ToAccessDeterminationLogConfigOutput() AccessDeterminationLogConfigOutput
	ToAccessDeterminationLogConfigOutputWithContext(context.Context) AccessDeterminationLogConfigOutput
}

// Configures consent audit log config for FHIR create, read, update, and delete (CRUD) operations. Cloud audit log for healthcare API must be [enabled](https://cloud.google.com/logging/docs/audit/configure-data-access#config-console-enable). The consent-related logs are included as part of `protoPayload.metadata`.
type AccessDeterminationLogConfigArgs struct {
	// Optional. Controls the amount of detail to include as part of the audit logs.
	LogLevel AccessDeterminationLogConfigLogLevelPtrInput `pulumi:"logLevel"`
}

func (AccessDeterminationLogConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AccessDeterminationLogConfig)(nil)).Elem()
}

func (i AccessDeterminationLogConfigArgs) ToAccessDeterminationLogConfigOutput() AccessDeterminationLogConfigOutput {
	return i.ToAccessDeterminationLogConfigOutputWithContext(context.Background())
}

func (i AccessDeterminationLogConfigArgs) ToAccessDeterminationLogConfigOutputWithContext(ctx context.Context) AccessDeterminationLogConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccessDeterminationLogConfigOutput)
}

func (i AccessDeterminationLogConfigArgs) ToAccessDeterminationLogConfigPtrOutput() AccessDeterminationLogConfigPtrOutput {
	return i.ToAccessDeterminationLogConfigPtrOutputWithContext(context.Background())
}

func (i AccessDeterminationLogConfigArgs) ToAccessDeterminationLogConfigPtrOutputWithContext(ctx context.Context) AccessDeterminationLogConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccessDeterminationLogConfigOutput).ToAccessDeterminationLogConfigPtrOutputWithContext(ctx)
}

// AccessDeterminationLogConfigPtrInput is an input type that accepts AccessDeterminationLogConfigArgs, AccessDeterminationLogConfigPtr and AccessDeterminationLogConfigPtrOutput values.
// You can construct a concrete instance of `AccessDeterminationLogConfigPtrInput` via:
//
//	        AccessDeterminationLogConfigArgs{...}
//
//	or:
//
//	        nil
type AccessDeterminationLogConfigPtrInput interface {
	pulumi.Input

	ToAccessDeterminationLogConfigPtrOutput() AccessDeterminationLogConfigPtrOutput
	ToAccessDeterminationLogConfigPtrOutputWithContext(context.Context) AccessDeterminationLogConfigPtrOutput
}

type accessDeterminationLogConfigPtrType AccessDeterminationLogConfigArgs

func AccessDeterminationLogConfigPtr(v *AccessDeterminationLogConfigArgs) AccessDeterminationLogConfigPtrInput {
	return (*accessDeterminationLogConfigPtrType)(v)
}

func (*accessDeterminationLogConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AccessDeterminationLogConfig)(nil)).Elem()
}

func (i *accessDeterminationLogConfigPtrType) ToAccessDeterminationLogConfigPtrOutput() AccessDeterminationLogConfigPtrOutput {
	return i.ToAccessDeterminationLogConfigPtrOutputWithContext(context.Background())
}

func (i *accessDeterminationLogConfigPtrType) ToAccessDeterminationLogConfigPtrOutputWithContext(ctx context.Context) AccessDeterminationLogConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccessDeterminationLogConfigPtrOutput)
}

// Configures consent audit log config for FHIR create, read, update, and delete (CRUD) operations. Cloud audit log for healthcare API must be [enabled](https://cloud.google.com/logging/docs/audit/configure-data-access#config-console-enable). The consent-related logs are included as part of `protoPayload.metadata`.
type AccessDeterminationLogConfigOutput struct{ *pulumi.OutputState }

func (AccessDeterminationLogConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AccessDeterminationLogConfig)(nil)).Elem()
}

func (o AccessDeterminationLogConfigOutput) ToAccessDeterminationLogConfigOutput() AccessDeterminationLogConfigOutput {
	return o
}

func (o AccessDeterminationLogConfigOutput) ToAccessDeterminationLogConfigOutputWithContext(ctx context.Context) AccessDeterminationLogConfigOutput {
	return o
}

func (o AccessDeterminationLogConfigOutput) ToAccessDeterminationLogConfigPtrOutput() AccessDeterminationLogConfigPtrOutput {
	return o.ToAccessDeterminationLogConfigPtrOutputWithContext(context.Background())
}

func (o AccessDeterminationLogConfigOutput) ToAccessDeterminationLogConfigPtrOutputWithContext(ctx context.Context) AccessDeterminationLogConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AccessDeterminationLogConfig) *AccessDeterminationLogConfig {
		return &v
	}).(AccessDeterminationLogConfigPtrOutput)
}

// Optional. Controls the amount of detail to include as part of the audit logs.
func (o AccessDeterminationLogConfigOutput) LogLevel() AccessDeterminationLogConfigLogLevelPtrOutput {
	return o.ApplyT(func(v AccessDeterminationLogConfig) *AccessDeterminationLogConfigLogLevel { return v.LogLevel }).(AccessDeterminationLogConfigLogLevelPtrOutput)
}

type AccessDeterminationLogConfigPtrOutput struct{ *pulumi.OutputState }

func (AccessDeterminationLogConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AccessDeterminationLogConfig)(nil)).Elem()
}

func (o AccessDeterminationLogConfigPtrOutput) ToAccessDeterminationLogConfigPtrOutput() AccessDeterminationLogConfigPtrOutput {
	return o
}

func (o AccessDeterminationLogConfigPtrOutput) ToAccessDeterminationLogConfigPtrOutputWithContext(ctx context.Context) AccessDeterminationLogConfigPtrOutput {
	return o
}

func (o AccessDeterminationLogConfigPtrOutput) Elem() AccessDeterminationLogConfigOutput {
	return o.ApplyT(func(v *AccessDeterminationLogConfig) AccessDeterminationLogConfig {
		if v != nil {
			return *v
		}
		var ret AccessDeterminationLogConfig
		return ret
	}).(AccessDeterminationLogConfigOutput)
}

// Optional. Controls the amount of detail to include as part of the audit logs.
func (o AccessDeterminationLogConfigPtrOutput) LogLevel() AccessDeterminationLogConfigLogLevelPtrOutput {
	return o.ApplyT(func(v *AccessDeterminationLogConfig) *AccessDeterminationLogConfigLogLevel {
		if v == nil {
			return nil
		}
		return v.LogLevel
	}).(AccessDeterminationLogConfigLogLevelPtrOutput)
}

// Configures consent audit log config for FHIR create, read, update, and delete (CRUD) operations. Cloud audit log for healthcare API must be [enabled](https://cloud.google.com/logging/docs/audit/configure-data-access#config-console-enable). The consent-related logs are included as part of `protoPayload.metadata`.
type AccessDeterminationLogConfigResponse struct {
	// Optional. Controls the amount of detail to include as part of the audit logs.
	LogLevel string `pulumi:"logLevel"`
}

// Configures consent audit log config for FHIR create, read, update, and delete (CRUD) operations. Cloud audit log for healthcare API must be [enabled](https://cloud.google.com/logging/docs/audit/configure-data-access#config-console-enable). The consent-related logs are included as part of `protoPayload.metadata`.
type AccessDeterminationLogConfigResponseOutput struct{ *pulumi.OutputState }

func (AccessDeterminationLogConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AccessDeterminationLogConfigResponse)(nil)).Elem()
}

func (o AccessDeterminationLogConfigResponseOutput) ToAccessDeterminationLogConfigResponseOutput() AccessDeterminationLogConfigResponseOutput {
	return o
}

func (o AccessDeterminationLogConfigResponseOutput) ToAccessDeterminationLogConfigResponseOutputWithContext(ctx context.Context) AccessDeterminationLogConfigResponseOutput {
	return o
}

// Optional. Controls the amount of detail to include as part of the audit logs.
func (o AccessDeterminationLogConfigResponseOutput) LogLevel() pulumi.StringOutput {
	return o.ApplyT(func(v AccessDeterminationLogConfigResponse) string { return v.LogLevel }).(pulumi.StringOutput)
}

// Specifies a selection of tags and an `Action` to apply to each one.
type Action struct {
	// Inspect image and transform sensitive burnt-in text. Doesn't apply to elements nested in a sequence, which revert to `Keep`. Supported [tags](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part06/chapter_6.html): PixelData
	CleanImageTag *ImageConfig `pulumi:"cleanImageTag"`
	// Inspect text and transform sensitive text. Configurable via TextConfig. Supported Value Representations: AE, LO, LT, PN, SH, ST, UC, UT, DA, DT, AS
	CleanTextTag *CleanTextTag `pulumi:"cleanTextTag"`
	// Delete tag.
	DeleteTag *DeleteTag `pulumi:"deleteTag"`
	// Keep tag unchanged.
	KeepTag *KeepTag `pulumi:"keepTag"`
	// Select all tags with the listed tag IDs, names, or Value Representations (VRs). Examples: ID: "00100010" Keyword: "PatientName" VR: "PN"
	Queries []string `pulumi:"queries"`
	// Recursively apply DICOM de-id to tags nested in a sequence. Supported [Value Representation] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): SQ
	RecurseTag *RecurseTag `pulumi:"recurseTag"`
	// Replace UID with a new generated UID. Supported [Value Representation] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): UI
	RegenUidTag *RegenUidTag `pulumi:"regenUidTag"`
	// Replace with empty tag.
	RemoveTag *RemoveTag `pulumi:"removeTag"`
	// Reset tag to a placeholder value.
	ResetTag *ResetTag `pulumi:"resetTag"`
}

// ActionInput is an input type that accepts ActionArgs and ActionOutput values.
// You can construct a concrete instance of `ActionInput` via:
//
//	ActionArgs{...}
type ActionInput interface {
	pulumi.Input

	ToActionOutput() ActionOutput
	ToActionOutputWithContext(context.Context) ActionOutput
}

// Specifies a selection of tags and an `Action` to apply to each one.
type ActionArgs struct {
	// Inspect image and transform sensitive burnt-in text. Doesn't apply to elements nested in a sequence, which revert to `Keep`. Supported [tags](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part06/chapter_6.html): PixelData
	CleanImageTag ImageConfigPtrInput `pulumi:"cleanImageTag"`
	// Inspect text and transform sensitive text. Configurable via TextConfig. Supported Value Representations: AE, LO, LT, PN, SH, ST, UC, UT, DA, DT, AS
	CleanTextTag CleanTextTagPtrInput `pulumi:"cleanTextTag"`
	// Delete tag.
	DeleteTag DeleteTagPtrInput `pulumi:"deleteTag"`
	// Keep tag unchanged.
	KeepTag KeepTagPtrInput `pulumi:"keepTag"`
	// Select all tags with the listed tag IDs, names, or Value Representations (VRs). Examples: ID: "00100010" Keyword: "PatientName" VR: "PN"
	Queries pulumi.StringArrayInput `pulumi:"queries"`
	// Recursively apply DICOM de-id to tags nested in a sequence. Supported [Value Representation] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): SQ
	RecurseTag RecurseTagPtrInput `pulumi:"recurseTag"`
	// Replace UID with a new generated UID. Supported [Value Representation] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): UI
	RegenUidTag RegenUidTagPtrInput `pulumi:"regenUidTag"`
	// Replace with empty tag.
	RemoveTag RemoveTagPtrInput `pulumi:"removeTag"`
	// Reset tag to a placeholder value.
	ResetTag ResetTagPtrInput `pulumi:"resetTag"`
}

func (ActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Action)(nil)).Elem()
}

func (i ActionArgs) ToActionOutput() ActionOutput {
	return i.ToActionOutputWithContext(context.Background())
}

func (i ActionArgs) ToActionOutputWithContext(ctx context.Context) ActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ActionOutput)
}

// ActionArrayInput is an input type that accepts ActionArray and ActionArrayOutput values.
// You can construct a concrete instance of `ActionArrayInput` via:
//
//	ActionArray{ ActionArgs{...} }
type ActionArrayInput interface {
	pulumi.Input

	ToActionArrayOutput() ActionArrayOutput
	ToActionArrayOutputWithContext(context.Context) ActionArrayOutput
}

type ActionArray []ActionInput

func (ActionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Action)(nil)).Elem()
}

func (i ActionArray) ToActionArrayOutput() ActionArrayOutput {
	return i.ToActionArrayOutputWithContext(context.Background())
}

func (i ActionArray) ToActionArrayOutputWithContext(ctx context.Context) ActionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ActionArrayOutput)
}

// Specifies a selection of tags and an `Action` to apply to each one.
type ActionOutput struct{ *pulumi.OutputState }

func (ActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Action)(nil)).Elem()
}

func (o ActionOutput) ToActionOutput() ActionOutput {
	return o
}

func (o ActionOutput) ToActionOutputWithContext(ctx context.Context) ActionOutput {
	return o
}

// Inspect image and transform sensitive burnt-in text. Doesn't apply to elements nested in a sequence, which revert to `Keep`. Supported [tags](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part06/chapter_6.html): PixelData
func (o ActionOutput) CleanImageTag() ImageConfigPtrOutput {
	return o.ApplyT(func(v Action) *ImageConfig { return v.CleanImageTag }).(ImageConfigPtrOutput)
}

// Inspect text and transform sensitive text. Configurable via TextConfig. Supported Value Representations: AE, LO, LT, PN, SH, ST, UC, UT, DA, DT, AS
func (o ActionOutput) CleanTextTag() CleanTextTagPtrOutput {
	return o.ApplyT(func(v Action) *CleanTextTag { return v.CleanTextTag }).(CleanTextTagPtrOutput)
}

// Delete tag.
func (o ActionOutput) DeleteTag() DeleteTagPtrOutput {
	return o.ApplyT(func(v Action) *DeleteTag { return v.DeleteTag }).(DeleteTagPtrOutput)
}

// Keep tag unchanged.
func (o ActionOutput) KeepTag() KeepTagPtrOutput {
	return o.ApplyT(func(v Action) *KeepTag { return v.KeepTag }).(KeepTagPtrOutput)
}

// Select all tags with the listed tag IDs, names, or Value Representations (VRs). Examples: ID: "00100010" Keyword: "PatientName" VR: "PN"
func (o ActionOutput) Queries() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Action) []string { return v.Queries }).(pulumi.StringArrayOutput)
}

// Recursively apply DICOM de-id to tags nested in a sequence. Supported [Value Representation] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): SQ
func (o ActionOutput) RecurseTag() RecurseTagPtrOutput {
	return o.ApplyT(func(v Action) *RecurseTag { return v.RecurseTag }).(RecurseTagPtrOutput)
}

// Replace UID with a new generated UID. Supported [Value Representation] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): UI
func (o ActionOutput) RegenUidTag() RegenUidTagPtrOutput {
	return o.ApplyT(func(v Action) *RegenUidTag { return v.RegenUidTag }).(RegenUidTagPtrOutput)
}

// Replace with empty tag.
func (o ActionOutput) RemoveTag() RemoveTagPtrOutput {
	return o.ApplyT(func(v Action) *RemoveTag { return v.RemoveTag }).(RemoveTagPtrOutput)
}

// Reset tag to a placeholder value.
func (o ActionOutput) ResetTag() ResetTagPtrOutput {
	return o.ApplyT(func(v Action) *ResetTag { return v.ResetTag }).(ResetTagPtrOutput)
}

type ActionArrayOutput struct{ *pulumi.OutputState }

func (ActionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Action)(nil)).Elem()
}

func (o ActionArrayOutput) ToActionArrayOutput() ActionArrayOutput {
	return o
}

func (o ActionArrayOutput) ToActionArrayOutputWithContext(ctx context.Context) ActionArrayOutput {
	return o
}

func (o ActionArrayOutput) Index(i pulumi.IntInput) ActionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Action {
		return vs[0].([]Action)[vs[1].(int)]
	}).(ActionOutput)
}

// Specifies a selection of tags and an `Action` to apply to each one.
type ActionResponse struct {
	// Inspect image and transform sensitive burnt-in text. Doesn't apply to elements nested in a sequence, which revert to `Keep`. Supported [tags](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part06/chapter_6.html): PixelData
	CleanImageTag ImageConfigResponse `pulumi:"cleanImageTag"`
	// Inspect text and transform sensitive text. Configurable via TextConfig. Supported Value Representations: AE, LO, LT, PN, SH, ST, UC, UT, DA, DT, AS
	CleanTextTag CleanTextTagResponse `pulumi:"cleanTextTag"`
	// Delete tag.
	DeleteTag DeleteTagResponse `pulumi:"deleteTag"`
	// Keep tag unchanged.
	KeepTag KeepTagResponse `pulumi:"keepTag"`
	// Select all tags with the listed tag IDs, names, or Value Representations (VRs). Examples: ID: "00100010" Keyword: "PatientName" VR: "PN"
	Queries []string `pulumi:"queries"`
	// Recursively apply DICOM de-id to tags nested in a sequence. Supported [Value Representation] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): SQ
	RecurseTag RecurseTagResponse `pulumi:"recurseTag"`
	// Replace UID with a new generated UID. Supported [Value Representation] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): UI
	RegenUidTag RegenUidTagResponse `pulumi:"regenUidTag"`
	// Replace with empty tag.
	RemoveTag RemoveTagResponse `pulumi:"removeTag"`
	// Reset tag to a placeholder value.
	ResetTag ResetTagResponse `pulumi:"resetTag"`
}

// Specifies a selection of tags and an `Action` to apply to each one.
type ActionResponseOutput struct{ *pulumi.OutputState }

func (ActionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ActionResponse)(nil)).Elem()
}

func (o ActionResponseOutput) ToActionResponseOutput() ActionResponseOutput {
	return o
}

func (o ActionResponseOutput) ToActionResponseOutputWithContext(ctx context.Context) ActionResponseOutput {
	return o
}

// Inspect image and transform sensitive burnt-in text. Doesn't apply to elements nested in a sequence, which revert to `Keep`. Supported [tags](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part06/chapter_6.html): PixelData
func (o ActionResponseOutput) CleanImageTag() ImageConfigResponseOutput {
	return o.ApplyT(func(v ActionResponse) ImageConfigResponse { return v.CleanImageTag }).(ImageConfigResponseOutput)
}

// Inspect text and transform sensitive text. Configurable via TextConfig. Supported Value Representations: AE, LO, LT, PN, SH, ST, UC, UT, DA, DT, AS
func (o ActionResponseOutput) CleanTextTag() CleanTextTagResponseOutput {
	return o.ApplyT(func(v ActionResponse) CleanTextTagResponse { return v.CleanTextTag }).(CleanTextTagResponseOutput)
}

// Delete tag.
func (o ActionResponseOutput) DeleteTag() DeleteTagResponseOutput {
	return o.ApplyT(func(v ActionResponse) DeleteTagResponse { return v.DeleteTag }).(DeleteTagResponseOutput)
}

// Keep tag unchanged.
func (o ActionResponseOutput) KeepTag() KeepTagResponseOutput {
	return o.ApplyT(func(v ActionResponse) KeepTagResponse { return v.KeepTag }).(KeepTagResponseOutput)
}

// Select all tags with the listed tag IDs, names, or Value Representations (VRs). Examples: ID: "00100010" Keyword: "PatientName" VR: "PN"
func (o ActionResponseOutput) Queries() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ActionResponse) []string { return v.Queries }).(pulumi.StringArrayOutput)
}

// Recursively apply DICOM de-id to tags nested in a sequence. Supported [Value Representation] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): SQ
func (o ActionResponseOutput) RecurseTag() RecurseTagResponseOutput {
	return o.ApplyT(func(v ActionResponse) RecurseTagResponse { return v.RecurseTag }).(RecurseTagResponseOutput)
}

// Replace UID with a new generated UID. Supported [Value Representation] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): UI
func (o ActionResponseOutput) RegenUidTag() RegenUidTagResponseOutput {
	return o.ApplyT(func(v ActionResponse) RegenUidTagResponse { return v.RegenUidTag }).(RegenUidTagResponseOutput)
}

// Replace with empty tag.
func (o ActionResponseOutput) RemoveTag() RemoveTagResponseOutput {
	return o.ApplyT(func(v ActionResponse) RemoveTagResponse { return v.RemoveTag }).(RemoveTagResponseOutput)
}

// Reset tag to a placeholder value.
func (o ActionResponseOutput) ResetTag() ResetTagResponseOutput {
	return o.ApplyT(func(v ActionResponse) ResetTagResponse { return v.ResetTag }).(ResetTagResponseOutput)
}

type ActionResponseArrayOutput struct{ *pulumi.OutputState }

func (ActionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ActionResponse)(nil)).Elem()
}

func (o ActionResponseArrayOutput) ToActionResponseArrayOutput() ActionResponseArrayOutput {
	return o
}

func (o ActionResponseArrayOutput) ToActionResponseArrayOutputWithContext(ctx context.Context) ActionResponseArrayOutput {
	return o
}

func (o ActionResponseArrayOutput) Index(i pulumi.IntInput) ActionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ActionResponse {
		return vs[0].([]ActionResponse)[vs[1].(int)]
	}).(ActionResponseOutput)
}

// Specifies how to store annotations during de-identification operation.
type AnnotationConfig struct {
	// The name of the annotation store, in the form `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/annotationStores/{annotation_store_id}`). * The destination annotation store must be in the same project as the source data. De-identifying data across multiple projects is not supported. * The destination annotation store must exist when using DeidentifyDicomStore or DeidentifyFhirStore. DeidentifyDataset automatically creates the destination annotation store.
	AnnotationStoreName *string `pulumi:"annotationStoreName"`
	// If set to true, the sensitive texts are included in SensitiveTextAnnotation of Annotation.
	StoreQuote *bool `pulumi:"storeQuote"`
}

// AnnotationConfigInput is an input type that accepts AnnotationConfigArgs and AnnotationConfigOutput values.
// You can construct a concrete instance of `AnnotationConfigInput` via:
//
//	AnnotationConfigArgs{...}
type AnnotationConfigInput interface {
	pulumi.Input

	ToAnnotationConfigOutput() AnnotationConfigOutput
	ToAnnotationConfigOutputWithContext(context.Context) AnnotationConfigOutput
}

// Specifies how to store annotations during de-identification operation.
type AnnotationConfigArgs struct {
	// The name of the annotation store, in the form `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/annotationStores/{annotation_store_id}`). * The destination annotation store must be in the same project as the source data. De-identifying data across multiple projects is not supported. * The destination annotation store must exist when using DeidentifyDicomStore or DeidentifyFhirStore. DeidentifyDataset automatically creates the destination annotation store.
	AnnotationStoreName pulumi.StringPtrInput `pulumi:"annotationStoreName"`
	// If set to true, the sensitive texts are included in SensitiveTextAnnotation of Annotation.
	StoreQuote pulumi.BoolPtrInput `pulumi:"storeQuote"`
}

func (AnnotationConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AnnotationConfig)(nil)).Elem()
}

func (i AnnotationConfigArgs) ToAnnotationConfigOutput() AnnotationConfigOutput {
	return i.ToAnnotationConfigOutputWithContext(context.Background())
}

func (i AnnotationConfigArgs) ToAnnotationConfigOutputWithContext(ctx context.Context) AnnotationConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AnnotationConfigOutput)
}

func (i AnnotationConfigArgs) ToAnnotationConfigPtrOutput() AnnotationConfigPtrOutput {
	return i.ToAnnotationConfigPtrOutputWithContext(context.Background())
}

func (i AnnotationConfigArgs) ToAnnotationConfigPtrOutputWithContext(ctx context.Context) AnnotationConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AnnotationConfigOutput).ToAnnotationConfigPtrOutputWithContext(ctx)
}

// AnnotationConfigPtrInput is an input type that accepts AnnotationConfigArgs, AnnotationConfigPtr and AnnotationConfigPtrOutput values.
// You can construct a concrete instance of `AnnotationConfigPtrInput` via:
//
//	        AnnotationConfigArgs{...}
//
//	or:
//
//	        nil
type AnnotationConfigPtrInput interface {
	pulumi.Input

	ToAnnotationConfigPtrOutput() AnnotationConfigPtrOutput
	ToAnnotationConfigPtrOutputWithContext(context.Context) AnnotationConfigPtrOutput
}

type annotationConfigPtrType AnnotationConfigArgs

func AnnotationConfigPtr(v *AnnotationConfigArgs) AnnotationConfigPtrInput {
	return (*annotationConfigPtrType)(v)
}

func (*annotationConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AnnotationConfig)(nil)).Elem()
}

func (i *annotationConfigPtrType) ToAnnotationConfigPtrOutput() AnnotationConfigPtrOutput {
	return i.ToAnnotationConfigPtrOutputWithContext(context.Background())
}

func (i *annotationConfigPtrType) ToAnnotationConfigPtrOutputWithContext(ctx context.Context) AnnotationConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AnnotationConfigPtrOutput)
}

// Specifies how to store annotations during de-identification operation.
type AnnotationConfigOutput struct{ *pulumi.OutputState }

func (AnnotationConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AnnotationConfig)(nil)).Elem()
}

func (o AnnotationConfigOutput) ToAnnotationConfigOutput() AnnotationConfigOutput {
	return o
}

func (o AnnotationConfigOutput) ToAnnotationConfigOutputWithContext(ctx context.Context) AnnotationConfigOutput {
	return o
}

func (o AnnotationConfigOutput) ToAnnotationConfigPtrOutput() AnnotationConfigPtrOutput {
	return o.ToAnnotationConfigPtrOutputWithContext(context.Background())
}

func (o AnnotationConfigOutput) ToAnnotationConfigPtrOutputWithContext(ctx context.Context) AnnotationConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AnnotationConfig) *AnnotationConfig {
		return &v
	}).(AnnotationConfigPtrOutput)
}

// The name of the annotation store, in the form `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/annotationStores/{annotation_store_id}`). * The destination annotation store must be in the same project as the source data. De-identifying data across multiple projects is not supported. * The destination annotation store must exist when using DeidentifyDicomStore or DeidentifyFhirStore. DeidentifyDataset automatically creates the destination annotation store.
func (o AnnotationConfigOutput) AnnotationStoreName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AnnotationConfig) *string { return v.AnnotationStoreName }).(pulumi.StringPtrOutput)
}

// If set to true, the sensitive texts are included in SensitiveTextAnnotation of Annotation.
func (o AnnotationConfigOutput) StoreQuote() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v AnnotationConfig) *bool { return v.StoreQuote }).(pulumi.BoolPtrOutput)
}

type AnnotationConfigPtrOutput struct{ *pulumi.OutputState }

func (AnnotationConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AnnotationConfig)(nil)).Elem()
}

func (o AnnotationConfigPtrOutput) ToAnnotationConfigPtrOutput() AnnotationConfigPtrOutput {
	return o
}

func (o AnnotationConfigPtrOutput) ToAnnotationConfigPtrOutputWithContext(ctx context.Context) AnnotationConfigPtrOutput {
	return o
}

func (o AnnotationConfigPtrOutput) Elem() AnnotationConfigOutput {
	return o.ApplyT(func(v *AnnotationConfig) AnnotationConfig {
		if v != nil {
			return *v
		}
		var ret AnnotationConfig
		return ret
	}).(AnnotationConfigOutput)
}

// The name of the annotation store, in the form `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/annotationStores/{annotation_store_id}`). * The destination annotation store must be in the same project as the source data. De-identifying data across multiple projects is not supported. * The destination annotation store must exist when using DeidentifyDicomStore or DeidentifyFhirStore. DeidentifyDataset automatically creates the destination annotation store.
func (o AnnotationConfigPtrOutput) AnnotationStoreName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AnnotationConfig) *string {
		if v == nil {
			return nil
		}
		return v.AnnotationStoreName
	}).(pulumi.StringPtrOutput)
}

// If set to true, the sensitive texts are included in SensitiveTextAnnotation of Annotation.
func (o AnnotationConfigPtrOutput) StoreQuote() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *AnnotationConfig) *bool {
		if v == nil {
			return nil
		}
		return v.StoreQuote
	}).(pulumi.BoolPtrOutput)
}

// Specifies how to store annotations during de-identification operation.
type AnnotationConfigResponse struct {
	// The name of the annotation store, in the form `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/annotationStores/{annotation_store_id}`). * The destination annotation store must be in the same project as the source data. De-identifying data across multiple projects is not supported. * The destination annotation store must exist when using DeidentifyDicomStore or DeidentifyFhirStore. DeidentifyDataset automatically creates the destination annotation store.
	AnnotationStoreName string `pulumi:"annotationStoreName"`
	// If set to true, the sensitive texts are included in SensitiveTextAnnotation of Annotation.
	StoreQuote bool `pulumi:"storeQuote"`
}

// Specifies how to store annotations during de-identification operation.
type AnnotationConfigResponseOutput struct{ *pulumi.OutputState }

func (AnnotationConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AnnotationConfigResponse)(nil)).Elem()
}

func (o AnnotationConfigResponseOutput) ToAnnotationConfigResponseOutput() AnnotationConfigResponseOutput {
	return o
}

func (o AnnotationConfigResponseOutput) ToAnnotationConfigResponseOutputWithContext(ctx context.Context) AnnotationConfigResponseOutput {
	return o
}

// The name of the annotation store, in the form `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/annotationStores/{annotation_store_id}`). * The destination annotation store must be in the same project as the source data. De-identifying data across multiple projects is not supported. * The destination annotation store must exist when using DeidentifyDicomStore or DeidentifyFhirStore. DeidentifyDataset automatically creates the destination annotation store.
func (o AnnotationConfigResponseOutput) AnnotationStoreName() pulumi.StringOutput {
	return o.ApplyT(func(v AnnotationConfigResponse) string { return v.AnnotationStoreName }).(pulumi.StringOutput)
}

// If set to true, the sensitive texts are included in SensitiveTextAnnotation of Annotation.
func (o AnnotationConfigResponseOutput) StoreQuote() pulumi.BoolOutput {
	return o.ApplyT(func(v AnnotationConfigResponse) bool { return v.StoreQuote }).(pulumi.BoolOutput)
}

// AnnotationSource holds the source information of the annotation.
type AnnotationSource struct {
	// Cloud Healthcare API resource.
	CloudHealthcareSource *CloudHealthcareSource `pulumi:"cloudHealthcareSource"`
}

// AnnotationSourceInput is an input type that accepts AnnotationSourceArgs and AnnotationSourceOutput values.
// You can construct a concrete instance of `AnnotationSourceInput` via:
//
//	AnnotationSourceArgs{...}
type AnnotationSourceInput interface {
	pulumi.Input

	ToAnnotationSourceOutput() AnnotationSourceOutput
	ToAnnotationSourceOutputWithContext(context.Context) AnnotationSourceOutput
}

// AnnotationSource holds the source information of the annotation.
type AnnotationSourceArgs struct {
	// Cloud Healthcare API resource.
	CloudHealthcareSource CloudHealthcareSourcePtrInput `pulumi:"cloudHealthcareSource"`
}

func (AnnotationSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AnnotationSource)(nil)).Elem()
}

func (i AnnotationSourceArgs) ToAnnotationSourceOutput() AnnotationSourceOutput {
	return i.ToAnnotationSourceOutputWithContext(context.Background())
}

func (i AnnotationSourceArgs) ToAnnotationSourceOutputWithContext(ctx context.Context) AnnotationSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AnnotationSourceOutput)
}

func (i AnnotationSourceArgs) ToAnnotationSourcePtrOutput() AnnotationSourcePtrOutput {
	return i.ToAnnotationSourcePtrOutputWithContext(context.Background())
}

func (i AnnotationSourceArgs) ToAnnotationSourcePtrOutputWithContext(ctx context.Context) AnnotationSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AnnotationSourceOutput).ToAnnotationSourcePtrOutputWithContext(ctx)
}

// AnnotationSourcePtrInput is an input type that accepts AnnotationSourceArgs, AnnotationSourcePtr and AnnotationSourcePtrOutput values.
// You can construct a concrete instance of `AnnotationSourcePtrInput` via:
//
//	        AnnotationSourceArgs{...}
//
//	or:
//
//	        nil
type AnnotationSourcePtrInput interface {
	pulumi.Input

	ToAnnotationSourcePtrOutput() AnnotationSourcePtrOutput
	ToAnnotationSourcePtrOutputWithContext(context.Context) AnnotationSourcePtrOutput
}

type annotationSourcePtrType AnnotationSourceArgs

func AnnotationSourcePtr(v *AnnotationSourceArgs) AnnotationSourcePtrInput {
	return (*annotationSourcePtrType)(v)
}

func (*annotationSourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AnnotationSource)(nil)).Elem()
}

func (i *annotationSourcePtrType) ToAnnotationSourcePtrOutput() AnnotationSourcePtrOutput {
	return i.ToAnnotationSourcePtrOutputWithContext(context.Background())
}

func (i *annotationSourcePtrType) ToAnnotationSourcePtrOutputWithContext(ctx context.Context) AnnotationSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AnnotationSourcePtrOutput)
}

// AnnotationSource holds the source information of the annotation.
type AnnotationSourceOutput struct{ *pulumi.OutputState }

func (AnnotationSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AnnotationSource)(nil)).Elem()
}

func (o AnnotationSourceOutput) ToAnnotationSourceOutput() AnnotationSourceOutput {
	return o
}

func (o AnnotationSourceOutput) ToAnnotationSourceOutputWithContext(ctx context.Context) AnnotationSourceOutput {
	return o
}

func (o AnnotationSourceOutput) ToAnnotationSourcePtrOutput() AnnotationSourcePtrOutput {
	return o.ToAnnotationSourcePtrOutputWithContext(context.Background())
}

func (o AnnotationSourceOutput) ToAnnotationSourcePtrOutputWithContext(ctx context.Context) AnnotationSourcePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AnnotationSource) *AnnotationSource {
		return &v
	}).(AnnotationSourcePtrOutput)
}

// Cloud Healthcare API resource.
func (o AnnotationSourceOutput) CloudHealthcareSource() CloudHealthcareSourcePtrOutput {
	return o.ApplyT(func(v AnnotationSource) *CloudHealthcareSource { return v.CloudHealthcareSource }).(CloudHealthcareSourcePtrOutput)
}

type AnnotationSourcePtrOutput struct{ *pulumi.OutputState }

func (AnnotationSourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AnnotationSource)(nil)).Elem()
}

func (o AnnotationSourcePtrOutput) ToAnnotationSourcePtrOutput() AnnotationSourcePtrOutput {
	return o
}

func (o AnnotationSourcePtrOutput) ToAnnotationSourcePtrOutputWithContext(ctx context.Context) AnnotationSourcePtrOutput {
	return o
}

func (o AnnotationSourcePtrOutput) Elem() AnnotationSourceOutput {
	return o.ApplyT(func(v *AnnotationSource) AnnotationSource {
		if v != nil {
			return *v
		}
		var ret AnnotationSource
		return ret
	}).(AnnotationSourceOutput)
}

// Cloud Healthcare API resource.
func (o AnnotationSourcePtrOutput) CloudHealthcareSource() CloudHealthcareSourcePtrOutput {
	return o.ApplyT(func(v *AnnotationSource) *CloudHealthcareSource {
		if v == nil {
			return nil
		}
		return v.CloudHealthcareSource
	}).(CloudHealthcareSourcePtrOutput)
}

// AnnotationSource holds the source information of the annotation.
type AnnotationSourceResponse struct {
	// Cloud Healthcare API resource.
	CloudHealthcareSource CloudHealthcareSourceResponse `pulumi:"cloudHealthcareSource"`
}

// AnnotationSource holds the source information of the annotation.
type AnnotationSourceResponseOutput struct{ *pulumi.OutputState }

func (AnnotationSourceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AnnotationSourceResponse)(nil)).Elem()
}

func (o AnnotationSourceResponseOutput) ToAnnotationSourceResponseOutput() AnnotationSourceResponseOutput {
	return o
}

func (o AnnotationSourceResponseOutput) ToAnnotationSourceResponseOutputWithContext(ctx context.Context) AnnotationSourceResponseOutput {
	return o
}

// Cloud Healthcare API resource.
func (o AnnotationSourceResponseOutput) CloudHealthcareSource() CloudHealthcareSourceResponseOutput {
	return o.ApplyT(func(v AnnotationSourceResponse) CloudHealthcareSourceResponse { return v.CloudHealthcareSource }).(CloudHealthcareSourceResponseOutput)
}

// An attribute value for a Consent or User data mapping. Each Attribute must have a corresponding AttributeDefinition in the consent store that defines the default and allowed values.
type Attribute struct {
	// Indicates the name of an attribute defined in the consent store.
	AttributeDefinitionId *string `pulumi:"attributeDefinitionId"`
	// The value of the attribute. Must be an acceptable value as defined in the consent store. For example, if the consent store defines "data type" with acceptable values "questionnaire" and "step-count", when the attribute name is data type, this field must contain one of those values.
	Values []string `pulumi:"values"`
}

// AttributeInput is an input type that accepts AttributeArgs and AttributeOutput values.
// You can construct a concrete instance of `AttributeInput` via:
//
//	AttributeArgs{...}
type AttributeInput interface {
	pulumi.Input

	ToAttributeOutput() AttributeOutput
	ToAttributeOutputWithContext(context.Context) AttributeOutput
}

// An attribute value for a Consent or User data mapping. Each Attribute must have a corresponding AttributeDefinition in the consent store that defines the default and allowed values.
type AttributeArgs struct {
	// Indicates the name of an attribute defined in the consent store.
	AttributeDefinitionId pulumi.StringPtrInput `pulumi:"attributeDefinitionId"`
	// The value of the attribute. Must be an acceptable value as defined in the consent store. For example, if the consent store defines "data type" with acceptable values "questionnaire" and "step-count", when the attribute name is data type, this field must contain one of those values.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (AttributeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Attribute)(nil)).Elem()
}

func (i AttributeArgs) ToAttributeOutput() AttributeOutput {
	return i.ToAttributeOutputWithContext(context.Background())
}

func (i AttributeArgs) ToAttributeOutputWithContext(ctx context.Context) AttributeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttributeOutput)
}

// AttributeArrayInput is an input type that accepts AttributeArray and AttributeArrayOutput values.
// You can construct a concrete instance of `AttributeArrayInput` via:
//
//	AttributeArray{ AttributeArgs{...} }
type AttributeArrayInput interface {
	pulumi.Input

	ToAttributeArrayOutput() AttributeArrayOutput
	ToAttributeArrayOutputWithContext(context.Context) AttributeArrayOutput
}

type AttributeArray []AttributeInput

func (AttributeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Attribute)(nil)).Elem()
}

func (i AttributeArray) ToAttributeArrayOutput() AttributeArrayOutput {
	return i.ToAttributeArrayOutputWithContext(context.Background())
}

func (i AttributeArray) ToAttributeArrayOutputWithContext(ctx context.Context) AttributeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttributeArrayOutput)
}

// An attribute value for a Consent or User data mapping. Each Attribute must have a corresponding AttributeDefinition in the consent store that defines the default and allowed values.
type AttributeOutput struct{ *pulumi.OutputState }

func (AttributeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Attribute)(nil)).Elem()
}

func (o AttributeOutput) ToAttributeOutput() AttributeOutput {
	return o
}

func (o AttributeOutput) ToAttributeOutputWithContext(ctx context.Context) AttributeOutput {
	return o
}

// Indicates the name of an attribute defined in the consent store.
func (o AttributeOutput) AttributeDefinitionId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Attribute) *string { return v.AttributeDefinitionId }).(pulumi.StringPtrOutput)
}

// The value of the attribute. Must be an acceptable value as defined in the consent store. For example, if the consent store defines "data type" with acceptable values "questionnaire" and "step-count", when the attribute name is data type, this field must contain one of those values.
func (o AttributeOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Attribute) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type AttributeArrayOutput struct{ *pulumi.OutputState }

func (AttributeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Attribute)(nil)).Elem()
}

func (o AttributeArrayOutput) ToAttributeArrayOutput() AttributeArrayOutput {
	return o
}

func (o AttributeArrayOutput) ToAttributeArrayOutputWithContext(ctx context.Context) AttributeArrayOutput {
	return o
}

func (o AttributeArrayOutput) Index(i pulumi.IntInput) AttributeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Attribute {
		return vs[0].([]Attribute)[vs[1].(int)]
	}).(AttributeOutput)
}

// An attribute value for a Consent or User data mapping. Each Attribute must have a corresponding AttributeDefinition in the consent store that defines the default and allowed values.
type AttributeResponse struct {
	// Indicates the name of an attribute defined in the consent store.
	AttributeDefinitionId string `pulumi:"attributeDefinitionId"`
	// The value of the attribute. Must be an acceptable value as defined in the consent store. For example, if the consent store defines "data type" with acceptable values "questionnaire" and "step-count", when the attribute name is data type, this field must contain one of those values.
	Values []string `pulumi:"values"`
}

// An attribute value for a Consent or User data mapping. Each Attribute must have a corresponding AttributeDefinition in the consent store that defines the default and allowed values.
type AttributeResponseOutput struct{ *pulumi.OutputState }

func (AttributeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AttributeResponse)(nil)).Elem()
}

func (o AttributeResponseOutput) ToAttributeResponseOutput() AttributeResponseOutput {
	return o
}

func (o AttributeResponseOutput) ToAttributeResponseOutputWithContext(ctx context.Context) AttributeResponseOutput {
	return o
}

// Indicates the name of an attribute defined in the consent store.
func (o AttributeResponseOutput) AttributeDefinitionId() pulumi.StringOutput {
	return o.ApplyT(func(v AttributeResponse) string { return v.AttributeDefinitionId }).(pulumi.StringOutput)
}

// The value of the attribute. Must be an acceptable value as defined in the consent store. For example, if the consent store defines "data type" with acceptable values "questionnaire" and "step-count", when the attribute name is data type, this field must contain one of those values.
func (o AttributeResponseOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AttributeResponse) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type AttributeResponseArrayOutput struct{ *pulumi.OutputState }

func (AttributeResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AttributeResponse)(nil)).Elem()
}

func (o AttributeResponseArrayOutput) ToAttributeResponseArrayOutput() AttributeResponseArrayOutput {
	return o
}

func (o AttributeResponseArrayOutput) ToAttributeResponseArrayOutputWithContext(ctx context.Context) AttributeResponseArrayOutput {
	return o
}

func (o AttributeResponseArrayOutput) Index(i pulumi.IntInput) AttributeResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AttributeResponse {
		return vs[0].([]AttributeResponse)[vs[1].(int)]
	}).(AttributeResponseOutput)
}

// Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts `jose@example.com` from DATA_READ logging, and `aliya@example.com` from DATA_WRITE logging.
type AuditConfig struct {
	// The configuration for logging of each type of permission.
	AuditLogConfigs []AuditLogConfig `pulumi:"auditLogConfigs"`
	// Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
	Service *string `pulumi:"service"`
}

// AuditConfigInput is an input type that accepts AuditConfigArgs and AuditConfigOutput values.
// You can construct a concrete instance of `AuditConfigInput` via:
//
//	AuditConfigArgs{...}
type AuditConfigInput interface {
	pulumi.Input

	ToAuditConfigOutput() AuditConfigOutput
	ToAuditConfigOutputWithContext(context.Context) AuditConfigOutput
}

// Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts `jose@example.com` from DATA_READ logging, and `aliya@example.com` from DATA_WRITE logging.
type AuditConfigArgs struct {
	// The configuration for logging of each type of permission.
	AuditLogConfigs AuditLogConfigArrayInput `pulumi:"auditLogConfigs"`
	// Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
	Service pulumi.StringPtrInput `pulumi:"service"`
}

func (AuditConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AuditConfig)(nil)).Elem()
}

func (i AuditConfigArgs) ToAuditConfigOutput() AuditConfigOutput {
	return i.ToAuditConfigOutputWithContext(context.Background())
}

func (i AuditConfigArgs) ToAuditConfigOutputWithContext(ctx context.Context) AuditConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuditConfigOutput)
}

// AuditConfigArrayInput is an input type that accepts AuditConfigArray and AuditConfigArrayOutput values.
// You can construct a concrete instance of `AuditConfigArrayInput` via:
//
//	AuditConfigArray{ AuditConfigArgs{...} }
type AuditConfigArrayInput interface {
	pulumi.Input

	ToAuditConfigArrayOutput() AuditConfigArrayOutput
	ToAuditConfigArrayOutputWithContext(context.Context) AuditConfigArrayOutput
}

type AuditConfigArray []AuditConfigInput

func (AuditConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AuditConfig)(nil)).Elem()
}

func (i AuditConfigArray) ToAuditConfigArrayOutput() AuditConfigArrayOutput {
	return i.ToAuditConfigArrayOutputWithContext(context.Background())
}

func (i AuditConfigArray) ToAuditConfigArrayOutputWithContext(ctx context.Context) AuditConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuditConfigArrayOutput)
}

// Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts `jose@example.com` from DATA_READ logging, and `aliya@example.com` from DATA_WRITE logging.
type AuditConfigOutput struct{ *pulumi.OutputState }

func (AuditConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AuditConfig)(nil)).Elem()
}

func (o AuditConfigOutput) ToAuditConfigOutput() AuditConfigOutput {
	return o
}

func (o AuditConfigOutput) ToAuditConfigOutputWithContext(ctx context.Context) AuditConfigOutput {
	return o
}

// The configuration for logging of each type of permission.
func (o AuditConfigOutput) AuditLogConfigs() AuditLogConfigArrayOutput {
	return o.ApplyT(func(v AuditConfig) []AuditLogConfig { return v.AuditLogConfigs }).(AuditLogConfigArrayOutput)
}

// Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
func (o AuditConfigOutput) Service() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AuditConfig) *string { return v.Service }).(pulumi.StringPtrOutput)
}

type AuditConfigArrayOutput struct{ *pulumi.OutputState }

func (AuditConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AuditConfig)(nil)).Elem()
}

func (o AuditConfigArrayOutput) ToAuditConfigArrayOutput() AuditConfigArrayOutput {
	return o
}

func (o AuditConfigArrayOutput) ToAuditConfigArrayOutputWithContext(ctx context.Context) AuditConfigArrayOutput {
	return o
}

func (o AuditConfigArrayOutput) Index(i pulumi.IntInput) AuditConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AuditConfig {
		return vs[0].([]AuditConfig)[vs[1].(int)]
	}).(AuditConfigOutput)
}

// Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts `jose@example.com` from DATA_READ logging, and `aliya@example.com` from DATA_WRITE logging.
type AuditConfigResponse struct {
	// The configuration for logging of each type of permission.
	AuditLogConfigs []AuditLogConfigResponse `pulumi:"auditLogConfigs"`
	// Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
	Service string `pulumi:"service"`
}

// Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts `jose@example.com` from DATA_READ logging, and `aliya@example.com` from DATA_WRITE logging.
type AuditConfigResponseOutput struct{ *pulumi.OutputState }

func (AuditConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AuditConfigResponse)(nil)).Elem()
}

func (o AuditConfigResponseOutput) ToAuditConfigResponseOutput() AuditConfigResponseOutput {
	return o
}

func (o AuditConfigResponseOutput) ToAuditConfigResponseOutputWithContext(ctx context.Context) AuditConfigResponseOutput {
	return o
}

// The configuration for logging of each type of permission.
func (o AuditConfigResponseOutput) AuditLogConfigs() AuditLogConfigResponseArrayOutput {
	return o.ApplyT(func(v AuditConfigResponse) []AuditLogConfigResponse { return v.AuditLogConfigs }).(AuditLogConfigResponseArrayOutput)
}

// Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
func (o AuditConfigResponseOutput) Service() pulumi.StringOutput {
	return o.ApplyT(func(v AuditConfigResponse) string { return v.Service }).(pulumi.StringOutput)
}

type AuditConfigResponseArrayOutput struct{ *pulumi.OutputState }

func (AuditConfigResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AuditConfigResponse)(nil)).Elem()
}

func (o AuditConfigResponseArrayOutput) ToAuditConfigResponseArrayOutput() AuditConfigResponseArrayOutput {
	return o
}

func (o AuditConfigResponseArrayOutput) ToAuditConfigResponseArrayOutputWithContext(ctx context.Context) AuditConfigResponseArrayOutput {
	return o
}

func (o AuditConfigResponseArrayOutput) Index(i pulumi.IntInput) AuditConfigResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AuditConfigResponse {
		return vs[0].([]AuditConfigResponse)[vs[1].(int)]
	}).(AuditConfigResponseOutput)
}

// Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
type AuditLogConfig struct {
	// Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
	ExemptedMembers []string `pulumi:"exemptedMembers"`
	// The log type that this config enables.
	LogType *AuditLogConfigLogType `pulumi:"logType"`
}

// AuditLogConfigInput is an input type that accepts AuditLogConfigArgs and AuditLogConfigOutput values.
// You can construct a concrete instance of `AuditLogConfigInput` via:
//
//	AuditLogConfigArgs{...}
type AuditLogConfigInput interface {
	pulumi.Input

	ToAuditLogConfigOutput() AuditLogConfigOutput
	ToAuditLogConfigOutputWithContext(context.Context) AuditLogConfigOutput
}

// Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
type AuditLogConfigArgs struct {
	// Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
	ExemptedMembers pulumi.StringArrayInput `pulumi:"exemptedMembers"`
	// The log type that this config enables.
	LogType AuditLogConfigLogTypePtrInput `pulumi:"logType"`
}

func (AuditLogConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AuditLogConfig)(nil)).Elem()
}

func (i AuditLogConfigArgs) ToAuditLogConfigOutput() AuditLogConfigOutput {
	return i.ToAuditLogConfigOutputWithContext(context.Background())
}

func (i AuditLogConfigArgs) ToAuditLogConfigOutputWithContext(ctx context.Context) AuditLogConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuditLogConfigOutput)
}

// AuditLogConfigArrayInput is an input type that accepts AuditLogConfigArray and AuditLogConfigArrayOutput values.
// You can construct a concrete instance of `AuditLogConfigArrayInput` via:
//
//	AuditLogConfigArray{ AuditLogConfigArgs{...} }
type AuditLogConfigArrayInput interface {
	pulumi.Input

	ToAuditLogConfigArrayOutput() AuditLogConfigArrayOutput
	ToAuditLogConfigArrayOutputWithContext(context.Context) AuditLogConfigArrayOutput
}

type AuditLogConfigArray []AuditLogConfigInput

func (AuditLogConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AuditLogConfig)(nil)).Elem()
}

func (i AuditLogConfigArray) ToAuditLogConfigArrayOutput() AuditLogConfigArrayOutput {
	return i.ToAuditLogConfigArrayOutputWithContext(context.Background())
}

func (i AuditLogConfigArray) ToAuditLogConfigArrayOutputWithContext(ctx context.Context) AuditLogConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuditLogConfigArrayOutput)
}

// Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
type AuditLogConfigOutput struct{ *pulumi.OutputState }

func (AuditLogConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AuditLogConfig)(nil)).Elem()
}

func (o AuditLogConfigOutput) ToAuditLogConfigOutput() AuditLogConfigOutput {
	return o
}

func (o AuditLogConfigOutput) ToAuditLogConfigOutputWithContext(ctx context.Context) AuditLogConfigOutput {
	return o
}

// Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
func (o AuditLogConfigOutput) ExemptedMembers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AuditLogConfig) []string { return v.ExemptedMembers }).(pulumi.StringArrayOutput)
}

// The log type that this config enables.
func (o AuditLogConfigOutput) LogType() AuditLogConfigLogTypePtrOutput {
	return o.ApplyT(func(v AuditLogConfig) *AuditLogConfigLogType { return v.LogType }).(AuditLogConfigLogTypePtrOutput)
}

type AuditLogConfigArrayOutput struct{ *pulumi.OutputState }

func (AuditLogConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AuditLogConfig)(nil)).Elem()
}

func (o AuditLogConfigArrayOutput) ToAuditLogConfigArrayOutput() AuditLogConfigArrayOutput {
	return o
}

func (o AuditLogConfigArrayOutput) ToAuditLogConfigArrayOutputWithContext(ctx context.Context) AuditLogConfigArrayOutput {
	return o
}

func (o AuditLogConfigArrayOutput) Index(i pulumi.IntInput) AuditLogConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AuditLogConfig {
		return vs[0].([]AuditLogConfig)[vs[1].(int)]
	}).(AuditLogConfigOutput)
}

// Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
type AuditLogConfigResponse struct {
	// Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
	ExemptedMembers []string `pulumi:"exemptedMembers"`
	// The log type that this config enables.
	LogType string `pulumi:"logType"`
}

// Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
type AuditLogConfigResponseOutput struct{ *pulumi.OutputState }

func (AuditLogConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AuditLogConfigResponse)(nil)).Elem()
}

func (o AuditLogConfigResponseOutput) ToAuditLogConfigResponseOutput() AuditLogConfigResponseOutput {
	return o
}

func (o AuditLogConfigResponseOutput) ToAuditLogConfigResponseOutputWithContext(ctx context.Context) AuditLogConfigResponseOutput {
	return o
}

// Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
func (o AuditLogConfigResponseOutput) ExemptedMembers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AuditLogConfigResponse) []string { return v.ExemptedMembers }).(pulumi.StringArrayOutput)
}

// The log type that this config enables.
func (o AuditLogConfigResponseOutput) LogType() pulumi.StringOutput {
	return o.ApplyT(func(v AuditLogConfigResponse) string { return v.LogType }).(pulumi.StringOutput)
}

type AuditLogConfigResponseArrayOutput struct{ *pulumi.OutputState }

func (AuditLogConfigResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AuditLogConfigResponse)(nil)).Elem()
}

func (o AuditLogConfigResponseArrayOutput) ToAuditLogConfigResponseArrayOutput() AuditLogConfigResponseArrayOutput {
	return o
}

func (o AuditLogConfigResponseArrayOutput) ToAuditLogConfigResponseArrayOutputWithContext(ctx context.Context) AuditLogConfigResponseArrayOutput {
	return o
}

func (o AuditLogConfigResponseArrayOutput) Index(i pulumi.IntInput) AuditLogConfigResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AuditLogConfigResponse {
		return vs[0].([]AuditLogConfigResponse)[vs[1].(int)]
	}).(AuditLogConfigResponseOutput)
}

// Associates `members`, or principals, with a `role`.
type Binding struct {
	// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
	Condition *Expr `pulumi:"condition"`
	// Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.
	Members []string `pulumi:"members"`
	// Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
	Role *string `pulumi:"role"`
}

// BindingInput is an input type that accepts BindingArgs and BindingOutput values.
// You can construct a concrete instance of `BindingInput` via:
//
//	BindingArgs{...}
type BindingInput interface {
	pulumi.Input

	ToBindingOutput() BindingOutput
	ToBindingOutputWithContext(context.Context) BindingOutput
}

// Associates `members`, or principals, with a `role`.
type BindingArgs struct {
	// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
	Condition ExprPtrInput `pulumi:"condition"`
	// Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.
	Members pulumi.StringArrayInput `pulumi:"members"`
	// Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
	Role pulumi.StringPtrInput `pulumi:"role"`
}

func (BindingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Binding)(nil)).Elem()
}

func (i BindingArgs) ToBindingOutput() BindingOutput {
	return i.ToBindingOutputWithContext(context.Background())
}

func (i BindingArgs) ToBindingOutputWithContext(ctx context.Context) BindingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BindingOutput)
}

// BindingArrayInput is an input type that accepts BindingArray and BindingArrayOutput values.
// You can construct a concrete instance of `BindingArrayInput` via:
//
//	BindingArray{ BindingArgs{...} }
type BindingArrayInput interface {
	pulumi.Input

	ToBindingArrayOutput() BindingArrayOutput
	ToBindingArrayOutputWithContext(context.Context) BindingArrayOutput
}

type BindingArray []BindingInput

func (BindingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Binding)(nil)).Elem()
}

func (i BindingArray) ToBindingArrayOutput() BindingArrayOutput {
	return i.ToBindingArrayOutputWithContext(context.Background())
}

func (i BindingArray) ToBindingArrayOutputWithContext(ctx context.Context) BindingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BindingArrayOutput)
}

// Associates `members`, or principals, with a `role`.
type BindingOutput struct{ *pulumi.OutputState }

func (BindingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Binding)(nil)).Elem()
}

func (o BindingOutput) ToBindingOutput() BindingOutput {
	return o
}

func (o BindingOutput) ToBindingOutputWithContext(ctx context.Context) BindingOutput {
	return o
}

// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
func (o BindingOutput) Condition() ExprPtrOutput {
	return o.ApplyT(func(v Binding) *Expr { return v.Condition }).(ExprPtrOutput)
}

// Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.
func (o BindingOutput) Members() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Binding) []string { return v.Members }).(pulumi.StringArrayOutput)
}

// Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
func (o BindingOutput) Role() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Binding) *string { return v.Role }).(pulumi.StringPtrOutput)
}

type BindingArrayOutput struct{ *pulumi.OutputState }

func (BindingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Binding)(nil)).Elem()
}

func (o BindingArrayOutput) ToBindingArrayOutput() BindingArrayOutput {
	return o
}

func (o BindingArrayOutput) ToBindingArrayOutputWithContext(ctx context.Context) BindingArrayOutput {
	return o
}

func (o BindingArrayOutput) Index(i pulumi.IntInput) BindingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Binding {
		return vs[0].([]Binding)[vs[1].(int)]
	}).(BindingOutput)
}

// Associates `members`, or principals, with a `role`.
type BindingResponse struct {
	// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
	Condition ExprResponse `pulumi:"condition"`
	// Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.
	Members []string `pulumi:"members"`
	// Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
	Role string `pulumi:"role"`
}

// Associates `members`, or principals, with a `role`.
type BindingResponseOutput struct{ *pulumi.OutputState }

func (BindingResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BindingResponse)(nil)).Elem()
}

func (o BindingResponseOutput) ToBindingResponseOutput() BindingResponseOutput {
	return o
}

func (o BindingResponseOutput) ToBindingResponseOutputWithContext(ctx context.Context) BindingResponseOutput {
	return o
}

// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
func (o BindingResponseOutput) Condition() ExprResponseOutput {
	return o.ApplyT(func(v BindingResponse) ExprResponse { return v.Condition }).(ExprResponseOutput)
}

// Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.
func (o BindingResponseOutput) Members() pulumi.StringArrayOutput {
	return o.ApplyT(func(v BindingResponse) []string { return v.Members }).(pulumi.StringArrayOutput)
}

// Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
func (o BindingResponseOutput) Role() pulumi.StringOutput {
	return o.ApplyT(func(v BindingResponse) string { return v.Role }).(pulumi.StringOutput)
}

type BindingResponseArrayOutput struct{ *pulumi.OutputState }

func (BindingResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BindingResponse)(nil)).Elem()
}

func (o BindingResponseArrayOutput) ToBindingResponseArrayOutput() BindingResponseArrayOutput {
	return o
}

func (o BindingResponseArrayOutput) ToBindingResponseArrayOutputWithContext(ctx context.Context) BindingResponseArrayOutput {
	return o
}

func (o BindingResponseArrayOutput) Index(i pulumi.IntInput) BindingResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) BindingResponse {
		return vs[0].([]BindingResponse)[vs[1].(int)]
	}).(BindingResponseOutput)
}

// A bounding polygon for the detected image annotation.
type BoundingPoly struct {
	// A description of this polygon.
	Label *string `pulumi:"label"`
	// List of the vertices of this polygon.
	Vertices []Vertex `pulumi:"vertices"`
}

// BoundingPolyInput is an input type that accepts BoundingPolyArgs and BoundingPolyOutput values.
// You can construct a concrete instance of `BoundingPolyInput` via:
//
//	BoundingPolyArgs{...}
type BoundingPolyInput interface {
	pulumi.Input

	ToBoundingPolyOutput() BoundingPolyOutput
	ToBoundingPolyOutputWithContext(context.Context) BoundingPolyOutput
}

// A bounding polygon for the detected image annotation.
type BoundingPolyArgs struct {
	// A description of this polygon.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// List of the vertices of this polygon.
	Vertices VertexArrayInput `pulumi:"vertices"`
}

func (BoundingPolyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BoundingPoly)(nil)).Elem()
}

func (i BoundingPolyArgs) ToBoundingPolyOutput() BoundingPolyOutput {
	return i.ToBoundingPolyOutputWithContext(context.Background())
}

func (i BoundingPolyArgs) ToBoundingPolyOutputWithContext(ctx context.Context) BoundingPolyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BoundingPolyOutput)
}

// BoundingPolyArrayInput is an input type that accepts BoundingPolyArray and BoundingPolyArrayOutput values.
// You can construct a concrete instance of `BoundingPolyArrayInput` via:
//
//	BoundingPolyArray{ BoundingPolyArgs{...} }
type BoundingPolyArrayInput interface {
	pulumi.Input

	ToBoundingPolyArrayOutput() BoundingPolyArrayOutput
	ToBoundingPolyArrayOutputWithContext(context.Context) BoundingPolyArrayOutput
}

type BoundingPolyArray []BoundingPolyInput

func (BoundingPolyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BoundingPoly)(nil)).Elem()
}

func (i BoundingPolyArray) ToBoundingPolyArrayOutput() BoundingPolyArrayOutput {
	return i.ToBoundingPolyArrayOutputWithContext(context.Background())
}

func (i BoundingPolyArray) ToBoundingPolyArrayOutputWithContext(ctx context.Context) BoundingPolyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BoundingPolyArrayOutput)
}

// A bounding polygon for the detected image annotation.
type BoundingPolyOutput struct{ *pulumi.OutputState }

func (BoundingPolyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BoundingPoly)(nil)).Elem()
}

func (o BoundingPolyOutput) ToBoundingPolyOutput() BoundingPolyOutput {
	return o
}

func (o BoundingPolyOutput) ToBoundingPolyOutputWithContext(ctx context.Context) BoundingPolyOutput {
	return o
}

// A description of this polygon.
func (o BoundingPolyOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BoundingPoly) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// List of the vertices of this polygon.
func (o BoundingPolyOutput) Vertices() VertexArrayOutput {
	return o.ApplyT(func(v BoundingPoly) []Vertex { return v.Vertices }).(VertexArrayOutput)
}

type BoundingPolyArrayOutput struct{ *pulumi.OutputState }

func (BoundingPolyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BoundingPoly)(nil)).Elem()
}

func (o BoundingPolyArrayOutput) ToBoundingPolyArrayOutput() BoundingPolyArrayOutput {
	return o
}

func (o BoundingPolyArrayOutput) ToBoundingPolyArrayOutputWithContext(ctx context.Context) BoundingPolyArrayOutput {
	return o
}

func (o BoundingPolyArrayOutput) Index(i pulumi.IntInput) BoundingPolyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) BoundingPoly {
		return vs[0].([]BoundingPoly)[vs[1].(int)]
	}).(BoundingPolyOutput)
}

// A bounding polygon for the detected image annotation.
type BoundingPolyResponse struct {
	// A description of this polygon.
	Label string `pulumi:"label"`
	// List of the vertices of this polygon.
	Vertices []VertexResponse `pulumi:"vertices"`
}

// A bounding polygon for the detected image annotation.
type BoundingPolyResponseOutput struct{ *pulumi.OutputState }

func (BoundingPolyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BoundingPolyResponse)(nil)).Elem()
}

func (o BoundingPolyResponseOutput) ToBoundingPolyResponseOutput() BoundingPolyResponseOutput {
	return o
}

func (o BoundingPolyResponseOutput) ToBoundingPolyResponseOutputWithContext(ctx context.Context) BoundingPolyResponseOutput {
	return o
}

// A description of this polygon.
func (o BoundingPolyResponseOutput) Label() pulumi.StringOutput {
	return o.ApplyT(func(v BoundingPolyResponse) string { return v.Label }).(pulumi.StringOutput)
}

// List of the vertices of this polygon.
func (o BoundingPolyResponseOutput) Vertices() VertexResponseArrayOutput {
	return o.ApplyT(func(v BoundingPolyResponse) []VertexResponse { return v.Vertices }).(VertexResponseArrayOutput)
}

type BoundingPolyResponseArrayOutput struct{ *pulumi.OutputState }

func (BoundingPolyResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BoundingPolyResponse)(nil)).Elem()
}

func (o BoundingPolyResponseArrayOutput) ToBoundingPolyResponseArrayOutput() BoundingPolyResponseArrayOutput {
	return o
}

func (o BoundingPolyResponseArrayOutput) ToBoundingPolyResponseArrayOutputWithContext(ctx context.Context) BoundingPolyResponseArrayOutput {
	return o
}

func (o BoundingPolyResponseArrayOutput) Index(i pulumi.IntInput) BoundingPolyResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) BoundingPolyResponse {
		return vs[0].([]BoundingPolyResponse)[vs[1].(int)]
	}).(BoundingPolyResponseOutput)
}

// Mask a string by replacing its characters with a fixed character.
type CharacterMaskConfig struct {
	// Character to mask the sensitive values. If not supplied, defaults to "*".
	MaskingCharacter *string `pulumi:"maskingCharacter"`
}

// CharacterMaskConfigInput is an input type that accepts CharacterMaskConfigArgs and CharacterMaskConfigOutput values.
// You can construct a concrete instance of `CharacterMaskConfigInput` via:
//
//	CharacterMaskConfigArgs{...}
type CharacterMaskConfigInput interface {
	pulumi.Input

	ToCharacterMaskConfigOutput() CharacterMaskConfigOutput
	ToCharacterMaskConfigOutputWithContext(context.Context) CharacterMaskConfigOutput
}

// Mask a string by replacing its characters with a fixed character.
type CharacterMaskConfigArgs struct {
	// Character to mask the sensitive values. If not supplied, defaults to "*".
	MaskingCharacter pulumi.StringPtrInput `pulumi:"maskingCharacter"`
}

func (CharacterMaskConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CharacterMaskConfig)(nil)).Elem()
}

func (i CharacterMaskConfigArgs) ToCharacterMaskConfigOutput() CharacterMaskConfigOutput {
	return i.ToCharacterMaskConfigOutputWithContext(context.Background())
}

func (i CharacterMaskConfigArgs) ToCharacterMaskConfigOutputWithContext(ctx context.Context) CharacterMaskConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CharacterMaskConfigOutput)
}

func (i CharacterMaskConfigArgs) ToCharacterMaskConfigPtrOutput() CharacterMaskConfigPtrOutput {
	return i.ToCharacterMaskConfigPtrOutputWithContext(context.Background())
}

func (i CharacterMaskConfigArgs) ToCharacterMaskConfigPtrOutputWithContext(ctx context.Context) CharacterMaskConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CharacterMaskConfigOutput).ToCharacterMaskConfigPtrOutputWithContext(ctx)
}

// CharacterMaskConfigPtrInput is an input type that accepts CharacterMaskConfigArgs, CharacterMaskConfigPtr and CharacterMaskConfigPtrOutput values.
// You can construct a concrete instance of `CharacterMaskConfigPtrInput` via:
//
//	        CharacterMaskConfigArgs{...}
//
//	or:
//
//	        nil
type CharacterMaskConfigPtrInput interface {
	pulumi.Input

	ToCharacterMaskConfigPtrOutput() CharacterMaskConfigPtrOutput
	ToCharacterMaskConfigPtrOutputWithContext(context.Context) CharacterMaskConfigPtrOutput
}

type characterMaskConfigPtrType CharacterMaskConfigArgs

func CharacterMaskConfigPtr(v *CharacterMaskConfigArgs) CharacterMaskConfigPtrInput {
	return (*characterMaskConfigPtrType)(v)
}

func (*characterMaskConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CharacterMaskConfig)(nil)).Elem()
}

func (i *characterMaskConfigPtrType) ToCharacterMaskConfigPtrOutput() CharacterMaskConfigPtrOutput {
	return i.ToCharacterMaskConfigPtrOutputWithContext(context.Background())
}

func (i *characterMaskConfigPtrType) ToCharacterMaskConfigPtrOutputWithContext(ctx context.Context) CharacterMaskConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CharacterMaskConfigPtrOutput)
}

// Mask a string by replacing its characters with a fixed character.
type CharacterMaskConfigOutput struct{ *pulumi.OutputState }

func (CharacterMaskConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CharacterMaskConfig)(nil)).Elem()
}

func (o CharacterMaskConfigOutput) ToCharacterMaskConfigOutput() CharacterMaskConfigOutput {
	return o
}

func (o CharacterMaskConfigOutput) ToCharacterMaskConfigOutputWithContext(ctx context.Context) CharacterMaskConfigOutput {
	return o
}

func (o CharacterMaskConfigOutput) ToCharacterMaskConfigPtrOutput() CharacterMaskConfigPtrOutput {
	return o.ToCharacterMaskConfigPtrOutputWithContext(context.Background())
}

func (o CharacterMaskConfigOutput) ToCharacterMaskConfigPtrOutputWithContext(ctx context.Context) CharacterMaskConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CharacterMaskConfig) *CharacterMaskConfig {
		return &v
	}).(CharacterMaskConfigPtrOutput)
}

// Character to mask the sensitive values. If not supplied, defaults to "*".
func (o CharacterMaskConfigOutput) MaskingCharacter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CharacterMaskConfig) *string { return v.MaskingCharacter }).(pulumi.StringPtrOutput)
}

type CharacterMaskConfigPtrOutput struct{ *pulumi.OutputState }

func (CharacterMaskConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CharacterMaskConfig)(nil)).Elem()
}

func (o CharacterMaskConfigPtrOutput) ToCharacterMaskConfigPtrOutput() CharacterMaskConfigPtrOutput {
	return o
}

func (o CharacterMaskConfigPtrOutput) ToCharacterMaskConfigPtrOutputWithContext(ctx context.Context) CharacterMaskConfigPtrOutput {
	return o
}

func (o CharacterMaskConfigPtrOutput) Elem() CharacterMaskConfigOutput {
	return o.ApplyT(func(v *CharacterMaskConfig) CharacterMaskConfig {
		if v != nil {
			return *v
		}
		var ret CharacterMaskConfig
		return ret
	}).(CharacterMaskConfigOutput)
}

// Character to mask the sensitive values. If not supplied, defaults to "*".
func (o CharacterMaskConfigPtrOutput) MaskingCharacter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CharacterMaskConfig) *string {
		if v == nil {
			return nil
		}
		return v.MaskingCharacter
	}).(pulumi.StringPtrOutput)
}

// Mask a string by replacing its characters with a fixed character.
type CharacterMaskConfigResponse struct {
	// Character to mask the sensitive values. If not supplied, defaults to "*".
	MaskingCharacter string `pulumi:"maskingCharacter"`
}

// Mask a string by replacing its characters with a fixed character.
type CharacterMaskConfigResponseOutput struct{ *pulumi.OutputState }

func (CharacterMaskConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CharacterMaskConfigResponse)(nil)).Elem()
}

func (o CharacterMaskConfigResponseOutput) ToCharacterMaskConfigResponseOutput() CharacterMaskConfigResponseOutput {
	return o
}

func (o CharacterMaskConfigResponseOutput) ToCharacterMaskConfigResponseOutputWithContext(ctx context.Context) CharacterMaskConfigResponseOutput {
	return o
}

// Character to mask the sensitive values. If not supplied, defaults to "*".
func (o CharacterMaskConfigResponseOutput) MaskingCharacter() pulumi.StringOutput {
	return o.ApplyT(func(v CharacterMaskConfigResponse) string { return v.MaskingCharacter }).(pulumi.StringOutput)
}

// Replace field value with masking character. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
type CharacterMaskField struct {
}

// CharacterMaskFieldInput is an input type that accepts CharacterMaskFieldArgs and CharacterMaskFieldOutput values.
// You can construct a concrete instance of `CharacterMaskFieldInput` via:
//
//	CharacterMaskFieldArgs{...}
type CharacterMaskFieldInput interface {
	pulumi.Input

	ToCharacterMaskFieldOutput() CharacterMaskFieldOutput
	ToCharacterMaskFieldOutputWithContext(context.Context) CharacterMaskFieldOutput
}

// Replace field value with masking character. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
type CharacterMaskFieldArgs struct {
}

func (CharacterMaskFieldArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CharacterMaskField)(nil)).Elem()
}

func (i CharacterMaskFieldArgs) ToCharacterMaskFieldOutput() CharacterMaskFieldOutput {
	return i.ToCharacterMaskFieldOutputWithContext(context.Background())
}

func (i CharacterMaskFieldArgs) ToCharacterMaskFieldOutputWithContext(ctx context.Context) CharacterMaskFieldOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CharacterMaskFieldOutput)
}

func (i CharacterMaskFieldArgs) ToCharacterMaskFieldPtrOutput() CharacterMaskFieldPtrOutput {
	return i.ToCharacterMaskFieldPtrOutputWithContext(context.Background())
}

func (i CharacterMaskFieldArgs) ToCharacterMaskFieldPtrOutputWithContext(ctx context.Context) CharacterMaskFieldPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CharacterMaskFieldOutput).ToCharacterMaskFieldPtrOutputWithContext(ctx)
}

// CharacterMaskFieldPtrInput is an input type that accepts CharacterMaskFieldArgs, CharacterMaskFieldPtr and CharacterMaskFieldPtrOutput values.
// You can construct a concrete instance of `CharacterMaskFieldPtrInput` via:
//
//	        CharacterMaskFieldArgs{...}
//
//	or:
//
//	        nil
type CharacterMaskFieldPtrInput interface {
	pulumi.Input

	ToCharacterMaskFieldPtrOutput() CharacterMaskFieldPtrOutput
	ToCharacterMaskFieldPtrOutputWithContext(context.Context) CharacterMaskFieldPtrOutput
}

type characterMaskFieldPtrType CharacterMaskFieldArgs

func CharacterMaskFieldPtr(v *CharacterMaskFieldArgs) CharacterMaskFieldPtrInput {
	return (*characterMaskFieldPtrType)(v)
}

func (*characterMaskFieldPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CharacterMaskField)(nil)).Elem()
}

func (i *characterMaskFieldPtrType) ToCharacterMaskFieldPtrOutput() CharacterMaskFieldPtrOutput {
	return i.ToCharacterMaskFieldPtrOutputWithContext(context.Background())
}

func (i *characterMaskFieldPtrType) ToCharacterMaskFieldPtrOutputWithContext(ctx context.Context) CharacterMaskFieldPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CharacterMaskFieldPtrOutput)
}

// Replace field value with masking character. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
type CharacterMaskFieldOutput struct{ *pulumi.OutputState }

func (CharacterMaskFieldOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CharacterMaskField)(nil)).Elem()
}

func (o CharacterMaskFieldOutput) ToCharacterMaskFieldOutput() CharacterMaskFieldOutput {
	return o
}

func (o CharacterMaskFieldOutput) ToCharacterMaskFieldOutputWithContext(ctx context.Context) CharacterMaskFieldOutput {
	return o
}

func (o CharacterMaskFieldOutput) ToCharacterMaskFieldPtrOutput() CharacterMaskFieldPtrOutput {
	return o.ToCharacterMaskFieldPtrOutputWithContext(context.Background())
}

func (o CharacterMaskFieldOutput) ToCharacterMaskFieldPtrOutputWithContext(ctx context.Context) CharacterMaskFieldPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CharacterMaskField) *CharacterMaskField {
		return &v
	}).(CharacterMaskFieldPtrOutput)
}

type CharacterMaskFieldPtrOutput struct{ *pulumi.OutputState }

func (CharacterMaskFieldPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CharacterMaskField)(nil)).Elem()
}

func (o CharacterMaskFieldPtrOutput) ToCharacterMaskFieldPtrOutput() CharacterMaskFieldPtrOutput {
	return o
}

func (o CharacterMaskFieldPtrOutput) ToCharacterMaskFieldPtrOutputWithContext(ctx context.Context) CharacterMaskFieldPtrOutput {
	return o
}

func (o CharacterMaskFieldPtrOutput) Elem() CharacterMaskFieldOutput {
	return o.ApplyT(func(v *CharacterMaskField) CharacterMaskField {
		if v != nil {
			return *v
		}
		var ret CharacterMaskField
		return ret
	}).(CharacterMaskFieldOutput)
}

// Replace field value with masking character. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
type CharacterMaskFieldResponse struct {
}

// Replace field value with masking character. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
type CharacterMaskFieldResponseOutput struct{ *pulumi.OutputState }

func (CharacterMaskFieldResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CharacterMaskFieldResponse)(nil)).Elem()
}

func (o CharacterMaskFieldResponseOutput) ToCharacterMaskFieldResponseOutput() CharacterMaskFieldResponseOutput {
	return o
}

func (o CharacterMaskFieldResponseOutput) ToCharacterMaskFieldResponseOutputWithContext(ctx context.Context) CharacterMaskFieldResponseOutput {
	return o
}

// This option is based on the DICOM Standard's [Clean Descriptors Option](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part15/sect_E.3.5.html), and the `CleanText` `Action` is applied to all the specified fields. When cleaning text, the process attempts to transform phrases matching any of the tags marked for removal (action codes D, Z, X, and U) in the [Basic Profile](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part15/chapter_E.html). These contextual phrases are replaced with the token "[CTX]". This option uses an additional infoType during inspection.
type CleanDescriptorsOption struct {
}

// CleanDescriptorsOptionInput is an input type that accepts CleanDescriptorsOptionArgs and CleanDescriptorsOptionOutput values.
// You can construct a concrete instance of `CleanDescriptorsOptionInput` via:
//
//	CleanDescriptorsOptionArgs{...}
type CleanDescriptorsOptionInput interface {
	pulumi.Input

	ToCleanDescriptorsOptionOutput() CleanDescriptorsOptionOutput
	ToCleanDescriptorsOptionOutputWithContext(context.Context) CleanDescriptorsOptionOutput
}

// This option is based on the DICOM Standard's [Clean Descriptors Option](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part15/sect_E.3.5.html), and the `CleanText` `Action` is applied to all the specified fields. When cleaning text, the process attempts to transform phrases matching any of the tags marked for removal (action codes D, Z, X, and U) in the [Basic Profile](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part15/chapter_E.html). These contextual phrases are replaced with the token "[CTX]". This option uses an additional infoType during inspection.
type CleanDescriptorsOptionArgs struct {
}

func (CleanDescriptorsOptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CleanDescriptorsOption)(nil)).Elem()
}

func (i CleanDescriptorsOptionArgs) ToCleanDescriptorsOptionOutput() CleanDescriptorsOptionOutput {
	return i.ToCleanDescriptorsOptionOutputWithContext(context.Background())
}

func (i CleanDescriptorsOptionArgs) ToCleanDescriptorsOptionOutputWithContext(ctx context.Context) CleanDescriptorsOptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CleanDescriptorsOptionOutput)
}

func (i CleanDescriptorsOptionArgs) ToCleanDescriptorsOptionPtrOutput() CleanDescriptorsOptionPtrOutput {
	return i.ToCleanDescriptorsOptionPtrOutputWithContext(context.Background())
}

func (i CleanDescriptorsOptionArgs) ToCleanDescriptorsOptionPtrOutputWithContext(ctx context.Context) CleanDescriptorsOptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CleanDescriptorsOptionOutput).ToCleanDescriptorsOptionPtrOutputWithContext(ctx)
}

// CleanDescriptorsOptionPtrInput is an input type that accepts CleanDescriptorsOptionArgs, CleanDescriptorsOptionPtr and CleanDescriptorsOptionPtrOutput values.
// You can construct a concrete instance of `CleanDescriptorsOptionPtrInput` via:
//
//	        CleanDescriptorsOptionArgs{...}
//
//	or:
//
//	        nil
type CleanDescriptorsOptionPtrInput interface {
	pulumi.Input

	ToCleanDescriptorsOptionPtrOutput() CleanDescriptorsOptionPtrOutput
	ToCleanDescriptorsOptionPtrOutputWithContext(context.Context) CleanDescriptorsOptionPtrOutput
}

type cleanDescriptorsOptionPtrType CleanDescriptorsOptionArgs

func CleanDescriptorsOptionPtr(v *CleanDescriptorsOptionArgs) CleanDescriptorsOptionPtrInput {
	return (*cleanDescriptorsOptionPtrType)(v)
}

func (*cleanDescriptorsOptionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CleanDescriptorsOption)(nil)).Elem()
}

func (i *cleanDescriptorsOptionPtrType) ToCleanDescriptorsOptionPtrOutput() CleanDescriptorsOptionPtrOutput {
	return i.ToCleanDescriptorsOptionPtrOutputWithContext(context.Background())
}

func (i *cleanDescriptorsOptionPtrType) ToCleanDescriptorsOptionPtrOutputWithContext(ctx context.Context) CleanDescriptorsOptionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CleanDescriptorsOptionPtrOutput)
}

// This option is based on the DICOM Standard's [Clean Descriptors Option](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part15/sect_E.3.5.html), and the `CleanText` `Action` is applied to all the specified fields. When cleaning text, the process attempts to transform phrases matching any of the tags marked for removal (action codes D, Z, X, and U) in the [Basic Profile](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part15/chapter_E.html). These contextual phrases are replaced with the token "[CTX]". This option uses an additional infoType during inspection.
type CleanDescriptorsOptionOutput struct{ *pulumi.OutputState }

func (CleanDescriptorsOptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CleanDescriptorsOption)(nil)).Elem()
}

func (o CleanDescriptorsOptionOutput) ToCleanDescriptorsOptionOutput() CleanDescriptorsOptionOutput {
	return o
}

func (o CleanDescriptorsOptionOutput) ToCleanDescriptorsOptionOutputWithContext(ctx context.Context) CleanDescriptorsOptionOutput {
	return o
}

func (o CleanDescriptorsOptionOutput) ToCleanDescriptorsOptionPtrOutput() CleanDescriptorsOptionPtrOutput {
	return o.ToCleanDescriptorsOptionPtrOutputWithContext(context.Background())
}

func (o CleanDescriptorsOptionOutput) ToCleanDescriptorsOptionPtrOutputWithContext(ctx context.Context) CleanDescriptorsOptionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CleanDescriptorsOption) *CleanDescriptorsOption {
		return &v
	}).(CleanDescriptorsOptionPtrOutput)
}

type CleanDescriptorsOptionPtrOutput struct{ *pulumi.OutputState }

func (CleanDescriptorsOptionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CleanDescriptorsOption)(nil)).Elem()
}

func (o CleanDescriptorsOptionPtrOutput) ToCleanDescriptorsOptionPtrOutput() CleanDescriptorsOptionPtrOutput {
	return o
}

func (o CleanDescriptorsOptionPtrOutput) ToCleanDescriptorsOptionPtrOutputWithContext(ctx context.Context) CleanDescriptorsOptionPtrOutput {
	return o
}

func (o CleanDescriptorsOptionPtrOutput) Elem() CleanDescriptorsOptionOutput {
	return o.ApplyT(func(v *CleanDescriptorsOption) CleanDescriptorsOption {
		if v != nil {
			return *v
		}
		var ret CleanDescriptorsOption
		return ret
	}).(CleanDescriptorsOptionOutput)
}

// This option is based on the DICOM Standard's [Clean Descriptors Option](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part15/sect_E.3.5.html), and the `CleanText` `Action` is applied to all the specified fields. When cleaning text, the process attempts to transform phrases matching any of the tags marked for removal (action codes D, Z, X, and U) in the [Basic Profile](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part15/chapter_E.html). These contextual phrases are replaced with the token "[CTX]". This option uses an additional infoType during inspection.
type CleanDescriptorsOptionResponse struct {
}

// This option is based on the DICOM Standard's [Clean Descriptors Option](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part15/sect_E.3.5.html), and the `CleanText` `Action` is applied to all the specified fields. When cleaning text, the process attempts to transform phrases matching any of the tags marked for removal (action codes D, Z, X, and U) in the [Basic Profile](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part15/chapter_E.html). These contextual phrases are replaced with the token "[CTX]". This option uses an additional infoType during inspection.
type CleanDescriptorsOptionResponseOutput struct{ *pulumi.OutputState }

func (CleanDescriptorsOptionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CleanDescriptorsOptionResponse)(nil)).Elem()
}

func (o CleanDescriptorsOptionResponseOutput) ToCleanDescriptorsOptionResponseOutput() CleanDescriptorsOptionResponseOutput {
	return o
}

func (o CleanDescriptorsOptionResponseOutput) ToCleanDescriptorsOptionResponseOutputWithContext(ctx context.Context) CleanDescriptorsOptionResponseOutput {
	return o
}

// Inspect text and transform sensitive text. Configure using TextConfig. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Date, DateTime, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
type CleanTextField struct {
}

// CleanTextFieldInput is an input type that accepts CleanTextFieldArgs and CleanTextFieldOutput values.
// You can construct a concrete instance of `CleanTextFieldInput` via:
//
//	CleanTextFieldArgs{...}
type CleanTextFieldInput interface {
	pulumi.Input

	ToCleanTextFieldOutput() CleanTextFieldOutput
	ToCleanTextFieldOutputWithContext(context.Context) CleanTextFieldOutput
}

// Inspect text and transform sensitive text. Configure using TextConfig. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Date, DateTime, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
type CleanTextFieldArgs struct {
}

func (CleanTextFieldArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CleanTextField)(nil)).Elem()
}

func (i CleanTextFieldArgs) ToCleanTextFieldOutput() CleanTextFieldOutput {
	return i.ToCleanTextFieldOutputWithContext(context.Background())
}

func (i CleanTextFieldArgs) ToCleanTextFieldOutputWithContext(ctx context.Context) CleanTextFieldOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CleanTextFieldOutput)
}

func (i CleanTextFieldArgs) ToCleanTextFieldPtrOutput() CleanTextFieldPtrOutput {
	return i.ToCleanTextFieldPtrOutputWithContext(context.Background())
}

func (i CleanTextFieldArgs) ToCleanTextFieldPtrOutputWithContext(ctx context.Context) CleanTextFieldPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CleanTextFieldOutput).ToCleanTextFieldPtrOutputWithContext(ctx)
}

// CleanTextFieldPtrInput is an input type that accepts CleanTextFieldArgs, CleanTextFieldPtr and CleanTextFieldPtrOutput values.
// You can construct a concrete instance of `CleanTextFieldPtrInput` via:
//
//	        CleanTextFieldArgs{...}
//
//	or:
//
//	        nil
type CleanTextFieldPtrInput interface {
	pulumi.Input

	ToCleanTextFieldPtrOutput() CleanTextFieldPtrOutput
	ToCleanTextFieldPtrOutputWithContext(context.Context) CleanTextFieldPtrOutput
}

type cleanTextFieldPtrType CleanTextFieldArgs

func CleanTextFieldPtr(v *CleanTextFieldArgs) CleanTextFieldPtrInput {
	return (*cleanTextFieldPtrType)(v)
}

func (*cleanTextFieldPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CleanTextField)(nil)).Elem()
}

func (i *cleanTextFieldPtrType) ToCleanTextFieldPtrOutput() CleanTextFieldPtrOutput {
	return i.ToCleanTextFieldPtrOutputWithContext(context.Background())
}

func (i *cleanTextFieldPtrType) ToCleanTextFieldPtrOutputWithContext(ctx context.Context) CleanTextFieldPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CleanTextFieldPtrOutput)
}

// Inspect text and transform sensitive text. Configure using TextConfig. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Date, DateTime, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
type CleanTextFieldOutput struct{ *pulumi.OutputState }

func (CleanTextFieldOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CleanTextField)(nil)).Elem()
}

func (o CleanTextFieldOutput) ToCleanTextFieldOutput() CleanTextFieldOutput {
	return o
}

func (o CleanTextFieldOutput) ToCleanTextFieldOutputWithContext(ctx context.Context) CleanTextFieldOutput {
	return o
}

func (o CleanTextFieldOutput) ToCleanTextFieldPtrOutput() CleanTextFieldPtrOutput {
	return o.ToCleanTextFieldPtrOutputWithContext(context.Background())
}

func (o CleanTextFieldOutput) ToCleanTextFieldPtrOutputWithContext(ctx context.Context) CleanTextFieldPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CleanTextField) *CleanTextField {
		return &v
	}).(CleanTextFieldPtrOutput)
}

type CleanTextFieldPtrOutput struct{ *pulumi.OutputState }

func (CleanTextFieldPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CleanTextField)(nil)).Elem()
}

func (o CleanTextFieldPtrOutput) ToCleanTextFieldPtrOutput() CleanTextFieldPtrOutput {
	return o
}

func (o CleanTextFieldPtrOutput) ToCleanTextFieldPtrOutputWithContext(ctx context.Context) CleanTextFieldPtrOutput {
	return o
}

func (o CleanTextFieldPtrOutput) Elem() CleanTextFieldOutput {
	return o.ApplyT(func(v *CleanTextField) CleanTextField {
		if v != nil {
			return *v
		}
		var ret CleanTextField
		return ret
	}).(CleanTextFieldOutput)
}

// Inspect text and transform sensitive text. Configure using TextConfig. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Date, DateTime, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
type CleanTextFieldResponse struct {
}

// Inspect text and transform sensitive text. Configure using TextConfig. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Date, DateTime, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
type CleanTextFieldResponseOutput struct{ *pulumi.OutputState }

func (CleanTextFieldResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CleanTextFieldResponse)(nil)).Elem()
}

func (o CleanTextFieldResponseOutput) ToCleanTextFieldResponseOutput() CleanTextFieldResponseOutput {
	return o
}

func (o CleanTextFieldResponseOutput) ToCleanTextFieldResponseOutputWithContext(ctx context.Context) CleanTextFieldResponseOutput {
	return o
}

// Inspect text and transform sensitive text. Configurable using TextConfig. Supported [Value Representations] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): AE, LO, LT, PN, SH, ST, UC, UT, DA, DT, AS
type CleanTextTag struct {
}

// CleanTextTagInput is an input type that accepts CleanTextTagArgs and CleanTextTagOutput values.
// You can construct a concrete instance of `CleanTextTagInput` via:
//
//	CleanTextTagArgs{...}
type CleanTextTagInput interface {
	pulumi.Input

	ToCleanTextTagOutput() CleanTextTagOutput
	ToCleanTextTagOutputWithContext(context.Context) CleanTextTagOutput
}

// Inspect text and transform sensitive text. Configurable using TextConfig. Supported [Value Representations] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): AE, LO, LT, PN, SH, ST, UC, UT, DA, DT, AS
type CleanTextTagArgs struct {
}

func (CleanTextTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CleanTextTag)(nil)).Elem()
}

func (i CleanTextTagArgs) ToCleanTextTagOutput() CleanTextTagOutput {
	return i.ToCleanTextTagOutputWithContext(context.Background())
}

func (i CleanTextTagArgs) ToCleanTextTagOutputWithContext(ctx context.Context) CleanTextTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CleanTextTagOutput)
}

func (i CleanTextTagArgs) ToCleanTextTagPtrOutput() CleanTextTagPtrOutput {
	return i.ToCleanTextTagPtrOutputWithContext(context.Background())
}

func (i CleanTextTagArgs) ToCleanTextTagPtrOutputWithContext(ctx context.Context) CleanTextTagPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CleanTextTagOutput).ToCleanTextTagPtrOutputWithContext(ctx)
}

// CleanTextTagPtrInput is an input type that accepts CleanTextTagArgs, CleanTextTagPtr and CleanTextTagPtrOutput values.
// You can construct a concrete instance of `CleanTextTagPtrInput` via:
//
//	        CleanTextTagArgs{...}
//
//	or:
//
//	        nil
type CleanTextTagPtrInput interface {
	pulumi.Input

	ToCleanTextTagPtrOutput() CleanTextTagPtrOutput
	ToCleanTextTagPtrOutputWithContext(context.Context) CleanTextTagPtrOutput
}

type cleanTextTagPtrType CleanTextTagArgs

func CleanTextTagPtr(v *CleanTextTagArgs) CleanTextTagPtrInput {
	return (*cleanTextTagPtrType)(v)
}

func (*cleanTextTagPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CleanTextTag)(nil)).Elem()
}

func (i *cleanTextTagPtrType) ToCleanTextTagPtrOutput() CleanTextTagPtrOutput {
	return i.ToCleanTextTagPtrOutputWithContext(context.Background())
}

func (i *cleanTextTagPtrType) ToCleanTextTagPtrOutputWithContext(ctx context.Context) CleanTextTagPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CleanTextTagPtrOutput)
}

// Inspect text and transform sensitive text. Configurable using TextConfig. Supported [Value Representations] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): AE, LO, LT, PN, SH, ST, UC, UT, DA, DT, AS
type CleanTextTagOutput struct{ *pulumi.OutputState }

func (CleanTextTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CleanTextTag)(nil)).Elem()
}

func (o CleanTextTagOutput) ToCleanTextTagOutput() CleanTextTagOutput {
	return o
}

func (o CleanTextTagOutput) ToCleanTextTagOutputWithContext(ctx context.Context) CleanTextTagOutput {
	return o
}

func (o CleanTextTagOutput) ToCleanTextTagPtrOutput() CleanTextTagPtrOutput {
	return o.ToCleanTextTagPtrOutputWithContext(context.Background())
}

func (o CleanTextTagOutput) ToCleanTextTagPtrOutputWithContext(ctx context.Context) CleanTextTagPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CleanTextTag) *CleanTextTag {
		return &v
	}).(CleanTextTagPtrOutput)
}

type CleanTextTagPtrOutput struct{ *pulumi.OutputState }

func (CleanTextTagPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CleanTextTag)(nil)).Elem()
}

func (o CleanTextTagPtrOutput) ToCleanTextTagPtrOutput() CleanTextTagPtrOutput {
	return o
}

func (o CleanTextTagPtrOutput) ToCleanTextTagPtrOutputWithContext(ctx context.Context) CleanTextTagPtrOutput {
	return o
}

func (o CleanTextTagPtrOutput) Elem() CleanTextTagOutput {
	return o.ApplyT(func(v *CleanTextTag) CleanTextTag {
		if v != nil {
			return *v
		}
		var ret CleanTextTag
		return ret
	}).(CleanTextTagOutput)
}

// Inspect text and transform sensitive text. Configurable using TextConfig. Supported [Value Representations] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): AE, LO, LT, PN, SH, ST, UC, UT, DA, DT, AS
type CleanTextTagResponse struct {
}

// Inspect text and transform sensitive text. Configurable using TextConfig. Supported [Value Representations] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): AE, LO, LT, PN, SH, ST, UC, UT, DA, DT, AS
type CleanTextTagResponseOutput struct{ *pulumi.OutputState }

func (CleanTextTagResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CleanTextTagResponse)(nil)).Elem()
}

func (o CleanTextTagResponseOutput) ToCleanTextTagResponseOutput() CleanTextTagResponseOutput {
	return o
}

func (o CleanTextTagResponseOutput) ToCleanTextTagResponseOutputWithContext(ctx context.Context) CleanTextTagResponseOutput {
	return o
}

// Cloud Healthcare API resource.
type CloudHealthcareSource struct {
	// Full path of a Cloud Healthcare API resource.
	Name *string `pulumi:"name"`
}

// CloudHealthcareSourceInput is an input type that accepts CloudHealthcareSourceArgs and CloudHealthcareSourceOutput values.
// You can construct a concrete instance of `CloudHealthcareSourceInput` via:
//
//	CloudHealthcareSourceArgs{...}
type CloudHealthcareSourceInput interface {
	pulumi.Input

	ToCloudHealthcareSourceOutput() CloudHealthcareSourceOutput
	ToCloudHealthcareSourceOutputWithContext(context.Context) CloudHealthcareSourceOutput
}

// Cloud Healthcare API resource.
type CloudHealthcareSourceArgs struct {
	// Full path of a Cloud Healthcare API resource.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (CloudHealthcareSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudHealthcareSource)(nil)).Elem()
}

func (i CloudHealthcareSourceArgs) ToCloudHealthcareSourceOutput() CloudHealthcareSourceOutput {
	return i.ToCloudHealthcareSourceOutputWithContext(context.Background())
}

func (i CloudHealthcareSourceArgs) ToCloudHealthcareSourceOutputWithContext(ctx context.Context) CloudHealthcareSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudHealthcareSourceOutput)
}

func (i CloudHealthcareSourceArgs) ToCloudHealthcareSourcePtrOutput() CloudHealthcareSourcePtrOutput {
	return i.ToCloudHealthcareSourcePtrOutputWithContext(context.Background())
}

func (i CloudHealthcareSourceArgs) ToCloudHealthcareSourcePtrOutputWithContext(ctx context.Context) CloudHealthcareSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudHealthcareSourceOutput).ToCloudHealthcareSourcePtrOutputWithContext(ctx)
}

// CloudHealthcareSourcePtrInput is an input type that accepts CloudHealthcareSourceArgs, CloudHealthcareSourcePtr and CloudHealthcareSourcePtrOutput values.
// You can construct a concrete instance of `CloudHealthcareSourcePtrInput` via:
//
//	        CloudHealthcareSourceArgs{...}
//
//	or:
//
//	        nil
type CloudHealthcareSourcePtrInput interface {
	pulumi.Input

	ToCloudHealthcareSourcePtrOutput() CloudHealthcareSourcePtrOutput
	ToCloudHealthcareSourcePtrOutputWithContext(context.Context) CloudHealthcareSourcePtrOutput
}

type cloudHealthcareSourcePtrType CloudHealthcareSourceArgs

func CloudHealthcareSourcePtr(v *CloudHealthcareSourceArgs) CloudHealthcareSourcePtrInput {
	return (*cloudHealthcareSourcePtrType)(v)
}

func (*cloudHealthcareSourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CloudHealthcareSource)(nil)).Elem()
}

func (i *cloudHealthcareSourcePtrType) ToCloudHealthcareSourcePtrOutput() CloudHealthcareSourcePtrOutput {
	return i.ToCloudHealthcareSourcePtrOutputWithContext(context.Background())
}

func (i *cloudHealthcareSourcePtrType) ToCloudHealthcareSourcePtrOutputWithContext(ctx context.Context) CloudHealthcareSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudHealthcareSourcePtrOutput)
}

// Cloud Healthcare API resource.
type CloudHealthcareSourceOutput struct{ *pulumi.OutputState }

func (CloudHealthcareSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudHealthcareSource)(nil)).Elem()
}

func (o CloudHealthcareSourceOutput) ToCloudHealthcareSourceOutput() CloudHealthcareSourceOutput {
	return o
}

func (o CloudHealthcareSourceOutput) ToCloudHealthcareSourceOutputWithContext(ctx context.Context) CloudHealthcareSourceOutput {
	return o
}

func (o CloudHealthcareSourceOutput) ToCloudHealthcareSourcePtrOutput() CloudHealthcareSourcePtrOutput {
	return o.ToCloudHealthcareSourcePtrOutputWithContext(context.Background())
}

func (o CloudHealthcareSourceOutput) ToCloudHealthcareSourcePtrOutputWithContext(ctx context.Context) CloudHealthcareSourcePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CloudHealthcareSource) *CloudHealthcareSource {
		return &v
	}).(CloudHealthcareSourcePtrOutput)
}

// Full path of a Cloud Healthcare API resource.
func (o CloudHealthcareSourceOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CloudHealthcareSource) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type CloudHealthcareSourcePtrOutput struct{ *pulumi.OutputState }

func (CloudHealthcareSourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CloudHealthcareSource)(nil)).Elem()
}

func (o CloudHealthcareSourcePtrOutput) ToCloudHealthcareSourcePtrOutput() CloudHealthcareSourcePtrOutput {
	return o
}

func (o CloudHealthcareSourcePtrOutput) ToCloudHealthcareSourcePtrOutputWithContext(ctx context.Context) CloudHealthcareSourcePtrOutput {
	return o
}

func (o CloudHealthcareSourcePtrOutput) Elem() CloudHealthcareSourceOutput {
	return o.ApplyT(func(v *CloudHealthcareSource) CloudHealthcareSource {
		if v != nil {
			return *v
		}
		var ret CloudHealthcareSource
		return ret
	}).(CloudHealthcareSourceOutput)
}

// Full path of a Cloud Healthcare API resource.
func (o CloudHealthcareSourcePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CloudHealthcareSource) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Cloud Healthcare API resource.
type CloudHealthcareSourceResponse struct {
	// Full path of a Cloud Healthcare API resource.
	Name string `pulumi:"name"`
}

// Cloud Healthcare API resource.
type CloudHealthcareSourceResponseOutput struct{ *pulumi.OutputState }

func (CloudHealthcareSourceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudHealthcareSourceResponse)(nil)).Elem()
}

func (o CloudHealthcareSourceResponseOutput) ToCloudHealthcareSourceResponseOutput() CloudHealthcareSourceResponseOutput {
	return o
}

func (o CloudHealthcareSourceResponseOutput) ToCloudHealthcareSourceResponseOutputWithContext(ctx context.Context) CloudHealthcareSourceResponseOutput {
	return o
}

// Full path of a Cloud Healthcare API resource.
func (o CloudHealthcareSourceResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v CloudHealthcareSourceResponse) string { return v.Name }).(pulumi.StringOutput)
}

// Configures whether to enforce consent for the FHIR store and which consent enforcement version is being used.
type ConsentConfig struct {
	// Optional. Specifies how the server logs the consent-aware requests. If not specified, the `AccessDeterminationLogConfig.LogLevel.MINIMUM` option is used.
	AccessDeterminationLogConfig *AccessDeterminationLogConfig `pulumi:"accessDeterminationLogConfig"`
	// Optional. If set to true, when accessing FHIR resources, the consent headers provided using [SMART-on-FHIR](https://cloud.google.com/healthcare/private/docs/how-tos/smart-on-fhir) will be verified against consents given by patients. See the ConsentEnforcementVersion for the supported consent headers.
	AccessEnforced *bool `pulumi:"accessEnforced"`
	// Optional. Different options to configure the behaviour of the server when handling the `X-Consent-Scope` header.
	ConsentHeaderHandling *ConsentHeaderHandling `pulumi:"consentHeaderHandling"`
	// The versioned names of the enforced admin Consent resource(s), in the format `projects/{project_id}/locations/{location}/datasets/{dataset_id}/fhirStores/{fhir_store_id}/fhir/Consent/{resource_id}/_history/{version_id}`. For FHIR stores with `disable_resource_versioning=true`, the format is `projects/{project_id}/locations/{location}/datasets/{dataset_id}/fhirStores/{fhir_store_id}/fhir/Consent/{resource_id}`. This field can only be updated using ApplyAdminConsents.
	EnforcedAdminConsents []string `pulumi:"enforcedAdminConsents"`
	// Specifies which consent enforcement version is being used for this FHIR store. This field can only be set once by either CreateFhirStore or UpdateFhirStore. After that, you must call ApplyConsents to change the version.
	Version ConsentConfigVersion `pulumi:"version"`
}

// ConsentConfigInput is an input type that accepts ConsentConfigArgs and ConsentConfigOutput values.
// You can construct a concrete instance of `ConsentConfigInput` via:
//
//	ConsentConfigArgs{...}
type ConsentConfigInput interface {
	pulumi.Input

	ToConsentConfigOutput() ConsentConfigOutput
	ToConsentConfigOutputWithContext(context.Context) ConsentConfigOutput
}

// Configures whether to enforce consent for the FHIR store and which consent enforcement version is being used.
type ConsentConfigArgs struct {
	// Optional. Specifies how the server logs the consent-aware requests. If not specified, the `AccessDeterminationLogConfig.LogLevel.MINIMUM` option is used.
	AccessDeterminationLogConfig AccessDeterminationLogConfigPtrInput `pulumi:"accessDeterminationLogConfig"`
	// Optional. If set to true, when accessing FHIR resources, the consent headers provided using [SMART-on-FHIR](https://cloud.google.com/healthcare/private/docs/how-tos/smart-on-fhir) will be verified against consents given by patients. See the ConsentEnforcementVersion for the supported consent headers.
	AccessEnforced pulumi.BoolPtrInput `pulumi:"accessEnforced"`
	// Optional. Different options to configure the behaviour of the server when handling the `X-Consent-Scope` header.
	ConsentHeaderHandling ConsentHeaderHandlingPtrInput `pulumi:"consentHeaderHandling"`
	// The versioned names of the enforced admin Consent resource(s), in the format `projects/{project_id}/locations/{location}/datasets/{dataset_id}/fhirStores/{fhir_store_id}/fhir/Consent/{resource_id}/_history/{version_id}`. For FHIR stores with `disable_resource_versioning=true`, the format is `projects/{project_id}/locations/{location}/datasets/{dataset_id}/fhirStores/{fhir_store_id}/fhir/Consent/{resource_id}`. This field can only be updated using ApplyAdminConsents.
	EnforcedAdminConsents pulumi.StringArrayInput `pulumi:"enforcedAdminConsents"`
	// Specifies which consent enforcement version is being used for this FHIR store. This field can only be set once by either CreateFhirStore or UpdateFhirStore. After that, you must call ApplyConsents to change the version.
	Version ConsentConfigVersionInput `pulumi:"version"`
}

func (ConsentConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ConsentConfig)(nil)).Elem()
}

func (i ConsentConfigArgs) ToConsentConfigOutput() ConsentConfigOutput {
	return i.ToConsentConfigOutputWithContext(context.Background())
}

func (i ConsentConfigArgs) ToConsentConfigOutputWithContext(ctx context.Context) ConsentConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConsentConfigOutput)
}

func (i ConsentConfigArgs) ToConsentConfigPtrOutput() ConsentConfigPtrOutput {
	return i.ToConsentConfigPtrOutputWithContext(context.Background())
}

func (i ConsentConfigArgs) ToConsentConfigPtrOutputWithContext(ctx context.Context) ConsentConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConsentConfigOutput).ToConsentConfigPtrOutputWithContext(ctx)
}

// ConsentConfigPtrInput is an input type that accepts ConsentConfigArgs, ConsentConfigPtr and ConsentConfigPtrOutput values.
// You can construct a concrete instance of `ConsentConfigPtrInput` via:
//
//	        ConsentConfigArgs{...}
//
//	or:
//
//	        nil
type ConsentConfigPtrInput interface {
	pulumi.Input

	ToConsentConfigPtrOutput() ConsentConfigPtrOutput
	ToConsentConfigPtrOutputWithContext(context.Context) ConsentConfigPtrOutput
}

type consentConfigPtrType ConsentConfigArgs

func ConsentConfigPtr(v *ConsentConfigArgs) ConsentConfigPtrInput {
	return (*consentConfigPtrType)(v)
}

func (*consentConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ConsentConfig)(nil)).Elem()
}

func (i *consentConfigPtrType) ToConsentConfigPtrOutput() ConsentConfigPtrOutput {
	return i.ToConsentConfigPtrOutputWithContext(context.Background())
}

func (i *consentConfigPtrType) ToConsentConfigPtrOutputWithContext(ctx context.Context) ConsentConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConsentConfigPtrOutput)
}

// Configures whether to enforce consent for the FHIR store and which consent enforcement version is being used.
type ConsentConfigOutput struct{ *pulumi.OutputState }

func (ConsentConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ConsentConfig)(nil)).Elem()
}

func (o ConsentConfigOutput) ToConsentConfigOutput() ConsentConfigOutput {
	return o
}

func (o ConsentConfigOutput) ToConsentConfigOutputWithContext(ctx context.Context) ConsentConfigOutput {
	return o
}

func (o ConsentConfigOutput) ToConsentConfigPtrOutput() ConsentConfigPtrOutput {
	return o.ToConsentConfigPtrOutputWithContext(context.Background())
}

func (o ConsentConfigOutput) ToConsentConfigPtrOutputWithContext(ctx context.Context) ConsentConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ConsentConfig) *ConsentConfig {
		return &v
	}).(ConsentConfigPtrOutput)
}

// Optional. Specifies how the server logs the consent-aware requests. If not specified, the `AccessDeterminationLogConfig.LogLevel.MINIMUM` option is used.
func (o ConsentConfigOutput) AccessDeterminationLogConfig() AccessDeterminationLogConfigPtrOutput {
	return o.ApplyT(func(v ConsentConfig) *AccessDeterminationLogConfig { return v.AccessDeterminationLogConfig }).(AccessDeterminationLogConfigPtrOutput)
}

// Optional. If set to true, when accessing FHIR resources, the consent headers provided using [SMART-on-FHIR](https://cloud.google.com/healthcare/private/docs/how-tos/smart-on-fhir) will be verified against consents given by patients. See the ConsentEnforcementVersion for the supported consent headers.
func (o ConsentConfigOutput) AccessEnforced() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ConsentConfig) *bool { return v.AccessEnforced }).(pulumi.BoolPtrOutput)
}

// Optional. Different options to configure the behaviour of the server when handling the `X-Consent-Scope` header.
func (o ConsentConfigOutput) ConsentHeaderHandling() ConsentHeaderHandlingPtrOutput {
	return o.ApplyT(func(v ConsentConfig) *ConsentHeaderHandling { return v.ConsentHeaderHandling }).(ConsentHeaderHandlingPtrOutput)
}

// The versioned names of the enforced admin Consent resource(s), in the format `projects/{project_id}/locations/{location}/datasets/{dataset_id}/fhirStores/{fhir_store_id}/fhir/Consent/{resource_id}/_history/{version_id}`. For FHIR stores with `disable_resource_versioning=true`, the format is `projects/{project_id}/locations/{location}/datasets/{dataset_id}/fhirStores/{fhir_store_id}/fhir/Consent/{resource_id}`. This field can only be updated using ApplyAdminConsents.
func (o ConsentConfigOutput) EnforcedAdminConsents() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ConsentConfig) []string { return v.EnforcedAdminConsents }).(pulumi.StringArrayOutput)
}

// Specifies which consent enforcement version is being used for this FHIR store. This field can only be set once by either CreateFhirStore or UpdateFhirStore. After that, you must call ApplyConsents to change the version.
func (o ConsentConfigOutput) Version() ConsentConfigVersionOutput {
	return o.ApplyT(func(v ConsentConfig) ConsentConfigVersion { return v.Version }).(ConsentConfigVersionOutput)
}

type ConsentConfigPtrOutput struct{ *pulumi.OutputState }

func (ConsentConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ConsentConfig)(nil)).Elem()
}

func (o ConsentConfigPtrOutput) ToConsentConfigPtrOutput() ConsentConfigPtrOutput {
	return o
}

func (o ConsentConfigPtrOutput) ToConsentConfigPtrOutputWithContext(ctx context.Context) ConsentConfigPtrOutput {
	return o
}

func (o ConsentConfigPtrOutput) Elem() ConsentConfigOutput {
	return o.ApplyT(func(v *ConsentConfig) ConsentConfig {
		if v != nil {
			return *v
		}
		var ret ConsentConfig
		return ret
	}).(ConsentConfigOutput)
}

// Optional. Specifies how the server logs the consent-aware requests. If not specified, the `AccessDeterminationLogConfig.LogLevel.MINIMUM` option is used.
func (o ConsentConfigPtrOutput) AccessDeterminationLogConfig() AccessDeterminationLogConfigPtrOutput {
	return o.ApplyT(func(v *ConsentConfig) *AccessDeterminationLogConfig {
		if v == nil {
			return nil
		}
		return v.AccessDeterminationLogConfig
	}).(AccessDeterminationLogConfigPtrOutput)
}

// Optional. If set to true, when accessing FHIR resources, the consent headers provided using [SMART-on-FHIR](https://cloud.google.com/healthcare/private/docs/how-tos/smart-on-fhir) will be verified against consents given by patients. See the ConsentEnforcementVersion for the supported consent headers.
func (o ConsentConfigPtrOutput) AccessEnforced() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ConsentConfig) *bool {
		if v == nil {
			return nil
		}
		return v.AccessEnforced
	}).(pulumi.BoolPtrOutput)
}

// Optional. Different options to configure the behaviour of the server when handling the `X-Consent-Scope` header.
func (o ConsentConfigPtrOutput) ConsentHeaderHandling() ConsentHeaderHandlingPtrOutput {
	return o.ApplyT(func(v *ConsentConfig) *ConsentHeaderHandling {
		if v == nil {
			return nil
		}
		return v.ConsentHeaderHandling
	}).(ConsentHeaderHandlingPtrOutput)
}

// The versioned names of the enforced admin Consent resource(s), in the format `projects/{project_id}/locations/{location}/datasets/{dataset_id}/fhirStores/{fhir_store_id}/fhir/Consent/{resource_id}/_history/{version_id}`. For FHIR stores with `disable_resource_versioning=true`, the format is `projects/{project_id}/locations/{location}/datasets/{dataset_id}/fhirStores/{fhir_store_id}/fhir/Consent/{resource_id}`. This field can only be updated using ApplyAdminConsents.
func (o ConsentConfigPtrOutput) EnforcedAdminConsents() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ConsentConfig) []string {
		if v == nil {
			return nil
		}
		return v.EnforcedAdminConsents
	}).(pulumi.StringArrayOutput)
}

// Specifies which consent enforcement version is being used for this FHIR store. This field can only be set once by either CreateFhirStore or UpdateFhirStore. After that, you must call ApplyConsents to change the version.
func (o ConsentConfigPtrOutput) Version() ConsentConfigVersionPtrOutput {
	return o.ApplyT(func(v *ConsentConfig) *ConsentConfigVersion {
		if v == nil {
			return nil
		}
		return &v.Version
	}).(ConsentConfigVersionPtrOutput)
}

// Configures whether to enforce consent for the FHIR store and which consent enforcement version is being used.
type ConsentConfigResponse struct {
	// Optional. Specifies how the server logs the consent-aware requests. If not specified, the `AccessDeterminationLogConfig.LogLevel.MINIMUM` option is used.
	AccessDeterminationLogConfig AccessDeterminationLogConfigResponse `pulumi:"accessDeterminationLogConfig"`
	// Optional. If set to true, when accessing FHIR resources, the consent headers provided using [SMART-on-FHIR](https://cloud.google.com/healthcare/private/docs/how-tos/smart-on-fhir) will be verified against consents given by patients. See the ConsentEnforcementVersion for the supported consent headers.
	AccessEnforced bool `pulumi:"accessEnforced"`
	// Optional. Different options to configure the behaviour of the server when handling the `X-Consent-Scope` header.
	ConsentHeaderHandling ConsentHeaderHandlingResponse `pulumi:"consentHeaderHandling"`
	// The versioned names of the enforced admin Consent resource(s), in the format `projects/{project_id}/locations/{location}/datasets/{dataset_id}/fhirStores/{fhir_store_id}/fhir/Consent/{resource_id}/_history/{version_id}`. For FHIR stores with `disable_resource_versioning=true`, the format is `projects/{project_id}/locations/{location}/datasets/{dataset_id}/fhirStores/{fhir_store_id}/fhir/Consent/{resource_id}`. This field can only be updated using ApplyAdminConsents.
	EnforcedAdminConsents []string `pulumi:"enforcedAdminConsents"`
	// Specifies which consent enforcement version is being used for this FHIR store. This field can only be set once by either CreateFhirStore or UpdateFhirStore. After that, you must call ApplyConsents to change the version.
	Version string `pulumi:"version"`
}

// Configures whether to enforce consent for the FHIR store and which consent enforcement version is being used.
type ConsentConfigResponseOutput struct{ *pulumi.OutputState }

func (ConsentConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ConsentConfigResponse)(nil)).Elem()
}

func (o ConsentConfigResponseOutput) ToConsentConfigResponseOutput() ConsentConfigResponseOutput {
	return o
}

func (o ConsentConfigResponseOutput) ToConsentConfigResponseOutputWithContext(ctx context.Context) ConsentConfigResponseOutput {
	return o
}

// Optional. Specifies how the server logs the consent-aware requests. If not specified, the `AccessDeterminationLogConfig.LogLevel.MINIMUM` option is used.
func (o ConsentConfigResponseOutput) AccessDeterminationLogConfig() AccessDeterminationLogConfigResponseOutput {
	return o.ApplyT(func(v ConsentConfigResponse) AccessDeterminationLogConfigResponse {
		return v.AccessDeterminationLogConfig
	}).(AccessDeterminationLogConfigResponseOutput)
}

// Optional. If set to true, when accessing FHIR resources, the consent headers provided using [SMART-on-FHIR](https://cloud.google.com/healthcare/private/docs/how-tos/smart-on-fhir) will be verified against consents given by patients. See the ConsentEnforcementVersion for the supported consent headers.
func (o ConsentConfigResponseOutput) AccessEnforced() pulumi.BoolOutput {
	return o.ApplyT(func(v ConsentConfigResponse) bool { return v.AccessEnforced }).(pulumi.BoolOutput)
}

// Optional. Different options to configure the behaviour of the server when handling the `X-Consent-Scope` header.
func (o ConsentConfigResponseOutput) ConsentHeaderHandling() ConsentHeaderHandlingResponseOutput {
	return o.ApplyT(func(v ConsentConfigResponse) ConsentHeaderHandlingResponse { return v.ConsentHeaderHandling }).(ConsentHeaderHandlingResponseOutput)
}

// The versioned names of the enforced admin Consent resource(s), in the format `projects/{project_id}/locations/{location}/datasets/{dataset_id}/fhirStores/{fhir_store_id}/fhir/Consent/{resource_id}/_history/{version_id}`. For FHIR stores with `disable_resource_versioning=true`, the format is `projects/{project_id}/locations/{location}/datasets/{dataset_id}/fhirStores/{fhir_store_id}/fhir/Consent/{resource_id}`. This field can only be updated using ApplyAdminConsents.
func (o ConsentConfigResponseOutput) EnforcedAdminConsents() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ConsentConfigResponse) []string { return v.EnforcedAdminConsents }).(pulumi.StringArrayOutput)
}

// Specifies which consent enforcement version is being used for this FHIR store. This field can only be set once by either CreateFhirStore or UpdateFhirStore. After that, you must call ApplyConsents to change the version.
func (o ConsentConfigResponseOutput) Version() pulumi.StringOutput {
	return o.ApplyT(func(v ConsentConfigResponse) string { return v.Version }).(pulumi.StringOutput)
}

// How the server handles the consent header.
type ConsentHeaderHandling struct {
	// Optional. Specifies the default server behavior when the header is empty. If not specified, the `ScopeProfile.PERMIT_EMPTY_SCOPE` option is used.
	Profile *ConsentHeaderHandlingProfile `pulumi:"profile"`
}

// ConsentHeaderHandlingInput is an input type that accepts ConsentHeaderHandlingArgs and ConsentHeaderHandlingOutput values.
// You can construct a concrete instance of `ConsentHeaderHandlingInput` via:
//
//	ConsentHeaderHandlingArgs{...}
type ConsentHeaderHandlingInput interface {
	pulumi.Input

	ToConsentHeaderHandlingOutput() ConsentHeaderHandlingOutput
	ToConsentHeaderHandlingOutputWithContext(context.Context) ConsentHeaderHandlingOutput
}

// How the server handles the consent header.
type ConsentHeaderHandlingArgs struct {
	// Optional. Specifies the default server behavior when the header is empty. If not specified, the `ScopeProfile.PERMIT_EMPTY_SCOPE` option is used.
	Profile ConsentHeaderHandlingProfilePtrInput `pulumi:"profile"`
}

func (ConsentHeaderHandlingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ConsentHeaderHandling)(nil)).Elem()
}

func (i ConsentHeaderHandlingArgs) ToConsentHeaderHandlingOutput() ConsentHeaderHandlingOutput {
	return i.ToConsentHeaderHandlingOutputWithContext(context.Background())
}

func (i ConsentHeaderHandlingArgs) ToConsentHeaderHandlingOutputWithContext(ctx context.Context) ConsentHeaderHandlingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConsentHeaderHandlingOutput)
}

func (i ConsentHeaderHandlingArgs) ToConsentHeaderHandlingPtrOutput() ConsentHeaderHandlingPtrOutput {
	return i.ToConsentHeaderHandlingPtrOutputWithContext(context.Background())
}

func (i ConsentHeaderHandlingArgs) ToConsentHeaderHandlingPtrOutputWithContext(ctx context.Context) ConsentHeaderHandlingPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConsentHeaderHandlingOutput).ToConsentHeaderHandlingPtrOutputWithContext(ctx)
}

// ConsentHeaderHandlingPtrInput is an input type that accepts ConsentHeaderHandlingArgs, ConsentHeaderHandlingPtr and ConsentHeaderHandlingPtrOutput values.
// You can construct a concrete instance of `ConsentHeaderHandlingPtrInput` via:
//
//	        ConsentHeaderHandlingArgs{...}
//
//	or:
//
//	        nil
type ConsentHeaderHandlingPtrInput interface {
	pulumi.Input

	ToConsentHeaderHandlingPtrOutput() ConsentHeaderHandlingPtrOutput
	ToConsentHeaderHandlingPtrOutputWithContext(context.Context) ConsentHeaderHandlingPtrOutput
}

type consentHeaderHandlingPtrType ConsentHeaderHandlingArgs

func ConsentHeaderHandlingPtr(v *ConsentHeaderHandlingArgs) ConsentHeaderHandlingPtrInput {
	return (*consentHeaderHandlingPtrType)(v)
}

func (*consentHeaderHandlingPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ConsentHeaderHandling)(nil)).Elem()
}

func (i *consentHeaderHandlingPtrType) ToConsentHeaderHandlingPtrOutput() ConsentHeaderHandlingPtrOutput {
	return i.ToConsentHeaderHandlingPtrOutputWithContext(context.Background())
}

func (i *consentHeaderHandlingPtrType) ToConsentHeaderHandlingPtrOutputWithContext(ctx context.Context) ConsentHeaderHandlingPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConsentHeaderHandlingPtrOutput)
}

// How the server handles the consent header.
type ConsentHeaderHandlingOutput struct{ *pulumi.OutputState }

func (ConsentHeaderHandlingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ConsentHeaderHandling)(nil)).Elem()
}

func (o ConsentHeaderHandlingOutput) ToConsentHeaderHandlingOutput() ConsentHeaderHandlingOutput {
	return o
}

func (o ConsentHeaderHandlingOutput) ToConsentHeaderHandlingOutputWithContext(ctx context.Context) ConsentHeaderHandlingOutput {
	return o
}

func (o ConsentHeaderHandlingOutput) ToConsentHeaderHandlingPtrOutput() ConsentHeaderHandlingPtrOutput {
	return o.ToConsentHeaderHandlingPtrOutputWithContext(context.Background())
}

func (o ConsentHeaderHandlingOutput) ToConsentHeaderHandlingPtrOutputWithContext(ctx context.Context) ConsentHeaderHandlingPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ConsentHeaderHandling) *ConsentHeaderHandling {
		return &v
	}).(ConsentHeaderHandlingPtrOutput)
}

// Optional. Specifies the default server behavior when the header is empty. If not specified, the `ScopeProfile.PERMIT_EMPTY_SCOPE` option is used.
func (o ConsentHeaderHandlingOutput) Profile() ConsentHeaderHandlingProfilePtrOutput {
	return o.ApplyT(func(v ConsentHeaderHandling) *ConsentHeaderHandlingProfile { return v.Profile }).(ConsentHeaderHandlingProfilePtrOutput)
}

type ConsentHeaderHandlingPtrOutput struct{ *pulumi.OutputState }

func (ConsentHeaderHandlingPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ConsentHeaderHandling)(nil)).Elem()
}

func (o ConsentHeaderHandlingPtrOutput) ToConsentHeaderHandlingPtrOutput() ConsentHeaderHandlingPtrOutput {
	return o
}

func (o ConsentHeaderHandlingPtrOutput) ToConsentHeaderHandlingPtrOutputWithContext(ctx context.Context) ConsentHeaderHandlingPtrOutput {
	return o
}

func (o ConsentHeaderHandlingPtrOutput) Elem() ConsentHeaderHandlingOutput {
	return o.ApplyT(func(v *ConsentHeaderHandling) ConsentHeaderHandling {
		if v != nil {
			return *v
		}
		var ret ConsentHeaderHandling
		return ret
	}).(ConsentHeaderHandlingOutput)
}

// Optional. Specifies the default server behavior when the header is empty. If not specified, the `ScopeProfile.PERMIT_EMPTY_SCOPE` option is used.
func (o ConsentHeaderHandlingPtrOutput) Profile() ConsentHeaderHandlingProfilePtrOutput {
	return o.ApplyT(func(v *ConsentHeaderHandling) *ConsentHeaderHandlingProfile {
		if v == nil {
			return nil
		}
		return v.Profile
	}).(ConsentHeaderHandlingProfilePtrOutput)
}

// How the server handles the consent header.
type ConsentHeaderHandlingResponse struct {
	// Optional. Specifies the default server behavior when the header is empty. If not specified, the `ScopeProfile.PERMIT_EMPTY_SCOPE` option is used.
	Profile string `pulumi:"profile"`
}

// How the server handles the consent header.
type ConsentHeaderHandlingResponseOutput struct{ *pulumi.OutputState }

func (ConsentHeaderHandlingResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ConsentHeaderHandlingResponse)(nil)).Elem()
}

func (o ConsentHeaderHandlingResponseOutput) ToConsentHeaderHandlingResponseOutput() ConsentHeaderHandlingResponseOutput {
	return o
}

func (o ConsentHeaderHandlingResponseOutput) ToConsentHeaderHandlingResponseOutputWithContext(ctx context.Context) ConsentHeaderHandlingResponseOutput {
	return o
}

// Optional. Specifies the default server behavior when the header is empty. If not specified, the `ScopeProfile.PERMIT_EMPTY_SCOPE` option is used.
func (o ConsentHeaderHandlingResponseOutput) Profile() pulumi.StringOutput {
	return o.ApplyT(func(v ConsentHeaderHandlingResponse) string { return v.Profile }).(pulumi.StringOutput)
}

// Fields that don't match a KeepField or CleanTextField `action` in the BASIC profile are collected into a contextual phrase list. For fields that match a CleanTextField `action` in FieldMetadata or ProfileType, the process attempts to transform phrases matching these contextual entries. These contextual phrases are replaced with the token "[CTX]". This feature uses an additional InfoType during inspection.
type ContextualDeidConfig struct {
}

// ContextualDeidConfigInput is an input type that accepts ContextualDeidConfigArgs and ContextualDeidConfigOutput values.
// You can construct a concrete instance of `ContextualDeidConfigInput` via:
//
//	ContextualDeidConfigArgs{...}
type ContextualDeidConfigInput interface {
	pulumi.Input

	ToContextualDeidConfigOutput() ContextualDeidConfigOutput
	ToContextualDeidConfigOutputWithContext(context.Context) ContextualDeidConfigOutput
}

// Fields that don't match a KeepField or CleanTextField `action` in the BASIC profile are collected into a contextual phrase list. For fields that match a CleanTextField `action` in FieldMetadata or ProfileType, the process attempts to transform phrases matching these contextual entries. These contextual phrases are replaced with the token "[CTX]". This feature uses an additional InfoType during inspection.
type ContextualDeidConfigArgs struct {
}

func (ContextualDeidConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContextualDeidConfig)(nil)).Elem()
}

func (i ContextualDeidConfigArgs) ToContextualDeidConfigOutput() ContextualDeidConfigOutput {
	return i.ToContextualDeidConfigOutputWithContext(context.Background())
}

func (i ContextualDeidConfigArgs) ToContextualDeidConfigOutputWithContext(ctx context.Context) ContextualDeidConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContextualDeidConfigOutput)
}

func (i ContextualDeidConfigArgs) ToContextualDeidConfigPtrOutput() ContextualDeidConfigPtrOutput {
	return i.ToContextualDeidConfigPtrOutputWithContext(context.Background())
}

func (i ContextualDeidConfigArgs) ToContextualDeidConfigPtrOutputWithContext(ctx context.Context) ContextualDeidConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContextualDeidConfigOutput).ToContextualDeidConfigPtrOutputWithContext(ctx)
}

// ContextualDeidConfigPtrInput is an input type that accepts ContextualDeidConfigArgs, ContextualDeidConfigPtr and ContextualDeidConfigPtrOutput values.
// You can construct a concrete instance of `ContextualDeidConfigPtrInput` via:
//
//	        ContextualDeidConfigArgs{...}
//
//	or:
//
//	        nil
type ContextualDeidConfigPtrInput interface {
	pulumi.Input

	ToContextualDeidConfigPtrOutput() ContextualDeidConfigPtrOutput
	ToContextualDeidConfigPtrOutputWithContext(context.Context) ContextualDeidConfigPtrOutput
}

type contextualDeidConfigPtrType ContextualDeidConfigArgs

func ContextualDeidConfigPtr(v *ContextualDeidConfigArgs) ContextualDeidConfigPtrInput {
	return (*contextualDeidConfigPtrType)(v)
}

func (*contextualDeidConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ContextualDeidConfig)(nil)).Elem()
}

func (i *contextualDeidConfigPtrType) ToContextualDeidConfigPtrOutput() ContextualDeidConfigPtrOutput {
	return i.ToContextualDeidConfigPtrOutputWithContext(context.Background())
}

func (i *contextualDeidConfigPtrType) ToContextualDeidConfigPtrOutputWithContext(ctx context.Context) ContextualDeidConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContextualDeidConfigPtrOutput)
}

// Fields that don't match a KeepField or CleanTextField `action` in the BASIC profile are collected into a contextual phrase list. For fields that match a CleanTextField `action` in FieldMetadata or ProfileType, the process attempts to transform phrases matching these contextual entries. These contextual phrases are replaced with the token "[CTX]". This feature uses an additional InfoType during inspection.
type ContextualDeidConfigOutput struct{ *pulumi.OutputState }

func (ContextualDeidConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContextualDeidConfig)(nil)).Elem()
}

func (o ContextualDeidConfigOutput) ToContextualDeidConfigOutput() ContextualDeidConfigOutput {
	return o
}

func (o ContextualDeidConfigOutput) ToContextualDeidConfigOutputWithContext(ctx context.Context) ContextualDeidConfigOutput {
	return o
}

func (o ContextualDeidConfigOutput) ToContextualDeidConfigPtrOutput() ContextualDeidConfigPtrOutput {
	return o.ToContextualDeidConfigPtrOutputWithContext(context.Background())
}

func (o ContextualDeidConfigOutput) ToContextualDeidConfigPtrOutputWithContext(ctx context.Context) ContextualDeidConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ContextualDeidConfig) *ContextualDeidConfig {
		return &v
	}).(ContextualDeidConfigPtrOutput)
}

type ContextualDeidConfigPtrOutput struct{ *pulumi.OutputState }

func (ContextualDeidConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ContextualDeidConfig)(nil)).Elem()
}

func (o ContextualDeidConfigPtrOutput) ToContextualDeidConfigPtrOutput() ContextualDeidConfigPtrOutput {
	return o
}

func (o ContextualDeidConfigPtrOutput) ToContextualDeidConfigPtrOutputWithContext(ctx context.Context) ContextualDeidConfigPtrOutput {
	return o
}

func (o ContextualDeidConfigPtrOutput) Elem() ContextualDeidConfigOutput {
	return o.ApplyT(func(v *ContextualDeidConfig) ContextualDeidConfig {
		if v != nil {
			return *v
		}
		var ret ContextualDeidConfig
		return ret
	}).(ContextualDeidConfigOutput)
}

// Fields that don't match a KeepField or CleanTextField `action` in the BASIC profile are collected into a contextual phrase list. For fields that match a CleanTextField `action` in FieldMetadata or ProfileType, the process attempts to transform phrases matching these contextual entries. These contextual phrases are replaced with the token "[CTX]". This feature uses an additional InfoType during inspection.
type ContextualDeidConfigResponse struct {
}

// Fields that don't match a KeepField or CleanTextField `action` in the BASIC profile are collected into a contextual phrase list. For fields that match a CleanTextField `action` in FieldMetadata or ProfileType, the process attempts to transform phrases matching these contextual entries. These contextual phrases are replaced with the token "[CTX]". This feature uses an additional InfoType during inspection.
type ContextualDeidConfigResponseOutput struct{ *pulumi.OutputState }

func (ContextualDeidConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContextualDeidConfigResponse)(nil)).Elem()
}

func (o ContextualDeidConfigResponseOutput) ToContextualDeidConfigResponseOutput() ContextualDeidConfigResponseOutput {
	return o
}

func (o ContextualDeidConfigResponseOutput) ToContextualDeidConfigResponseOutputWithContext(ctx context.Context) ContextualDeidConfigResponseOutput {
	return o
}

// Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. Outputs a base64-encoded representation of the hashed output. For example, `L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=`.
type CryptoHashConfig struct {
	// An AES 128/192/256 bit key. Causes the hash to be computed based on this key. A default key is generated for each Deidentify operation and is used when neither crypto_key nor kms_wrapped is specified. Must not be set if kms_wrapped is set.
	CryptoKey *string `pulumi:"cryptoKey"`
	// KMS wrapped key. Must not be set if crypto_key is set.
	KmsWrapped *KmsWrappedCryptoKey `pulumi:"kmsWrapped"`
}

// CryptoHashConfigInput is an input type that accepts CryptoHashConfigArgs and CryptoHashConfigOutput values.
// You can construct a concrete instance of `CryptoHashConfigInput` via:
//
//	CryptoHashConfigArgs{...}
type CryptoHashConfigInput interface {
	pulumi.Input

	ToCryptoHashConfigOutput() CryptoHashConfigOutput
	ToCryptoHashConfigOutputWithContext(context.Context) CryptoHashConfigOutput
}

// Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. Outputs a base64-encoded representation of the hashed output. For example, `L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=`.
type CryptoHashConfigArgs struct {
	// An AES 128/192/256 bit key. Causes the hash to be computed based on this key. A default key is generated for each Deidentify operation and is used when neither crypto_key nor kms_wrapped is specified. Must not be set if kms_wrapped is set.
	CryptoKey pulumi.StringPtrInput `pulumi:"cryptoKey"`
	// KMS wrapped key. Must not be set if crypto_key is set.
	KmsWrapped KmsWrappedCryptoKeyPtrInput `pulumi:"kmsWrapped"`
}

func (CryptoHashConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CryptoHashConfig)(nil)).Elem()
}

func (i CryptoHashConfigArgs) ToCryptoHashConfigOutput() CryptoHashConfigOutput {
	return i.ToCryptoHashConfigOutputWithContext(context.Background())
}

func (i CryptoHashConfigArgs) ToCryptoHashConfigOutputWithContext(ctx context.Context) CryptoHashConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CryptoHashConfigOutput)
}

func (i CryptoHashConfigArgs) ToCryptoHashConfigPtrOutput() CryptoHashConfigPtrOutput {
	return i.ToCryptoHashConfigPtrOutputWithContext(context.Background())
}

func (i CryptoHashConfigArgs) ToCryptoHashConfigPtrOutputWithContext(ctx context.Context) CryptoHashConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CryptoHashConfigOutput).ToCryptoHashConfigPtrOutputWithContext(ctx)
}

// CryptoHashConfigPtrInput is an input type that accepts CryptoHashConfigArgs, CryptoHashConfigPtr and CryptoHashConfigPtrOutput values.
// You can construct a concrete instance of `CryptoHashConfigPtrInput` via:
//
//	        CryptoHashConfigArgs{...}
//
//	or:
//
//	        nil
type CryptoHashConfigPtrInput interface {
	pulumi.Input

	ToCryptoHashConfigPtrOutput() CryptoHashConfigPtrOutput
	ToCryptoHashConfigPtrOutputWithContext(context.Context) CryptoHashConfigPtrOutput
}

type cryptoHashConfigPtrType CryptoHashConfigArgs

func CryptoHashConfigPtr(v *CryptoHashConfigArgs) CryptoHashConfigPtrInput {
	return (*cryptoHashConfigPtrType)(v)
}

func (*cryptoHashConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CryptoHashConfig)(nil)).Elem()
}

func (i *cryptoHashConfigPtrType) ToCryptoHashConfigPtrOutput() CryptoHashConfigPtrOutput {
	return i.ToCryptoHashConfigPtrOutputWithContext(context.Background())
}

func (i *cryptoHashConfigPtrType) ToCryptoHashConfigPtrOutputWithContext(ctx context.Context) CryptoHashConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CryptoHashConfigPtrOutput)
}

// Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. Outputs a base64-encoded representation of the hashed output. For example, `L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=`.
type CryptoHashConfigOutput struct{ *pulumi.OutputState }

func (CryptoHashConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CryptoHashConfig)(nil)).Elem()
}

func (o CryptoHashConfigOutput) ToCryptoHashConfigOutput() CryptoHashConfigOutput {
	return o
}

func (o CryptoHashConfigOutput) ToCryptoHashConfigOutputWithContext(ctx context.Context) CryptoHashConfigOutput {
	return o
}

func (o CryptoHashConfigOutput) ToCryptoHashConfigPtrOutput() CryptoHashConfigPtrOutput {
	return o.ToCryptoHashConfigPtrOutputWithContext(context.Background())
}

func (o CryptoHashConfigOutput) ToCryptoHashConfigPtrOutputWithContext(ctx context.Context) CryptoHashConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CryptoHashConfig) *CryptoHashConfig {
		return &v
	}).(CryptoHashConfigPtrOutput)
}

// An AES 128/192/256 bit key. Causes the hash to be computed based on this key. A default key is generated for each Deidentify operation and is used when neither crypto_key nor kms_wrapped is specified. Must not be set if kms_wrapped is set.
func (o CryptoHashConfigOutput) CryptoKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CryptoHashConfig) *string { return v.CryptoKey }).(pulumi.StringPtrOutput)
}

// KMS wrapped key. Must not be set if crypto_key is set.
func (o CryptoHashConfigOutput) KmsWrapped() KmsWrappedCryptoKeyPtrOutput {
	return o.ApplyT(func(v CryptoHashConfig) *KmsWrappedCryptoKey { return v.KmsWrapped }).(KmsWrappedCryptoKeyPtrOutput)
}

type CryptoHashConfigPtrOutput struct{ *pulumi.OutputState }

func (CryptoHashConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CryptoHashConfig)(nil)).Elem()
}

func (o CryptoHashConfigPtrOutput) ToCryptoHashConfigPtrOutput() CryptoHashConfigPtrOutput {
	return o
}

func (o CryptoHashConfigPtrOutput) ToCryptoHashConfigPtrOutputWithContext(ctx context.Context) CryptoHashConfigPtrOutput {
	return o
}

func (o CryptoHashConfigPtrOutput) Elem() CryptoHashConfigOutput {
	return o.ApplyT(func(v *CryptoHashConfig) CryptoHashConfig {
		if v != nil {
			return *v
		}
		var ret CryptoHashConfig
		return ret
	}).(CryptoHashConfigOutput)
}

// An AES 128/192/256 bit key. Causes the hash to be computed based on this key. A default key is generated for each Deidentify operation and is used when neither crypto_key nor kms_wrapped is specified. Must not be set if kms_wrapped is set.
func (o CryptoHashConfigPtrOutput) CryptoKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CryptoHashConfig) *string {
		if v == nil {
			return nil
		}
		return v.CryptoKey
	}).(pulumi.StringPtrOutput)
}

// KMS wrapped key. Must not be set if crypto_key is set.
func (o CryptoHashConfigPtrOutput) KmsWrapped() KmsWrappedCryptoKeyPtrOutput {
	return o.ApplyT(func(v *CryptoHashConfig) *KmsWrappedCryptoKey {
		if v == nil {
			return nil
		}
		return v.KmsWrapped
	}).(KmsWrappedCryptoKeyPtrOutput)
}

// Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. Outputs a base64-encoded representation of the hashed output. For example, `L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=`.
type CryptoHashConfigResponse struct {
	// An AES 128/192/256 bit key. Causes the hash to be computed based on this key. A default key is generated for each Deidentify operation and is used when neither crypto_key nor kms_wrapped is specified. Must not be set if kms_wrapped is set.
	CryptoKey string `pulumi:"cryptoKey"`
	// KMS wrapped key. Must not be set if crypto_key is set.
	KmsWrapped KmsWrappedCryptoKeyResponse `pulumi:"kmsWrapped"`
}

// Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. Outputs a base64-encoded representation of the hashed output. For example, `L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=`.
type CryptoHashConfigResponseOutput struct{ *pulumi.OutputState }

func (CryptoHashConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CryptoHashConfigResponse)(nil)).Elem()
}

func (o CryptoHashConfigResponseOutput) ToCryptoHashConfigResponseOutput() CryptoHashConfigResponseOutput {
	return o
}

func (o CryptoHashConfigResponseOutput) ToCryptoHashConfigResponseOutputWithContext(ctx context.Context) CryptoHashConfigResponseOutput {
	return o
}

// An AES 128/192/256 bit key. Causes the hash to be computed based on this key. A default key is generated for each Deidentify operation and is used when neither crypto_key nor kms_wrapped is specified. Must not be set if kms_wrapped is set.
func (o CryptoHashConfigResponseOutput) CryptoKey() pulumi.StringOutput {
	return o.ApplyT(func(v CryptoHashConfigResponse) string { return v.CryptoKey }).(pulumi.StringOutput)
}

// KMS wrapped key. Must not be set if crypto_key is set.
func (o CryptoHashConfigResponseOutput) KmsWrapped() KmsWrappedCryptoKeyResponseOutput {
	return o.ApplyT(func(v CryptoHashConfigResponse) KmsWrappedCryptoKeyResponse { return v.KmsWrapped }).(KmsWrappedCryptoKeyResponseOutput)
}

// Replace field value with a hash of that value. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
type CryptoHashField struct {
}

// CryptoHashFieldInput is an input type that accepts CryptoHashFieldArgs and CryptoHashFieldOutput values.
// You can construct a concrete instance of `CryptoHashFieldInput` via:
//
//	CryptoHashFieldArgs{...}
type CryptoHashFieldInput interface {
	pulumi.Input

	ToCryptoHashFieldOutput() CryptoHashFieldOutput
	ToCryptoHashFieldOutputWithContext(context.Context) CryptoHashFieldOutput
}

// Replace field value with a hash of that value. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
type CryptoHashFieldArgs struct {
}

func (CryptoHashFieldArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CryptoHashField)(nil)).Elem()
}

func (i CryptoHashFieldArgs) ToCryptoHashFieldOutput() CryptoHashFieldOutput {
	return i.ToCryptoHashFieldOutputWithContext(context.Background())
}

func (i CryptoHashFieldArgs) ToCryptoHashFieldOutputWithContext(ctx context.Context) CryptoHashFieldOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CryptoHashFieldOutput)
}

func (i CryptoHashFieldArgs) ToCryptoHashFieldPtrOutput() CryptoHashFieldPtrOutput {
	return i.ToCryptoHashFieldPtrOutputWithContext(context.Background())
}

func (i CryptoHashFieldArgs) ToCryptoHashFieldPtrOutputWithContext(ctx context.Context) CryptoHashFieldPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CryptoHashFieldOutput).ToCryptoHashFieldPtrOutputWithContext(ctx)
}

// CryptoHashFieldPtrInput is an input type that accepts CryptoHashFieldArgs, CryptoHashFieldPtr and CryptoHashFieldPtrOutput values.
// You can construct a concrete instance of `CryptoHashFieldPtrInput` via:
//
//	        CryptoHashFieldArgs{...}
//
//	or:
//
//	        nil
type CryptoHashFieldPtrInput interface {
	pulumi.Input

	ToCryptoHashFieldPtrOutput() CryptoHashFieldPtrOutput
	ToCryptoHashFieldPtrOutputWithContext(context.Context) CryptoHashFieldPtrOutput
}

type cryptoHashFieldPtrType CryptoHashFieldArgs

func CryptoHashFieldPtr(v *CryptoHashFieldArgs) CryptoHashFieldPtrInput {
	return (*cryptoHashFieldPtrType)(v)
}

func (*cryptoHashFieldPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CryptoHashField)(nil)).Elem()
}

func (i *cryptoHashFieldPtrType) ToCryptoHashFieldPtrOutput() CryptoHashFieldPtrOutput {
	return i.ToCryptoHashFieldPtrOutputWithContext(context.Background())
}

func (i *cryptoHashFieldPtrType) ToCryptoHashFieldPtrOutputWithContext(ctx context.Context) CryptoHashFieldPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CryptoHashFieldPtrOutput)
}

// Replace field value with a hash of that value. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
type CryptoHashFieldOutput struct{ *pulumi.OutputState }

func (CryptoHashFieldOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CryptoHashField)(nil)).Elem()
}

func (o CryptoHashFieldOutput) ToCryptoHashFieldOutput() CryptoHashFieldOutput {
	return o
}

func (o CryptoHashFieldOutput) ToCryptoHashFieldOutputWithContext(ctx context.Context) CryptoHashFieldOutput {
	return o
}

func (o CryptoHashFieldOutput) ToCryptoHashFieldPtrOutput() CryptoHashFieldPtrOutput {
	return o.ToCryptoHashFieldPtrOutputWithContext(context.Background())
}

func (o CryptoHashFieldOutput) ToCryptoHashFieldPtrOutputWithContext(ctx context.Context) CryptoHashFieldPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CryptoHashField) *CryptoHashField {
		return &v
	}).(CryptoHashFieldPtrOutput)
}

type CryptoHashFieldPtrOutput struct{ *pulumi.OutputState }

func (CryptoHashFieldPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CryptoHashField)(nil)).Elem()
}

func (o CryptoHashFieldPtrOutput) ToCryptoHashFieldPtrOutput() CryptoHashFieldPtrOutput {
	return o
}

func (o CryptoHashFieldPtrOutput) ToCryptoHashFieldPtrOutputWithContext(ctx context.Context) CryptoHashFieldPtrOutput {
	return o
}

func (o CryptoHashFieldPtrOutput) Elem() CryptoHashFieldOutput {
	return o.ApplyT(func(v *CryptoHashField) CryptoHashField {
		if v != nil {
			return *v
		}
		var ret CryptoHashField
		return ret
	}).(CryptoHashFieldOutput)
}

// Replace field value with a hash of that value. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
type CryptoHashFieldResponse struct {
}

// Replace field value with a hash of that value. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
type CryptoHashFieldResponseOutput struct{ *pulumi.OutputState }

func (CryptoHashFieldResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CryptoHashFieldResponse)(nil)).Elem()
}

func (o CryptoHashFieldResponseOutput) ToCryptoHashFieldResponseOutput() CryptoHashFieldResponseOutput {
	return o
}

func (o CryptoHashFieldResponseOutput) ToCryptoHashFieldResponseOutputWithContext(ctx context.Context) CryptoHashFieldResponseOutput {
	return o
}

// Shift a date forward or backward in time by a random amount which is consistent for a given patient and crypto key combination.
type DateShiftConfig struct {
	// An AES 128/192/256 bit key. The date shift is computed based on this key and the patient ID. If the patient ID is empty for a DICOM resource, the date shift is computed based on this key and the study instance UID. If crypto_key is not set, then kms_wrapped is used to calculate the date shift. If neither is set, a default key is generated for each de-identify operation. Must not be set if kms_wrapped is set.
	CryptoKey *string `pulumi:"cryptoKey"`
	// KMS wrapped key. If kms_wrapped is not set, then crypto_key is used to calculate the date shift. If neither is set, a default key is generated for each de-identify operation. Must not be set if crypto_key is set.
	KmsWrapped *KmsWrappedCryptoKey `pulumi:"kmsWrapped"`
}

// DateShiftConfigInput is an input type that accepts DateShiftConfigArgs and DateShiftConfigOutput values.
// You can construct a concrete instance of `DateShiftConfigInput` via:
//
//	DateShiftConfigArgs{...}
type DateShiftConfigInput interface {
	pulumi.Input

	ToDateShiftConfigOutput() DateShiftConfigOutput
	ToDateShiftConfigOutputWithContext(context.Context) DateShiftConfigOutput
}

// Shift a date forward or backward in time by a random amount which is consistent for a given patient and crypto key combination.
type DateShiftConfigArgs struct {
	// An AES 128/192/256 bit key. The date shift is computed based on this key and the patient ID. If the patient ID is empty for a DICOM resource, the date shift is computed based on this key and the study instance UID. If crypto_key is not set, then kms_wrapped is used to calculate the date shift. If neither is set, a default key is generated for each de-identify operation. Must not be set if kms_wrapped is set.
	CryptoKey pulumi.StringPtrInput `pulumi:"cryptoKey"`
	// KMS wrapped key. If kms_wrapped is not set, then crypto_key is used to calculate the date shift. If neither is set, a default key is generated for each de-identify operation. Must not be set if crypto_key is set.
	KmsWrapped KmsWrappedCryptoKeyPtrInput `pulumi:"kmsWrapped"`
}

func (DateShiftConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DateShiftConfig)(nil)).Elem()
}

func (i DateShiftConfigArgs) ToDateShiftConfigOutput() DateShiftConfigOutput {
	return i.ToDateShiftConfigOutputWithContext(context.Background())
}

func (i DateShiftConfigArgs) ToDateShiftConfigOutputWithContext(ctx context.Context) DateShiftConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DateShiftConfigOutput)
}

func (i DateShiftConfigArgs) ToDateShiftConfigPtrOutput() DateShiftConfigPtrOutput {
	return i.ToDateShiftConfigPtrOutputWithContext(context.Background())
}

func (i DateShiftConfigArgs) ToDateShiftConfigPtrOutputWithContext(ctx context.Context) DateShiftConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DateShiftConfigOutput).ToDateShiftConfigPtrOutputWithContext(ctx)
}

// DateShiftConfigPtrInput is an input type that accepts DateShiftConfigArgs, DateShiftConfigPtr and DateShiftConfigPtrOutput values.
// You can construct a concrete instance of `DateShiftConfigPtrInput` via:
//
//	        DateShiftConfigArgs{...}
//
//	or:
//
//	        nil
type DateShiftConfigPtrInput interface {
	pulumi.Input

	ToDateShiftConfigPtrOutput() DateShiftConfigPtrOutput
	ToDateShiftConfigPtrOutputWithContext(context.Context) DateShiftConfigPtrOutput
}

type dateShiftConfigPtrType DateShiftConfigArgs

func DateShiftConfigPtr(v *DateShiftConfigArgs) DateShiftConfigPtrInput {
	return (*dateShiftConfigPtrType)(v)
}

func (*dateShiftConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DateShiftConfig)(nil)).Elem()
}

func (i *dateShiftConfigPtrType) ToDateShiftConfigPtrOutput() DateShiftConfigPtrOutput {
	return i.ToDateShiftConfigPtrOutputWithContext(context.Background())
}

func (i *dateShiftConfigPtrType) ToDateShiftConfigPtrOutputWithContext(ctx context.Context) DateShiftConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DateShiftConfigPtrOutput)
}

// Shift a date forward or backward in time by a random amount which is consistent for a given patient and crypto key combination.
type DateShiftConfigOutput struct{ *pulumi.OutputState }

func (DateShiftConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DateShiftConfig)(nil)).Elem()
}

func (o DateShiftConfigOutput) ToDateShiftConfigOutput() DateShiftConfigOutput {
	return o
}

func (o DateShiftConfigOutput) ToDateShiftConfigOutputWithContext(ctx context.Context) DateShiftConfigOutput {
	return o
}

func (o DateShiftConfigOutput) ToDateShiftConfigPtrOutput() DateShiftConfigPtrOutput {
	return o.ToDateShiftConfigPtrOutputWithContext(context.Background())
}

func (o DateShiftConfigOutput) ToDateShiftConfigPtrOutputWithContext(ctx context.Context) DateShiftConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DateShiftConfig) *DateShiftConfig {
		return &v
	}).(DateShiftConfigPtrOutput)
}

// An AES 128/192/256 bit key. The date shift is computed based on this key and the patient ID. If the patient ID is empty for a DICOM resource, the date shift is computed based on this key and the study instance UID. If crypto_key is not set, then kms_wrapped is used to calculate the date shift. If neither is set, a default key is generated for each de-identify operation. Must not be set if kms_wrapped is set.
func (o DateShiftConfigOutput) CryptoKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DateShiftConfig) *string { return v.CryptoKey }).(pulumi.StringPtrOutput)
}

// KMS wrapped key. If kms_wrapped is not set, then crypto_key is used to calculate the date shift. If neither is set, a default key is generated for each de-identify operation. Must not be set if crypto_key is set.
func (o DateShiftConfigOutput) KmsWrapped() KmsWrappedCryptoKeyPtrOutput {
	return o.ApplyT(func(v DateShiftConfig) *KmsWrappedCryptoKey { return v.KmsWrapped }).(KmsWrappedCryptoKeyPtrOutput)
}

type DateShiftConfigPtrOutput struct{ *pulumi.OutputState }

func (DateShiftConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DateShiftConfig)(nil)).Elem()
}

func (o DateShiftConfigPtrOutput) ToDateShiftConfigPtrOutput() DateShiftConfigPtrOutput {
	return o
}

func (o DateShiftConfigPtrOutput) ToDateShiftConfigPtrOutputWithContext(ctx context.Context) DateShiftConfigPtrOutput {
	return o
}

func (o DateShiftConfigPtrOutput) Elem() DateShiftConfigOutput {
	return o.ApplyT(func(v *DateShiftConfig) DateShiftConfig {
		if v != nil {
			return *v
		}
		var ret DateShiftConfig
		return ret
	}).(DateShiftConfigOutput)
}

// An AES 128/192/256 bit key. The date shift is computed based on this key and the patient ID. If the patient ID is empty for a DICOM resource, the date shift is computed based on this key and the study instance UID. If crypto_key is not set, then kms_wrapped is used to calculate the date shift. If neither is set, a default key is generated for each de-identify operation. Must not be set if kms_wrapped is set.
func (o DateShiftConfigPtrOutput) CryptoKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DateShiftConfig) *string {
		if v == nil {
			return nil
		}
		return v.CryptoKey
	}).(pulumi.StringPtrOutput)
}

// KMS wrapped key. If kms_wrapped is not set, then crypto_key is used to calculate the date shift. If neither is set, a default key is generated for each de-identify operation. Must not be set if crypto_key is set.
func (o DateShiftConfigPtrOutput) KmsWrapped() KmsWrappedCryptoKeyPtrOutput {
	return o.ApplyT(func(v *DateShiftConfig) *KmsWrappedCryptoKey {
		if v == nil {
			return nil
		}
		return v.KmsWrapped
	}).(KmsWrappedCryptoKeyPtrOutput)
}

// Shift a date forward or backward in time by a random amount which is consistent for a given patient and crypto key combination.
type DateShiftConfigResponse struct {
	// An AES 128/192/256 bit key. The date shift is computed based on this key and the patient ID. If the patient ID is empty for a DICOM resource, the date shift is computed based on this key and the study instance UID. If crypto_key is not set, then kms_wrapped is used to calculate the date shift. If neither is set, a default key is generated for each de-identify operation. Must not be set if kms_wrapped is set.
	CryptoKey string `pulumi:"cryptoKey"`
	// KMS wrapped key. If kms_wrapped is not set, then crypto_key is used to calculate the date shift. If neither is set, a default key is generated for each de-identify operation. Must not be set if crypto_key is set.
	KmsWrapped KmsWrappedCryptoKeyResponse `pulumi:"kmsWrapped"`
}

// Shift a date forward or backward in time by a random amount which is consistent for a given patient and crypto key combination.
type DateShiftConfigResponseOutput struct{ *pulumi.OutputState }

func (DateShiftConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DateShiftConfigResponse)(nil)).Elem()
}

func (o DateShiftConfigResponseOutput) ToDateShiftConfigResponseOutput() DateShiftConfigResponseOutput {
	return o
}

func (o DateShiftConfigResponseOutput) ToDateShiftConfigResponseOutputWithContext(ctx context.Context) DateShiftConfigResponseOutput {
	return o
}

// An AES 128/192/256 bit key. The date shift is computed based on this key and the patient ID. If the patient ID is empty for a DICOM resource, the date shift is computed based on this key and the study instance UID. If crypto_key is not set, then kms_wrapped is used to calculate the date shift. If neither is set, a default key is generated for each de-identify operation. Must not be set if kms_wrapped is set.
func (o DateShiftConfigResponseOutput) CryptoKey() pulumi.StringOutput {
	return o.ApplyT(func(v DateShiftConfigResponse) string { return v.CryptoKey }).(pulumi.StringOutput)
}

// KMS wrapped key. If kms_wrapped is not set, then crypto_key is used to calculate the date shift. If neither is set, a default key is generated for each de-identify operation. Must not be set if crypto_key is set.
func (o DateShiftConfigResponseOutput) KmsWrapped() KmsWrappedCryptoKeyResponseOutput {
	return o.ApplyT(func(v DateShiftConfigResponse) KmsWrappedCryptoKeyResponse { return v.KmsWrapped }).(KmsWrappedCryptoKeyResponseOutput)
}

// Shift the date by a randomized number of days. See [date shifting](https://cloud.google.com/dlp/docs/concepts-date-shifting) for more information. Supported [types](https://www.hl7.org/fhir/datatypes.html): Date, DateTime.
type DateShiftField struct {
}

// DateShiftFieldInput is an input type that accepts DateShiftFieldArgs and DateShiftFieldOutput values.
// You can construct a concrete instance of `DateShiftFieldInput` via:
//
//	DateShiftFieldArgs{...}
type DateShiftFieldInput interface {
	pulumi.Input

	ToDateShiftFieldOutput() DateShiftFieldOutput
	ToDateShiftFieldOutputWithContext(context.Context) DateShiftFieldOutput
}

// Shift the date by a randomized number of days. See [date shifting](https://cloud.google.com/dlp/docs/concepts-date-shifting) for more information. Supported [types](https://www.hl7.org/fhir/datatypes.html): Date, DateTime.
type DateShiftFieldArgs struct {
}

func (DateShiftFieldArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DateShiftField)(nil)).Elem()
}

func (i DateShiftFieldArgs) ToDateShiftFieldOutput() DateShiftFieldOutput {
	return i.ToDateShiftFieldOutputWithContext(context.Background())
}

func (i DateShiftFieldArgs) ToDateShiftFieldOutputWithContext(ctx context.Context) DateShiftFieldOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DateShiftFieldOutput)
}

func (i DateShiftFieldArgs) ToDateShiftFieldPtrOutput() DateShiftFieldPtrOutput {
	return i.ToDateShiftFieldPtrOutputWithContext(context.Background())
}

func (i DateShiftFieldArgs) ToDateShiftFieldPtrOutputWithContext(ctx context.Context) DateShiftFieldPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DateShiftFieldOutput).ToDateShiftFieldPtrOutputWithContext(ctx)
}

// DateShiftFieldPtrInput is an input type that accepts DateShiftFieldArgs, DateShiftFieldPtr and DateShiftFieldPtrOutput values.
// You can construct a concrete instance of `DateShiftFieldPtrInput` via:
//
//	        DateShiftFieldArgs{...}
//
//	or:
//
//	        nil
type DateShiftFieldPtrInput interface {
	pulumi.Input

	ToDateShiftFieldPtrOutput() DateShiftFieldPtrOutput
	ToDateShiftFieldPtrOutputWithContext(context.Context) DateShiftFieldPtrOutput
}

type dateShiftFieldPtrType DateShiftFieldArgs

func DateShiftFieldPtr(v *DateShiftFieldArgs) DateShiftFieldPtrInput {
	return (*dateShiftFieldPtrType)(v)
}

func (*dateShiftFieldPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DateShiftField)(nil)).Elem()
}

func (i *dateShiftFieldPtrType) ToDateShiftFieldPtrOutput() DateShiftFieldPtrOutput {
	return i.ToDateShiftFieldPtrOutputWithContext(context.Background())
}

func (i *dateShiftFieldPtrType) ToDateShiftFieldPtrOutputWithContext(ctx context.Context) DateShiftFieldPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DateShiftFieldPtrOutput)
}

// Shift the date by a randomized number of days. See [date shifting](https://cloud.google.com/dlp/docs/concepts-date-shifting) for more information. Supported [types](https://www.hl7.org/fhir/datatypes.html): Date, DateTime.
type DateShiftFieldOutput struct{ *pulumi.OutputState }

func (DateShiftFieldOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DateShiftField)(nil)).Elem()
}

func (o DateShiftFieldOutput) ToDateShiftFieldOutput() DateShiftFieldOutput {
	return o
}

func (o DateShiftFieldOutput) ToDateShiftFieldOutputWithContext(ctx context.Context) DateShiftFieldOutput {
	return o
}

func (o DateShiftFieldOutput) ToDateShiftFieldPtrOutput() DateShiftFieldPtrOutput {
	return o.ToDateShiftFieldPtrOutputWithContext(context.Background())
}

func (o DateShiftFieldOutput) ToDateShiftFieldPtrOutputWithContext(ctx context.Context) DateShiftFieldPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DateShiftField) *DateShiftField {
		return &v
	}).(DateShiftFieldPtrOutput)
}

type DateShiftFieldPtrOutput struct{ *pulumi.OutputState }

func (DateShiftFieldPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DateShiftField)(nil)).Elem()
}

func (o DateShiftFieldPtrOutput) ToDateShiftFieldPtrOutput() DateShiftFieldPtrOutput {
	return o
}

func (o DateShiftFieldPtrOutput) ToDateShiftFieldPtrOutputWithContext(ctx context.Context) DateShiftFieldPtrOutput {
	return o
}

func (o DateShiftFieldPtrOutput) Elem() DateShiftFieldOutput {
	return o.ApplyT(func(v *DateShiftField) DateShiftField {
		if v != nil {
			return *v
		}
		var ret DateShiftField
		return ret
	}).(DateShiftFieldOutput)
}

// Shift the date by a randomized number of days. See [date shifting](https://cloud.google.com/dlp/docs/concepts-date-shifting) for more information. Supported [types](https://www.hl7.org/fhir/datatypes.html): Date, DateTime.
type DateShiftFieldResponse struct {
}

// Shift the date by a randomized number of days. See [date shifting](https://cloud.google.com/dlp/docs/concepts-date-shifting) for more information. Supported [types](https://www.hl7.org/fhir/datatypes.html): Date, DateTime.
type DateShiftFieldResponseOutput struct{ *pulumi.OutputState }

func (DateShiftFieldResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DateShiftFieldResponse)(nil)).Elem()
}

func (o DateShiftFieldResponseOutput) ToDateShiftFieldResponseOutput() DateShiftFieldResponseOutput {
	return o
}

func (o DateShiftFieldResponseOutput) ToDateShiftFieldResponseOutputWithContext(ctx context.Context) DateShiftFieldResponseOutput {
	return o
}

// Contains configuration for streaming de-identified FHIR export.
type DeidentifiedStoreDestination struct {
	// The configuration to use when de-identifying resources that are added to this store.
	Config *DeidentifyConfig `pulumi:"config"`
	// The full resource name of a Cloud Healthcare FHIR store, for example, `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/fhirStores/{fhir_store_id}`.
	Store *string `pulumi:"store"`
}

// DeidentifiedStoreDestinationInput is an input type that accepts DeidentifiedStoreDestinationArgs and DeidentifiedStoreDestinationOutput values.
// You can construct a concrete instance of `DeidentifiedStoreDestinationInput` via:
//
//	DeidentifiedStoreDestinationArgs{...}
type DeidentifiedStoreDestinationInput interface {
	pulumi.Input

	ToDeidentifiedStoreDestinationOutput() DeidentifiedStoreDestinationOutput
	ToDeidentifiedStoreDestinationOutputWithContext(context.Context) DeidentifiedStoreDestinationOutput
}

// Contains configuration for streaming de-identified FHIR export.
type DeidentifiedStoreDestinationArgs struct {
	// The configuration to use when de-identifying resources that are added to this store.
	Config DeidentifyConfigPtrInput `pulumi:"config"`
	// The full resource name of a Cloud Healthcare FHIR store, for example, `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/fhirStores/{fhir_store_id}`.
	Store pulumi.StringPtrInput `pulumi:"store"`
}

func (DeidentifiedStoreDestinationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeidentifiedStoreDestination)(nil)).Elem()
}

func (i DeidentifiedStoreDestinationArgs) ToDeidentifiedStoreDestinationOutput() DeidentifiedStoreDestinationOutput {
	return i.ToDeidentifiedStoreDestinationOutputWithContext(context.Background())
}

func (i DeidentifiedStoreDestinationArgs) ToDeidentifiedStoreDestinationOutputWithContext(ctx context.Context) DeidentifiedStoreDestinationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeidentifiedStoreDestinationOutput)
}

func (i DeidentifiedStoreDestinationArgs) ToDeidentifiedStoreDestinationPtrOutput() DeidentifiedStoreDestinationPtrOutput {
	return i.ToDeidentifiedStoreDestinationPtrOutputWithContext(context.Background())
}

func (i DeidentifiedStoreDestinationArgs) ToDeidentifiedStoreDestinationPtrOutputWithContext(ctx context.Context) DeidentifiedStoreDestinationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeidentifiedStoreDestinationOutput).ToDeidentifiedStoreDestinationPtrOutputWithContext(ctx)
}

// DeidentifiedStoreDestinationPtrInput is an input type that accepts DeidentifiedStoreDestinationArgs, DeidentifiedStoreDestinationPtr and DeidentifiedStoreDestinationPtrOutput values.
// You can construct a concrete instance of `DeidentifiedStoreDestinationPtrInput` via:
//
//	        DeidentifiedStoreDestinationArgs{...}
//
//	or:
//
//	        nil
type DeidentifiedStoreDestinationPtrInput interface {
	pulumi.Input

	ToDeidentifiedStoreDestinationPtrOutput() DeidentifiedStoreDestinationPtrOutput
	ToDeidentifiedStoreDestinationPtrOutputWithContext(context.Context) DeidentifiedStoreDestinationPtrOutput
}

type deidentifiedStoreDestinationPtrType DeidentifiedStoreDestinationArgs

func DeidentifiedStoreDestinationPtr(v *DeidentifiedStoreDestinationArgs) DeidentifiedStoreDestinationPtrInput {
	return (*deidentifiedStoreDestinationPtrType)(v)
}

func (*deidentifiedStoreDestinationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeidentifiedStoreDestination)(nil)).Elem()
}

func (i *deidentifiedStoreDestinationPtrType) ToDeidentifiedStoreDestinationPtrOutput() DeidentifiedStoreDestinationPtrOutput {
	return i.ToDeidentifiedStoreDestinationPtrOutputWithContext(context.Background())
}

func (i *deidentifiedStoreDestinationPtrType) ToDeidentifiedStoreDestinationPtrOutputWithContext(ctx context.Context) DeidentifiedStoreDestinationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeidentifiedStoreDestinationPtrOutput)
}

// Contains configuration for streaming de-identified FHIR export.
type DeidentifiedStoreDestinationOutput struct{ *pulumi.OutputState }

func (DeidentifiedStoreDestinationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeidentifiedStoreDestination)(nil)).Elem()
}

func (o DeidentifiedStoreDestinationOutput) ToDeidentifiedStoreDestinationOutput() DeidentifiedStoreDestinationOutput {
	return o
}

func (o DeidentifiedStoreDestinationOutput) ToDeidentifiedStoreDestinationOutputWithContext(ctx context.Context) DeidentifiedStoreDestinationOutput {
	return o
}

func (o DeidentifiedStoreDestinationOutput) ToDeidentifiedStoreDestinationPtrOutput() DeidentifiedStoreDestinationPtrOutput {
	return o.ToDeidentifiedStoreDestinationPtrOutputWithContext(context.Background())
}

func (o DeidentifiedStoreDestinationOutput) ToDeidentifiedStoreDestinationPtrOutputWithContext(ctx context.Context) DeidentifiedStoreDestinationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DeidentifiedStoreDestination) *DeidentifiedStoreDestination {
		return &v
	}).(DeidentifiedStoreDestinationPtrOutput)
}

// The configuration to use when de-identifying resources that are added to this store.
func (o DeidentifiedStoreDestinationOutput) Config() DeidentifyConfigPtrOutput {
	return o.ApplyT(func(v DeidentifiedStoreDestination) *DeidentifyConfig { return v.Config }).(DeidentifyConfigPtrOutput)
}

// The full resource name of a Cloud Healthcare FHIR store, for example, `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/fhirStores/{fhir_store_id}`.
func (o DeidentifiedStoreDestinationOutput) Store() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeidentifiedStoreDestination) *string { return v.Store }).(pulumi.StringPtrOutput)
}

type DeidentifiedStoreDestinationPtrOutput struct{ *pulumi.OutputState }

func (DeidentifiedStoreDestinationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeidentifiedStoreDestination)(nil)).Elem()
}

func (o DeidentifiedStoreDestinationPtrOutput) ToDeidentifiedStoreDestinationPtrOutput() DeidentifiedStoreDestinationPtrOutput {
	return o
}

func (o DeidentifiedStoreDestinationPtrOutput) ToDeidentifiedStoreDestinationPtrOutputWithContext(ctx context.Context) DeidentifiedStoreDestinationPtrOutput {
	return o
}

func (o DeidentifiedStoreDestinationPtrOutput) Elem() DeidentifiedStoreDestinationOutput {
	return o.ApplyT(func(v *DeidentifiedStoreDestination) DeidentifiedStoreDestination {
		if v != nil {
			return *v
		}
		var ret DeidentifiedStoreDestination
		return ret
	}).(DeidentifiedStoreDestinationOutput)
}

// The configuration to use when de-identifying resources that are added to this store.
func (o DeidentifiedStoreDestinationPtrOutput) Config() DeidentifyConfigPtrOutput {
	return o.ApplyT(func(v *DeidentifiedStoreDestination) *DeidentifyConfig {
		if v == nil {
			return nil
		}
		return v.Config
	}).(DeidentifyConfigPtrOutput)
}

// The full resource name of a Cloud Healthcare FHIR store, for example, `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/fhirStores/{fhir_store_id}`.
func (o DeidentifiedStoreDestinationPtrOutput) Store() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeidentifiedStoreDestination) *string {
		if v == nil {
			return nil
		}
		return v.Store
	}).(pulumi.StringPtrOutput)
}

// Contains configuration for streaming de-identified FHIR export.
type DeidentifiedStoreDestinationResponse struct {
	// The configuration to use when de-identifying resources that are added to this store.
	Config DeidentifyConfigResponse `pulumi:"config"`
	// The full resource name of a Cloud Healthcare FHIR store, for example, `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/fhirStores/{fhir_store_id}`.
	Store string `pulumi:"store"`
}

// Contains configuration for streaming de-identified FHIR export.
type DeidentifiedStoreDestinationResponseOutput struct{ *pulumi.OutputState }

func (DeidentifiedStoreDestinationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeidentifiedStoreDestinationResponse)(nil)).Elem()
}

func (o DeidentifiedStoreDestinationResponseOutput) ToDeidentifiedStoreDestinationResponseOutput() DeidentifiedStoreDestinationResponseOutput {
	return o
}

func (o DeidentifiedStoreDestinationResponseOutput) ToDeidentifiedStoreDestinationResponseOutputWithContext(ctx context.Context) DeidentifiedStoreDestinationResponseOutput {
	return o
}

// The configuration to use when de-identifying resources that are added to this store.
func (o DeidentifiedStoreDestinationResponseOutput) Config() DeidentifyConfigResponseOutput {
	return o.ApplyT(func(v DeidentifiedStoreDestinationResponse) DeidentifyConfigResponse { return v.Config }).(DeidentifyConfigResponseOutput)
}

// The full resource name of a Cloud Healthcare FHIR store, for example, `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/fhirStores/{fhir_store_id}`.
func (o DeidentifiedStoreDestinationResponseOutput) Store() pulumi.StringOutput {
	return o.ApplyT(func(v DeidentifiedStoreDestinationResponse) string { return v.Store }).(pulumi.StringOutput)
}

// Configures de-id options specific to different types of content. Each submessage customizes the handling of an https://tools.ietf.org/html/rfc6838 media type or subtype. Configs are applied in a nested manner at runtime.
type DeidentifyConfig struct {
	// Configures how annotations, meaning that the location and infoType of sensitive information findings, are created during de-identification. If unspecified, no annotations are created.
	Annotation *AnnotationConfig `pulumi:"annotation"`
	// Configures de-id of application/DICOM content. Deprecated. Use `dicom_tag_config` instead.
	//
	// Deprecated: Configures de-id of application/DICOM content. Deprecated. Use `dicom_tag_config` instead.
	Dicom *DicomConfig `pulumi:"dicom"`
	// Configures de-id of application/DICOM content.
	DicomTagConfig *DicomTagConfig `pulumi:"dicomTagConfig"`
	// Configures de-id of application/FHIR content. Deprecated. Use `fhir_field_config` instead.
	//
	// Deprecated: Configures de-id of application/FHIR content. Deprecated. Use `fhir_field_config` instead.
	Fhir *FhirConfig `pulumi:"fhir"`
	// Configures de-id of application/FHIR content.
	FhirFieldConfig *FhirFieldConfig `pulumi:"fhirFieldConfig"`
	// Configures the de-identification of image pixels in the source_dataset. Deprecated. Use `dicom_tag_config.options.clean_image` instead.
	//
	// Deprecated: Configures the de-identification of image pixels in the source_dataset. Deprecated. Use `dicom_tag_config.options.clean_image` instead.
	Image *ImageConfig `pulumi:"image"`
	// Details about the work the de-identify operation performed.
	OperationMetadata *DeidentifyOperationMetadata `pulumi:"operationMetadata"`
	// Configures de-identification of text wherever it is found in the source_dataset.
	Text *TextConfig `pulumi:"text"`
	// Ensures in-flight data remains in the region of origin during de-identification. Using this option results in a significant reduction of throughput, and is not compatible with `LOCATION` or `ORGANIZATION_NAME` infoTypes. If the deprecated DicomConfig or FhirConfig are used, then `LOCATION` must be excluded within TextConfig, and must also be excluded within ImageConfig if image redaction is required.
	UseRegionalDataProcessing *bool `pulumi:"useRegionalDataProcessing"`
}

// DeidentifyConfigInput is an input type that accepts DeidentifyConfigArgs and DeidentifyConfigOutput values.
// You can construct a concrete instance of `DeidentifyConfigInput` via:
//
//	DeidentifyConfigArgs{...}
type DeidentifyConfigInput interface {
	pulumi.Input

	ToDeidentifyConfigOutput() DeidentifyConfigOutput
	ToDeidentifyConfigOutputWithContext(context.Context) DeidentifyConfigOutput
}

// Configures de-id options specific to different types of content. Each submessage customizes the handling of an https://tools.ietf.org/html/rfc6838 media type or subtype. Configs are applied in a nested manner at runtime.
type DeidentifyConfigArgs struct {
	// Configures how annotations, meaning that the location and infoType of sensitive information findings, are created during de-identification. If unspecified, no annotations are created.
	Annotation AnnotationConfigPtrInput `pulumi:"annotation"`
	// Configures de-id of application/DICOM content. Deprecated. Use `dicom_tag_config` instead.
	//
	// Deprecated: Configures de-id of application/DICOM content. Deprecated. Use `dicom_tag_config` instead.
	Dicom DicomConfigPtrInput `pulumi:"dicom"`
	// Configures de-id of application/DICOM content.
	DicomTagConfig DicomTagConfigPtrInput `pulumi:"dicomTagConfig"`
	// Configures de-id of application/FHIR content. Deprecated. Use `fhir_field_config` instead.
	//
	// Deprecated: Configures de-id of application/FHIR content. Deprecated. Use `fhir_field_config` instead.
	Fhir FhirConfigPtrInput `pulumi:"fhir"`
	// Configures de-id of application/FHIR content.
	FhirFieldConfig FhirFieldConfigPtrInput `pulumi:"fhirFieldConfig"`
	// Configures the de-identification of image pixels in the source_dataset. Deprecated. Use `dicom_tag_config.options.clean_image` instead.
	//
	// Deprecated: Configures the de-identification of image pixels in the source_dataset. Deprecated. Use `dicom_tag_config.options.clean_image` instead.
	Image ImageConfigPtrInput `pulumi:"image"`
	// Details about the work the de-identify operation performed.
	OperationMetadata DeidentifyOperationMetadataPtrInput `pulumi:"operationMetadata"`
	// Configures de-identification of text wherever it is found in the source_dataset.
	Text TextConfigPtrInput `pulumi:"text"`
	// Ensures in-flight data remains in the region of origin during de-identification. Using this option results in a significant reduction of throughput, and is not compatible with `LOCATION` or `ORGANIZATION_NAME` infoTypes. If the deprecated DicomConfig or FhirConfig are used, then `LOCATION` must be excluded within TextConfig, and must also be excluded within ImageConfig if image redaction is required.
	UseRegionalDataProcessing pulumi.BoolPtrInput `pulumi:"useRegionalDataProcessing"`
}

func (DeidentifyConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeidentifyConfig)(nil)).Elem()
}

func (i DeidentifyConfigArgs) ToDeidentifyConfigOutput() DeidentifyConfigOutput {
	return i.ToDeidentifyConfigOutputWithContext(context.Background())
}

func (i DeidentifyConfigArgs) ToDeidentifyConfigOutputWithContext(ctx context.Context) DeidentifyConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeidentifyConfigOutput)
}

func (i DeidentifyConfigArgs) ToDeidentifyConfigPtrOutput() DeidentifyConfigPtrOutput {
	return i.ToDeidentifyConfigPtrOutputWithContext(context.Background())
}

func (i DeidentifyConfigArgs) ToDeidentifyConfigPtrOutputWithContext(ctx context.Context) DeidentifyConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeidentifyConfigOutput).ToDeidentifyConfigPtrOutputWithContext(ctx)
}

// DeidentifyConfigPtrInput is an input type that accepts DeidentifyConfigArgs, DeidentifyConfigPtr and DeidentifyConfigPtrOutput values.
// You can construct a concrete instance of `DeidentifyConfigPtrInput` via:
//
//	        DeidentifyConfigArgs{...}
//
//	or:
//
//	        nil
type DeidentifyConfigPtrInput interface {
	pulumi.Input

	ToDeidentifyConfigPtrOutput() DeidentifyConfigPtrOutput
	ToDeidentifyConfigPtrOutputWithContext(context.Context) DeidentifyConfigPtrOutput
}

type deidentifyConfigPtrType DeidentifyConfigArgs

func DeidentifyConfigPtr(v *DeidentifyConfigArgs) DeidentifyConfigPtrInput {
	return (*deidentifyConfigPtrType)(v)
}

func (*deidentifyConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeidentifyConfig)(nil)).Elem()
}

func (i *deidentifyConfigPtrType) ToDeidentifyConfigPtrOutput() DeidentifyConfigPtrOutput {
	return i.ToDeidentifyConfigPtrOutputWithContext(context.Background())
}

func (i *deidentifyConfigPtrType) ToDeidentifyConfigPtrOutputWithContext(ctx context.Context) DeidentifyConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeidentifyConfigPtrOutput)
}

// Configures de-id options specific to different types of content. Each submessage customizes the handling of an https://tools.ietf.org/html/rfc6838 media type or subtype. Configs are applied in a nested manner at runtime.
type DeidentifyConfigOutput struct{ *pulumi.OutputState }

func (DeidentifyConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeidentifyConfig)(nil)).Elem()
}

func (o DeidentifyConfigOutput) ToDeidentifyConfigOutput() DeidentifyConfigOutput {
	return o
}

func (o DeidentifyConfigOutput) ToDeidentifyConfigOutputWithContext(ctx context.Context) DeidentifyConfigOutput {
	return o
}

func (o DeidentifyConfigOutput) ToDeidentifyConfigPtrOutput() DeidentifyConfigPtrOutput {
	return o.ToDeidentifyConfigPtrOutputWithContext(context.Background())
}

func (o DeidentifyConfigOutput) ToDeidentifyConfigPtrOutputWithContext(ctx context.Context) DeidentifyConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DeidentifyConfig) *DeidentifyConfig {
		return &v
	}).(DeidentifyConfigPtrOutput)
}

// Configures how annotations, meaning that the location and infoType of sensitive information findings, are created during de-identification. If unspecified, no annotations are created.
func (o DeidentifyConfigOutput) Annotation() AnnotationConfigPtrOutput {
	return o.ApplyT(func(v DeidentifyConfig) *AnnotationConfig { return v.Annotation }).(AnnotationConfigPtrOutput)
}

// Configures de-id of application/DICOM content. Deprecated. Use `dicom_tag_config` instead.
//
// Deprecated: Configures de-id of application/DICOM content. Deprecated. Use `dicom_tag_config` instead.
func (o DeidentifyConfigOutput) Dicom() DicomConfigPtrOutput {
	return o.ApplyT(func(v DeidentifyConfig) *DicomConfig { return v.Dicom }).(DicomConfigPtrOutput)
}

// Configures de-id of application/DICOM content.
func (o DeidentifyConfigOutput) DicomTagConfig() DicomTagConfigPtrOutput {
	return o.ApplyT(func(v DeidentifyConfig) *DicomTagConfig { return v.DicomTagConfig }).(DicomTagConfigPtrOutput)
}

// Configures de-id of application/FHIR content. Deprecated. Use `fhir_field_config` instead.
//
// Deprecated: Configures de-id of application/FHIR content. Deprecated. Use `fhir_field_config` instead.
func (o DeidentifyConfigOutput) Fhir() FhirConfigPtrOutput {
	return o.ApplyT(func(v DeidentifyConfig) *FhirConfig { return v.Fhir }).(FhirConfigPtrOutput)
}

// Configures de-id of application/FHIR content.
func (o DeidentifyConfigOutput) FhirFieldConfig() FhirFieldConfigPtrOutput {
	return o.ApplyT(func(v DeidentifyConfig) *FhirFieldConfig { return v.FhirFieldConfig }).(FhirFieldConfigPtrOutput)
}

// Configures the de-identification of image pixels in the source_dataset. Deprecated. Use `dicom_tag_config.options.clean_image` instead.
//
// Deprecated: Configures the de-identification of image pixels in the source_dataset. Deprecated. Use `dicom_tag_config.options.clean_image` instead.
func (o DeidentifyConfigOutput) Image() ImageConfigPtrOutput {
	return o.ApplyT(func(v DeidentifyConfig) *ImageConfig { return v.Image }).(ImageConfigPtrOutput)
}

// Details about the work the de-identify operation performed.
func (o DeidentifyConfigOutput) OperationMetadata() DeidentifyOperationMetadataPtrOutput {
	return o.ApplyT(func(v DeidentifyConfig) *DeidentifyOperationMetadata { return v.OperationMetadata }).(DeidentifyOperationMetadataPtrOutput)
}

// Configures de-identification of text wherever it is found in the source_dataset.
func (o DeidentifyConfigOutput) Text() TextConfigPtrOutput {
	return o.ApplyT(func(v DeidentifyConfig) *TextConfig { return v.Text }).(TextConfigPtrOutput)
}

// Ensures in-flight data remains in the region of origin during de-identification. Using this option results in a significant reduction of throughput, and is not compatible with `LOCATION` or `ORGANIZATION_NAME` infoTypes. If the deprecated DicomConfig or FhirConfig are used, then `LOCATION` must be excluded within TextConfig, and must also be excluded within ImageConfig if image redaction is required.
func (o DeidentifyConfigOutput) UseRegionalDataProcessing() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DeidentifyConfig) *bool { return v.UseRegionalDataProcessing }).(pulumi.BoolPtrOutput)
}

type DeidentifyConfigPtrOutput struct{ *pulumi.OutputState }

func (DeidentifyConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeidentifyConfig)(nil)).Elem()
}

func (o DeidentifyConfigPtrOutput) ToDeidentifyConfigPtrOutput() DeidentifyConfigPtrOutput {
	return o
}

func (o DeidentifyConfigPtrOutput) ToDeidentifyConfigPtrOutputWithContext(ctx context.Context) DeidentifyConfigPtrOutput {
	return o
}

func (o DeidentifyConfigPtrOutput) Elem() DeidentifyConfigOutput {
	return o.ApplyT(func(v *DeidentifyConfig) DeidentifyConfig {
		if v != nil {
			return *v
		}
		var ret DeidentifyConfig
		return ret
	}).(DeidentifyConfigOutput)
}

// Configures how annotations, meaning that the location and infoType of sensitive information findings, are created during de-identification. If unspecified, no annotations are created.
func (o DeidentifyConfigPtrOutput) Annotation() AnnotationConfigPtrOutput {
	return o.ApplyT(func(v *DeidentifyConfig) *AnnotationConfig {
		if v == nil {
			return nil
		}
		return v.Annotation
	}).(AnnotationConfigPtrOutput)
}

// Configures de-id of application/DICOM content. Deprecated. Use `dicom_tag_config` instead.
//
// Deprecated: Configures de-id of application/DICOM content. Deprecated. Use `dicom_tag_config` instead.
func (o DeidentifyConfigPtrOutput) Dicom() DicomConfigPtrOutput {
	return o.ApplyT(func(v *DeidentifyConfig) *DicomConfig {
		if v == nil {
			return nil
		}
		return v.Dicom
	}).(DicomConfigPtrOutput)
}

// Configures de-id of application/DICOM content.
func (o DeidentifyConfigPtrOutput) DicomTagConfig() DicomTagConfigPtrOutput {
	return o.ApplyT(func(v *DeidentifyConfig) *DicomTagConfig {
		if v == nil {
			return nil
		}
		return v.DicomTagConfig
	}).(DicomTagConfigPtrOutput)
}

// Configures de-id of application/FHIR content. Deprecated. Use `fhir_field_config` instead.
//
// Deprecated: Configures de-id of application/FHIR content. Deprecated. Use `fhir_field_config` instead.
func (o DeidentifyConfigPtrOutput) Fhir() FhirConfigPtrOutput {
	return o.ApplyT(func(v *DeidentifyConfig) *FhirConfig {
		if v == nil {
			return nil
		}
		return v.Fhir
	}).(FhirConfigPtrOutput)
}

// Configures de-id of application/FHIR content.
func (o DeidentifyConfigPtrOutput) FhirFieldConfig() FhirFieldConfigPtrOutput {
	return o.ApplyT(func(v *DeidentifyConfig) *FhirFieldConfig {
		if v == nil {
			return nil
		}
		return v.FhirFieldConfig
	}).(FhirFieldConfigPtrOutput)
}

// Configures the de-identification of image pixels in the source_dataset. Deprecated. Use `dicom_tag_config.options.clean_image` instead.
//
// Deprecated: Configures the de-identification of image pixels in the source_dataset. Deprecated. Use `dicom_tag_config.options.clean_image` instead.
func (o DeidentifyConfigPtrOutput) Image() ImageConfigPtrOutput {
	return o.ApplyT(func(v *DeidentifyConfig) *ImageConfig {
		if v == nil {
			return nil
		}
		return v.Image
	}).(ImageConfigPtrOutput)
}

// Details about the work the de-identify operation performed.
func (o DeidentifyConfigPtrOutput) OperationMetadata() DeidentifyOperationMetadataPtrOutput {
	return o.ApplyT(func(v *DeidentifyConfig) *DeidentifyOperationMetadata {
		if v == nil {
			return nil
		}
		return v.OperationMetadata
	}).(DeidentifyOperationMetadataPtrOutput)
}

// Configures de-identification of text wherever it is found in the source_dataset.
func (o DeidentifyConfigPtrOutput) Text() TextConfigPtrOutput {
	return o.ApplyT(func(v *DeidentifyConfig) *TextConfig {
		if v == nil {
			return nil
		}
		return v.Text
	}).(TextConfigPtrOutput)
}

// Ensures in-flight data remains in the region of origin during de-identification. Using this option results in a significant reduction of throughput, and is not compatible with `LOCATION` or `ORGANIZATION_NAME` infoTypes. If the deprecated DicomConfig or FhirConfig are used, then `LOCATION` must be excluded within TextConfig, and must also be excluded within ImageConfig if image redaction is required.
func (o DeidentifyConfigPtrOutput) UseRegionalDataProcessing() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DeidentifyConfig) *bool {
		if v == nil {
			return nil
		}
		return v.UseRegionalDataProcessing
	}).(pulumi.BoolPtrOutput)
}

// Configures de-id options specific to different types of content. Each submessage customizes the handling of an https://tools.ietf.org/html/rfc6838 media type or subtype. Configs are applied in a nested manner at runtime.
type DeidentifyConfigResponse struct {
	// Configures how annotations, meaning that the location and infoType of sensitive information findings, are created during de-identification. If unspecified, no annotations are created.
	Annotation AnnotationConfigResponse `pulumi:"annotation"`
	// Configures de-id of application/DICOM content. Deprecated. Use `dicom_tag_config` instead.
	//
	// Deprecated: Configures de-id of application/DICOM content. Deprecated. Use `dicom_tag_config` instead.
	Dicom DicomConfigResponse `pulumi:"dicom"`
	// Configures de-id of application/DICOM content.
	DicomTagConfig DicomTagConfigResponse `pulumi:"dicomTagConfig"`
	// Configures de-id of application/FHIR content. Deprecated. Use `fhir_field_config` instead.
	//
	// Deprecated: Configures de-id of application/FHIR content. Deprecated. Use `fhir_field_config` instead.
	Fhir FhirConfigResponse `pulumi:"fhir"`
	// Configures de-id of application/FHIR content.
	FhirFieldConfig FhirFieldConfigResponse `pulumi:"fhirFieldConfig"`
	// Configures the de-identification of image pixels in the source_dataset. Deprecated. Use `dicom_tag_config.options.clean_image` instead.
	//
	// Deprecated: Configures the de-identification of image pixels in the source_dataset. Deprecated. Use `dicom_tag_config.options.clean_image` instead.
	Image ImageConfigResponse `pulumi:"image"`
	// Details about the work the de-identify operation performed.
	OperationMetadata DeidentifyOperationMetadataResponse `pulumi:"operationMetadata"`
	// Configures de-identification of text wherever it is found in the source_dataset.
	Text TextConfigResponse `pulumi:"text"`
	// Ensures in-flight data remains in the region of origin during de-identification. Using this option results in a significant reduction of throughput, and is not compatible with `LOCATION` or `ORGANIZATION_NAME` infoTypes. If the deprecated DicomConfig or FhirConfig are used, then `LOCATION` must be excluded within TextConfig, and must also be excluded within ImageConfig if image redaction is required.
	UseRegionalDataProcessing bool `pulumi:"useRegionalDataProcessing"`
}

// Configures de-id options specific to different types of content. Each submessage customizes the handling of an https://tools.ietf.org/html/rfc6838 media type or subtype. Configs are applied in a nested manner at runtime.
type DeidentifyConfigResponseOutput struct{ *pulumi.OutputState }

func (DeidentifyConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeidentifyConfigResponse)(nil)).Elem()
}

func (o DeidentifyConfigResponseOutput) ToDeidentifyConfigResponseOutput() DeidentifyConfigResponseOutput {
	return o
}

func (o DeidentifyConfigResponseOutput) ToDeidentifyConfigResponseOutputWithContext(ctx context.Context) DeidentifyConfigResponseOutput {
	return o
}

// Configures how annotations, meaning that the location and infoType of sensitive information findings, are created during de-identification. If unspecified, no annotations are created.
func (o DeidentifyConfigResponseOutput) Annotation() AnnotationConfigResponseOutput {
	return o.ApplyT(func(v DeidentifyConfigResponse) AnnotationConfigResponse { return v.Annotation }).(AnnotationConfigResponseOutput)
}

// Configures de-id of application/DICOM content. Deprecated. Use `dicom_tag_config` instead.
//
// Deprecated: Configures de-id of application/DICOM content. Deprecated. Use `dicom_tag_config` instead.
func (o DeidentifyConfigResponseOutput) Dicom() DicomConfigResponseOutput {
	return o.ApplyT(func(v DeidentifyConfigResponse) DicomConfigResponse { return v.Dicom }).(DicomConfigResponseOutput)
}

// Configures de-id of application/DICOM content.
func (o DeidentifyConfigResponseOutput) DicomTagConfig() DicomTagConfigResponseOutput {
	return o.ApplyT(func(v DeidentifyConfigResponse) DicomTagConfigResponse { return v.DicomTagConfig }).(DicomTagConfigResponseOutput)
}

// Configures de-id of application/FHIR content. Deprecated. Use `fhir_field_config` instead.
//
// Deprecated: Configures de-id of application/FHIR content. Deprecated. Use `fhir_field_config` instead.
func (o DeidentifyConfigResponseOutput) Fhir() FhirConfigResponseOutput {
	return o.ApplyT(func(v DeidentifyConfigResponse) FhirConfigResponse { return v.Fhir }).(FhirConfigResponseOutput)
}

// Configures de-id of application/FHIR content.
func (o DeidentifyConfigResponseOutput) FhirFieldConfig() FhirFieldConfigResponseOutput {
	return o.ApplyT(func(v DeidentifyConfigResponse) FhirFieldConfigResponse { return v.FhirFieldConfig }).(FhirFieldConfigResponseOutput)
}

// Configures the de-identification of image pixels in the source_dataset. Deprecated. Use `dicom_tag_config.options.clean_image` instead.
//
// Deprecated: Configures the de-identification of image pixels in the source_dataset. Deprecated. Use `dicom_tag_config.options.clean_image` instead.
func (o DeidentifyConfigResponseOutput) Image() ImageConfigResponseOutput {
	return o.ApplyT(func(v DeidentifyConfigResponse) ImageConfigResponse { return v.Image }).(ImageConfigResponseOutput)
}

// Details about the work the de-identify operation performed.
func (o DeidentifyConfigResponseOutput) OperationMetadata() DeidentifyOperationMetadataResponseOutput {
	return o.ApplyT(func(v DeidentifyConfigResponse) DeidentifyOperationMetadataResponse { return v.OperationMetadata }).(DeidentifyOperationMetadataResponseOutput)
}

// Configures de-identification of text wherever it is found in the source_dataset.
func (o DeidentifyConfigResponseOutput) Text() TextConfigResponseOutput {
	return o.ApplyT(func(v DeidentifyConfigResponse) TextConfigResponse { return v.Text }).(TextConfigResponseOutput)
}

// Ensures in-flight data remains in the region of origin during de-identification. Using this option results in a significant reduction of throughput, and is not compatible with `LOCATION` or `ORGANIZATION_NAME` infoTypes. If the deprecated DicomConfig or FhirConfig are used, then `LOCATION` must be excluded within TextConfig, and must also be excluded within ImageConfig if image redaction is required.
func (o DeidentifyConfigResponseOutput) UseRegionalDataProcessing() pulumi.BoolOutput {
	return o.ApplyT(func(v DeidentifyConfigResponse) bool { return v.UseRegionalDataProcessing }).(pulumi.BoolOutput)
}

// Details about the work the de-identify operation performed.
type DeidentifyOperationMetadata struct {
	// Details about the FHIR store to write the output to.
	FhirOutput *FhirOutput `pulumi:"fhirOutput"`
}

// DeidentifyOperationMetadataInput is an input type that accepts DeidentifyOperationMetadataArgs and DeidentifyOperationMetadataOutput values.
// You can construct a concrete instance of `DeidentifyOperationMetadataInput` via:
//
//	DeidentifyOperationMetadataArgs{...}
type DeidentifyOperationMetadataInput interface {
	pulumi.Input

	ToDeidentifyOperationMetadataOutput() DeidentifyOperationMetadataOutput
	ToDeidentifyOperationMetadataOutputWithContext(context.Context) DeidentifyOperationMetadataOutput
}

// Details about the work the de-identify operation performed.
type DeidentifyOperationMetadataArgs struct {
	// Details about the FHIR store to write the output to.
	FhirOutput FhirOutputPtrInput `pulumi:"fhirOutput"`
}

func (DeidentifyOperationMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeidentifyOperationMetadata)(nil)).Elem()
}

func (i DeidentifyOperationMetadataArgs) ToDeidentifyOperationMetadataOutput() DeidentifyOperationMetadataOutput {
	return i.ToDeidentifyOperationMetadataOutputWithContext(context.Background())
}

func (i DeidentifyOperationMetadataArgs) ToDeidentifyOperationMetadataOutputWithContext(ctx context.Context) DeidentifyOperationMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeidentifyOperationMetadataOutput)
}

func (i DeidentifyOperationMetadataArgs) ToDeidentifyOperationMetadataPtrOutput() DeidentifyOperationMetadataPtrOutput {
	return i.ToDeidentifyOperationMetadataPtrOutputWithContext(context.Background())
}

func (i DeidentifyOperationMetadataArgs) ToDeidentifyOperationMetadataPtrOutputWithContext(ctx context.Context) DeidentifyOperationMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeidentifyOperationMetadataOutput).ToDeidentifyOperationMetadataPtrOutputWithContext(ctx)
}

// DeidentifyOperationMetadataPtrInput is an input type that accepts DeidentifyOperationMetadataArgs, DeidentifyOperationMetadataPtr and DeidentifyOperationMetadataPtrOutput values.
// You can construct a concrete instance of `DeidentifyOperationMetadataPtrInput` via:
//
//	        DeidentifyOperationMetadataArgs{...}
//
//	or:
//
//	        nil
type DeidentifyOperationMetadataPtrInput interface {
	pulumi.Input

	ToDeidentifyOperationMetadataPtrOutput() DeidentifyOperationMetadataPtrOutput
	ToDeidentifyOperationMetadataPtrOutputWithContext(context.Context) DeidentifyOperationMetadataPtrOutput
}

type deidentifyOperationMetadataPtrType DeidentifyOperationMetadataArgs

func DeidentifyOperationMetadataPtr(v *DeidentifyOperationMetadataArgs) DeidentifyOperationMetadataPtrInput {
	return (*deidentifyOperationMetadataPtrType)(v)
}

func (*deidentifyOperationMetadataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeidentifyOperationMetadata)(nil)).Elem()
}

func (i *deidentifyOperationMetadataPtrType) ToDeidentifyOperationMetadataPtrOutput() DeidentifyOperationMetadataPtrOutput {
	return i.ToDeidentifyOperationMetadataPtrOutputWithContext(context.Background())
}

func (i *deidentifyOperationMetadataPtrType) ToDeidentifyOperationMetadataPtrOutputWithContext(ctx context.Context) DeidentifyOperationMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeidentifyOperationMetadataPtrOutput)
}

// Details about the work the de-identify operation performed.
type DeidentifyOperationMetadataOutput struct{ *pulumi.OutputState }

func (DeidentifyOperationMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeidentifyOperationMetadata)(nil)).Elem()
}

func (o DeidentifyOperationMetadataOutput) ToDeidentifyOperationMetadataOutput() DeidentifyOperationMetadataOutput {
	return o
}

func (o DeidentifyOperationMetadataOutput) ToDeidentifyOperationMetadataOutputWithContext(ctx context.Context) DeidentifyOperationMetadataOutput {
	return o
}

func (o DeidentifyOperationMetadataOutput) ToDeidentifyOperationMetadataPtrOutput() DeidentifyOperationMetadataPtrOutput {
	return o.ToDeidentifyOperationMetadataPtrOutputWithContext(context.Background())
}

func (o DeidentifyOperationMetadataOutput) ToDeidentifyOperationMetadataPtrOutputWithContext(ctx context.Context) DeidentifyOperationMetadataPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DeidentifyOperationMetadata) *DeidentifyOperationMetadata {
		return &v
	}).(DeidentifyOperationMetadataPtrOutput)
}

// Details about the FHIR store to write the output to.
func (o DeidentifyOperationMetadataOutput) FhirOutput() FhirOutputPtrOutput {
	return o.ApplyT(func(v DeidentifyOperationMetadata) *FhirOutput { return v.FhirOutput }).(FhirOutputPtrOutput)
}

type DeidentifyOperationMetadataPtrOutput struct{ *pulumi.OutputState }

func (DeidentifyOperationMetadataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeidentifyOperationMetadata)(nil)).Elem()
}

func (o DeidentifyOperationMetadataPtrOutput) ToDeidentifyOperationMetadataPtrOutput() DeidentifyOperationMetadataPtrOutput {
	return o
}

func (o DeidentifyOperationMetadataPtrOutput) ToDeidentifyOperationMetadataPtrOutputWithContext(ctx context.Context) DeidentifyOperationMetadataPtrOutput {
	return o
}

func (o DeidentifyOperationMetadataPtrOutput) Elem() DeidentifyOperationMetadataOutput {
	return o.ApplyT(func(v *DeidentifyOperationMetadata) DeidentifyOperationMetadata {
		if v != nil {
			return *v
		}
		var ret DeidentifyOperationMetadata
		return ret
	}).(DeidentifyOperationMetadataOutput)
}

// Details about the FHIR store to write the output to.
func (o DeidentifyOperationMetadataPtrOutput) FhirOutput() FhirOutputPtrOutput {
	return o.ApplyT(func(v *DeidentifyOperationMetadata) *FhirOutput {
		if v == nil {
			return nil
		}
		return v.FhirOutput
	}).(FhirOutputPtrOutput)
}

// Details about the work the de-identify operation performed.
type DeidentifyOperationMetadataResponse struct {
	// Details about the FHIR store to write the output to.
	FhirOutput FhirOutputResponse `pulumi:"fhirOutput"`
}

// Details about the work the de-identify operation performed.
type DeidentifyOperationMetadataResponseOutput struct{ *pulumi.OutputState }

func (DeidentifyOperationMetadataResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeidentifyOperationMetadataResponse)(nil)).Elem()
}

func (o DeidentifyOperationMetadataResponseOutput) ToDeidentifyOperationMetadataResponseOutput() DeidentifyOperationMetadataResponseOutput {
	return o
}

func (o DeidentifyOperationMetadataResponseOutput) ToDeidentifyOperationMetadataResponseOutputWithContext(ctx context.Context) DeidentifyOperationMetadataResponseOutput {
	return o
}

// Details about the FHIR store to write the output to.
func (o DeidentifyOperationMetadataResponseOutput) FhirOutput() FhirOutputResponseOutput {
	return o.ApplyT(func(v DeidentifyOperationMetadataResponse) FhirOutputResponse { return v.FhirOutput }).(FhirOutputResponseOutput)
}

// Delete tag.
type DeleteTag struct {
}

// DeleteTagInput is an input type that accepts DeleteTagArgs and DeleteTagOutput values.
// You can construct a concrete instance of `DeleteTagInput` via:
//
//	DeleteTagArgs{...}
type DeleteTagInput interface {
	pulumi.Input

	ToDeleteTagOutput() DeleteTagOutput
	ToDeleteTagOutputWithContext(context.Context) DeleteTagOutput
}

// Delete tag.
type DeleteTagArgs struct {
}

func (DeleteTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeleteTag)(nil)).Elem()
}

func (i DeleteTagArgs) ToDeleteTagOutput() DeleteTagOutput {
	return i.ToDeleteTagOutputWithContext(context.Background())
}

func (i DeleteTagArgs) ToDeleteTagOutputWithContext(ctx context.Context) DeleteTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeleteTagOutput)
}

func (i DeleteTagArgs) ToDeleteTagPtrOutput() DeleteTagPtrOutput {
	return i.ToDeleteTagPtrOutputWithContext(context.Background())
}

func (i DeleteTagArgs) ToDeleteTagPtrOutputWithContext(ctx context.Context) DeleteTagPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeleteTagOutput).ToDeleteTagPtrOutputWithContext(ctx)
}

// DeleteTagPtrInput is an input type that accepts DeleteTagArgs, DeleteTagPtr and DeleteTagPtrOutput values.
// You can construct a concrete instance of `DeleteTagPtrInput` via:
//
//	        DeleteTagArgs{...}
//
//	or:
//
//	        nil
type DeleteTagPtrInput interface {
	pulumi.Input

	ToDeleteTagPtrOutput() DeleteTagPtrOutput
	ToDeleteTagPtrOutputWithContext(context.Context) DeleteTagPtrOutput
}

type deleteTagPtrType DeleteTagArgs

func DeleteTagPtr(v *DeleteTagArgs) DeleteTagPtrInput {
	return (*deleteTagPtrType)(v)
}

func (*deleteTagPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeleteTag)(nil)).Elem()
}

func (i *deleteTagPtrType) ToDeleteTagPtrOutput() DeleteTagPtrOutput {
	return i.ToDeleteTagPtrOutputWithContext(context.Background())
}

func (i *deleteTagPtrType) ToDeleteTagPtrOutputWithContext(ctx context.Context) DeleteTagPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeleteTagPtrOutput)
}

// Delete tag.
type DeleteTagOutput struct{ *pulumi.OutputState }

func (DeleteTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeleteTag)(nil)).Elem()
}

func (o DeleteTagOutput) ToDeleteTagOutput() DeleteTagOutput {
	return o
}

func (o DeleteTagOutput) ToDeleteTagOutputWithContext(ctx context.Context) DeleteTagOutput {
	return o
}

func (o DeleteTagOutput) ToDeleteTagPtrOutput() DeleteTagPtrOutput {
	return o.ToDeleteTagPtrOutputWithContext(context.Background())
}

func (o DeleteTagOutput) ToDeleteTagPtrOutputWithContext(ctx context.Context) DeleteTagPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DeleteTag) *DeleteTag {
		return &v
	}).(DeleteTagPtrOutput)
}

type DeleteTagPtrOutput struct{ *pulumi.OutputState }

func (DeleteTagPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeleteTag)(nil)).Elem()
}

func (o DeleteTagPtrOutput) ToDeleteTagPtrOutput() DeleteTagPtrOutput {
	return o
}

func (o DeleteTagPtrOutput) ToDeleteTagPtrOutputWithContext(ctx context.Context) DeleteTagPtrOutput {
	return o
}

func (o DeleteTagPtrOutput) Elem() DeleteTagOutput {
	return o.ApplyT(func(v *DeleteTag) DeleteTag {
		if v != nil {
			return *v
		}
		var ret DeleteTag
		return ret
	}).(DeleteTagOutput)
}

// Delete tag.
type DeleteTagResponse struct {
}

// Delete tag.
type DeleteTagResponseOutput struct{ *pulumi.OutputState }

func (DeleteTagResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeleteTagResponse)(nil)).Elem()
}

func (o DeleteTagResponseOutput) ToDeleteTagResponseOutput() DeleteTagResponseOutput {
	return o
}

func (o DeleteTagResponseOutput) ToDeleteTagResponseOutputWithContext(ctx context.Context) DeleteTagResponseOutput {
	return o
}

// Contains multiple sensitive information findings for each resource slice.
type Detail struct {
	Findings []Finding `pulumi:"findings"`
}

// DetailInput is an input type that accepts DetailArgs and DetailOutput values.
// You can construct a concrete instance of `DetailInput` via:
//
//	DetailArgs{...}
type DetailInput interface {
	pulumi.Input

	ToDetailOutput() DetailOutput
	ToDetailOutputWithContext(context.Context) DetailOutput
}

// Contains multiple sensitive information findings for each resource slice.
type DetailArgs struct {
	Findings FindingArrayInput `pulumi:"findings"`
}

func (DetailArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Detail)(nil)).Elem()
}

func (i DetailArgs) ToDetailOutput() DetailOutput {
	return i.ToDetailOutputWithContext(context.Background())
}

func (i DetailArgs) ToDetailOutputWithContext(ctx context.Context) DetailOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DetailOutput)
}

// DetailMapInput is an input type that accepts DetailMap and DetailMapOutput values.
// You can construct a concrete instance of `DetailMapInput` via:
//
//	DetailMap{ "key": DetailArgs{...} }
type DetailMapInput interface {
	pulumi.Input

	ToDetailMapOutput() DetailMapOutput
	ToDetailMapOutputWithContext(context.Context) DetailMapOutput
}

type DetailMap map[string]DetailInput

func (DetailMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]Detail)(nil)).Elem()
}

func (i DetailMap) ToDetailMapOutput() DetailMapOutput {
	return i.ToDetailMapOutputWithContext(context.Background())
}

func (i DetailMap) ToDetailMapOutputWithContext(ctx context.Context) DetailMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DetailMapOutput)
}

// Contains multiple sensitive information findings for each resource slice.
type DetailOutput struct{ *pulumi.OutputState }

func (DetailOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Detail)(nil)).Elem()
}

func (o DetailOutput) ToDetailOutput() DetailOutput {
	return o
}

func (o DetailOutput) ToDetailOutputWithContext(ctx context.Context) DetailOutput {
	return o
}

func (o DetailOutput) Findings() FindingArrayOutput {
	return o.ApplyT(func(v Detail) []Finding { return v.Findings }).(FindingArrayOutput)
}

type DetailMapOutput struct{ *pulumi.OutputState }

func (DetailMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]Detail)(nil)).Elem()
}

func (o DetailMapOutput) ToDetailMapOutput() DetailMapOutput {
	return o
}

func (o DetailMapOutput) ToDetailMapOutputWithContext(ctx context.Context) DetailMapOutput {
	return o
}

func (o DetailMapOutput) MapIndex(k pulumi.StringInput) DetailOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) Detail {
		return vs[0].(map[string]Detail)[vs[1].(string)]
	}).(DetailOutput)
}

// Contains multiple sensitive information findings for each resource slice.
type DetailResponse struct {
	Findings []FindingResponse `pulumi:"findings"`
}

// Contains multiple sensitive information findings for each resource slice.
type DetailResponseOutput struct{ *pulumi.OutputState }

func (DetailResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DetailResponse)(nil)).Elem()
}

func (o DetailResponseOutput) ToDetailResponseOutput() DetailResponseOutput {
	return o
}

func (o DetailResponseOutput) ToDetailResponseOutputWithContext(ctx context.Context) DetailResponseOutput {
	return o
}

func (o DetailResponseOutput) Findings() FindingResponseArrayOutput {
	return o.ApplyT(func(v DetailResponse) []FindingResponse { return v.Findings }).(FindingResponseArrayOutput)
}

type DetailResponseMapOutput struct{ *pulumi.OutputState }

func (DetailResponseMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]DetailResponse)(nil)).Elem()
}

func (o DetailResponseMapOutput) ToDetailResponseMapOutput() DetailResponseMapOutput {
	return o
}

func (o DetailResponseMapOutput) ToDetailResponseMapOutputWithContext(ctx context.Context) DetailResponseMapOutput {
	return o
}

func (o DetailResponseMapOutput) MapIndex(k pulumi.StringInput) DetailResponseOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) DetailResponse {
		return vs[0].(map[string]DetailResponse)[vs[1].(string)]
	}).(DetailResponseOutput)
}

// Specifies the parameters needed for de-identification of DICOM stores.
type DicomConfig struct {
	// Tag filtering profile that determines which tags to keep/remove.
	FilterProfile *DicomConfigFilterProfile `pulumi:"filterProfile"`
	// List of tags to keep. Remove all other tags.
	KeepList *TagFilterList `pulumi:"keepList"`
	// List of tags to remove. Keep all other tags.
	RemoveList *TagFilterList `pulumi:"removeList"`
	// If true, skip replacing StudyInstanceUID, SeriesInstanceUID, SOPInstanceUID, and MediaStorageSOPInstanceUID and leave them untouched. The Cloud Healthcare API regenerates these UIDs by default based on the DICOM Standard's reasoning: "Whilst these UIDs cannot be mapped directly to an individual out of context, given access to the original images, or to a database of the original images containing the UIDs, it would be possible to recover the individual's identity." http://dicom.nema.org/medical/dicom/current/output/chtml/part15/sect_E.3.9.html
	SkipIdRedaction *bool `pulumi:"skipIdRedaction"`
}

// DicomConfigInput is an input type that accepts DicomConfigArgs and DicomConfigOutput values.
// You can construct a concrete instance of `DicomConfigInput` via:
//
//	DicomConfigArgs{...}
type DicomConfigInput interface {
	pulumi.Input

	ToDicomConfigOutput() DicomConfigOutput
	ToDicomConfigOutputWithContext(context.Context) DicomConfigOutput
}

// Specifies the parameters needed for de-identification of DICOM stores.
type DicomConfigArgs struct {
	// Tag filtering profile that determines which tags to keep/remove.
	FilterProfile DicomConfigFilterProfilePtrInput `pulumi:"filterProfile"`
	// List of tags to keep. Remove all other tags.
	KeepList TagFilterListPtrInput `pulumi:"keepList"`
	// List of tags to remove. Keep all other tags.
	RemoveList TagFilterListPtrInput `pulumi:"removeList"`
	// If true, skip replacing StudyInstanceUID, SeriesInstanceUID, SOPInstanceUID, and MediaStorageSOPInstanceUID and leave them untouched. The Cloud Healthcare API regenerates these UIDs by default based on the DICOM Standard's reasoning: "Whilst these UIDs cannot be mapped directly to an individual out of context, given access to the original images, or to a database of the original images containing the UIDs, it would be possible to recover the individual's identity." http://dicom.nema.org/medical/dicom/current/output/chtml/part15/sect_E.3.9.html
	SkipIdRedaction pulumi.BoolPtrInput `pulumi:"skipIdRedaction"`
}

func (DicomConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DicomConfig)(nil)).Elem()
}

func (i DicomConfigArgs) ToDicomConfigOutput() DicomConfigOutput {
	return i.ToDicomConfigOutputWithContext(context.Background())
}

func (i DicomConfigArgs) ToDicomConfigOutputWithContext(ctx context.Context) DicomConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DicomConfigOutput)
}

func (i DicomConfigArgs) ToDicomConfigPtrOutput() DicomConfigPtrOutput {
	return i.ToDicomConfigPtrOutputWithContext(context.Background())
}

func (i DicomConfigArgs) ToDicomConfigPtrOutputWithContext(ctx context.Context) DicomConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DicomConfigOutput).ToDicomConfigPtrOutputWithContext(ctx)
}

// DicomConfigPtrInput is an input type that accepts DicomConfigArgs, DicomConfigPtr and DicomConfigPtrOutput values.
// You can construct a concrete instance of `DicomConfigPtrInput` via:
//
//	        DicomConfigArgs{...}
//
//	or:
//
//	        nil
type DicomConfigPtrInput interface {
	pulumi.Input

	ToDicomConfigPtrOutput() DicomConfigPtrOutput
	ToDicomConfigPtrOutputWithContext(context.Context) DicomConfigPtrOutput
}

type dicomConfigPtrType DicomConfigArgs

func DicomConfigPtr(v *DicomConfigArgs) DicomConfigPtrInput {
	return (*dicomConfigPtrType)(v)
}

func (*dicomConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DicomConfig)(nil)).Elem()
}

func (i *dicomConfigPtrType) ToDicomConfigPtrOutput() DicomConfigPtrOutput {
	return i.ToDicomConfigPtrOutputWithContext(context.Background())
}

func (i *dicomConfigPtrType) ToDicomConfigPtrOutputWithContext(ctx context.Context) DicomConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DicomConfigPtrOutput)
}

// Specifies the parameters needed for de-identification of DICOM stores.
type DicomConfigOutput struct{ *pulumi.OutputState }

func (DicomConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DicomConfig)(nil)).Elem()
}

func (o DicomConfigOutput) ToDicomConfigOutput() DicomConfigOutput {
	return o
}

func (o DicomConfigOutput) ToDicomConfigOutputWithContext(ctx context.Context) DicomConfigOutput {
	return o
}

func (o DicomConfigOutput) ToDicomConfigPtrOutput() DicomConfigPtrOutput {
	return o.ToDicomConfigPtrOutputWithContext(context.Background())
}

func (o DicomConfigOutput) ToDicomConfigPtrOutputWithContext(ctx context.Context) DicomConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DicomConfig) *DicomConfig {
		return &v
	}).(DicomConfigPtrOutput)
}

// Tag filtering profile that determines which tags to keep/remove.
func (o DicomConfigOutput) FilterProfile() DicomConfigFilterProfilePtrOutput {
	return o.ApplyT(func(v DicomConfig) *DicomConfigFilterProfile { return v.FilterProfile }).(DicomConfigFilterProfilePtrOutput)
}

// List of tags to keep. Remove all other tags.
func (o DicomConfigOutput) KeepList() TagFilterListPtrOutput {
	return o.ApplyT(func(v DicomConfig) *TagFilterList { return v.KeepList }).(TagFilterListPtrOutput)
}

// List of tags to remove. Keep all other tags.
func (o DicomConfigOutput) RemoveList() TagFilterListPtrOutput {
	return o.ApplyT(func(v DicomConfig) *TagFilterList { return v.RemoveList }).(TagFilterListPtrOutput)
}

// If true, skip replacing StudyInstanceUID, SeriesInstanceUID, SOPInstanceUID, and MediaStorageSOPInstanceUID and leave them untouched. The Cloud Healthcare API regenerates these UIDs by default based on the DICOM Standard's reasoning: "Whilst these UIDs cannot be mapped directly to an individual out of context, given access to the original images, or to a database of the original images containing the UIDs, it would be possible to recover the individual's identity." http://dicom.nema.org/medical/dicom/current/output/chtml/part15/sect_E.3.9.html
func (o DicomConfigOutput) SkipIdRedaction() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DicomConfig) *bool { return v.SkipIdRedaction }).(pulumi.BoolPtrOutput)
}

type DicomConfigPtrOutput struct{ *pulumi.OutputState }

func (DicomConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DicomConfig)(nil)).Elem()
}

func (o DicomConfigPtrOutput) ToDicomConfigPtrOutput() DicomConfigPtrOutput {
	return o
}

func (o DicomConfigPtrOutput) ToDicomConfigPtrOutputWithContext(ctx context.Context) DicomConfigPtrOutput {
	return o
}

func (o DicomConfigPtrOutput) Elem() DicomConfigOutput {
	return o.ApplyT(func(v *DicomConfig) DicomConfig {
		if v != nil {
			return *v
		}
		var ret DicomConfig
		return ret
	}).(DicomConfigOutput)
}

// Tag filtering profile that determines which tags to keep/remove.
func (o DicomConfigPtrOutput) FilterProfile() DicomConfigFilterProfilePtrOutput {
	return o.ApplyT(func(v *DicomConfig) *DicomConfigFilterProfile {
		if v == nil {
			return nil
		}
		return v.FilterProfile
	}).(DicomConfigFilterProfilePtrOutput)
}

// List of tags to keep. Remove all other tags.
func (o DicomConfigPtrOutput) KeepList() TagFilterListPtrOutput {
	return o.ApplyT(func(v *DicomConfig) *TagFilterList {
		if v == nil {
			return nil
		}
		return v.KeepList
	}).(TagFilterListPtrOutput)
}

// List of tags to remove. Keep all other tags.
func (o DicomConfigPtrOutput) RemoveList() TagFilterListPtrOutput {
	return o.ApplyT(func(v *DicomConfig) *TagFilterList {
		if v == nil {
			return nil
		}
		return v.RemoveList
	}).(TagFilterListPtrOutput)
}

// If true, skip replacing StudyInstanceUID, SeriesInstanceUID, SOPInstanceUID, and MediaStorageSOPInstanceUID and leave them untouched. The Cloud Healthcare API regenerates these UIDs by default based on the DICOM Standard's reasoning: "Whilst these UIDs cannot be mapped directly to an individual out of context, given access to the original images, or to a database of the original images containing the UIDs, it would be possible to recover the individual's identity." http://dicom.nema.org/medical/dicom/current/output/chtml/part15/sect_E.3.9.html
func (o DicomConfigPtrOutput) SkipIdRedaction() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DicomConfig) *bool {
		if v == nil {
			return nil
		}
		return v.SkipIdRedaction
	}).(pulumi.BoolPtrOutput)
}

// Specifies the parameters needed for de-identification of DICOM stores.
type DicomConfigResponse struct {
	// Tag filtering profile that determines which tags to keep/remove.
	FilterProfile string `pulumi:"filterProfile"`
	// List of tags to keep. Remove all other tags.
	KeepList TagFilterListResponse `pulumi:"keepList"`
	// List of tags to remove. Keep all other tags.
	RemoveList TagFilterListResponse `pulumi:"removeList"`
	// If true, skip replacing StudyInstanceUID, SeriesInstanceUID, SOPInstanceUID, and MediaStorageSOPInstanceUID and leave them untouched. The Cloud Healthcare API regenerates these UIDs by default based on the DICOM Standard's reasoning: "Whilst these UIDs cannot be mapped directly to an individual out of context, given access to the original images, or to a database of the original images containing the UIDs, it would be possible to recover the individual's identity." http://dicom.nema.org/medical/dicom/current/output/chtml/part15/sect_E.3.9.html
	SkipIdRedaction bool `pulumi:"skipIdRedaction"`
}

// Specifies the parameters needed for de-identification of DICOM stores.
type DicomConfigResponseOutput struct{ *pulumi.OutputState }

func (DicomConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DicomConfigResponse)(nil)).Elem()
}

func (o DicomConfigResponseOutput) ToDicomConfigResponseOutput() DicomConfigResponseOutput {
	return o
}

func (o DicomConfigResponseOutput) ToDicomConfigResponseOutputWithContext(ctx context.Context) DicomConfigResponseOutput {
	return o
}

// Tag filtering profile that determines which tags to keep/remove.
func (o DicomConfigResponseOutput) FilterProfile() pulumi.StringOutput {
	return o.ApplyT(func(v DicomConfigResponse) string { return v.FilterProfile }).(pulumi.StringOutput)
}

// List of tags to keep. Remove all other tags.
func (o DicomConfigResponseOutput) KeepList() TagFilterListResponseOutput {
	return o.ApplyT(func(v DicomConfigResponse) TagFilterListResponse { return v.KeepList }).(TagFilterListResponseOutput)
}

// List of tags to remove. Keep all other tags.
func (o DicomConfigResponseOutput) RemoveList() TagFilterListResponseOutput {
	return o.ApplyT(func(v DicomConfigResponse) TagFilterListResponse { return v.RemoveList }).(TagFilterListResponseOutput)
}

// If true, skip replacing StudyInstanceUID, SeriesInstanceUID, SOPInstanceUID, and MediaStorageSOPInstanceUID and leave them untouched. The Cloud Healthcare API regenerates these UIDs by default based on the DICOM Standard's reasoning: "Whilst these UIDs cannot be mapped directly to an individual out of context, given access to the original images, or to a database of the original images containing the UIDs, it would be possible to recover the individual's identity." http://dicom.nema.org/medical/dicom/current/output/chtml/part15/sect_E.3.9.html
func (o DicomConfigResponseOutput) SkipIdRedaction() pulumi.BoolOutput {
	return o.ApplyT(func(v DicomConfigResponse) bool { return v.SkipIdRedaction }).(pulumi.BoolOutput)
}

// Specifies the parameters needed for the de-identification of DICOM stores.
type DicomTagConfig struct {
	// Specifies custom tag selections and `Actions` to apply to them. Overrides `options` and `profile`. Conflicting `Actions` are applied in the order given.
	Actions []Action `pulumi:"actions"`
	// Specifies additional options to apply, overriding the base `profile`.
	Options *Options `pulumi:"options"`
	// Base profile type for handling DICOM tags.
	ProfileType *DicomTagConfigProfileType `pulumi:"profileType"`
}

// DicomTagConfigInput is an input type that accepts DicomTagConfigArgs and DicomTagConfigOutput values.
// You can construct a concrete instance of `DicomTagConfigInput` via:
//
//	DicomTagConfigArgs{...}
type DicomTagConfigInput interface {
	pulumi.Input

	ToDicomTagConfigOutput() DicomTagConfigOutput
	ToDicomTagConfigOutputWithContext(context.Context) DicomTagConfigOutput
}

// Specifies the parameters needed for the de-identification of DICOM stores.
type DicomTagConfigArgs struct {
	// Specifies custom tag selections and `Actions` to apply to them. Overrides `options` and `profile`. Conflicting `Actions` are applied in the order given.
	Actions ActionArrayInput `pulumi:"actions"`
	// Specifies additional options to apply, overriding the base `profile`.
	Options OptionsPtrInput `pulumi:"options"`
	// Base profile type for handling DICOM tags.
	ProfileType DicomTagConfigProfileTypePtrInput `pulumi:"profileType"`
}

func (DicomTagConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DicomTagConfig)(nil)).Elem()
}

func (i DicomTagConfigArgs) ToDicomTagConfigOutput() DicomTagConfigOutput {
	return i.ToDicomTagConfigOutputWithContext(context.Background())
}

func (i DicomTagConfigArgs) ToDicomTagConfigOutputWithContext(ctx context.Context) DicomTagConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DicomTagConfigOutput)
}

func (i DicomTagConfigArgs) ToDicomTagConfigPtrOutput() DicomTagConfigPtrOutput {
	return i.ToDicomTagConfigPtrOutputWithContext(context.Background())
}

func (i DicomTagConfigArgs) ToDicomTagConfigPtrOutputWithContext(ctx context.Context) DicomTagConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DicomTagConfigOutput).ToDicomTagConfigPtrOutputWithContext(ctx)
}

// DicomTagConfigPtrInput is an input type that accepts DicomTagConfigArgs, DicomTagConfigPtr and DicomTagConfigPtrOutput values.
// You can construct a concrete instance of `DicomTagConfigPtrInput` via:
//
//	        DicomTagConfigArgs{...}
//
//	or:
//
//	        nil
type DicomTagConfigPtrInput interface {
	pulumi.Input

	ToDicomTagConfigPtrOutput() DicomTagConfigPtrOutput
	ToDicomTagConfigPtrOutputWithContext(context.Context) DicomTagConfigPtrOutput
}

type dicomTagConfigPtrType DicomTagConfigArgs

func DicomTagConfigPtr(v *DicomTagConfigArgs) DicomTagConfigPtrInput {
	return (*dicomTagConfigPtrType)(v)
}

func (*dicomTagConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DicomTagConfig)(nil)).Elem()
}

func (i *dicomTagConfigPtrType) ToDicomTagConfigPtrOutput() DicomTagConfigPtrOutput {
	return i.ToDicomTagConfigPtrOutputWithContext(context.Background())
}

func (i *dicomTagConfigPtrType) ToDicomTagConfigPtrOutputWithContext(ctx context.Context) DicomTagConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DicomTagConfigPtrOutput)
}

// Specifies the parameters needed for the de-identification of DICOM stores.
type DicomTagConfigOutput struct{ *pulumi.OutputState }

func (DicomTagConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DicomTagConfig)(nil)).Elem()
}

func (o DicomTagConfigOutput) ToDicomTagConfigOutput() DicomTagConfigOutput {
	return o
}

func (o DicomTagConfigOutput) ToDicomTagConfigOutputWithContext(ctx context.Context) DicomTagConfigOutput {
	return o
}

func (o DicomTagConfigOutput) ToDicomTagConfigPtrOutput() DicomTagConfigPtrOutput {
	return o.ToDicomTagConfigPtrOutputWithContext(context.Background())
}

func (o DicomTagConfigOutput) ToDicomTagConfigPtrOutputWithContext(ctx context.Context) DicomTagConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DicomTagConfig) *DicomTagConfig {
		return &v
	}).(DicomTagConfigPtrOutput)
}

// Specifies custom tag selections and `Actions` to apply to them. Overrides `options` and `profile`. Conflicting `Actions` are applied in the order given.
func (o DicomTagConfigOutput) Actions() ActionArrayOutput {
	return o.ApplyT(func(v DicomTagConfig) []Action { return v.Actions }).(ActionArrayOutput)
}

// Specifies additional options to apply, overriding the base `profile`.
func (o DicomTagConfigOutput) Options() OptionsPtrOutput {
	return o.ApplyT(func(v DicomTagConfig) *Options { return v.Options }).(OptionsPtrOutput)
}

// Base profile type for handling DICOM tags.
func (o DicomTagConfigOutput) ProfileType() DicomTagConfigProfileTypePtrOutput {
	return o.ApplyT(func(v DicomTagConfig) *DicomTagConfigProfileType { return v.ProfileType }).(DicomTagConfigProfileTypePtrOutput)
}

type DicomTagConfigPtrOutput struct{ *pulumi.OutputState }

func (DicomTagConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DicomTagConfig)(nil)).Elem()
}

func (o DicomTagConfigPtrOutput) ToDicomTagConfigPtrOutput() DicomTagConfigPtrOutput {
	return o
}

func (o DicomTagConfigPtrOutput) ToDicomTagConfigPtrOutputWithContext(ctx context.Context) DicomTagConfigPtrOutput {
	return o
}

func (o DicomTagConfigPtrOutput) Elem() DicomTagConfigOutput {
	return o.ApplyT(func(v *DicomTagConfig) DicomTagConfig {
		if v != nil {
			return *v
		}
		var ret DicomTagConfig
		return ret
	}).(DicomTagConfigOutput)
}

// Specifies custom tag selections and `Actions` to apply to them. Overrides `options` and `profile`. Conflicting `Actions` are applied in the order given.
func (o DicomTagConfigPtrOutput) Actions() ActionArrayOutput {
	return o.ApplyT(func(v *DicomTagConfig) []Action {
		if v == nil {
			return nil
		}
		return v.Actions
	}).(ActionArrayOutput)
}

// Specifies additional options to apply, overriding the base `profile`.
func (o DicomTagConfigPtrOutput) Options() OptionsPtrOutput {
	return o.ApplyT(func(v *DicomTagConfig) *Options {
		if v == nil {
			return nil
		}
		return v.Options
	}).(OptionsPtrOutput)
}

// Base profile type for handling DICOM tags.
func (o DicomTagConfigPtrOutput) ProfileType() DicomTagConfigProfileTypePtrOutput {
	return o.ApplyT(func(v *DicomTagConfig) *DicomTagConfigProfileType {
		if v == nil {
			return nil
		}
		return v.ProfileType
	}).(DicomTagConfigProfileTypePtrOutput)
}

// Specifies the parameters needed for the de-identification of DICOM stores.
type DicomTagConfigResponse struct {
	// Specifies custom tag selections and `Actions` to apply to them. Overrides `options` and `profile`. Conflicting `Actions` are applied in the order given.
	Actions []ActionResponse `pulumi:"actions"`
	// Specifies additional options to apply, overriding the base `profile`.
	Options OptionsResponse `pulumi:"options"`
	// Base profile type for handling DICOM tags.
	ProfileType string `pulumi:"profileType"`
}

// Specifies the parameters needed for the de-identification of DICOM stores.
type DicomTagConfigResponseOutput struct{ *pulumi.OutputState }

func (DicomTagConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DicomTagConfigResponse)(nil)).Elem()
}

func (o DicomTagConfigResponseOutput) ToDicomTagConfigResponseOutput() DicomTagConfigResponseOutput {
	return o
}

func (o DicomTagConfigResponseOutput) ToDicomTagConfigResponseOutputWithContext(ctx context.Context) DicomTagConfigResponseOutput {
	return o
}

// Specifies custom tag selections and `Actions` to apply to them. Overrides `options` and `profile`. Conflicting `Actions` are applied in the order given.
func (o DicomTagConfigResponseOutput) Actions() ActionResponseArrayOutput {
	return o.ApplyT(func(v DicomTagConfigResponse) []ActionResponse { return v.Actions }).(ActionResponseArrayOutput)
}

// Specifies additional options to apply, overriding the base `profile`.
func (o DicomTagConfigResponseOutput) Options() OptionsResponseOutput {
	return o.ApplyT(func(v DicomTagConfigResponse) OptionsResponse { return v.Options }).(OptionsResponseOutput)
}

// Base profile type for handling DICOM tags.
func (o DicomTagConfigResponseOutput) ProfileType() pulumi.StringOutput {
	return o.ApplyT(func(v DicomTagConfigResponse) string { return v.ProfileType }).(pulumi.StringOutput)
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type Expr struct {
	// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
	Description *string `pulumi:"description"`
	// Textual representation of an expression in Common Expression Language syntax.
	Expression *string `pulumi:"expression"`
	// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
	Location *string `pulumi:"location"`
	// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
	Title *string `pulumi:"title"`
}

// ExprInput is an input type that accepts ExprArgs and ExprOutput values.
// You can construct a concrete instance of `ExprInput` via:
//
//	ExprArgs{...}
type ExprInput interface {
	pulumi.Input

	ToExprOutput() ExprOutput
	ToExprOutputWithContext(context.Context) ExprOutput
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprArgs struct {
	// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Textual representation of an expression in Common Expression Language syntax.
	Expression pulumi.StringPtrInput `pulumi:"expression"`
	// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
	Location pulumi.StringPtrInput `pulumi:"location"`
	// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
	Title pulumi.StringPtrInput `pulumi:"title"`
}

func (ExprArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Expr)(nil)).Elem()
}

func (i ExprArgs) ToExprOutput() ExprOutput {
	return i.ToExprOutputWithContext(context.Background())
}

func (i ExprArgs) ToExprOutputWithContext(ctx context.Context) ExprOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExprOutput)
}

func (i ExprArgs) ToExprPtrOutput() ExprPtrOutput {
	return i.ToExprPtrOutputWithContext(context.Background())
}

func (i ExprArgs) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExprOutput).ToExprPtrOutputWithContext(ctx)
}

// ExprPtrInput is an input type that accepts ExprArgs, ExprPtr and ExprPtrOutput values.
// You can construct a concrete instance of `ExprPtrInput` via:
//
//	        ExprArgs{...}
//
//	or:
//
//	        nil
type ExprPtrInput interface {
	pulumi.Input

	ToExprPtrOutput() ExprPtrOutput
	ToExprPtrOutputWithContext(context.Context) ExprPtrOutput
}

type exprPtrType ExprArgs

func ExprPtr(v *ExprArgs) ExprPtrInput {
	return (*exprPtrType)(v)
}

func (*exprPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Expr)(nil)).Elem()
}

func (i *exprPtrType) ToExprPtrOutput() ExprPtrOutput {
	return i.ToExprPtrOutputWithContext(context.Background())
}

func (i *exprPtrType) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExprPtrOutput)
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprOutput struct{ *pulumi.OutputState }

func (ExprOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Expr)(nil)).Elem()
}

func (o ExprOutput) ToExprOutput() ExprOutput {
	return o
}

func (o ExprOutput) ToExprOutputWithContext(ctx context.Context) ExprOutput {
	return o
}

func (o ExprOutput) ToExprPtrOutput() ExprPtrOutput {
	return o.ToExprPtrOutputWithContext(context.Background())
}

func (o ExprOutput) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Expr) *Expr {
		return &v
	}).(ExprPtrOutput)
}

// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
func (o ExprOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Textual representation of an expression in Common Expression Language syntax.
func (o ExprOutput) Expression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Expression }).(pulumi.StringPtrOutput)
}

// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
func (o ExprOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Location }).(pulumi.StringPtrOutput)
}

// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
func (o ExprOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Expr) *string { return v.Title }).(pulumi.StringPtrOutput)
}

type ExprPtrOutput struct{ *pulumi.OutputState }

func (ExprPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Expr)(nil)).Elem()
}

func (o ExprPtrOutput) ToExprPtrOutput() ExprPtrOutput {
	return o
}

func (o ExprPtrOutput) ToExprPtrOutputWithContext(ctx context.Context) ExprPtrOutput {
	return o
}

func (o ExprPtrOutput) Elem() ExprOutput {
	return o.ApplyT(func(v *Expr) Expr {
		if v != nil {
			return *v
		}
		var ret Expr
		return ret
	}).(ExprOutput)
}

// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
func (o ExprPtrOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Description
	}).(pulumi.StringPtrOutput)
}

// Textual representation of an expression in Common Expression Language syntax.
func (o ExprPtrOutput) Expression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Expression
	}).(pulumi.StringPtrOutput)
}

// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
func (o ExprPtrOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Location
	}).(pulumi.StringPtrOutput)
}

// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
func (o ExprPtrOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Expr) *string {
		if v == nil {
			return nil
		}
		return v.Title
	}).(pulumi.StringPtrOutput)
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprResponse struct {
	// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
	Description string `pulumi:"description"`
	// Textual representation of an expression in Common Expression Language syntax.
	Expression string `pulumi:"expression"`
	// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
	Location string `pulumi:"location"`
	// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
	Title string `pulumi:"title"`
}

// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
type ExprResponseOutput struct{ *pulumi.OutputState }

func (ExprResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ExprResponse)(nil)).Elem()
}

func (o ExprResponseOutput) ToExprResponseOutput() ExprResponseOutput {
	return o
}

func (o ExprResponseOutput) ToExprResponseOutputWithContext(ctx context.Context) ExprResponseOutput {
	return o
}

// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
func (o ExprResponseOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v ExprResponse) string { return v.Description }).(pulumi.StringOutput)
}

// Textual representation of an expression in Common Expression Language syntax.
func (o ExprResponseOutput) Expression() pulumi.StringOutput {
	return o.ApplyT(func(v ExprResponse) string { return v.Expression }).(pulumi.StringOutput)
}

// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
func (o ExprResponseOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v ExprResponse) string { return v.Location }).(pulumi.StringOutput)
}

// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
func (o ExprResponseOutput) Title() pulumi.StringOutput {
	return o.ApplyT(func(v ExprResponse) string { return v.Title }).(pulumi.StringOutput)
}

// Specifies how to handle de-identification of a FHIR store.
type FhirConfig struct {
	// The behaviour for handling FHIR extensions that aren't otherwise specified for de-identification. If true, all extensions are preserved during de-identification by default. If false or unspecified, all extensions are removed during de-identification by default.
	DefaultKeepExtensions *bool `pulumi:"defaultKeepExtensions"`
	// Specifies FHIR paths to match and how to transform them. Any field that is not matched by a FieldMetadata is passed through to the output dataset unmodified. All extensions will be processed according to `default_keep_extensions`. If a field can be matched by more than one FieldMetadata, the first FieldMetadata.Action is applied.
	FieldMetadataList []FieldMetadata `pulumi:"fieldMetadataList"`
}

// FhirConfigInput is an input type that accepts FhirConfigArgs and FhirConfigOutput values.
// You can construct a concrete instance of `FhirConfigInput` via:
//
//	FhirConfigArgs{...}
type FhirConfigInput interface {
	pulumi.Input

	ToFhirConfigOutput() FhirConfigOutput
	ToFhirConfigOutputWithContext(context.Context) FhirConfigOutput
}

// Specifies how to handle de-identification of a FHIR store.
type FhirConfigArgs struct {
	// The behaviour for handling FHIR extensions that aren't otherwise specified for de-identification. If true, all extensions are preserved during de-identification by default. If false or unspecified, all extensions are removed during de-identification by default.
	DefaultKeepExtensions pulumi.BoolPtrInput `pulumi:"defaultKeepExtensions"`
	// Specifies FHIR paths to match and how to transform them. Any field that is not matched by a FieldMetadata is passed through to the output dataset unmodified. All extensions will be processed according to `default_keep_extensions`. If a field can be matched by more than one FieldMetadata, the first FieldMetadata.Action is applied.
	FieldMetadataList FieldMetadataArrayInput `pulumi:"fieldMetadataList"`
}

func (FhirConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FhirConfig)(nil)).Elem()
}

func (i FhirConfigArgs) ToFhirConfigOutput() FhirConfigOutput {
	return i.ToFhirConfigOutputWithContext(context.Background())
}

func (i FhirConfigArgs) ToFhirConfigOutputWithContext(ctx context.Context) FhirConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FhirConfigOutput)
}

func (i FhirConfigArgs) ToFhirConfigPtrOutput() FhirConfigPtrOutput {
	return i.ToFhirConfigPtrOutputWithContext(context.Background())
}

func (i FhirConfigArgs) ToFhirConfigPtrOutputWithContext(ctx context.Context) FhirConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FhirConfigOutput).ToFhirConfigPtrOutputWithContext(ctx)
}

// FhirConfigPtrInput is an input type that accepts FhirConfigArgs, FhirConfigPtr and FhirConfigPtrOutput values.
// You can construct a concrete instance of `FhirConfigPtrInput` via:
//
//	        FhirConfigArgs{...}
//
//	or:
//
//	        nil
type FhirConfigPtrInput interface {
	pulumi.Input

	ToFhirConfigPtrOutput() FhirConfigPtrOutput
	ToFhirConfigPtrOutputWithContext(context.Context) FhirConfigPtrOutput
}

type fhirConfigPtrType FhirConfigArgs

func FhirConfigPtr(v *FhirConfigArgs) FhirConfigPtrInput {
	return (*fhirConfigPtrType)(v)
}

func (*fhirConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FhirConfig)(nil)).Elem()
}

func (i *fhirConfigPtrType) ToFhirConfigPtrOutput() FhirConfigPtrOutput {
	return i.ToFhirConfigPtrOutputWithContext(context.Background())
}

func (i *fhirConfigPtrType) ToFhirConfigPtrOutputWithContext(ctx context.Context) FhirConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FhirConfigPtrOutput)
}

// Specifies how to handle de-identification of a FHIR store.
type FhirConfigOutput struct{ *pulumi.OutputState }

func (FhirConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FhirConfig)(nil)).Elem()
}

func (o FhirConfigOutput) ToFhirConfigOutput() FhirConfigOutput {
	return o
}

func (o FhirConfigOutput) ToFhirConfigOutputWithContext(ctx context.Context) FhirConfigOutput {
	return o
}

func (o FhirConfigOutput) ToFhirConfigPtrOutput() FhirConfigPtrOutput {
	return o.ToFhirConfigPtrOutputWithContext(context.Background())
}

func (o FhirConfigOutput) ToFhirConfigPtrOutputWithContext(ctx context.Context) FhirConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FhirConfig) *FhirConfig {
		return &v
	}).(FhirConfigPtrOutput)
}

// The behaviour for handling FHIR extensions that aren't otherwise specified for de-identification. If true, all extensions are preserved during de-identification by default. If false or unspecified, all extensions are removed during de-identification by default.
func (o FhirConfigOutput) DefaultKeepExtensions() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v FhirConfig) *bool { return v.DefaultKeepExtensions }).(pulumi.BoolPtrOutput)
}

// Specifies FHIR paths to match and how to transform them. Any field that is not matched by a FieldMetadata is passed through to the output dataset unmodified. All extensions will be processed according to `default_keep_extensions`. If a field can be matched by more than one FieldMetadata, the first FieldMetadata.Action is applied.
func (o FhirConfigOutput) FieldMetadataList() FieldMetadataArrayOutput {
	return o.ApplyT(func(v FhirConfig) []FieldMetadata { return v.FieldMetadataList }).(FieldMetadataArrayOutput)
}

type FhirConfigPtrOutput struct{ *pulumi.OutputState }

func (FhirConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FhirConfig)(nil)).Elem()
}

func (o FhirConfigPtrOutput) ToFhirConfigPtrOutput() FhirConfigPtrOutput {
	return o
}

func (o FhirConfigPtrOutput) ToFhirConfigPtrOutputWithContext(ctx context.Context) FhirConfigPtrOutput {
	return o
}

func (o FhirConfigPtrOutput) Elem() FhirConfigOutput {
	return o.ApplyT(func(v *FhirConfig) FhirConfig {
		if v != nil {
			return *v
		}
		var ret FhirConfig
		return ret
	}).(FhirConfigOutput)
}

// The behaviour for handling FHIR extensions that aren't otherwise specified for de-identification. If true, all extensions are preserved during de-identification by default. If false or unspecified, all extensions are removed during de-identification by default.
func (o FhirConfigPtrOutput) DefaultKeepExtensions() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *FhirConfig) *bool {
		if v == nil {
			return nil
		}
		return v.DefaultKeepExtensions
	}).(pulumi.BoolPtrOutput)
}

// Specifies FHIR paths to match and how to transform them. Any field that is not matched by a FieldMetadata is passed through to the output dataset unmodified. All extensions will be processed according to `default_keep_extensions`. If a field can be matched by more than one FieldMetadata, the first FieldMetadata.Action is applied.
func (o FhirConfigPtrOutput) FieldMetadataList() FieldMetadataArrayOutput {
	return o.ApplyT(func(v *FhirConfig) []FieldMetadata {
		if v == nil {
			return nil
		}
		return v.FieldMetadataList
	}).(FieldMetadataArrayOutput)
}

// Specifies how to handle de-identification of a FHIR store.
type FhirConfigResponse struct {
	// The behaviour for handling FHIR extensions that aren't otherwise specified for de-identification. If true, all extensions are preserved during de-identification by default. If false or unspecified, all extensions are removed during de-identification by default.
	DefaultKeepExtensions bool `pulumi:"defaultKeepExtensions"`
	// Specifies FHIR paths to match and how to transform them. Any field that is not matched by a FieldMetadata is passed through to the output dataset unmodified. All extensions will be processed according to `default_keep_extensions`. If a field can be matched by more than one FieldMetadata, the first FieldMetadata.Action is applied.
	FieldMetadataList []FieldMetadataResponse `pulumi:"fieldMetadataList"`
}

// Specifies how to handle de-identification of a FHIR store.
type FhirConfigResponseOutput struct{ *pulumi.OutputState }

func (FhirConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FhirConfigResponse)(nil)).Elem()
}

func (o FhirConfigResponseOutput) ToFhirConfigResponseOutput() FhirConfigResponseOutput {
	return o
}

func (o FhirConfigResponseOutput) ToFhirConfigResponseOutputWithContext(ctx context.Context) FhirConfigResponseOutput {
	return o
}

// The behaviour for handling FHIR extensions that aren't otherwise specified for de-identification. If true, all extensions are preserved during de-identification by default. If false or unspecified, all extensions are removed during de-identification by default.
func (o FhirConfigResponseOutput) DefaultKeepExtensions() pulumi.BoolOutput {
	return o.ApplyT(func(v FhirConfigResponse) bool { return v.DefaultKeepExtensions }).(pulumi.BoolOutput)
}

// Specifies FHIR paths to match and how to transform them. Any field that is not matched by a FieldMetadata is passed through to the output dataset unmodified. All extensions will be processed according to `default_keep_extensions`. If a field can be matched by more than one FieldMetadata, the first FieldMetadata.Action is applied.
func (o FhirConfigResponseOutput) FieldMetadataList() FieldMetadataResponseArrayOutput {
	return o.ApplyT(func(v FhirConfigResponse) []FieldMetadataResponse { return v.FieldMetadataList }).(FieldMetadataResponseArrayOutput)
}

// Specifies how to handle the de-identification of a FHIR store.
type FhirFieldConfig struct {
	// Specifies FHIR paths to match and how to transform them. Any field that is not matched by a FieldMetadata `action` is passed through to the output dataset unmodified. All extensions will be processed according to keep_extensions. If a field can be matched by more than one FieldMetadata `action`, the first `action` option is applied. Overrides options and the union field `profile` in FhirFieldConfig.
	FieldMetadataList []GoogleCloudHealthcareV1beta1DeidentifyFieldMetadata `pulumi:"fieldMetadataList"`
	// Specifies additional options, overriding the base ProfileType.
	Options *GoogleCloudHealthcareV1beta1DeidentifyOptions `pulumi:"options"`
	// Base profile type for handling FHIR fields.
	ProfileType *FhirFieldConfigProfileType `pulumi:"profileType"`
}

// FhirFieldConfigInput is an input type that accepts FhirFieldConfigArgs and FhirFieldConfigOutput values.
// You can construct a concrete instance of `FhirFieldConfigInput` via:
//
//	FhirFieldConfigArgs{...}
type FhirFieldConfigInput interface {
	pulumi.Input

	ToFhirFieldConfigOutput() FhirFieldConfigOutput
	ToFhirFieldConfigOutputWithContext(context.Context) FhirFieldConfigOutput
}

// Specifies how to handle the de-identification of a FHIR store.
type FhirFieldConfigArgs struct {
	// Specifies FHIR paths to match and how to transform them. Any field that is not matched by a FieldMetadata `action` is passed through to the output dataset unmodified. All extensions will be processed according to keep_extensions. If a field can be matched by more than one FieldMetadata `action`, the first `action` option is applied. Overrides options and the union field `profile` in FhirFieldConfig.
	FieldMetadataList GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayInput `pulumi:"fieldMetadataList"`
	// Specifies additional options, overriding the base ProfileType.
	Options GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrInput `pulumi:"options"`
	// Base profile type for handling FHIR fields.
	ProfileType FhirFieldConfigProfileTypePtrInput `pulumi:"profileType"`
}

func (FhirFieldConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FhirFieldConfig)(nil)).Elem()
}

func (i FhirFieldConfigArgs) ToFhirFieldConfigOutput() FhirFieldConfigOutput {
	return i.ToFhirFieldConfigOutputWithContext(context.Background())
}

func (i FhirFieldConfigArgs) ToFhirFieldConfigOutputWithContext(ctx context.Context) FhirFieldConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FhirFieldConfigOutput)
}

func (i FhirFieldConfigArgs) ToFhirFieldConfigPtrOutput() FhirFieldConfigPtrOutput {
	return i.ToFhirFieldConfigPtrOutputWithContext(context.Background())
}

func (i FhirFieldConfigArgs) ToFhirFieldConfigPtrOutputWithContext(ctx context.Context) FhirFieldConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FhirFieldConfigOutput).ToFhirFieldConfigPtrOutputWithContext(ctx)
}

// FhirFieldConfigPtrInput is an input type that accepts FhirFieldConfigArgs, FhirFieldConfigPtr and FhirFieldConfigPtrOutput values.
// You can construct a concrete instance of `FhirFieldConfigPtrInput` via:
//
//	        FhirFieldConfigArgs{...}
//
//	or:
//
//	        nil
type FhirFieldConfigPtrInput interface {
	pulumi.Input

	ToFhirFieldConfigPtrOutput() FhirFieldConfigPtrOutput
	ToFhirFieldConfigPtrOutputWithContext(context.Context) FhirFieldConfigPtrOutput
}

type fhirFieldConfigPtrType FhirFieldConfigArgs

func FhirFieldConfigPtr(v *FhirFieldConfigArgs) FhirFieldConfigPtrInput {
	return (*fhirFieldConfigPtrType)(v)
}

func (*fhirFieldConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FhirFieldConfig)(nil)).Elem()
}

func (i *fhirFieldConfigPtrType) ToFhirFieldConfigPtrOutput() FhirFieldConfigPtrOutput {
	return i.ToFhirFieldConfigPtrOutputWithContext(context.Background())
}

func (i *fhirFieldConfigPtrType) ToFhirFieldConfigPtrOutputWithContext(ctx context.Context) FhirFieldConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FhirFieldConfigPtrOutput)
}

// Specifies how to handle the de-identification of a FHIR store.
type FhirFieldConfigOutput struct{ *pulumi.OutputState }

func (FhirFieldConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FhirFieldConfig)(nil)).Elem()
}

func (o FhirFieldConfigOutput) ToFhirFieldConfigOutput() FhirFieldConfigOutput {
	return o
}

func (o FhirFieldConfigOutput) ToFhirFieldConfigOutputWithContext(ctx context.Context) FhirFieldConfigOutput {
	return o
}

func (o FhirFieldConfigOutput) ToFhirFieldConfigPtrOutput() FhirFieldConfigPtrOutput {
	return o.ToFhirFieldConfigPtrOutputWithContext(context.Background())
}

func (o FhirFieldConfigOutput) ToFhirFieldConfigPtrOutputWithContext(ctx context.Context) FhirFieldConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FhirFieldConfig) *FhirFieldConfig {
		return &v
	}).(FhirFieldConfigPtrOutput)
}

// Specifies FHIR paths to match and how to transform them. Any field that is not matched by a FieldMetadata `action` is passed through to the output dataset unmodified. All extensions will be processed according to keep_extensions. If a field can be matched by more than one FieldMetadata `action`, the first `action` option is applied. Overrides options and the union field `profile` in FhirFieldConfig.
func (o FhirFieldConfigOutput) FieldMetadataList() GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayOutput {
	return o.ApplyT(func(v FhirFieldConfig) []GoogleCloudHealthcareV1beta1DeidentifyFieldMetadata {
		return v.FieldMetadataList
	}).(GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayOutput)
}

// Specifies additional options, overriding the base ProfileType.
func (o FhirFieldConfigOutput) Options() GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput {
	return o.ApplyT(func(v FhirFieldConfig) *GoogleCloudHealthcareV1beta1DeidentifyOptions { return v.Options }).(GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput)
}

// Base profile type for handling FHIR fields.
func (o FhirFieldConfigOutput) ProfileType() FhirFieldConfigProfileTypePtrOutput {
	return o.ApplyT(func(v FhirFieldConfig) *FhirFieldConfigProfileType { return v.ProfileType }).(FhirFieldConfigProfileTypePtrOutput)
}

type FhirFieldConfigPtrOutput struct{ *pulumi.OutputState }

func (FhirFieldConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FhirFieldConfig)(nil)).Elem()
}

func (o FhirFieldConfigPtrOutput) ToFhirFieldConfigPtrOutput() FhirFieldConfigPtrOutput {
	return o
}

func (o FhirFieldConfigPtrOutput) ToFhirFieldConfigPtrOutputWithContext(ctx context.Context) FhirFieldConfigPtrOutput {
	return o
}

func (o FhirFieldConfigPtrOutput) Elem() FhirFieldConfigOutput {
	return o.ApplyT(func(v *FhirFieldConfig) FhirFieldConfig {
		if v != nil {
			return *v
		}
		var ret FhirFieldConfig
		return ret
	}).(FhirFieldConfigOutput)
}

// Specifies FHIR paths to match and how to transform them. Any field that is not matched by a FieldMetadata `action` is passed through to the output dataset unmodified. All extensions will be processed according to keep_extensions. If a field can be matched by more than one FieldMetadata `action`, the first `action` option is applied. Overrides options and the union field `profile` in FhirFieldConfig.
func (o FhirFieldConfigPtrOutput) FieldMetadataList() GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayOutput {
	return o.ApplyT(func(v *FhirFieldConfig) []GoogleCloudHealthcareV1beta1DeidentifyFieldMetadata {
		if v == nil {
			return nil
		}
		return v.FieldMetadataList
	}).(GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayOutput)
}

// Specifies additional options, overriding the base ProfileType.
func (o FhirFieldConfigPtrOutput) Options() GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput {
	return o.ApplyT(func(v *FhirFieldConfig) *GoogleCloudHealthcareV1beta1DeidentifyOptions {
		if v == nil {
			return nil
		}
		return v.Options
	}).(GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput)
}

// Base profile type for handling FHIR fields.
func (o FhirFieldConfigPtrOutput) ProfileType() FhirFieldConfigProfileTypePtrOutput {
	return o.ApplyT(func(v *FhirFieldConfig) *FhirFieldConfigProfileType {
		if v == nil {
			return nil
		}
		return v.ProfileType
	}).(FhirFieldConfigProfileTypePtrOutput)
}

// Specifies how to handle the de-identification of a FHIR store.
type FhirFieldConfigResponse struct {
	// Specifies FHIR paths to match and how to transform them. Any field that is not matched by a FieldMetadata `action` is passed through to the output dataset unmodified. All extensions will be processed according to keep_extensions. If a field can be matched by more than one FieldMetadata `action`, the first `action` option is applied. Overrides options and the union field `profile` in FhirFieldConfig.
	FieldMetadataList []GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponse `pulumi:"fieldMetadataList"`
	// Specifies additional options, overriding the base ProfileType.
	Options GoogleCloudHealthcareV1beta1DeidentifyOptionsResponse `pulumi:"options"`
	// Base profile type for handling FHIR fields.
	ProfileType string `pulumi:"profileType"`
}

// Specifies how to handle the de-identification of a FHIR store.
type FhirFieldConfigResponseOutput struct{ *pulumi.OutputState }

func (FhirFieldConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FhirFieldConfigResponse)(nil)).Elem()
}

func (o FhirFieldConfigResponseOutput) ToFhirFieldConfigResponseOutput() FhirFieldConfigResponseOutput {
	return o
}

func (o FhirFieldConfigResponseOutput) ToFhirFieldConfigResponseOutputWithContext(ctx context.Context) FhirFieldConfigResponseOutput {
	return o
}

// Specifies FHIR paths to match and how to transform them. Any field that is not matched by a FieldMetadata `action` is passed through to the output dataset unmodified. All extensions will be processed according to keep_extensions. If a field can be matched by more than one FieldMetadata `action`, the first `action` option is applied. Overrides options and the union field `profile` in FhirFieldConfig.
func (o FhirFieldConfigResponseOutput) FieldMetadataList() GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseArrayOutput {
	return o.ApplyT(func(v FhirFieldConfigResponse) []GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponse {
		return v.FieldMetadataList
	}).(GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseArrayOutput)
}

// Specifies additional options, overriding the base ProfileType.
func (o FhirFieldConfigResponseOutput) Options() GoogleCloudHealthcareV1beta1DeidentifyOptionsResponseOutput {
	return o.ApplyT(func(v FhirFieldConfigResponse) GoogleCloudHealthcareV1beta1DeidentifyOptionsResponse {
		return v.Options
	}).(GoogleCloudHealthcareV1beta1DeidentifyOptionsResponseOutput)
}

// Base profile type for handling FHIR fields.
func (o FhirFieldConfigResponseOutput) ProfileType() pulumi.StringOutput {
	return o.ApplyT(func(v FhirFieldConfigResponse) string { return v.ProfileType }).(pulumi.StringOutput)
}

// Contains the configuration for FHIR notifications.
type FhirNotificationConfig struct {
	// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. The notification is a `PubsubMessage` with the following fields: * `PubsubMessage.Data` contains the resource name. * `PubsubMessage.MessageId` is the ID of this notification. It is guaranteed to be unique within the topic. * `PubsubMessage.PublishTime` is the time when the message was published. Note that notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. The Cloud Healthcare API service account, service-@gcp-sa-healthcare.iam.gserviceaccount.com, must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail (https://cloud.google.com/healthcare-api/docs/permissions-healthcare-api-gcp-products#dicom_fhir_and_hl7v2_store_cloud_pubsub_permissions). If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging. For more information, see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare-api/docs/how-tos/logging).
	PubsubTopic *string `pulumi:"pubsubTopic"`
	// Whether to send full FHIR resource to this Pub/Sub topic for Create and Update operation. Note that setting this to true does not guarantee that all resources will be sent in the format of full FHIR resource. When a resource change is too large or during heavy traffic, only the resource name will be sent. Clients should always check the "payloadType" label from a Pub/Sub message to determine whether it needs to fetch the full resource as a separate operation.
	SendFullResource *bool `pulumi:"sendFullResource"`
	// Whether to send full FHIR resource to this Pub/Sub topic for deleting FHIR resource. Note that setting this to true does not guarantee that all previous resources will be sent in the format of full FHIR resource. When a resource change is too large or during heavy traffic, only the resource name will be sent. Clients should always check the "payloadType" label from a Pub/Sub message to determine whether it needs to fetch the full previous resource as a separate operation.
	SendPreviousResourceOnDelete *bool `pulumi:"sendPreviousResourceOnDelete"`
}

// FhirNotificationConfigInput is an input type that accepts FhirNotificationConfigArgs and FhirNotificationConfigOutput values.
// You can construct a concrete instance of `FhirNotificationConfigInput` via:
//
//	FhirNotificationConfigArgs{...}
type FhirNotificationConfigInput interface {
	pulumi.Input

	ToFhirNotificationConfigOutput() FhirNotificationConfigOutput
	ToFhirNotificationConfigOutputWithContext(context.Context) FhirNotificationConfigOutput
}

// Contains the configuration for FHIR notifications.
type FhirNotificationConfigArgs struct {
	// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. The notification is a `PubsubMessage` with the following fields: * `PubsubMessage.Data` contains the resource name. * `PubsubMessage.MessageId` is the ID of this notification. It is guaranteed to be unique within the topic. * `PubsubMessage.PublishTime` is the time when the message was published. Note that notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. The Cloud Healthcare API service account, service-@gcp-sa-healthcare.iam.gserviceaccount.com, must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail (https://cloud.google.com/healthcare-api/docs/permissions-healthcare-api-gcp-products#dicom_fhir_and_hl7v2_store_cloud_pubsub_permissions). If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging. For more information, see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare-api/docs/how-tos/logging).
	PubsubTopic pulumi.StringPtrInput `pulumi:"pubsubTopic"`
	// Whether to send full FHIR resource to this Pub/Sub topic for Create and Update operation. Note that setting this to true does not guarantee that all resources will be sent in the format of full FHIR resource. When a resource change is too large or during heavy traffic, only the resource name will be sent. Clients should always check the "payloadType" label from a Pub/Sub message to determine whether it needs to fetch the full resource as a separate operation.
	SendFullResource pulumi.BoolPtrInput `pulumi:"sendFullResource"`
	// Whether to send full FHIR resource to this Pub/Sub topic for deleting FHIR resource. Note that setting this to true does not guarantee that all previous resources will be sent in the format of full FHIR resource. When a resource change is too large or during heavy traffic, only the resource name will be sent. Clients should always check the "payloadType" label from a Pub/Sub message to determine whether it needs to fetch the full previous resource as a separate operation.
	SendPreviousResourceOnDelete pulumi.BoolPtrInput `pulumi:"sendPreviousResourceOnDelete"`
}

func (FhirNotificationConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FhirNotificationConfig)(nil)).Elem()
}

func (i FhirNotificationConfigArgs) ToFhirNotificationConfigOutput() FhirNotificationConfigOutput {
	return i.ToFhirNotificationConfigOutputWithContext(context.Background())
}

func (i FhirNotificationConfigArgs) ToFhirNotificationConfigOutputWithContext(ctx context.Context) FhirNotificationConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FhirNotificationConfigOutput)
}

// FhirNotificationConfigArrayInput is an input type that accepts FhirNotificationConfigArray and FhirNotificationConfigArrayOutput values.
// You can construct a concrete instance of `FhirNotificationConfigArrayInput` via:
//
//	FhirNotificationConfigArray{ FhirNotificationConfigArgs{...} }
type FhirNotificationConfigArrayInput interface {
	pulumi.Input

	ToFhirNotificationConfigArrayOutput() FhirNotificationConfigArrayOutput
	ToFhirNotificationConfigArrayOutputWithContext(context.Context) FhirNotificationConfigArrayOutput
}

type FhirNotificationConfigArray []FhirNotificationConfigInput

func (FhirNotificationConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FhirNotificationConfig)(nil)).Elem()
}

func (i FhirNotificationConfigArray) ToFhirNotificationConfigArrayOutput() FhirNotificationConfigArrayOutput {
	return i.ToFhirNotificationConfigArrayOutputWithContext(context.Background())
}

func (i FhirNotificationConfigArray) ToFhirNotificationConfigArrayOutputWithContext(ctx context.Context) FhirNotificationConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FhirNotificationConfigArrayOutput)
}

// Contains the configuration for FHIR notifications.
type FhirNotificationConfigOutput struct{ *pulumi.OutputState }

func (FhirNotificationConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FhirNotificationConfig)(nil)).Elem()
}

func (o FhirNotificationConfigOutput) ToFhirNotificationConfigOutput() FhirNotificationConfigOutput {
	return o
}

func (o FhirNotificationConfigOutput) ToFhirNotificationConfigOutputWithContext(ctx context.Context) FhirNotificationConfigOutput {
	return o
}

// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. The notification is a `PubsubMessage` with the following fields: * `PubsubMessage.Data` contains the resource name. * `PubsubMessage.MessageId` is the ID of this notification. It is guaranteed to be unique within the topic. * `PubsubMessage.PublishTime` is the time when the message was published. Note that notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. The Cloud Healthcare API service account, service-@gcp-sa-healthcare.iam.gserviceaccount.com, must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail (https://cloud.google.com/healthcare-api/docs/permissions-healthcare-api-gcp-products#dicom_fhir_and_hl7v2_store_cloud_pubsub_permissions). If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging. For more information, see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare-api/docs/how-tos/logging).
func (o FhirNotificationConfigOutput) PubsubTopic() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FhirNotificationConfig) *string { return v.PubsubTopic }).(pulumi.StringPtrOutput)
}

// Whether to send full FHIR resource to this Pub/Sub topic for Create and Update operation. Note that setting this to true does not guarantee that all resources will be sent in the format of full FHIR resource. When a resource change is too large or during heavy traffic, only the resource name will be sent. Clients should always check the "payloadType" label from a Pub/Sub message to determine whether it needs to fetch the full resource as a separate operation.
func (o FhirNotificationConfigOutput) SendFullResource() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v FhirNotificationConfig) *bool { return v.SendFullResource }).(pulumi.BoolPtrOutput)
}

// Whether to send full FHIR resource to this Pub/Sub topic for deleting FHIR resource. Note that setting this to true does not guarantee that all previous resources will be sent in the format of full FHIR resource. When a resource change is too large or during heavy traffic, only the resource name will be sent. Clients should always check the "payloadType" label from a Pub/Sub message to determine whether it needs to fetch the full previous resource as a separate operation.
func (o FhirNotificationConfigOutput) SendPreviousResourceOnDelete() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v FhirNotificationConfig) *bool { return v.SendPreviousResourceOnDelete }).(pulumi.BoolPtrOutput)
}

type FhirNotificationConfigArrayOutput struct{ *pulumi.OutputState }

func (FhirNotificationConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FhirNotificationConfig)(nil)).Elem()
}

func (o FhirNotificationConfigArrayOutput) ToFhirNotificationConfigArrayOutput() FhirNotificationConfigArrayOutput {
	return o
}

func (o FhirNotificationConfigArrayOutput) ToFhirNotificationConfigArrayOutputWithContext(ctx context.Context) FhirNotificationConfigArrayOutput {
	return o
}

func (o FhirNotificationConfigArrayOutput) Index(i pulumi.IntInput) FhirNotificationConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FhirNotificationConfig {
		return vs[0].([]FhirNotificationConfig)[vs[1].(int)]
	}).(FhirNotificationConfigOutput)
}

// Contains the configuration for FHIR notifications.
type FhirNotificationConfigResponse struct {
	// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. The notification is a `PubsubMessage` with the following fields: * `PubsubMessage.Data` contains the resource name. * `PubsubMessage.MessageId` is the ID of this notification. It is guaranteed to be unique within the topic. * `PubsubMessage.PublishTime` is the time when the message was published. Note that notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. The Cloud Healthcare API service account, service-@gcp-sa-healthcare.iam.gserviceaccount.com, must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail (https://cloud.google.com/healthcare-api/docs/permissions-healthcare-api-gcp-products#dicom_fhir_and_hl7v2_store_cloud_pubsub_permissions). If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging. For more information, see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare-api/docs/how-tos/logging).
	PubsubTopic string `pulumi:"pubsubTopic"`
	// Whether to send full FHIR resource to this Pub/Sub topic for Create and Update operation. Note that setting this to true does not guarantee that all resources will be sent in the format of full FHIR resource. When a resource change is too large or during heavy traffic, only the resource name will be sent. Clients should always check the "payloadType" label from a Pub/Sub message to determine whether it needs to fetch the full resource as a separate operation.
	SendFullResource bool `pulumi:"sendFullResource"`
	// Whether to send full FHIR resource to this Pub/Sub topic for deleting FHIR resource. Note that setting this to true does not guarantee that all previous resources will be sent in the format of full FHIR resource. When a resource change is too large or during heavy traffic, only the resource name will be sent. Clients should always check the "payloadType" label from a Pub/Sub message to determine whether it needs to fetch the full previous resource as a separate operation.
	SendPreviousResourceOnDelete bool `pulumi:"sendPreviousResourceOnDelete"`
}

// Contains the configuration for FHIR notifications.
type FhirNotificationConfigResponseOutput struct{ *pulumi.OutputState }

func (FhirNotificationConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FhirNotificationConfigResponse)(nil)).Elem()
}

func (o FhirNotificationConfigResponseOutput) ToFhirNotificationConfigResponseOutput() FhirNotificationConfigResponseOutput {
	return o
}

func (o FhirNotificationConfigResponseOutput) ToFhirNotificationConfigResponseOutputWithContext(ctx context.Context) FhirNotificationConfigResponseOutput {
	return o
}

// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. The notification is a `PubsubMessage` with the following fields: * `PubsubMessage.Data` contains the resource name. * `PubsubMessage.MessageId` is the ID of this notification. It is guaranteed to be unique within the topic. * `PubsubMessage.PublishTime` is the time when the message was published. Note that notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. The Cloud Healthcare API service account, service-@gcp-sa-healthcare.iam.gserviceaccount.com, must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail (https://cloud.google.com/healthcare-api/docs/permissions-healthcare-api-gcp-products#dicom_fhir_and_hl7v2_store_cloud_pubsub_permissions). If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging. For more information, see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare-api/docs/how-tos/logging).
func (o FhirNotificationConfigResponseOutput) PubsubTopic() pulumi.StringOutput {
	return o.ApplyT(func(v FhirNotificationConfigResponse) string { return v.PubsubTopic }).(pulumi.StringOutput)
}

// Whether to send full FHIR resource to this Pub/Sub topic for Create and Update operation. Note that setting this to true does not guarantee that all resources will be sent in the format of full FHIR resource. When a resource change is too large or during heavy traffic, only the resource name will be sent. Clients should always check the "payloadType" label from a Pub/Sub message to determine whether it needs to fetch the full resource as a separate operation.
func (o FhirNotificationConfigResponseOutput) SendFullResource() pulumi.BoolOutput {
	return o.ApplyT(func(v FhirNotificationConfigResponse) bool { return v.SendFullResource }).(pulumi.BoolOutput)
}

// Whether to send full FHIR resource to this Pub/Sub topic for deleting FHIR resource. Note that setting this to true does not guarantee that all previous resources will be sent in the format of full FHIR resource. When a resource change is too large or during heavy traffic, only the resource name will be sent. Clients should always check the "payloadType" label from a Pub/Sub message to determine whether it needs to fetch the full previous resource as a separate operation.
func (o FhirNotificationConfigResponseOutput) SendPreviousResourceOnDelete() pulumi.BoolOutput {
	return o.ApplyT(func(v FhirNotificationConfigResponse) bool { return v.SendPreviousResourceOnDelete }).(pulumi.BoolOutput)
}

type FhirNotificationConfigResponseArrayOutput struct{ *pulumi.OutputState }

func (FhirNotificationConfigResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FhirNotificationConfigResponse)(nil)).Elem()
}

func (o FhirNotificationConfigResponseArrayOutput) ToFhirNotificationConfigResponseArrayOutput() FhirNotificationConfigResponseArrayOutput {
	return o
}

func (o FhirNotificationConfigResponseArrayOutput) ToFhirNotificationConfigResponseArrayOutputWithContext(ctx context.Context) FhirNotificationConfigResponseArrayOutput {
	return o
}

func (o FhirNotificationConfigResponseArrayOutput) Index(i pulumi.IntInput) FhirNotificationConfigResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FhirNotificationConfigResponse {
		return vs[0].([]FhirNotificationConfigResponse)[vs[1].(int)]
	}).(FhirNotificationConfigResponseOutput)
}

// Details about the FHIR store to write the output to.
type FhirOutput struct {
	// Name of the output FHIR store, which must already exist. You must grant the healthcare.fhirResources.update permission on the destination store to your project's **Cloud Healthcare Service Agent** [service account](https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#the_cloud_healthcare_service_agent). The destination store must set enableUpdateCreate to true. The destination store must use FHIR version R4. Writing these resources will consume FHIR operations quota from the project containing the source data. De-identify operation metadata is only generated for DICOM de-identification operations.
	FhirStore *string `pulumi:"fhirStore"`
}

// FhirOutputInput is an input type that accepts FhirOutputArgs and FhirOutputOutput values.
// You can construct a concrete instance of `FhirOutputInput` via:
//
//	FhirOutputArgs{...}
type FhirOutputInput interface {
	pulumi.Input

	ToFhirOutputOutput() FhirOutputOutput
	ToFhirOutputOutputWithContext(context.Context) FhirOutputOutput
}

// Details about the FHIR store to write the output to.
type FhirOutputArgs struct {
	// Name of the output FHIR store, which must already exist. You must grant the healthcare.fhirResources.update permission on the destination store to your project's **Cloud Healthcare Service Agent** [service account](https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#the_cloud_healthcare_service_agent). The destination store must set enableUpdateCreate to true. The destination store must use FHIR version R4. Writing these resources will consume FHIR operations quota from the project containing the source data. De-identify operation metadata is only generated for DICOM de-identification operations.
	FhirStore pulumi.StringPtrInput `pulumi:"fhirStore"`
}

func (FhirOutputArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FhirOutput)(nil)).Elem()
}

func (i FhirOutputArgs) ToFhirOutputOutput() FhirOutputOutput {
	return i.ToFhirOutputOutputWithContext(context.Background())
}

func (i FhirOutputArgs) ToFhirOutputOutputWithContext(ctx context.Context) FhirOutputOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FhirOutputOutput)
}

func (i FhirOutputArgs) ToFhirOutputPtrOutput() FhirOutputPtrOutput {
	return i.ToFhirOutputPtrOutputWithContext(context.Background())
}

func (i FhirOutputArgs) ToFhirOutputPtrOutputWithContext(ctx context.Context) FhirOutputPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FhirOutputOutput).ToFhirOutputPtrOutputWithContext(ctx)
}

// FhirOutputPtrInput is an input type that accepts FhirOutputArgs, FhirOutputPtr and FhirOutputPtrOutput values.
// You can construct a concrete instance of `FhirOutputPtrInput` via:
//
//	        FhirOutputArgs{...}
//
//	or:
//
//	        nil
type FhirOutputPtrInput interface {
	pulumi.Input

	ToFhirOutputPtrOutput() FhirOutputPtrOutput
	ToFhirOutputPtrOutputWithContext(context.Context) FhirOutputPtrOutput
}

type fhirOutputPtrType FhirOutputArgs

func FhirOutputPtr(v *FhirOutputArgs) FhirOutputPtrInput {
	return (*fhirOutputPtrType)(v)
}

func (*fhirOutputPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FhirOutput)(nil)).Elem()
}

func (i *fhirOutputPtrType) ToFhirOutputPtrOutput() FhirOutputPtrOutput {
	return i.ToFhirOutputPtrOutputWithContext(context.Background())
}

func (i *fhirOutputPtrType) ToFhirOutputPtrOutputWithContext(ctx context.Context) FhirOutputPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FhirOutputPtrOutput)
}

// Details about the FHIR store to write the output to.
type FhirOutputOutput struct{ *pulumi.OutputState }

func (FhirOutputOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FhirOutput)(nil)).Elem()
}

func (o FhirOutputOutput) ToFhirOutputOutput() FhirOutputOutput {
	return o
}

func (o FhirOutputOutput) ToFhirOutputOutputWithContext(ctx context.Context) FhirOutputOutput {
	return o
}

func (o FhirOutputOutput) ToFhirOutputPtrOutput() FhirOutputPtrOutput {
	return o.ToFhirOutputPtrOutputWithContext(context.Background())
}

func (o FhirOutputOutput) ToFhirOutputPtrOutputWithContext(ctx context.Context) FhirOutputPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FhirOutput) *FhirOutput {
		return &v
	}).(FhirOutputPtrOutput)
}

// Name of the output FHIR store, which must already exist. You must grant the healthcare.fhirResources.update permission on the destination store to your project's **Cloud Healthcare Service Agent** [service account](https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#the_cloud_healthcare_service_agent). The destination store must set enableUpdateCreate to true. The destination store must use FHIR version R4. Writing these resources will consume FHIR operations quota from the project containing the source data. De-identify operation metadata is only generated for DICOM de-identification operations.
func (o FhirOutputOutput) FhirStore() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FhirOutput) *string { return v.FhirStore }).(pulumi.StringPtrOutput)
}

type FhirOutputPtrOutput struct{ *pulumi.OutputState }

func (FhirOutputPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FhirOutput)(nil)).Elem()
}

func (o FhirOutputPtrOutput) ToFhirOutputPtrOutput() FhirOutputPtrOutput {
	return o
}

func (o FhirOutputPtrOutput) ToFhirOutputPtrOutputWithContext(ctx context.Context) FhirOutputPtrOutput {
	return o
}

func (o FhirOutputPtrOutput) Elem() FhirOutputOutput {
	return o.ApplyT(func(v *FhirOutput) FhirOutput {
		if v != nil {
			return *v
		}
		var ret FhirOutput
		return ret
	}).(FhirOutputOutput)
}

// Name of the output FHIR store, which must already exist. You must grant the healthcare.fhirResources.update permission on the destination store to your project's **Cloud Healthcare Service Agent** [service account](https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#the_cloud_healthcare_service_agent). The destination store must set enableUpdateCreate to true. The destination store must use FHIR version R4. Writing these resources will consume FHIR operations quota from the project containing the source data. De-identify operation metadata is only generated for DICOM de-identification operations.
func (o FhirOutputPtrOutput) FhirStore() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FhirOutput) *string {
		if v == nil {
			return nil
		}
		return v.FhirStore
	}).(pulumi.StringPtrOutput)
}

// Details about the FHIR store to write the output to.
type FhirOutputResponse struct {
	// Name of the output FHIR store, which must already exist. You must grant the healthcare.fhirResources.update permission on the destination store to your project's **Cloud Healthcare Service Agent** [service account](https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#the_cloud_healthcare_service_agent). The destination store must set enableUpdateCreate to true. The destination store must use FHIR version R4. Writing these resources will consume FHIR operations quota from the project containing the source data. De-identify operation metadata is only generated for DICOM de-identification operations.
	FhirStore string `pulumi:"fhirStore"`
}

// Details about the FHIR store to write the output to.
type FhirOutputResponseOutput struct{ *pulumi.OutputState }

func (FhirOutputResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FhirOutputResponse)(nil)).Elem()
}

func (o FhirOutputResponseOutput) ToFhirOutputResponseOutput() FhirOutputResponseOutput {
	return o
}

func (o FhirOutputResponseOutput) ToFhirOutputResponseOutputWithContext(ctx context.Context) FhirOutputResponseOutput {
	return o
}

// Name of the output FHIR store, which must already exist. You must grant the healthcare.fhirResources.update permission on the destination store to your project's **Cloud Healthcare Service Agent** [service account](https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#the_cloud_healthcare_service_agent). The destination store must set enableUpdateCreate to true. The destination store must use FHIR version R4. Writing these resources will consume FHIR operations quota from the project containing the source data. De-identify operation metadata is only generated for DICOM de-identification operations.
func (o FhirOutputResponseOutput) FhirStore() pulumi.StringOutput {
	return o.ApplyT(func(v FhirOutputResponse) string { return v.FhirStore }).(pulumi.StringOutput)
}

// A (sub) field of a type.
type Field struct {
	// The maximum number of times this field can be repeated. 0 or -1 means unbounded.
	MaxOccurs *int `pulumi:"maxOccurs"`
	// The minimum number of times this field must be present/repeated.
	MinOccurs *int `pulumi:"minOccurs"`
	// The name of the field. For example, "PID-1" or just "1".
	Name *string `pulumi:"name"`
	// The HL7v2 table this field refers to. For example, PID-15 (Patient's Primary Language) usually refers to table "0296".
	Table *string `pulumi:"table"`
	// The type of this field. A Type with this name must be defined in an Hl7TypesConfig.
	Type *string `pulumi:"type"`
}

// FieldInput is an input type that accepts FieldArgs and FieldOutput values.
// You can construct a concrete instance of `FieldInput` via:
//
//	FieldArgs{...}
type FieldInput interface {
	pulumi.Input

	ToFieldOutput() FieldOutput
	ToFieldOutputWithContext(context.Context) FieldOutput
}

// A (sub) field of a type.
type FieldArgs struct {
	// The maximum number of times this field can be repeated. 0 or -1 means unbounded.
	MaxOccurs pulumi.IntPtrInput `pulumi:"maxOccurs"`
	// The minimum number of times this field must be present/repeated.
	MinOccurs pulumi.IntPtrInput `pulumi:"minOccurs"`
	// The name of the field. For example, "PID-1" or just "1".
	Name pulumi.StringPtrInput `pulumi:"name"`
	// The HL7v2 table this field refers to. For example, PID-15 (Patient's Primary Language) usually refers to table "0296".
	Table pulumi.StringPtrInput `pulumi:"table"`
	// The type of this field. A Type with this name must be defined in an Hl7TypesConfig.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (FieldArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Field)(nil)).Elem()
}

func (i FieldArgs) ToFieldOutput() FieldOutput {
	return i.ToFieldOutputWithContext(context.Background())
}

func (i FieldArgs) ToFieldOutputWithContext(ctx context.Context) FieldOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FieldOutput)
}

// FieldArrayInput is an input type that accepts FieldArray and FieldArrayOutput values.
// You can construct a concrete instance of `FieldArrayInput` via:
//
//	FieldArray{ FieldArgs{...} }
type FieldArrayInput interface {
	pulumi.Input

	ToFieldArrayOutput() FieldArrayOutput
	ToFieldArrayOutputWithContext(context.Context) FieldArrayOutput
}

type FieldArray []FieldInput

func (FieldArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Field)(nil)).Elem()
}

func (i FieldArray) ToFieldArrayOutput() FieldArrayOutput {
	return i.ToFieldArrayOutputWithContext(context.Background())
}

func (i FieldArray) ToFieldArrayOutputWithContext(ctx context.Context) FieldArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FieldArrayOutput)
}

// A (sub) field of a type.
type FieldOutput struct{ *pulumi.OutputState }

func (FieldOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Field)(nil)).Elem()
}

func (o FieldOutput) ToFieldOutput() FieldOutput {
	return o
}

func (o FieldOutput) ToFieldOutputWithContext(ctx context.Context) FieldOutput {
	return o
}

// The maximum number of times this field can be repeated. 0 or -1 means unbounded.
func (o FieldOutput) MaxOccurs() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Field) *int { return v.MaxOccurs }).(pulumi.IntPtrOutput)
}

// The minimum number of times this field must be present/repeated.
func (o FieldOutput) MinOccurs() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Field) *int { return v.MinOccurs }).(pulumi.IntPtrOutput)
}

// The name of the field. For example, "PID-1" or just "1".
func (o FieldOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Field) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The HL7v2 table this field refers to. For example, PID-15 (Patient's Primary Language) usually refers to table "0296".
func (o FieldOutput) Table() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Field) *string { return v.Table }).(pulumi.StringPtrOutput)
}

// The type of this field. A Type with this name must be defined in an Hl7TypesConfig.
func (o FieldOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Field) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type FieldArrayOutput struct{ *pulumi.OutputState }

func (FieldArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Field)(nil)).Elem()
}

func (o FieldArrayOutput) ToFieldArrayOutput() FieldArrayOutput {
	return o
}

func (o FieldArrayOutput) ToFieldArrayOutputWithContext(ctx context.Context) FieldArrayOutput {
	return o
}

func (o FieldArrayOutput) Index(i pulumi.IntInput) FieldOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Field {
		return vs[0].([]Field)[vs[1].(int)]
	}).(FieldOutput)
}

// Specifies FHIR paths to match, and how to handle de-identification of matching fields.
type FieldMetadata struct {
	// Deidentify action for one field.
	Action *FieldMetadataAction `pulumi:"action"`
	// List of paths to FHIR fields to redact. Each path is a period-separated list where each component is either a field name or FHIR type name. All types begin with an upper case letter. For example, the resource field "Patient.Address.city", which uses a string type, can be matched by "Patient.Address.String". Path also supports partial matching. For example, "Patient.Address.city" can be matched by "Address.city" (Patient omitted). Partial matching and type matching can be combined. For example, "Patient.Address.city" can be matched by "Address.String". For "choice" types (those defined in the FHIR spec with the form: field[x]), use two separate components. For example, "deceasedAge.unit" is matched by "Deceased.Age.unit". Supported types are: AdministrativeGenderCode, Base64Binary, Boolean, Code, Date, DateTime, Decimal, HumanName, Id, Instant, Integer, LanguageCode, Markdown, Oid, PositiveInt, String, UnsignedInt, Uri, Uuid, Xhtml. The sub-type for HumanName(for example HumanName.given, HumanName.family) can be omitted.
	Paths []string `pulumi:"paths"`
}

// FieldMetadataInput is an input type that accepts FieldMetadataArgs and FieldMetadataOutput values.
// You can construct a concrete instance of `FieldMetadataInput` via:
//
//	FieldMetadataArgs{...}
type FieldMetadataInput interface {
	pulumi.Input

	ToFieldMetadataOutput() FieldMetadataOutput
	ToFieldMetadataOutputWithContext(context.Context) FieldMetadataOutput
}

// Specifies FHIR paths to match, and how to handle de-identification of matching fields.
type FieldMetadataArgs struct {
	// Deidentify action for one field.
	Action FieldMetadataActionPtrInput `pulumi:"action"`
	// List of paths to FHIR fields to redact. Each path is a period-separated list where each component is either a field name or FHIR type name. All types begin with an upper case letter. For example, the resource field "Patient.Address.city", which uses a string type, can be matched by "Patient.Address.String". Path also supports partial matching. For example, "Patient.Address.city" can be matched by "Address.city" (Patient omitted). Partial matching and type matching can be combined. For example, "Patient.Address.city" can be matched by "Address.String". For "choice" types (those defined in the FHIR spec with the form: field[x]), use two separate components. For example, "deceasedAge.unit" is matched by "Deceased.Age.unit". Supported types are: AdministrativeGenderCode, Base64Binary, Boolean, Code, Date, DateTime, Decimal, HumanName, Id, Instant, Integer, LanguageCode, Markdown, Oid, PositiveInt, String, UnsignedInt, Uri, Uuid, Xhtml. The sub-type for HumanName(for example HumanName.given, HumanName.family) can be omitted.
	Paths pulumi.StringArrayInput `pulumi:"paths"`
}

func (FieldMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FieldMetadata)(nil)).Elem()
}

func (i FieldMetadataArgs) ToFieldMetadataOutput() FieldMetadataOutput {
	return i.ToFieldMetadataOutputWithContext(context.Background())
}

func (i FieldMetadataArgs) ToFieldMetadataOutputWithContext(ctx context.Context) FieldMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FieldMetadataOutput)
}

// FieldMetadataArrayInput is an input type that accepts FieldMetadataArray and FieldMetadataArrayOutput values.
// You can construct a concrete instance of `FieldMetadataArrayInput` via:
//
//	FieldMetadataArray{ FieldMetadataArgs{...} }
type FieldMetadataArrayInput interface {
	pulumi.Input

	ToFieldMetadataArrayOutput() FieldMetadataArrayOutput
	ToFieldMetadataArrayOutputWithContext(context.Context) FieldMetadataArrayOutput
}

type FieldMetadataArray []FieldMetadataInput

func (FieldMetadataArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FieldMetadata)(nil)).Elem()
}

func (i FieldMetadataArray) ToFieldMetadataArrayOutput() FieldMetadataArrayOutput {
	return i.ToFieldMetadataArrayOutputWithContext(context.Background())
}

func (i FieldMetadataArray) ToFieldMetadataArrayOutputWithContext(ctx context.Context) FieldMetadataArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FieldMetadataArrayOutput)
}

// Specifies FHIR paths to match, and how to handle de-identification of matching fields.
type FieldMetadataOutput struct{ *pulumi.OutputState }

func (FieldMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FieldMetadata)(nil)).Elem()
}

func (o FieldMetadataOutput) ToFieldMetadataOutput() FieldMetadataOutput {
	return o
}

func (o FieldMetadataOutput) ToFieldMetadataOutputWithContext(ctx context.Context) FieldMetadataOutput {
	return o
}

// Deidentify action for one field.
func (o FieldMetadataOutput) Action() FieldMetadataActionPtrOutput {
	return o.ApplyT(func(v FieldMetadata) *FieldMetadataAction { return v.Action }).(FieldMetadataActionPtrOutput)
}

// List of paths to FHIR fields to redact. Each path is a period-separated list where each component is either a field name or FHIR type name. All types begin with an upper case letter. For example, the resource field "Patient.Address.city", which uses a string type, can be matched by "Patient.Address.String". Path also supports partial matching. For example, "Patient.Address.city" can be matched by "Address.city" (Patient omitted). Partial matching and type matching can be combined. For example, "Patient.Address.city" can be matched by "Address.String". For "choice" types (those defined in the FHIR spec with the form: field[x]), use two separate components. For example, "deceasedAge.unit" is matched by "Deceased.Age.unit". Supported types are: AdministrativeGenderCode, Base64Binary, Boolean, Code, Date, DateTime, Decimal, HumanName, Id, Instant, Integer, LanguageCode, Markdown, Oid, PositiveInt, String, UnsignedInt, Uri, Uuid, Xhtml. The sub-type for HumanName(for example HumanName.given, HumanName.family) can be omitted.
func (o FieldMetadataOutput) Paths() pulumi.StringArrayOutput {
	return o.ApplyT(func(v FieldMetadata) []string { return v.Paths }).(pulumi.StringArrayOutput)
}

type FieldMetadataArrayOutput struct{ *pulumi.OutputState }

func (FieldMetadataArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FieldMetadata)(nil)).Elem()
}

func (o FieldMetadataArrayOutput) ToFieldMetadataArrayOutput() FieldMetadataArrayOutput {
	return o
}

func (o FieldMetadataArrayOutput) ToFieldMetadataArrayOutputWithContext(ctx context.Context) FieldMetadataArrayOutput {
	return o
}

func (o FieldMetadataArrayOutput) Index(i pulumi.IntInput) FieldMetadataOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FieldMetadata {
		return vs[0].([]FieldMetadata)[vs[1].(int)]
	}).(FieldMetadataOutput)
}

// Specifies FHIR paths to match, and how to handle de-identification of matching fields.
type FieldMetadataResponse struct {
	// Deidentify action for one field.
	Action string `pulumi:"action"`
	// List of paths to FHIR fields to redact. Each path is a period-separated list where each component is either a field name or FHIR type name. All types begin with an upper case letter. For example, the resource field "Patient.Address.city", which uses a string type, can be matched by "Patient.Address.String". Path also supports partial matching. For example, "Patient.Address.city" can be matched by "Address.city" (Patient omitted). Partial matching and type matching can be combined. For example, "Patient.Address.city" can be matched by "Address.String". For "choice" types (those defined in the FHIR spec with the form: field[x]), use two separate components. For example, "deceasedAge.unit" is matched by "Deceased.Age.unit". Supported types are: AdministrativeGenderCode, Base64Binary, Boolean, Code, Date, DateTime, Decimal, HumanName, Id, Instant, Integer, LanguageCode, Markdown, Oid, PositiveInt, String, UnsignedInt, Uri, Uuid, Xhtml. The sub-type for HumanName(for example HumanName.given, HumanName.family) can be omitted.
	Paths []string `pulumi:"paths"`
}

// Specifies FHIR paths to match, and how to handle de-identification of matching fields.
type FieldMetadataResponseOutput struct{ *pulumi.OutputState }

func (FieldMetadataResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FieldMetadataResponse)(nil)).Elem()
}

func (o FieldMetadataResponseOutput) ToFieldMetadataResponseOutput() FieldMetadataResponseOutput {
	return o
}

func (o FieldMetadataResponseOutput) ToFieldMetadataResponseOutputWithContext(ctx context.Context) FieldMetadataResponseOutput {
	return o
}

// Deidentify action for one field.
func (o FieldMetadataResponseOutput) Action() pulumi.StringOutput {
	return o.ApplyT(func(v FieldMetadataResponse) string { return v.Action }).(pulumi.StringOutput)
}

// List of paths to FHIR fields to redact. Each path is a period-separated list where each component is either a field name or FHIR type name. All types begin with an upper case letter. For example, the resource field "Patient.Address.city", which uses a string type, can be matched by "Patient.Address.String". Path also supports partial matching. For example, "Patient.Address.city" can be matched by "Address.city" (Patient omitted). Partial matching and type matching can be combined. For example, "Patient.Address.city" can be matched by "Address.String". For "choice" types (those defined in the FHIR spec with the form: field[x]), use two separate components. For example, "deceasedAge.unit" is matched by "Deceased.Age.unit". Supported types are: AdministrativeGenderCode, Base64Binary, Boolean, Code, Date, DateTime, Decimal, HumanName, Id, Instant, Integer, LanguageCode, Markdown, Oid, PositiveInt, String, UnsignedInt, Uri, Uuid, Xhtml. The sub-type for HumanName(for example HumanName.given, HumanName.family) can be omitted.
func (o FieldMetadataResponseOutput) Paths() pulumi.StringArrayOutput {
	return o.ApplyT(func(v FieldMetadataResponse) []string { return v.Paths }).(pulumi.StringArrayOutput)
}

type FieldMetadataResponseArrayOutput struct{ *pulumi.OutputState }

func (FieldMetadataResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FieldMetadataResponse)(nil)).Elem()
}

func (o FieldMetadataResponseArrayOutput) ToFieldMetadataResponseArrayOutput() FieldMetadataResponseArrayOutput {
	return o
}

func (o FieldMetadataResponseArrayOutput) ToFieldMetadataResponseArrayOutputWithContext(ctx context.Context) FieldMetadataResponseArrayOutput {
	return o
}

func (o FieldMetadataResponseArrayOutput) Index(i pulumi.IntInput) FieldMetadataResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FieldMetadataResponse {
		return vs[0].([]FieldMetadataResponse)[vs[1].(int)]
	}).(FieldMetadataResponseOutput)
}

// A (sub) field of a type.
type FieldResponse struct {
	// The maximum number of times this field can be repeated. 0 or -1 means unbounded.
	MaxOccurs int `pulumi:"maxOccurs"`
	// The minimum number of times this field must be present/repeated.
	MinOccurs int `pulumi:"minOccurs"`
	// The name of the field. For example, "PID-1" or just "1".
	Name string `pulumi:"name"`
	// The HL7v2 table this field refers to. For example, PID-15 (Patient's Primary Language) usually refers to table "0296".
	Table string `pulumi:"table"`
	// The type of this field. A Type with this name must be defined in an Hl7TypesConfig.
	Type string `pulumi:"type"`
}

// A (sub) field of a type.
type FieldResponseOutput struct{ *pulumi.OutputState }

func (FieldResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FieldResponse)(nil)).Elem()
}

func (o FieldResponseOutput) ToFieldResponseOutput() FieldResponseOutput {
	return o
}

func (o FieldResponseOutput) ToFieldResponseOutputWithContext(ctx context.Context) FieldResponseOutput {
	return o
}

// The maximum number of times this field can be repeated. 0 or -1 means unbounded.
func (o FieldResponseOutput) MaxOccurs() pulumi.IntOutput {
	return o.ApplyT(func(v FieldResponse) int { return v.MaxOccurs }).(pulumi.IntOutput)
}

// The minimum number of times this field must be present/repeated.
func (o FieldResponseOutput) MinOccurs() pulumi.IntOutput {
	return o.ApplyT(func(v FieldResponse) int { return v.MinOccurs }).(pulumi.IntOutput)
}

// The name of the field. For example, "PID-1" or just "1".
func (o FieldResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v FieldResponse) string { return v.Name }).(pulumi.StringOutput)
}

// The HL7v2 table this field refers to. For example, PID-15 (Patient's Primary Language) usually refers to table "0296".
func (o FieldResponseOutput) Table() pulumi.StringOutput {
	return o.ApplyT(func(v FieldResponse) string { return v.Table }).(pulumi.StringOutput)
}

// The type of this field. A Type with this name must be defined in an Hl7TypesConfig.
func (o FieldResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v FieldResponse) string { return v.Type }).(pulumi.StringOutput)
}

type FieldResponseArrayOutput struct{ *pulumi.OutputState }

func (FieldResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FieldResponse)(nil)).Elem()
}

func (o FieldResponseArrayOutput) ToFieldResponseArrayOutput() FieldResponseArrayOutput {
	return o
}

func (o FieldResponseArrayOutput) ToFieldResponseArrayOutputWithContext(ctx context.Context) FieldResponseArrayOutput {
	return o
}

func (o FieldResponseArrayOutput) Index(i pulumi.IntInput) FieldResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FieldResponse {
		return vs[0].([]FieldResponse)[vs[1].(int)]
	}).(FieldResponseOutput)
}

type Finding struct {
	// Zero-based ending index of the found text, exclusively.
	End *string `pulumi:"end"`
	// The type of information stored in this text range. For example, HumanName, BirthDate, or Address.
	InfoType *string `pulumi:"infoType"`
	// The snippet of the sensitive text. This field is only populated during deidentification if `store_quote` is set to true in DeidentifyConfig.
	Quote *string `pulumi:"quote"`
	// Zero-based starting index of the found text, inclusively.
	Start *string `pulumi:"start"`
}

// FindingInput is an input type that accepts FindingArgs and FindingOutput values.
// You can construct a concrete instance of `FindingInput` via:
//
//	FindingArgs{...}
type FindingInput interface {
	pulumi.Input

	ToFindingOutput() FindingOutput
	ToFindingOutputWithContext(context.Context) FindingOutput
}

type FindingArgs struct {
	// Zero-based ending index of the found text, exclusively.
	End pulumi.StringPtrInput `pulumi:"end"`
	// The type of information stored in this text range. For example, HumanName, BirthDate, or Address.
	InfoType pulumi.StringPtrInput `pulumi:"infoType"`
	// The snippet of the sensitive text. This field is only populated during deidentification if `store_quote` is set to true in DeidentifyConfig.
	Quote pulumi.StringPtrInput `pulumi:"quote"`
	// Zero-based starting index of the found text, inclusively.
	Start pulumi.StringPtrInput `pulumi:"start"`
}

func (FindingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Finding)(nil)).Elem()
}

func (i FindingArgs) ToFindingOutput() FindingOutput {
	return i.ToFindingOutputWithContext(context.Background())
}

func (i FindingArgs) ToFindingOutputWithContext(ctx context.Context) FindingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FindingOutput)
}

// FindingArrayInput is an input type that accepts FindingArray and FindingArrayOutput values.
// You can construct a concrete instance of `FindingArrayInput` via:
//
//	FindingArray{ FindingArgs{...} }
type FindingArrayInput interface {
	pulumi.Input

	ToFindingArrayOutput() FindingArrayOutput
	ToFindingArrayOutputWithContext(context.Context) FindingArrayOutput
}

type FindingArray []FindingInput

func (FindingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Finding)(nil)).Elem()
}

func (i FindingArray) ToFindingArrayOutput() FindingArrayOutput {
	return i.ToFindingArrayOutputWithContext(context.Background())
}

func (i FindingArray) ToFindingArrayOutputWithContext(ctx context.Context) FindingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FindingArrayOutput)
}

type FindingOutput struct{ *pulumi.OutputState }

func (FindingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Finding)(nil)).Elem()
}

func (o FindingOutput) ToFindingOutput() FindingOutput {
	return o
}

func (o FindingOutput) ToFindingOutputWithContext(ctx context.Context) FindingOutput {
	return o
}

// Zero-based ending index of the found text, exclusively.
func (o FindingOutput) End() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Finding) *string { return v.End }).(pulumi.StringPtrOutput)
}

// The type of information stored in this text range. For example, HumanName, BirthDate, or Address.
func (o FindingOutput) InfoType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Finding) *string { return v.InfoType }).(pulumi.StringPtrOutput)
}

// The snippet of the sensitive text. This field is only populated during deidentification if `store_quote` is set to true in DeidentifyConfig.
func (o FindingOutput) Quote() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Finding) *string { return v.Quote }).(pulumi.StringPtrOutput)
}

// Zero-based starting index of the found text, inclusively.
func (o FindingOutput) Start() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Finding) *string { return v.Start }).(pulumi.StringPtrOutput)
}

type FindingArrayOutput struct{ *pulumi.OutputState }

func (FindingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Finding)(nil)).Elem()
}

func (o FindingArrayOutput) ToFindingArrayOutput() FindingArrayOutput {
	return o
}

func (o FindingArrayOutput) ToFindingArrayOutputWithContext(ctx context.Context) FindingArrayOutput {
	return o
}

func (o FindingArrayOutput) Index(i pulumi.IntInput) FindingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Finding {
		return vs[0].([]Finding)[vs[1].(int)]
	}).(FindingOutput)
}

type FindingResponse struct {
	// Zero-based ending index of the found text, exclusively.
	End string `pulumi:"end"`
	// The type of information stored in this text range. For example, HumanName, BirthDate, or Address.
	InfoType string `pulumi:"infoType"`
	// The snippet of the sensitive text. This field is only populated during deidentification if `store_quote` is set to true in DeidentifyConfig.
	Quote string `pulumi:"quote"`
	// Zero-based starting index of the found text, inclusively.
	Start string `pulumi:"start"`
}

type FindingResponseOutput struct{ *pulumi.OutputState }

func (FindingResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FindingResponse)(nil)).Elem()
}

func (o FindingResponseOutput) ToFindingResponseOutput() FindingResponseOutput {
	return o
}

func (o FindingResponseOutput) ToFindingResponseOutputWithContext(ctx context.Context) FindingResponseOutput {
	return o
}

// Zero-based ending index of the found text, exclusively.
func (o FindingResponseOutput) End() pulumi.StringOutput {
	return o.ApplyT(func(v FindingResponse) string { return v.End }).(pulumi.StringOutput)
}

// The type of information stored in this text range. For example, HumanName, BirthDate, or Address.
func (o FindingResponseOutput) InfoType() pulumi.StringOutput {
	return o.ApplyT(func(v FindingResponse) string { return v.InfoType }).(pulumi.StringOutput)
}

// The snippet of the sensitive text. This field is only populated during deidentification if `store_quote` is set to true in DeidentifyConfig.
func (o FindingResponseOutput) Quote() pulumi.StringOutput {
	return o.ApplyT(func(v FindingResponse) string { return v.Quote }).(pulumi.StringOutput)
}

// Zero-based starting index of the found text, inclusively.
func (o FindingResponseOutput) Start() pulumi.StringOutput {
	return o.ApplyT(func(v FindingResponse) string { return v.Start }).(pulumi.StringOutput)
}

type FindingResponseArrayOutput struct{ *pulumi.OutputState }

func (FindingResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FindingResponse)(nil)).Elem()
}

func (o FindingResponseArrayOutput) ToFindingResponseArrayOutput() FindingResponseArrayOutput {
	return o
}

func (o FindingResponseArrayOutput) ToFindingResponseArrayOutputWithContext(ctx context.Context) FindingResponseArrayOutput {
	return o
}

func (o FindingResponseArrayOutput) Index(i pulumi.IntInput) FindingResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FindingResponse {
		return vs[0].([]FindingResponse)[vs[1].(int)]
	}).(FindingResponseOutput)
}

// Represents a user's consent in terms of the resources that can be accessed and under what conditions.
type GoogleCloudHealthcareV1beta1ConsentPolicy struct {
	// The request conditions to meet to grant access. In addition to any supported comparison operators, authorization rules may have `IN` operator as well as at most 10 logical operators that are limited to `AND` (`&&`), `OR` (`||`).
	AuthorizationRule Expr `pulumi:"authorizationRule"`
	// The resources that this policy applies to. A resource is a match if it matches all the attributes listed here. If empty, this policy applies to all User data mappings for the given user.
	ResourceAttributes []Attribute `pulumi:"resourceAttributes"`
}

// GoogleCloudHealthcareV1beta1ConsentPolicyInput is an input type that accepts GoogleCloudHealthcareV1beta1ConsentPolicyArgs and GoogleCloudHealthcareV1beta1ConsentPolicyOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1beta1ConsentPolicyInput` via:
//
//	GoogleCloudHealthcareV1beta1ConsentPolicyArgs{...}
type GoogleCloudHealthcareV1beta1ConsentPolicyInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1beta1ConsentPolicyOutput() GoogleCloudHealthcareV1beta1ConsentPolicyOutput
	ToGoogleCloudHealthcareV1beta1ConsentPolicyOutputWithContext(context.Context) GoogleCloudHealthcareV1beta1ConsentPolicyOutput
}

// Represents a user's consent in terms of the resources that can be accessed and under what conditions.
type GoogleCloudHealthcareV1beta1ConsentPolicyArgs struct {
	// The request conditions to meet to grant access. In addition to any supported comparison operators, authorization rules may have `IN` operator as well as at most 10 logical operators that are limited to `AND` (`&&`), `OR` (`||`).
	AuthorizationRule ExprInput `pulumi:"authorizationRule"`
	// The resources that this policy applies to. A resource is a match if it matches all the attributes listed here. If empty, this policy applies to all User data mappings for the given user.
	ResourceAttributes AttributeArrayInput `pulumi:"resourceAttributes"`
}

func (GoogleCloudHealthcareV1beta1ConsentPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1ConsentPolicy)(nil)).Elem()
}

func (i GoogleCloudHealthcareV1beta1ConsentPolicyArgs) ToGoogleCloudHealthcareV1beta1ConsentPolicyOutput() GoogleCloudHealthcareV1beta1ConsentPolicyOutput {
	return i.ToGoogleCloudHealthcareV1beta1ConsentPolicyOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1beta1ConsentPolicyArgs) ToGoogleCloudHealthcareV1beta1ConsentPolicyOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1ConsentPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1ConsentPolicyOutput)
}

// GoogleCloudHealthcareV1beta1ConsentPolicyArrayInput is an input type that accepts GoogleCloudHealthcareV1beta1ConsentPolicyArray and GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1beta1ConsentPolicyArrayInput` via:
//
//	GoogleCloudHealthcareV1beta1ConsentPolicyArray{ GoogleCloudHealthcareV1beta1ConsentPolicyArgs{...} }
type GoogleCloudHealthcareV1beta1ConsentPolicyArrayInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput() GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput
	ToGoogleCloudHealthcareV1beta1ConsentPolicyArrayOutputWithContext(context.Context) GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput
}

type GoogleCloudHealthcareV1beta1ConsentPolicyArray []GoogleCloudHealthcareV1beta1ConsentPolicyInput

func (GoogleCloudHealthcareV1beta1ConsentPolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GoogleCloudHealthcareV1beta1ConsentPolicy)(nil)).Elem()
}

func (i GoogleCloudHealthcareV1beta1ConsentPolicyArray) ToGoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput() GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput {
	return i.ToGoogleCloudHealthcareV1beta1ConsentPolicyArrayOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1beta1ConsentPolicyArray) ToGoogleCloudHealthcareV1beta1ConsentPolicyArrayOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput)
}

// Represents a user's consent in terms of the resources that can be accessed and under what conditions.
type GoogleCloudHealthcareV1beta1ConsentPolicyOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1ConsentPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1ConsentPolicy)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1ConsentPolicyOutput) ToGoogleCloudHealthcareV1beta1ConsentPolicyOutput() GoogleCloudHealthcareV1beta1ConsentPolicyOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1ConsentPolicyOutput) ToGoogleCloudHealthcareV1beta1ConsentPolicyOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1ConsentPolicyOutput {
	return o
}

// The request conditions to meet to grant access. In addition to any supported comparison operators, authorization rules may have `IN` operator as well as at most 10 logical operators that are limited to `AND` (`&&`), `OR` (`||`).
func (o GoogleCloudHealthcareV1beta1ConsentPolicyOutput) AuthorizationRule() ExprOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1ConsentPolicy) Expr { return v.AuthorizationRule }).(ExprOutput)
}

// The resources that this policy applies to. A resource is a match if it matches all the attributes listed here. If empty, this policy applies to all User data mappings for the given user.
func (o GoogleCloudHealthcareV1beta1ConsentPolicyOutput) ResourceAttributes() AttributeArrayOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1ConsentPolicy) []Attribute { return v.ResourceAttributes }).(AttributeArrayOutput)
}

type GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GoogleCloudHealthcareV1beta1ConsentPolicy)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput) ToGoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput() GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput) ToGoogleCloudHealthcareV1beta1ConsentPolicyArrayOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput) Index(i pulumi.IntInput) GoogleCloudHealthcareV1beta1ConsentPolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GoogleCloudHealthcareV1beta1ConsentPolicy {
		return vs[0].([]GoogleCloudHealthcareV1beta1ConsentPolicy)[vs[1].(int)]
	}).(GoogleCloudHealthcareV1beta1ConsentPolicyOutput)
}

// Represents a user's consent in terms of the resources that can be accessed and under what conditions.
type GoogleCloudHealthcareV1beta1ConsentPolicyResponse struct {
	// The request conditions to meet to grant access. In addition to any supported comparison operators, authorization rules may have `IN` operator as well as at most 10 logical operators that are limited to `AND` (`&&`), `OR` (`||`).
	AuthorizationRule ExprResponse `pulumi:"authorizationRule"`
	// The resources that this policy applies to. A resource is a match if it matches all the attributes listed here. If empty, this policy applies to all User data mappings for the given user.
	ResourceAttributes []AttributeResponse `pulumi:"resourceAttributes"`
}

// Represents a user's consent in terms of the resources that can be accessed and under what conditions.
type GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1ConsentPolicyResponse)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput) ToGoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput() GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput) ToGoogleCloudHealthcareV1beta1ConsentPolicyResponseOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput {
	return o
}

// The request conditions to meet to grant access. In addition to any supported comparison operators, authorization rules may have `IN` operator as well as at most 10 logical operators that are limited to `AND` (`&&`), `OR` (`||`).
func (o GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput) AuthorizationRule() ExprResponseOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1ConsentPolicyResponse) ExprResponse { return v.AuthorizationRule }).(ExprResponseOutput)
}

// The resources that this policy applies to. A resource is a match if it matches all the attributes listed here. If empty, this policy applies to all User data mappings for the given user.
func (o GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput) ResourceAttributes() AttributeResponseArrayOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1ConsentPolicyResponse) []AttributeResponse {
		return v.ResourceAttributes
	}).(AttributeResponseArrayOutput)
}

type GoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GoogleCloudHealthcareV1beta1ConsentPolicyResponse)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutput) ToGoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutput() GoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutput) ToGoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutput) Index(i pulumi.IntInput) GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GoogleCloudHealthcareV1beta1ConsentPolicyResponse {
		return vs[0].([]GoogleCloudHealthcareV1beta1ConsentPolicyResponse)[vs[1].(int)]
	}).(GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput)
}

// Specifies the FHIR paths to match and how to handle the de-identification of matching fields.
type GoogleCloudHealthcareV1beta1DeidentifyFieldMetadata struct {
	// Replace the field's value with a masking character. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
	CharacterMaskField *CharacterMaskField `pulumi:"characterMaskField"`
	// Inspect the field's text and transform sensitive text. Configure using TextConfig. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Date, DateTime, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
	CleanTextField *CleanTextField `pulumi:"cleanTextField"`
	// Replace field value with a hash of that value. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
	CryptoHashField *CryptoHashField `pulumi:"cryptoHashField"`
	// Shift the date by a randomized number of days. See [date shifting](https://cloud.google.com/dlp/docs/concepts-date-shifting) for more information. Supported [types](https://www.hl7.org/fhir/datatypes.html): Date, DateTime.
	DateShiftField *DateShiftField `pulumi:"dateShiftField"`
	// Keep the field unchanged.
	KeepField *KeepField `pulumi:"keepField"`
	// List of paths to FHIR fields to redact. Each path is a period-separated list where each component is either a field name or FHIR [type](https://www.hl7.org/fhir/datatypes.html) name. All types begin with an upper case letter. For example, the resource field `Patient.Address.city`, which uses a [string](https://www.hl7.org/fhir/datatypes-definitions.html#Address.city) type, can be matched by `Patient.Address.String`. Partial matching is supported. For example, `Patient.Address.city` can be matched by `Address.city` (with `Patient` omitted). Partial matching and type matching can be combined, for example `Patient.Address.city` can be matched by `Address.String`. For "choice" types (those defined in the FHIR spec with the format `field[x]`), use two separate components. For example, `deceasedAge.unit` is matched by `Deceased.Age.unit`. The following types are supported: AdministrativeGenderCode, Base64Binary, Boolean, Code, Date, DateTime, Decimal, HumanName, Id, Instant, Integer, LanguageCode, Markdown, Oid, PositiveInt, String, UnsignedInt, Uri, Uuid, Xhtml. The sub-type for HumanName (for example `HumanName.given`, `HumanName.family`) can be omitted.
	Paths []string `pulumi:"paths"`
	// Remove the field.
	RemoveField *RemoveField `pulumi:"removeField"`
}

// GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataInput is an input type that accepts GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArgs and GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataInput` via:
//
//	GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArgs{...}
type GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutput() GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutput
	ToGoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutputWithContext(context.Context) GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutput
}

// Specifies the FHIR paths to match and how to handle the de-identification of matching fields.
type GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArgs struct {
	// Replace the field's value with a masking character. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
	CharacterMaskField CharacterMaskFieldPtrInput `pulumi:"characterMaskField"`
	// Inspect the field's text and transform sensitive text. Configure using TextConfig. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Date, DateTime, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
	CleanTextField CleanTextFieldPtrInput `pulumi:"cleanTextField"`
	// Replace field value with a hash of that value. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
	CryptoHashField CryptoHashFieldPtrInput `pulumi:"cryptoHashField"`
	// Shift the date by a randomized number of days. See [date shifting](https://cloud.google.com/dlp/docs/concepts-date-shifting) for more information. Supported [types](https://www.hl7.org/fhir/datatypes.html): Date, DateTime.
	DateShiftField DateShiftFieldPtrInput `pulumi:"dateShiftField"`
	// Keep the field unchanged.
	KeepField KeepFieldPtrInput `pulumi:"keepField"`
	// List of paths to FHIR fields to redact. Each path is a period-separated list where each component is either a field name or FHIR [type](https://www.hl7.org/fhir/datatypes.html) name. All types begin with an upper case letter. For example, the resource field `Patient.Address.city`, which uses a [string](https://www.hl7.org/fhir/datatypes-definitions.html#Address.city) type, can be matched by `Patient.Address.String`. Partial matching is supported. For example, `Patient.Address.city` can be matched by `Address.city` (with `Patient` omitted). Partial matching and type matching can be combined, for example `Patient.Address.city` can be matched by `Address.String`. For "choice" types (those defined in the FHIR spec with the format `field[x]`), use two separate components. For example, `deceasedAge.unit` is matched by `Deceased.Age.unit`. The following types are supported: AdministrativeGenderCode, Base64Binary, Boolean, Code, Date, DateTime, Decimal, HumanName, Id, Instant, Integer, LanguageCode, Markdown, Oid, PositiveInt, String, UnsignedInt, Uri, Uuid, Xhtml. The sub-type for HumanName (for example `HumanName.given`, `HumanName.family`) can be omitted.
	Paths pulumi.StringArrayInput `pulumi:"paths"`
	// Remove the field.
	RemoveField RemoveFieldPtrInput `pulumi:"removeField"`
}

func (GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1DeidentifyFieldMetadata)(nil)).Elem()
}

func (i GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArgs) ToGoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutput() GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutput {
	return i.ToGoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArgs) ToGoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutput)
}

// GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayInput is an input type that accepts GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArray and GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayInput` via:
//
//	GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArray{ GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArgs{...} }
type GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayOutput() GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayOutput
	ToGoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayOutputWithContext(context.Context) GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayOutput
}

type GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArray []GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataInput

func (GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GoogleCloudHealthcareV1beta1DeidentifyFieldMetadata)(nil)).Elem()
}

func (i GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArray) ToGoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayOutput() GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayOutput {
	return i.ToGoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArray) ToGoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayOutput)
}

// Specifies the FHIR paths to match and how to handle the de-identification of matching fields.
type GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1DeidentifyFieldMetadata)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutput) ToGoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutput() GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutput) ToGoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutput {
	return o
}

// Replace the field's value with a masking character. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
func (o GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutput) CharacterMaskField() CharacterMaskFieldPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DeidentifyFieldMetadata) *CharacterMaskField {
		return v.CharacterMaskField
	}).(CharacterMaskFieldPtrOutput)
}

// Inspect the field's text and transform sensitive text. Configure using TextConfig. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Date, DateTime, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
func (o GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutput) CleanTextField() CleanTextFieldPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DeidentifyFieldMetadata) *CleanTextField { return v.CleanTextField }).(CleanTextFieldPtrOutput)
}

// Replace field value with a hash of that value. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
func (o GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutput) CryptoHashField() CryptoHashFieldPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DeidentifyFieldMetadata) *CryptoHashField { return v.CryptoHashField }).(CryptoHashFieldPtrOutput)
}

// Shift the date by a randomized number of days. See [date shifting](https://cloud.google.com/dlp/docs/concepts-date-shifting) for more information. Supported [types](https://www.hl7.org/fhir/datatypes.html): Date, DateTime.
func (o GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutput) DateShiftField() DateShiftFieldPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DeidentifyFieldMetadata) *DateShiftField { return v.DateShiftField }).(DateShiftFieldPtrOutput)
}

// Keep the field unchanged.
func (o GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutput) KeepField() KeepFieldPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DeidentifyFieldMetadata) *KeepField { return v.KeepField }).(KeepFieldPtrOutput)
}

// List of paths to FHIR fields to redact. Each path is a period-separated list where each component is either a field name or FHIR [type](https://www.hl7.org/fhir/datatypes.html) name. All types begin with an upper case letter. For example, the resource field `Patient.Address.city`, which uses a [string](https://www.hl7.org/fhir/datatypes-definitions.html#Address.city) type, can be matched by `Patient.Address.String`. Partial matching is supported. For example, `Patient.Address.city` can be matched by `Address.city` (with `Patient` omitted). Partial matching and type matching can be combined, for example `Patient.Address.city` can be matched by `Address.String`. For "choice" types (those defined in the FHIR spec with the format `field[x]`), use two separate components. For example, `deceasedAge.unit` is matched by `Deceased.Age.unit`. The following types are supported: AdministrativeGenderCode, Base64Binary, Boolean, Code, Date, DateTime, Decimal, HumanName, Id, Instant, Integer, LanguageCode, Markdown, Oid, PositiveInt, String, UnsignedInt, Uri, Uuid, Xhtml. The sub-type for HumanName (for example `HumanName.given`, `HumanName.family`) can be omitted.
func (o GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutput) Paths() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DeidentifyFieldMetadata) []string { return v.Paths }).(pulumi.StringArrayOutput)
}

// Remove the field.
func (o GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutput) RemoveField() RemoveFieldPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DeidentifyFieldMetadata) *RemoveField { return v.RemoveField }).(RemoveFieldPtrOutput)
}

type GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GoogleCloudHealthcareV1beta1DeidentifyFieldMetadata)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayOutput) ToGoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayOutput() GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayOutput) ToGoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayOutput) Index(i pulumi.IntInput) GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GoogleCloudHealthcareV1beta1DeidentifyFieldMetadata {
		return vs[0].([]GoogleCloudHealthcareV1beta1DeidentifyFieldMetadata)[vs[1].(int)]
	}).(GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutput)
}

// Specifies the FHIR paths to match and how to handle the de-identification of matching fields.
type GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponse struct {
	// Replace the field's value with a masking character. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
	CharacterMaskField CharacterMaskFieldResponse `pulumi:"characterMaskField"`
	// Inspect the field's text and transform sensitive text. Configure using TextConfig. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Date, DateTime, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
	CleanTextField CleanTextFieldResponse `pulumi:"cleanTextField"`
	// Replace field value with a hash of that value. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
	CryptoHashField CryptoHashFieldResponse `pulumi:"cryptoHashField"`
	// Shift the date by a randomized number of days. See [date shifting](https://cloud.google.com/dlp/docs/concepts-date-shifting) for more information. Supported [types](https://www.hl7.org/fhir/datatypes.html): Date, DateTime.
	DateShiftField DateShiftFieldResponse `pulumi:"dateShiftField"`
	// Keep the field unchanged.
	KeepField KeepFieldResponse `pulumi:"keepField"`
	// List of paths to FHIR fields to redact. Each path is a period-separated list where each component is either a field name or FHIR [type](https://www.hl7.org/fhir/datatypes.html) name. All types begin with an upper case letter. For example, the resource field `Patient.Address.city`, which uses a [string](https://www.hl7.org/fhir/datatypes-definitions.html#Address.city) type, can be matched by `Patient.Address.String`. Partial matching is supported. For example, `Patient.Address.city` can be matched by `Address.city` (with `Patient` omitted). Partial matching and type matching can be combined, for example `Patient.Address.city` can be matched by `Address.String`. For "choice" types (those defined in the FHIR spec with the format `field[x]`), use two separate components. For example, `deceasedAge.unit` is matched by `Deceased.Age.unit`. The following types are supported: AdministrativeGenderCode, Base64Binary, Boolean, Code, Date, DateTime, Decimal, HumanName, Id, Instant, Integer, LanguageCode, Markdown, Oid, PositiveInt, String, UnsignedInt, Uri, Uuid, Xhtml. The sub-type for HumanName (for example `HumanName.given`, `HumanName.family`) can be omitted.
	Paths []string `pulumi:"paths"`
	// Remove the field.
	RemoveField RemoveFieldResponse `pulumi:"removeField"`
}

// Specifies the FHIR paths to match and how to handle the de-identification of matching fields.
type GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponse)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseOutput) ToGoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseOutput() GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseOutput) ToGoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseOutput {
	return o
}

// Replace the field's value with a masking character. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
func (o GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseOutput) CharacterMaskField() CharacterMaskFieldResponseOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponse) CharacterMaskFieldResponse {
		return v.CharacterMaskField
	}).(CharacterMaskFieldResponseOutput)
}

// Inspect the field's text and transform sensitive text. Configure using TextConfig. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Date, DateTime, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
func (o GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseOutput) CleanTextField() CleanTextFieldResponseOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponse) CleanTextFieldResponse {
		return v.CleanTextField
	}).(CleanTextFieldResponseOutput)
}

// Replace field value with a hash of that value. Supported [types](https://www.hl7.org/fhir/datatypes.html): Code, Decimal, HumanName, Id, LanguageCode, Markdown, Oid, String, Uri, Uuid, Xhtml.
func (o GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseOutput) CryptoHashField() CryptoHashFieldResponseOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponse) CryptoHashFieldResponse {
		return v.CryptoHashField
	}).(CryptoHashFieldResponseOutput)
}

// Shift the date by a randomized number of days. See [date shifting](https://cloud.google.com/dlp/docs/concepts-date-shifting) for more information. Supported [types](https://www.hl7.org/fhir/datatypes.html): Date, DateTime.
func (o GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseOutput) DateShiftField() DateShiftFieldResponseOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponse) DateShiftFieldResponse {
		return v.DateShiftField
	}).(DateShiftFieldResponseOutput)
}

// Keep the field unchanged.
func (o GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseOutput) KeepField() KeepFieldResponseOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponse) KeepFieldResponse {
		return v.KeepField
	}).(KeepFieldResponseOutput)
}

// List of paths to FHIR fields to redact. Each path is a period-separated list where each component is either a field name or FHIR [type](https://www.hl7.org/fhir/datatypes.html) name. All types begin with an upper case letter. For example, the resource field `Patient.Address.city`, which uses a [string](https://www.hl7.org/fhir/datatypes-definitions.html#Address.city) type, can be matched by `Patient.Address.String`. Partial matching is supported. For example, `Patient.Address.city` can be matched by `Address.city` (with `Patient` omitted). Partial matching and type matching can be combined, for example `Patient.Address.city` can be matched by `Address.String`. For "choice" types (those defined in the FHIR spec with the format `field[x]`), use two separate components. For example, `deceasedAge.unit` is matched by `Deceased.Age.unit`. The following types are supported: AdministrativeGenderCode, Base64Binary, Boolean, Code, Date, DateTime, Decimal, HumanName, Id, Instant, Integer, LanguageCode, Markdown, Oid, PositiveInt, String, UnsignedInt, Uri, Uuid, Xhtml. The sub-type for HumanName (for example `HumanName.given`, `HumanName.family`) can be omitted.
func (o GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseOutput) Paths() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponse) []string { return v.Paths }).(pulumi.StringArrayOutput)
}

// Remove the field.
func (o GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseOutput) RemoveField() RemoveFieldResponseOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponse) RemoveFieldResponse {
		return v.RemoveField
	}).(RemoveFieldResponseOutput)
}

type GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseArrayOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponse)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseArrayOutput) ToGoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseArrayOutput() GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseArrayOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseArrayOutput) ToGoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseArrayOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseArrayOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseArrayOutput) Index(i pulumi.IntInput) GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponse {
		return vs[0].([]GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponse)[vs[1].(int)]
	}).(GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseOutput)
}

// Specifies additional options to apply to the base ProfileType.
type GoogleCloudHealthcareV1beta1DeidentifyOptions struct {
	// Character mask config for CharacterMaskField.
	CharacterMaskConfig *CharacterMaskConfig `pulumi:"characterMaskConfig"`
	// Configure contextual de-id.
	ContextualDeid *ContextualDeidConfig `pulumi:"contextualDeid"`
	// Crypto hash config for CharacterMaskField.
	CryptoHashConfig *CryptoHashConfig `pulumi:"cryptoHashConfig"`
	// Date shifting config for CharacterMaskField.
	DateShiftConfig *DateShiftConfig `pulumi:"dateShiftConfig"`
	// Configure keeping extensions by default.
	KeepExtensions *KeepExtensionsConfig `pulumi:"keepExtensions"`
}

// GoogleCloudHealthcareV1beta1DeidentifyOptionsInput is an input type that accepts GoogleCloudHealthcareV1beta1DeidentifyOptionsArgs and GoogleCloudHealthcareV1beta1DeidentifyOptionsOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1beta1DeidentifyOptionsInput` via:
//
//	GoogleCloudHealthcareV1beta1DeidentifyOptionsArgs{...}
type GoogleCloudHealthcareV1beta1DeidentifyOptionsInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1beta1DeidentifyOptionsOutput() GoogleCloudHealthcareV1beta1DeidentifyOptionsOutput
	ToGoogleCloudHealthcareV1beta1DeidentifyOptionsOutputWithContext(context.Context) GoogleCloudHealthcareV1beta1DeidentifyOptionsOutput
}

// Specifies additional options to apply to the base ProfileType.
type GoogleCloudHealthcareV1beta1DeidentifyOptionsArgs struct {
	// Character mask config for CharacterMaskField.
	CharacterMaskConfig CharacterMaskConfigPtrInput `pulumi:"characterMaskConfig"`
	// Configure contextual de-id.
	ContextualDeid ContextualDeidConfigPtrInput `pulumi:"contextualDeid"`
	// Crypto hash config for CharacterMaskField.
	CryptoHashConfig CryptoHashConfigPtrInput `pulumi:"cryptoHashConfig"`
	// Date shifting config for CharacterMaskField.
	DateShiftConfig DateShiftConfigPtrInput `pulumi:"dateShiftConfig"`
	// Configure keeping extensions by default.
	KeepExtensions KeepExtensionsConfigPtrInput `pulumi:"keepExtensions"`
}

func (GoogleCloudHealthcareV1beta1DeidentifyOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1DeidentifyOptions)(nil)).Elem()
}

func (i GoogleCloudHealthcareV1beta1DeidentifyOptionsArgs) ToGoogleCloudHealthcareV1beta1DeidentifyOptionsOutput() GoogleCloudHealthcareV1beta1DeidentifyOptionsOutput {
	return i.ToGoogleCloudHealthcareV1beta1DeidentifyOptionsOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1beta1DeidentifyOptionsArgs) ToGoogleCloudHealthcareV1beta1DeidentifyOptionsOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DeidentifyOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1DeidentifyOptionsOutput)
}

func (i GoogleCloudHealthcareV1beta1DeidentifyOptionsArgs) ToGoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput() GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput {
	return i.ToGoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1beta1DeidentifyOptionsArgs) ToGoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1DeidentifyOptionsOutput).ToGoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutputWithContext(ctx)
}

// GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrInput is an input type that accepts GoogleCloudHealthcareV1beta1DeidentifyOptionsArgs, GoogleCloudHealthcareV1beta1DeidentifyOptionsPtr and GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrInput` via:
//
//	        GoogleCloudHealthcareV1beta1DeidentifyOptionsArgs{...}
//
//	or:
//
//	        nil
type GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput() GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput
	ToGoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutputWithContext(context.Context) GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput
}

type googleCloudHealthcareV1beta1DeidentifyOptionsPtrType GoogleCloudHealthcareV1beta1DeidentifyOptionsArgs

func GoogleCloudHealthcareV1beta1DeidentifyOptionsPtr(v *GoogleCloudHealthcareV1beta1DeidentifyOptionsArgs) GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrInput {
	return (*googleCloudHealthcareV1beta1DeidentifyOptionsPtrType)(v)
}

func (*googleCloudHealthcareV1beta1DeidentifyOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GoogleCloudHealthcareV1beta1DeidentifyOptions)(nil)).Elem()
}

func (i *googleCloudHealthcareV1beta1DeidentifyOptionsPtrType) ToGoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput() GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput {
	return i.ToGoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutputWithContext(context.Background())
}

func (i *googleCloudHealthcareV1beta1DeidentifyOptionsPtrType) ToGoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput)
}

// Specifies additional options to apply to the base ProfileType.
type GoogleCloudHealthcareV1beta1DeidentifyOptionsOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1DeidentifyOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1DeidentifyOptions)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1DeidentifyOptionsOutput) ToGoogleCloudHealthcareV1beta1DeidentifyOptionsOutput() GoogleCloudHealthcareV1beta1DeidentifyOptionsOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DeidentifyOptionsOutput) ToGoogleCloudHealthcareV1beta1DeidentifyOptionsOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DeidentifyOptionsOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DeidentifyOptionsOutput) ToGoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput() GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput {
	return o.ToGoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutputWithContext(context.Background())
}

func (o GoogleCloudHealthcareV1beta1DeidentifyOptionsOutput) ToGoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GoogleCloudHealthcareV1beta1DeidentifyOptions) *GoogleCloudHealthcareV1beta1DeidentifyOptions {
		return &v
	}).(GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput)
}

// Character mask config for CharacterMaskField.
func (o GoogleCloudHealthcareV1beta1DeidentifyOptionsOutput) CharacterMaskConfig() CharacterMaskConfigPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DeidentifyOptions) *CharacterMaskConfig {
		return v.CharacterMaskConfig
	}).(CharacterMaskConfigPtrOutput)
}

// Configure contextual de-id.
func (o GoogleCloudHealthcareV1beta1DeidentifyOptionsOutput) ContextualDeid() ContextualDeidConfigPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DeidentifyOptions) *ContextualDeidConfig { return v.ContextualDeid }).(ContextualDeidConfigPtrOutput)
}

// Crypto hash config for CharacterMaskField.
func (o GoogleCloudHealthcareV1beta1DeidentifyOptionsOutput) CryptoHashConfig() CryptoHashConfigPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DeidentifyOptions) *CryptoHashConfig { return v.CryptoHashConfig }).(CryptoHashConfigPtrOutput)
}

// Date shifting config for CharacterMaskField.
func (o GoogleCloudHealthcareV1beta1DeidentifyOptionsOutput) DateShiftConfig() DateShiftConfigPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DeidentifyOptions) *DateShiftConfig { return v.DateShiftConfig }).(DateShiftConfigPtrOutput)
}

// Configure keeping extensions by default.
func (o GoogleCloudHealthcareV1beta1DeidentifyOptionsOutput) KeepExtensions() KeepExtensionsConfigPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DeidentifyOptions) *KeepExtensionsConfig { return v.KeepExtensions }).(KeepExtensionsConfigPtrOutput)
}

type GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GoogleCloudHealthcareV1beta1DeidentifyOptions)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput) ToGoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput() GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput) ToGoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput) Elem() GoogleCloudHealthcareV1beta1DeidentifyOptionsOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1beta1DeidentifyOptions) GoogleCloudHealthcareV1beta1DeidentifyOptions {
		if v != nil {
			return *v
		}
		var ret GoogleCloudHealthcareV1beta1DeidentifyOptions
		return ret
	}).(GoogleCloudHealthcareV1beta1DeidentifyOptionsOutput)
}

// Character mask config for CharacterMaskField.
func (o GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput) CharacterMaskConfig() CharacterMaskConfigPtrOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1beta1DeidentifyOptions) *CharacterMaskConfig {
		if v == nil {
			return nil
		}
		return v.CharacterMaskConfig
	}).(CharacterMaskConfigPtrOutput)
}

// Configure contextual de-id.
func (o GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput) ContextualDeid() ContextualDeidConfigPtrOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1beta1DeidentifyOptions) *ContextualDeidConfig {
		if v == nil {
			return nil
		}
		return v.ContextualDeid
	}).(ContextualDeidConfigPtrOutput)
}

// Crypto hash config for CharacterMaskField.
func (o GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput) CryptoHashConfig() CryptoHashConfigPtrOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1beta1DeidentifyOptions) *CryptoHashConfig {
		if v == nil {
			return nil
		}
		return v.CryptoHashConfig
	}).(CryptoHashConfigPtrOutput)
}

// Date shifting config for CharacterMaskField.
func (o GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput) DateShiftConfig() DateShiftConfigPtrOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1beta1DeidentifyOptions) *DateShiftConfig {
		if v == nil {
			return nil
		}
		return v.DateShiftConfig
	}).(DateShiftConfigPtrOutput)
}

// Configure keeping extensions by default.
func (o GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput) KeepExtensions() KeepExtensionsConfigPtrOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1beta1DeidentifyOptions) *KeepExtensionsConfig {
		if v == nil {
			return nil
		}
		return v.KeepExtensions
	}).(KeepExtensionsConfigPtrOutput)
}

// Specifies additional options to apply to the base ProfileType.
type GoogleCloudHealthcareV1beta1DeidentifyOptionsResponse struct {
	// Character mask config for CharacterMaskField.
	CharacterMaskConfig CharacterMaskConfigResponse `pulumi:"characterMaskConfig"`
	// Configure contextual de-id.
	ContextualDeid ContextualDeidConfigResponse `pulumi:"contextualDeid"`
	// Crypto hash config for CharacterMaskField.
	CryptoHashConfig CryptoHashConfigResponse `pulumi:"cryptoHashConfig"`
	// Date shifting config for CharacterMaskField.
	DateShiftConfig DateShiftConfigResponse `pulumi:"dateShiftConfig"`
	// Configure keeping extensions by default.
	KeepExtensions KeepExtensionsConfigResponse `pulumi:"keepExtensions"`
}

// Specifies additional options to apply to the base ProfileType.
type GoogleCloudHealthcareV1beta1DeidentifyOptionsResponseOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1DeidentifyOptionsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1DeidentifyOptionsResponse)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1DeidentifyOptionsResponseOutput) ToGoogleCloudHealthcareV1beta1DeidentifyOptionsResponseOutput() GoogleCloudHealthcareV1beta1DeidentifyOptionsResponseOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DeidentifyOptionsResponseOutput) ToGoogleCloudHealthcareV1beta1DeidentifyOptionsResponseOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DeidentifyOptionsResponseOutput {
	return o
}

// Character mask config for CharacterMaskField.
func (o GoogleCloudHealthcareV1beta1DeidentifyOptionsResponseOutput) CharacterMaskConfig() CharacterMaskConfigResponseOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DeidentifyOptionsResponse) CharacterMaskConfigResponse {
		return v.CharacterMaskConfig
	}).(CharacterMaskConfigResponseOutput)
}

// Configure contextual de-id.
func (o GoogleCloudHealthcareV1beta1DeidentifyOptionsResponseOutput) ContextualDeid() ContextualDeidConfigResponseOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DeidentifyOptionsResponse) ContextualDeidConfigResponse {
		return v.ContextualDeid
	}).(ContextualDeidConfigResponseOutput)
}

// Crypto hash config for CharacterMaskField.
func (o GoogleCloudHealthcareV1beta1DeidentifyOptionsResponseOutput) CryptoHashConfig() CryptoHashConfigResponseOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DeidentifyOptionsResponse) CryptoHashConfigResponse {
		return v.CryptoHashConfig
	}).(CryptoHashConfigResponseOutput)
}

// Date shifting config for CharacterMaskField.
func (o GoogleCloudHealthcareV1beta1DeidentifyOptionsResponseOutput) DateShiftConfig() DateShiftConfigResponseOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DeidentifyOptionsResponse) DateShiftConfigResponse {
		return v.DateShiftConfig
	}).(DateShiftConfigResponseOutput)
}

// Configure keeping extensions by default.
func (o GoogleCloudHealthcareV1beta1DeidentifyOptionsResponseOutput) KeepExtensions() KeepExtensionsConfigResponseOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DeidentifyOptionsResponse) KeepExtensionsConfigResponse {
		return v.KeepExtensions
	}).(KeepExtensionsConfigResponseOutput)
}

// The BigQuery table where the server writes output.
type GoogleCloudHealthcareV1beta1DicomBigQueryDestination struct {
	// Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
	Force *bool `pulumi:"force"`
	// BigQuery URI to a table, up to 2000 characters long, in the format `bq://projectId.bqDatasetId.tableId`
	TableUri *string `pulumi:"tableUri"`
	// Determines whether the existing table in the destination is to be overwritten or appended to. If a write_disposition is specified, the `force` parameter is ignored.
	WriteDisposition *GoogleCloudHealthcareV1beta1DicomBigQueryDestinationWriteDisposition `pulumi:"writeDisposition"`
}

// GoogleCloudHealthcareV1beta1DicomBigQueryDestinationInput is an input type that accepts GoogleCloudHealthcareV1beta1DicomBigQueryDestinationArgs and GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1beta1DicomBigQueryDestinationInput` via:
//
//	GoogleCloudHealthcareV1beta1DicomBigQueryDestinationArgs{...}
type GoogleCloudHealthcareV1beta1DicomBigQueryDestinationInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput
	ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutputWithContext(context.Context) GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput
}

// The BigQuery table where the server writes output.
type GoogleCloudHealthcareV1beta1DicomBigQueryDestinationArgs struct {
	// Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
	Force pulumi.BoolPtrInput `pulumi:"force"`
	// BigQuery URI to a table, up to 2000 characters long, in the format `bq://projectId.bqDatasetId.tableId`
	TableUri pulumi.StringPtrInput `pulumi:"tableUri"`
	// Determines whether the existing table in the destination is to be overwritten or appended to. If a write_disposition is specified, the `force` parameter is ignored.
	WriteDisposition GoogleCloudHealthcareV1beta1DicomBigQueryDestinationWriteDispositionPtrInput `pulumi:"writeDisposition"`
}

func (GoogleCloudHealthcareV1beta1DicomBigQueryDestinationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1DicomBigQueryDestination)(nil)).Elem()
}

func (i GoogleCloudHealthcareV1beta1DicomBigQueryDestinationArgs) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput {
	return i.ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1beta1DicomBigQueryDestinationArgs) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput)
}

func (i GoogleCloudHealthcareV1beta1DicomBigQueryDestinationArgs) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput {
	return i.ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1beta1DicomBigQueryDestinationArgs) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput).ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutputWithContext(ctx)
}

// GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrInput is an input type that accepts GoogleCloudHealthcareV1beta1DicomBigQueryDestinationArgs, GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtr and GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrInput` via:
//
//	        GoogleCloudHealthcareV1beta1DicomBigQueryDestinationArgs{...}
//
//	or:
//
//	        nil
type GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput
	ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutputWithContext(context.Context) GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput
}

type googleCloudHealthcareV1beta1DicomBigQueryDestinationPtrType GoogleCloudHealthcareV1beta1DicomBigQueryDestinationArgs

func GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtr(v *GoogleCloudHealthcareV1beta1DicomBigQueryDestinationArgs) GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrInput {
	return (*googleCloudHealthcareV1beta1DicomBigQueryDestinationPtrType)(v)
}

func (*googleCloudHealthcareV1beta1DicomBigQueryDestinationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GoogleCloudHealthcareV1beta1DicomBigQueryDestination)(nil)).Elem()
}

func (i *googleCloudHealthcareV1beta1DicomBigQueryDestinationPtrType) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput {
	return i.ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutputWithContext(context.Background())
}

func (i *googleCloudHealthcareV1beta1DicomBigQueryDestinationPtrType) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput)
}

// The BigQuery table where the server writes output.
type GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1DicomBigQueryDestination)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput {
	return o.ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutputWithContext(context.Background())
}

func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GoogleCloudHealthcareV1beta1DicomBigQueryDestination) *GoogleCloudHealthcareV1beta1DicomBigQueryDestination {
		return &v
	}).(GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput)
}

// Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput) Force() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DicomBigQueryDestination) *bool { return v.Force }).(pulumi.BoolPtrOutput)
}

// BigQuery URI to a table, up to 2000 characters long, in the format `bq://projectId.bqDatasetId.tableId`
func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput) TableUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DicomBigQueryDestination) *string { return v.TableUri }).(pulumi.StringPtrOutput)
}

// Determines whether the existing table in the destination is to be overwritten or appended to. If a write_disposition is specified, the `force` parameter is ignored.
func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput) WriteDisposition() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationWriteDispositionPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DicomBigQueryDestination) *GoogleCloudHealthcareV1beta1DicomBigQueryDestinationWriteDisposition {
		return v.WriteDisposition
	}).(GoogleCloudHealthcareV1beta1DicomBigQueryDestinationWriteDispositionPtrOutput)
}

type GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GoogleCloudHealthcareV1beta1DicomBigQueryDestination)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput) Elem() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1beta1DicomBigQueryDestination) GoogleCloudHealthcareV1beta1DicomBigQueryDestination {
		if v != nil {
			return *v
		}
		var ret GoogleCloudHealthcareV1beta1DicomBigQueryDestination
		return ret
	}).(GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput)
}

// Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput) Force() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1beta1DicomBigQueryDestination) *bool {
		if v == nil {
			return nil
		}
		return v.Force
	}).(pulumi.BoolPtrOutput)
}

// BigQuery URI to a table, up to 2000 characters long, in the format `bq://projectId.bqDatasetId.tableId`
func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput) TableUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1beta1DicomBigQueryDestination) *string {
		if v == nil {
			return nil
		}
		return v.TableUri
	}).(pulumi.StringPtrOutput)
}

// Determines whether the existing table in the destination is to be overwritten or appended to. If a write_disposition is specified, the `force` parameter is ignored.
func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput) WriteDisposition() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationWriteDispositionPtrOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1beta1DicomBigQueryDestination) *GoogleCloudHealthcareV1beta1DicomBigQueryDestinationWriteDisposition {
		if v == nil {
			return nil
		}
		return v.WriteDisposition
	}).(GoogleCloudHealthcareV1beta1DicomBigQueryDestinationWriteDispositionPtrOutput)
}

// The BigQuery table where the server writes output.
type GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponse struct {
	// Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
	Force bool `pulumi:"force"`
	// BigQuery URI to a table, up to 2000 characters long, in the format `bq://projectId.bqDatasetId.tableId`
	TableUri string `pulumi:"tableUri"`
	// Determines whether the existing table in the destination is to be overwritten or appended to. If a write_disposition is specified, the `force` parameter is ignored.
	WriteDisposition string `pulumi:"writeDisposition"`
}

// The BigQuery table where the server writes output.
type GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponse)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput) ToGoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput {
	return o
}

// Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput) Force() pulumi.BoolOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponse) bool { return v.Force }).(pulumi.BoolOutput)
}

// BigQuery URI to a table, up to 2000 characters long, in the format `bq://projectId.bqDatasetId.tableId`
func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput) TableUri() pulumi.StringOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponse) string { return v.TableUri }).(pulumi.StringOutput)
}

// Determines whether the existing table in the destination is to be overwritten or appended to. If a write_disposition is specified, the `force` parameter is ignored.
func (o GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput) WriteDisposition() pulumi.StringOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponse) string { return v.WriteDisposition }).(pulumi.StringOutput)
}

// StreamConfig specifies configuration for a streaming DICOM export.
type GoogleCloudHealthcareV1beta1DicomStreamConfig struct {
	// Results are appended to this table. The server creates a new table in the given BigQuery dataset if the specified table does not exist. To enable the Cloud Healthcare API to write to your BigQuery table, you must give the Cloud Healthcare API service account the bigquery.dataEditor role. The service account is: `service-{PROJECT_NUMBER}@gcp-sa-healthcare.iam.gserviceaccount.com`. The PROJECT_NUMBER identifies the project that the DICOM store resides in. To get the project number, go to the Cloud Console Dashboard. It is recommended to not have a custom schema in the destination table which could conflict with the schema created by the Cloud Healthcare API. Instance deletions are not applied to the destination table. The destination's table schema will be automatically updated in case a new instance's data is incompatible with the current schema. The schema should not be updated manually as this can cause incompatibilies that cannot be resolved automatically. One resolution in this case is to delete the incompatible table and let the server recreate one, though the newly created table only contains data after the table recreation. BigQuery imposes a 1 MB limit on streaming insert row size, therefore any instance that generates more than 1 MB of BigQuery data will not be streamed. If an instance cannot be streamed to BigQuery, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
	BigqueryDestination *GoogleCloudHealthcareV1beta1DicomBigQueryDestination `pulumi:"bigqueryDestination"`
}

// GoogleCloudHealthcareV1beta1DicomStreamConfigInput is an input type that accepts GoogleCloudHealthcareV1beta1DicomStreamConfigArgs and GoogleCloudHealthcareV1beta1DicomStreamConfigOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1beta1DicomStreamConfigInput` via:
//
//	GoogleCloudHealthcareV1beta1DicomStreamConfigArgs{...}
type GoogleCloudHealthcareV1beta1DicomStreamConfigInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1beta1DicomStreamConfigOutput() GoogleCloudHealthcareV1beta1DicomStreamConfigOutput
	ToGoogleCloudHealthcareV1beta1DicomStreamConfigOutputWithContext(context.Context) GoogleCloudHealthcareV1beta1DicomStreamConfigOutput
}

// StreamConfig specifies configuration for a streaming DICOM export.
type GoogleCloudHealthcareV1beta1DicomStreamConfigArgs struct {
	// Results are appended to this table. The server creates a new table in the given BigQuery dataset if the specified table does not exist. To enable the Cloud Healthcare API to write to your BigQuery table, you must give the Cloud Healthcare API service account the bigquery.dataEditor role. The service account is: `service-{PROJECT_NUMBER}@gcp-sa-healthcare.iam.gserviceaccount.com`. The PROJECT_NUMBER identifies the project that the DICOM store resides in. To get the project number, go to the Cloud Console Dashboard. It is recommended to not have a custom schema in the destination table which could conflict with the schema created by the Cloud Healthcare API. Instance deletions are not applied to the destination table. The destination's table schema will be automatically updated in case a new instance's data is incompatible with the current schema. The schema should not be updated manually as this can cause incompatibilies that cannot be resolved automatically. One resolution in this case is to delete the incompatible table and let the server recreate one, though the newly created table only contains data after the table recreation. BigQuery imposes a 1 MB limit on streaming insert row size, therefore any instance that generates more than 1 MB of BigQuery data will not be streamed. If an instance cannot be streamed to BigQuery, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
	BigqueryDestination GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrInput `pulumi:"bigqueryDestination"`
}

func (GoogleCloudHealthcareV1beta1DicomStreamConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1DicomStreamConfig)(nil)).Elem()
}

func (i GoogleCloudHealthcareV1beta1DicomStreamConfigArgs) ToGoogleCloudHealthcareV1beta1DicomStreamConfigOutput() GoogleCloudHealthcareV1beta1DicomStreamConfigOutput {
	return i.ToGoogleCloudHealthcareV1beta1DicomStreamConfigOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1beta1DicomStreamConfigArgs) ToGoogleCloudHealthcareV1beta1DicomStreamConfigOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomStreamConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1DicomStreamConfigOutput)
}

// GoogleCloudHealthcareV1beta1DicomStreamConfigArrayInput is an input type that accepts GoogleCloudHealthcareV1beta1DicomStreamConfigArray and GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1beta1DicomStreamConfigArrayInput` via:
//
//	GoogleCloudHealthcareV1beta1DicomStreamConfigArray{ GoogleCloudHealthcareV1beta1DicomStreamConfigArgs{...} }
type GoogleCloudHealthcareV1beta1DicomStreamConfigArrayInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput() GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput
	ToGoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutputWithContext(context.Context) GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput
}

type GoogleCloudHealthcareV1beta1DicomStreamConfigArray []GoogleCloudHealthcareV1beta1DicomStreamConfigInput

func (GoogleCloudHealthcareV1beta1DicomStreamConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GoogleCloudHealthcareV1beta1DicomStreamConfig)(nil)).Elem()
}

func (i GoogleCloudHealthcareV1beta1DicomStreamConfigArray) ToGoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput() GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput {
	return i.ToGoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1beta1DicomStreamConfigArray) ToGoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput)
}

// StreamConfig specifies configuration for a streaming DICOM export.
type GoogleCloudHealthcareV1beta1DicomStreamConfigOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1DicomStreamConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1DicomStreamConfig)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1DicomStreamConfigOutput) ToGoogleCloudHealthcareV1beta1DicomStreamConfigOutput() GoogleCloudHealthcareV1beta1DicomStreamConfigOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DicomStreamConfigOutput) ToGoogleCloudHealthcareV1beta1DicomStreamConfigOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomStreamConfigOutput {
	return o
}

// Results are appended to this table. The server creates a new table in the given BigQuery dataset if the specified table does not exist. To enable the Cloud Healthcare API to write to your BigQuery table, you must give the Cloud Healthcare API service account the bigquery.dataEditor role. The service account is: `service-{PROJECT_NUMBER}@gcp-sa-healthcare.iam.gserviceaccount.com`. The PROJECT_NUMBER identifies the project that the DICOM store resides in. To get the project number, go to the Cloud Console Dashboard. It is recommended to not have a custom schema in the destination table which could conflict with the schema created by the Cloud Healthcare API. Instance deletions are not applied to the destination table. The destination's table schema will be automatically updated in case a new instance's data is incompatible with the current schema. The schema should not be updated manually as this can cause incompatibilies that cannot be resolved automatically. One resolution in this case is to delete the incompatible table and let the server recreate one, though the newly created table only contains data after the table recreation. BigQuery imposes a 1 MB limit on streaming insert row size, therefore any instance that generates more than 1 MB of BigQuery data will not be streamed. If an instance cannot be streamed to BigQuery, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
func (o GoogleCloudHealthcareV1beta1DicomStreamConfigOutput) BigqueryDestination() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DicomStreamConfig) *GoogleCloudHealthcareV1beta1DicomBigQueryDestination {
		return v.BigqueryDestination
	}).(GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput)
}

type GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GoogleCloudHealthcareV1beta1DicomStreamConfig)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput) ToGoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput() GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput) ToGoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput) Index(i pulumi.IntInput) GoogleCloudHealthcareV1beta1DicomStreamConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GoogleCloudHealthcareV1beta1DicomStreamConfig {
		return vs[0].([]GoogleCloudHealthcareV1beta1DicomStreamConfig)[vs[1].(int)]
	}).(GoogleCloudHealthcareV1beta1DicomStreamConfigOutput)
}

// StreamConfig specifies configuration for a streaming DICOM export.
type GoogleCloudHealthcareV1beta1DicomStreamConfigResponse struct {
	// Results are appended to this table. The server creates a new table in the given BigQuery dataset if the specified table does not exist. To enable the Cloud Healthcare API to write to your BigQuery table, you must give the Cloud Healthcare API service account the bigquery.dataEditor role. The service account is: `service-{PROJECT_NUMBER}@gcp-sa-healthcare.iam.gserviceaccount.com`. The PROJECT_NUMBER identifies the project that the DICOM store resides in. To get the project number, go to the Cloud Console Dashboard. It is recommended to not have a custom schema in the destination table which could conflict with the schema created by the Cloud Healthcare API. Instance deletions are not applied to the destination table. The destination's table schema will be automatically updated in case a new instance's data is incompatible with the current schema. The schema should not be updated manually as this can cause incompatibilies that cannot be resolved automatically. One resolution in this case is to delete the incompatible table and let the server recreate one, though the newly created table only contains data after the table recreation. BigQuery imposes a 1 MB limit on streaming insert row size, therefore any instance that generates more than 1 MB of BigQuery data will not be streamed. If an instance cannot be streamed to BigQuery, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
	BigqueryDestination GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponse `pulumi:"bigqueryDestination"`
}

// StreamConfig specifies configuration for a streaming DICOM export.
type GoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1DicomStreamConfigResponse)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput) ToGoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput() GoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput) ToGoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput {
	return o
}

// Results are appended to this table. The server creates a new table in the given BigQuery dataset if the specified table does not exist. To enable the Cloud Healthcare API to write to your BigQuery table, you must give the Cloud Healthcare API service account the bigquery.dataEditor role. The service account is: `service-{PROJECT_NUMBER}@gcp-sa-healthcare.iam.gserviceaccount.com`. The PROJECT_NUMBER identifies the project that the DICOM store resides in. To get the project number, go to the Cloud Console Dashboard. It is recommended to not have a custom schema in the destination table which could conflict with the schema created by the Cloud Healthcare API. Instance deletions are not applied to the destination table. The destination's table schema will be automatically updated in case a new instance's data is incompatible with the current schema. The schema should not be updated manually as this can cause incompatibilies that cannot be resolved automatically. One resolution in this case is to delete the incompatible table and let the server recreate one, though the newly created table only contains data after the table recreation. BigQuery imposes a 1 MB limit on streaming insert row size, therefore any instance that generates more than 1 MB of BigQuery data will not be streamed. If an instance cannot be streamed to BigQuery, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
func (o GoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput) BigqueryDestination() GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1DicomStreamConfigResponse) GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponse {
		return v.BigqueryDestination
	}).(GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput)
}

type GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GoogleCloudHealthcareV1beta1DicomStreamConfigResponse)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutput) ToGoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutput() GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutput) ToGoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutput) Index(i pulumi.IntInput) GoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GoogleCloudHealthcareV1beta1DicomStreamConfigResponse {
		return vs[0].([]GoogleCloudHealthcareV1beta1DicomStreamConfigResponse)[vs[1].(int)]
	}).(GoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput)
}

// The configuration for exporting to BigQuery.
type GoogleCloudHealthcareV1beta1FhirBigQueryDestination struct {
	// BigQuery URI to an existing dataset, up to 2000 characters long, in the format `bq://projectId.bqDatasetId`.
	DatasetUri *string `pulumi:"datasetUri"`
	// Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
	Force *bool `pulumi:"force"`
	// The configuration for the exported BigQuery schema.
	SchemaConfig *SchemaConfig `pulumi:"schemaConfig"`
	// Determines if existing data in the destination dataset is overwritten, appended to, or not written if the tables contain data. If a write_disposition is specified, the `force` parameter is ignored.
	WriteDisposition *GoogleCloudHealthcareV1beta1FhirBigQueryDestinationWriteDisposition `pulumi:"writeDisposition"`
}

// GoogleCloudHealthcareV1beta1FhirBigQueryDestinationInput is an input type that accepts GoogleCloudHealthcareV1beta1FhirBigQueryDestinationArgs and GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1beta1FhirBigQueryDestinationInput` via:
//
//	GoogleCloudHealthcareV1beta1FhirBigQueryDestinationArgs{...}
type GoogleCloudHealthcareV1beta1FhirBigQueryDestinationInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput
	ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutputWithContext(context.Context) GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput
}

// The configuration for exporting to BigQuery.
type GoogleCloudHealthcareV1beta1FhirBigQueryDestinationArgs struct {
	// BigQuery URI to an existing dataset, up to 2000 characters long, in the format `bq://projectId.bqDatasetId`.
	DatasetUri pulumi.StringPtrInput `pulumi:"datasetUri"`
	// Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
	Force pulumi.BoolPtrInput `pulumi:"force"`
	// The configuration for the exported BigQuery schema.
	SchemaConfig SchemaConfigPtrInput `pulumi:"schemaConfig"`
	// Determines if existing data in the destination dataset is overwritten, appended to, or not written if the tables contain data. If a write_disposition is specified, the `force` parameter is ignored.
	WriteDisposition GoogleCloudHealthcareV1beta1FhirBigQueryDestinationWriteDispositionPtrInput `pulumi:"writeDisposition"`
}

func (GoogleCloudHealthcareV1beta1FhirBigQueryDestinationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1FhirBigQueryDestination)(nil)).Elem()
}

func (i GoogleCloudHealthcareV1beta1FhirBigQueryDestinationArgs) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput {
	return i.ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1beta1FhirBigQueryDestinationArgs) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput)
}

func (i GoogleCloudHealthcareV1beta1FhirBigQueryDestinationArgs) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput {
	return i.ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutputWithContext(context.Background())
}

func (i GoogleCloudHealthcareV1beta1FhirBigQueryDestinationArgs) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput).ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutputWithContext(ctx)
}

// GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrInput is an input type that accepts GoogleCloudHealthcareV1beta1FhirBigQueryDestinationArgs, GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtr and GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput values.
// You can construct a concrete instance of `GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrInput` via:
//
//	        GoogleCloudHealthcareV1beta1FhirBigQueryDestinationArgs{...}
//
//	or:
//
//	        nil
type GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrInput interface {
	pulumi.Input

	ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput
	ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutputWithContext(context.Context) GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput
}

type googleCloudHealthcareV1beta1FhirBigQueryDestinationPtrType GoogleCloudHealthcareV1beta1FhirBigQueryDestinationArgs

func GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtr(v *GoogleCloudHealthcareV1beta1FhirBigQueryDestinationArgs) GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrInput {
	return (*googleCloudHealthcareV1beta1FhirBigQueryDestinationPtrType)(v)
}

func (*googleCloudHealthcareV1beta1FhirBigQueryDestinationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GoogleCloudHealthcareV1beta1FhirBigQueryDestination)(nil)).Elem()
}

func (i *googleCloudHealthcareV1beta1FhirBigQueryDestinationPtrType) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput {
	return i.ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutputWithContext(context.Background())
}

func (i *googleCloudHealthcareV1beta1FhirBigQueryDestinationPtrType) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput)
}

// The configuration for exporting to BigQuery.
type GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1FhirBigQueryDestination)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput {
	return o.ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutputWithContext(context.Background())
}

func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GoogleCloudHealthcareV1beta1FhirBigQueryDestination) *GoogleCloudHealthcareV1beta1FhirBigQueryDestination {
		return &v
	}).(GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput)
}

// BigQuery URI to an existing dataset, up to 2000 characters long, in the format `bq://projectId.bqDatasetId`.
func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput) DatasetUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1FhirBigQueryDestination) *string { return v.DatasetUri }).(pulumi.StringPtrOutput)
}

// Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput) Force() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1FhirBigQueryDestination) *bool { return v.Force }).(pulumi.BoolPtrOutput)
}

// The configuration for the exported BigQuery schema.
func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput) SchemaConfig() SchemaConfigPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1FhirBigQueryDestination) *SchemaConfig { return v.SchemaConfig }).(SchemaConfigPtrOutput)
}

// Determines if existing data in the destination dataset is overwritten, appended to, or not written if the tables contain data. If a write_disposition is specified, the `force` parameter is ignored.
func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput) WriteDisposition() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationWriteDispositionPtrOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1FhirBigQueryDestination) *GoogleCloudHealthcareV1beta1FhirBigQueryDestinationWriteDisposition {
		return v.WriteDisposition
	}).(GoogleCloudHealthcareV1beta1FhirBigQueryDestinationWriteDispositionPtrOutput)
}

type GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GoogleCloudHealthcareV1beta1FhirBigQueryDestination)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput) Elem() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1beta1FhirBigQueryDestination) GoogleCloudHealthcareV1beta1FhirBigQueryDestination {
		if v != nil {
			return *v
		}
		var ret GoogleCloudHealthcareV1beta1FhirBigQueryDestination
		return ret
	}).(GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput)
}

// BigQuery URI to an existing dataset, up to 2000 characters long, in the format `bq://projectId.bqDatasetId`.
func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput) DatasetUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1beta1FhirBigQueryDestination) *string {
		if v == nil {
			return nil
		}
		return v.DatasetUri
	}).(pulumi.StringPtrOutput)
}

// Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput) Force() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1beta1FhirBigQueryDestination) *bool {
		if v == nil {
			return nil
		}
		return v.Force
	}).(pulumi.BoolPtrOutput)
}

// The configuration for the exported BigQuery schema.
func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput) SchemaConfig() SchemaConfigPtrOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1beta1FhirBigQueryDestination) *SchemaConfig {
		if v == nil {
			return nil
		}
		return v.SchemaConfig
	}).(SchemaConfigPtrOutput)
}

// Determines if existing data in the destination dataset is overwritten, appended to, or not written if the tables contain data. If a write_disposition is specified, the `force` parameter is ignored.
func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput) WriteDisposition() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationWriteDispositionPtrOutput {
	return o.ApplyT(func(v *GoogleCloudHealthcareV1beta1FhirBigQueryDestination) *GoogleCloudHealthcareV1beta1FhirBigQueryDestinationWriteDisposition {
		if v == nil {
			return nil
		}
		return v.WriteDisposition
	}).(GoogleCloudHealthcareV1beta1FhirBigQueryDestinationWriteDispositionPtrOutput)
}

// The configuration for exporting to BigQuery.
type GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponse struct {
	// BigQuery URI to an existing dataset, up to 2000 characters long, in the format `bq://projectId.bqDatasetId`.
	DatasetUri string `pulumi:"datasetUri"`
	// Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
	Force bool `pulumi:"force"`
	// The configuration for the exported BigQuery schema.
	SchemaConfig SchemaConfigResponse `pulumi:"schemaConfig"`
	// Determines if existing data in the destination dataset is overwritten, appended to, or not written if the tables contain data. If a write_disposition is specified, the `force` parameter is ignored.
	WriteDisposition string `pulumi:"writeDisposition"`
}

// The configuration for exporting to BigQuery.
type GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput struct{ *pulumi.OutputState }

func (GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponse)(nil)).Elem()
}

func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput {
	return o
}

func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput) ToGoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutputWithContext(ctx context.Context) GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput {
	return o
}

// BigQuery URI to an existing dataset, up to 2000 characters long, in the format `bq://projectId.bqDatasetId`.
func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput) DatasetUri() pulumi.StringOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponse) string { return v.DatasetUri }).(pulumi.StringOutput)
}

// Use `write_disposition` instead. If `write_disposition` is specified, this parameter is ignored. force=false is equivalent to write_disposition=WRITE_EMPTY and force=true is equivalent to write_disposition=WRITE_TRUNCATE.
func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput) Force() pulumi.BoolOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponse) bool { return v.Force }).(pulumi.BoolOutput)
}

// The configuration for the exported BigQuery schema.
func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput) SchemaConfig() SchemaConfigResponseOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponse) SchemaConfigResponse {
		return v.SchemaConfig
	}).(SchemaConfigResponseOutput)
}

// Determines if existing data in the destination dataset is overwritten, appended to, or not written if the tables contain data. If a write_disposition is specified, the `force` parameter is ignored.
func (o GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput) WriteDisposition() pulumi.StringOutput {
	return o.ApplyT(func(v GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponse) string { return v.WriteDisposition }).(pulumi.StringOutput)
}

// Construct representing a logical group or a segment.
type GroupOrSegment struct {
	Group   *SchemaGroup   `pulumi:"group"`
	Segment *SchemaSegment `pulumi:"segment"`
}

// GroupOrSegmentInput is an input type that accepts GroupOrSegmentArgs and GroupOrSegmentOutput values.
// You can construct a concrete instance of `GroupOrSegmentInput` via:
//
//	GroupOrSegmentArgs{...}
type GroupOrSegmentInput interface {
	pulumi.Input

	ToGroupOrSegmentOutput() GroupOrSegmentOutput
	ToGroupOrSegmentOutputWithContext(context.Context) GroupOrSegmentOutput
}

// Construct representing a logical group or a segment.
type GroupOrSegmentArgs struct {
	Group   SchemaGroupPtrInput   `pulumi:"group"`
	Segment SchemaSegmentPtrInput `pulumi:"segment"`
}

func (GroupOrSegmentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupOrSegment)(nil)).Elem()
}

func (i GroupOrSegmentArgs) ToGroupOrSegmentOutput() GroupOrSegmentOutput {
	return i.ToGroupOrSegmentOutputWithContext(context.Background())
}

func (i GroupOrSegmentArgs) ToGroupOrSegmentOutputWithContext(ctx context.Context) GroupOrSegmentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupOrSegmentOutput)
}

// GroupOrSegmentArrayInput is an input type that accepts GroupOrSegmentArray and GroupOrSegmentArrayOutput values.
// You can construct a concrete instance of `GroupOrSegmentArrayInput` via:
//
//	GroupOrSegmentArray{ GroupOrSegmentArgs{...} }
type GroupOrSegmentArrayInput interface {
	pulumi.Input

	ToGroupOrSegmentArrayOutput() GroupOrSegmentArrayOutput
	ToGroupOrSegmentArrayOutputWithContext(context.Context) GroupOrSegmentArrayOutput
}

type GroupOrSegmentArray []GroupOrSegmentInput

func (GroupOrSegmentArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GroupOrSegment)(nil)).Elem()
}

func (i GroupOrSegmentArray) ToGroupOrSegmentArrayOutput() GroupOrSegmentArrayOutput {
	return i.ToGroupOrSegmentArrayOutputWithContext(context.Background())
}

func (i GroupOrSegmentArray) ToGroupOrSegmentArrayOutputWithContext(ctx context.Context) GroupOrSegmentArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupOrSegmentArrayOutput)
}

// Construct representing a logical group or a segment.
type GroupOrSegmentOutput struct{ *pulumi.OutputState }

func (GroupOrSegmentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupOrSegment)(nil)).Elem()
}

func (o GroupOrSegmentOutput) ToGroupOrSegmentOutput() GroupOrSegmentOutput {
	return o
}

func (o GroupOrSegmentOutput) ToGroupOrSegmentOutputWithContext(ctx context.Context) GroupOrSegmentOutput {
	return o
}

func (o GroupOrSegmentOutput) Group() SchemaGroupPtrOutput {
	return o.ApplyT(func(v GroupOrSegment) *SchemaGroup { return v.Group }).(SchemaGroupPtrOutput)
}

func (o GroupOrSegmentOutput) Segment() SchemaSegmentPtrOutput {
	return o.ApplyT(func(v GroupOrSegment) *SchemaSegment { return v.Segment }).(SchemaSegmentPtrOutput)
}

type GroupOrSegmentArrayOutput struct{ *pulumi.OutputState }

func (GroupOrSegmentArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GroupOrSegment)(nil)).Elem()
}

func (o GroupOrSegmentArrayOutput) ToGroupOrSegmentArrayOutput() GroupOrSegmentArrayOutput {
	return o
}

func (o GroupOrSegmentArrayOutput) ToGroupOrSegmentArrayOutputWithContext(ctx context.Context) GroupOrSegmentArrayOutput {
	return o
}

func (o GroupOrSegmentArrayOutput) Index(i pulumi.IntInput) GroupOrSegmentOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GroupOrSegment {
		return vs[0].([]GroupOrSegment)[vs[1].(int)]
	}).(GroupOrSegmentOutput)
}

// Construct representing a logical group or a segment.
type GroupOrSegmentResponse struct {
	Group   SchemaGroupResponse   `pulumi:"group"`
	Segment SchemaSegmentResponse `pulumi:"segment"`
}

// Construct representing a logical group or a segment.
type GroupOrSegmentResponseOutput struct{ *pulumi.OutputState }

func (GroupOrSegmentResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupOrSegmentResponse)(nil)).Elem()
}

func (o GroupOrSegmentResponseOutput) ToGroupOrSegmentResponseOutput() GroupOrSegmentResponseOutput {
	return o
}

func (o GroupOrSegmentResponseOutput) ToGroupOrSegmentResponseOutputWithContext(ctx context.Context) GroupOrSegmentResponseOutput {
	return o
}

func (o GroupOrSegmentResponseOutput) Group() SchemaGroupResponseOutput {
	return o.ApplyT(func(v GroupOrSegmentResponse) SchemaGroupResponse { return v.Group }).(SchemaGroupResponseOutput)
}

func (o GroupOrSegmentResponseOutput) Segment() SchemaSegmentResponseOutput {
	return o.ApplyT(func(v GroupOrSegmentResponse) SchemaSegmentResponse { return v.Segment }).(SchemaSegmentResponseOutput)
}

type GroupOrSegmentResponseArrayOutput struct{ *pulumi.OutputState }

func (GroupOrSegmentResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GroupOrSegmentResponse)(nil)).Elem()
}

func (o GroupOrSegmentResponseArrayOutput) ToGroupOrSegmentResponseArrayOutput() GroupOrSegmentResponseArrayOutput {
	return o
}

func (o GroupOrSegmentResponseArrayOutput) ToGroupOrSegmentResponseArrayOutputWithContext(ctx context.Context) GroupOrSegmentResponseArrayOutput {
	return o
}

func (o GroupOrSegmentResponseArrayOutput) Index(i pulumi.IntInput) GroupOrSegmentResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GroupOrSegmentResponse {
		return vs[0].([]GroupOrSegmentResponse)[vs[1].(int)]
	}).(GroupOrSegmentResponseOutput)
}

// Root config message for HL7v2 schema. This contains a schema structure of groups and segments, and filters that determine which messages to apply the schema structure to.
type Hl7SchemaConfig struct {
	// Map from each HL7v2 message type and trigger event pair, such as ADT_A04, to its schema configuration root group.
	MessageSchemaConfigs map[string]SchemaGroup `pulumi:"messageSchemaConfigs"`
	// Each VersionSource is tested and only if they all match is the schema used for the message.
	Version []VersionSource `pulumi:"version"`
}

// Hl7SchemaConfigInput is an input type that accepts Hl7SchemaConfigArgs and Hl7SchemaConfigOutput values.
// You can construct a concrete instance of `Hl7SchemaConfigInput` via:
//
//	Hl7SchemaConfigArgs{...}
type Hl7SchemaConfigInput interface {
	pulumi.Input

	ToHl7SchemaConfigOutput() Hl7SchemaConfigOutput
	ToHl7SchemaConfigOutputWithContext(context.Context) Hl7SchemaConfigOutput
}

// Root config message for HL7v2 schema. This contains a schema structure of groups and segments, and filters that determine which messages to apply the schema structure to.
type Hl7SchemaConfigArgs struct {
	// Map from each HL7v2 message type and trigger event pair, such as ADT_A04, to its schema configuration root group.
	MessageSchemaConfigs SchemaGroupMapInput `pulumi:"messageSchemaConfigs"`
	// Each VersionSource is tested and only if they all match is the schema used for the message.
	Version VersionSourceArrayInput `pulumi:"version"`
}

func (Hl7SchemaConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Hl7SchemaConfig)(nil)).Elem()
}

func (i Hl7SchemaConfigArgs) ToHl7SchemaConfigOutput() Hl7SchemaConfigOutput {
	return i.ToHl7SchemaConfigOutputWithContext(context.Background())
}

func (i Hl7SchemaConfigArgs) ToHl7SchemaConfigOutputWithContext(ctx context.Context) Hl7SchemaConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(Hl7SchemaConfigOutput)
}

// Hl7SchemaConfigArrayInput is an input type that accepts Hl7SchemaConfigArray and Hl7SchemaConfigArrayOutput values.
// You can construct a concrete instance of `Hl7SchemaConfigArrayInput` via:
//
//	Hl7SchemaConfigArray{ Hl7SchemaConfigArgs{...} }
type Hl7SchemaConfigArrayInput interface {
	pulumi.Input

	ToHl7SchemaConfigArrayOutput() Hl7SchemaConfigArrayOutput
	ToHl7SchemaConfigArrayOutputWithContext(context.Context) Hl7SchemaConfigArrayOutput
}

type Hl7SchemaConfigArray []Hl7SchemaConfigInput

func (Hl7SchemaConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Hl7SchemaConfig)(nil)).Elem()
}

func (i Hl7SchemaConfigArray) ToHl7SchemaConfigArrayOutput() Hl7SchemaConfigArrayOutput {
	return i.ToHl7SchemaConfigArrayOutputWithContext(context.Background())
}

func (i Hl7SchemaConfigArray) ToHl7SchemaConfigArrayOutputWithContext(ctx context.Context) Hl7SchemaConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(Hl7SchemaConfigArrayOutput)
}

// Root config message for HL7v2 schema. This contains a schema structure of groups and segments, and filters that determine which messages to apply the schema structure to.
type Hl7SchemaConfigOutput struct{ *pulumi.OutputState }

func (Hl7SchemaConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Hl7SchemaConfig)(nil)).Elem()
}

func (o Hl7SchemaConfigOutput) ToHl7SchemaConfigOutput() Hl7SchemaConfigOutput {
	return o
}

func (o Hl7SchemaConfigOutput) ToHl7SchemaConfigOutputWithContext(ctx context.Context) Hl7SchemaConfigOutput {
	return o
}

// Map from each HL7v2 message type and trigger event pair, such as ADT_A04, to its schema configuration root group.
func (o Hl7SchemaConfigOutput) MessageSchemaConfigs() SchemaGroupMapOutput {
	return o.ApplyT(func(v Hl7SchemaConfig) map[string]SchemaGroup { return v.MessageSchemaConfigs }).(SchemaGroupMapOutput)
}

// Each VersionSource is tested and only if they all match is the schema used for the message.
func (o Hl7SchemaConfigOutput) Version() VersionSourceArrayOutput {
	return o.ApplyT(func(v Hl7SchemaConfig) []VersionSource { return v.Version }).(VersionSourceArrayOutput)
}

type Hl7SchemaConfigArrayOutput struct{ *pulumi.OutputState }

func (Hl7SchemaConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Hl7SchemaConfig)(nil)).Elem()
}

func (o Hl7SchemaConfigArrayOutput) ToHl7SchemaConfigArrayOutput() Hl7SchemaConfigArrayOutput {
	return o
}

func (o Hl7SchemaConfigArrayOutput) ToHl7SchemaConfigArrayOutputWithContext(ctx context.Context) Hl7SchemaConfigArrayOutput {
	return o
}

func (o Hl7SchemaConfigArrayOutput) Index(i pulumi.IntInput) Hl7SchemaConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Hl7SchemaConfig {
		return vs[0].([]Hl7SchemaConfig)[vs[1].(int)]
	}).(Hl7SchemaConfigOutput)
}

// Root config message for HL7v2 schema. This contains a schema structure of groups and segments, and filters that determine which messages to apply the schema structure to.
type Hl7SchemaConfigResponse struct {
	// Map from each HL7v2 message type and trigger event pair, such as ADT_A04, to its schema configuration root group.
	MessageSchemaConfigs map[string]SchemaGroupResponse `pulumi:"messageSchemaConfigs"`
	// Each VersionSource is tested and only if they all match is the schema used for the message.
	Version []VersionSourceResponse `pulumi:"version"`
}

// Root config message for HL7v2 schema. This contains a schema structure of groups and segments, and filters that determine which messages to apply the schema structure to.
type Hl7SchemaConfigResponseOutput struct{ *pulumi.OutputState }

func (Hl7SchemaConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Hl7SchemaConfigResponse)(nil)).Elem()
}

func (o Hl7SchemaConfigResponseOutput) ToHl7SchemaConfigResponseOutput() Hl7SchemaConfigResponseOutput {
	return o
}

func (o Hl7SchemaConfigResponseOutput) ToHl7SchemaConfigResponseOutputWithContext(ctx context.Context) Hl7SchemaConfigResponseOutput {
	return o
}

// Map from each HL7v2 message type and trigger event pair, such as ADT_A04, to its schema configuration root group.
func (o Hl7SchemaConfigResponseOutput) MessageSchemaConfigs() SchemaGroupResponseMapOutput {
	return o.ApplyT(func(v Hl7SchemaConfigResponse) map[string]SchemaGroupResponse { return v.MessageSchemaConfigs }).(SchemaGroupResponseMapOutput)
}

// Each VersionSource is tested and only if they all match is the schema used for the message.
func (o Hl7SchemaConfigResponseOutput) Version() VersionSourceResponseArrayOutput {
	return o.ApplyT(func(v Hl7SchemaConfigResponse) []VersionSourceResponse { return v.Version }).(VersionSourceResponseArrayOutput)
}

type Hl7SchemaConfigResponseArrayOutput struct{ *pulumi.OutputState }

func (Hl7SchemaConfigResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Hl7SchemaConfigResponse)(nil)).Elem()
}

func (o Hl7SchemaConfigResponseArrayOutput) ToHl7SchemaConfigResponseArrayOutput() Hl7SchemaConfigResponseArrayOutput {
	return o
}

func (o Hl7SchemaConfigResponseArrayOutput) ToHl7SchemaConfigResponseArrayOutputWithContext(ctx context.Context) Hl7SchemaConfigResponseArrayOutput {
	return o
}

func (o Hl7SchemaConfigResponseArrayOutput) Index(i pulumi.IntInput) Hl7SchemaConfigResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Hl7SchemaConfigResponse {
		return vs[0].([]Hl7SchemaConfigResponse)[vs[1].(int)]
	}).(Hl7SchemaConfigResponseOutput)
}

// Root config for HL7v2 datatype definitions for a specific HL7v2 version.
type Hl7TypesConfig struct {
	// The HL7v2 type definitions.
	Type []Type `pulumi:"type"`
	// The version selectors that this config applies to. A message must match ALL version sources to apply.
	Version []VersionSource `pulumi:"version"`
}

// Hl7TypesConfigInput is an input type that accepts Hl7TypesConfigArgs and Hl7TypesConfigOutput values.
// You can construct a concrete instance of `Hl7TypesConfigInput` via:
//
//	Hl7TypesConfigArgs{...}
type Hl7TypesConfigInput interface {
	pulumi.Input

	ToHl7TypesConfigOutput() Hl7TypesConfigOutput
	ToHl7TypesConfigOutputWithContext(context.Context) Hl7TypesConfigOutput
}

// Root config for HL7v2 datatype definitions for a specific HL7v2 version.
type Hl7TypesConfigArgs struct {
	// The HL7v2 type definitions.
	Type TypeArrayInput `pulumi:"type"`
	// The version selectors that this config applies to. A message must match ALL version sources to apply.
	Version VersionSourceArrayInput `pulumi:"version"`
}

func (Hl7TypesConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Hl7TypesConfig)(nil)).Elem()
}

func (i Hl7TypesConfigArgs) ToHl7TypesConfigOutput() Hl7TypesConfigOutput {
	return i.ToHl7TypesConfigOutputWithContext(context.Background())
}

func (i Hl7TypesConfigArgs) ToHl7TypesConfigOutputWithContext(ctx context.Context) Hl7TypesConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(Hl7TypesConfigOutput)
}

// Hl7TypesConfigArrayInput is an input type that accepts Hl7TypesConfigArray and Hl7TypesConfigArrayOutput values.
// You can construct a concrete instance of `Hl7TypesConfigArrayInput` via:
//
//	Hl7TypesConfigArray{ Hl7TypesConfigArgs{...} }
type Hl7TypesConfigArrayInput interface {
	pulumi.Input

	ToHl7TypesConfigArrayOutput() Hl7TypesConfigArrayOutput
	ToHl7TypesConfigArrayOutputWithContext(context.Context) Hl7TypesConfigArrayOutput
}

type Hl7TypesConfigArray []Hl7TypesConfigInput

func (Hl7TypesConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Hl7TypesConfig)(nil)).Elem()
}

func (i Hl7TypesConfigArray) ToHl7TypesConfigArrayOutput() Hl7TypesConfigArrayOutput {
	return i.ToHl7TypesConfigArrayOutputWithContext(context.Background())
}

func (i Hl7TypesConfigArray) ToHl7TypesConfigArrayOutputWithContext(ctx context.Context) Hl7TypesConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(Hl7TypesConfigArrayOutput)
}

// Root config for HL7v2 datatype definitions for a specific HL7v2 version.
type Hl7TypesConfigOutput struct{ *pulumi.OutputState }

func (Hl7TypesConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Hl7TypesConfig)(nil)).Elem()
}

func (o Hl7TypesConfigOutput) ToHl7TypesConfigOutput() Hl7TypesConfigOutput {
	return o
}

func (o Hl7TypesConfigOutput) ToHl7TypesConfigOutputWithContext(ctx context.Context) Hl7TypesConfigOutput {
	return o
}

// The HL7v2 type definitions.
func (o Hl7TypesConfigOutput) Type() TypeArrayOutput {
	return o.ApplyT(func(v Hl7TypesConfig) []Type { return v.Type }).(TypeArrayOutput)
}

// The version selectors that this config applies to. A message must match ALL version sources to apply.
func (o Hl7TypesConfigOutput) Version() VersionSourceArrayOutput {
	return o.ApplyT(func(v Hl7TypesConfig) []VersionSource { return v.Version }).(VersionSourceArrayOutput)
}

type Hl7TypesConfigArrayOutput struct{ *pulumi.OutputState }

func (Hl7TypesConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Hl7TypesConfig)(nil)).Elem()
}

func (o Hl7TypesConfigArrayOutput) ToHl7TypesConfigArrayOutput() Hl7TypesConfigArrayOutput {
	return o
}

func (o Hl7TypesConfigArrayOutput) ToHl7TypesConfigArrayOutputWithContext(ctx context.Context) Hl7TypesConfigArrayOutput {
	return o
}

func (o Hl7TypesConfigArrayOutput) Index(i pulumi.IntInput) Hl7TypesConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Hl7TypesConfig {
		return vs[0].([]Hl7TypesConfig)[vs[1].(int)]
	}).(Hl7TypesConfigOutput)
}

// Root config for HL7v2 datatype definitions for a specific HL7v2 version.
type Hl7TypesConfigResponse struct {
	// The HL7v2 type definitions.
	Type []TypeResponse `pulumi:"type"`
	// The version selectors that this config applies to. A message must match ALL version sources to apply.
	Version []VersionSourceResponse `pulumi:"version"`
}

// Root config for HL7v2 datatype definitions for a specific HL7v2 version.
type Hl7TypesConfigResponseOutput struct{ *pulumi.OutputState }

func (Hl7TypesConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Hl7TypesConfigResponse)(nil)).Elem()
}

func (o Hl7TypesConfigResponseOutput) ToHl7TypesConfigResponseOutput() Hl7TypesConfigResponseOutput {
	return o
}

func (o Hl7TypesConfigResponseOutput) ToHl7TypesConfigResponseOutputWithContext(ctx context.Context) Hl7TypesConfigResponseOutput {
	return o
}

// The HL7v2 type definitions.
func (o Hl7TypesConfigResponseOutput) Type() TypeResponseArrayOutput {
	return o.ApplyT(func(v Hl7TypesConfigResponse) []TypeResponse { return v.Type }).(TypeResponseArrayOutput)
}

// The version selectors that this config applies to. A message must match ALL version sources to apply.
func (o Hl7TypesConfigResponseOutput) Version() VersionSourceResponseArrayOutput {
	return o.ApplyT(func(v Hl7TypesConfigResponse) []VersionSourceResponse { return v.Version }).(VersionSourceResponseArrayOutput)
}

type Hl7TypesConfigResponseArrayOutput struct{ *pulumi.OutputState }

func (Hl7TypesConfigResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Hl7TypesConfigResponse)(nil)).Elem()
}

func (o Hl7TypesConfigResponseArrayOutput) ToHl7TypesConfigResponseArrayOutput() Hl7TypesConfigResponseArrayOutput {
	return o
}

func (o Hl7TypesConfigResponseArrayOutput) ToHl7TypesConfigResponseArrayOutputWithContext(ctx context.Context) Hl7TypesConfigResponseArrayOutput {
	return o
}

func (o Hl7TypesConfigResponseArrayOutput) Index(i pulumi.IntInput) Hl7TypesConfigResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Hl7TypesConfigResponse {
		return vs[0].([]Hl7TypesConfigResponse)[vs[1].(int)]
	}).(Hl7TypesConfigResponseOutput)
}

// Specifies where and whether to send notifications upon changes to a data store.
type Hl7V2NotificationConfig struct {
	// Restricts notifications sent for messages matching a filter. If this is empty, all messages are matched. The following syntax is available: * A string field value can be written as text inside quotation marks, for example `"query text"`. The only valid relational operation for text fields is equality (`=`), where text is searched within the field, rather than having the field be equal to the text. For example, `"Comment = great"` returns messages with `great` in the comment field. * A number field value can be written as an integer, a decimal, or an exponential. The valid relational operators for number fields are the equality operator (`=`), along with the less than/greater than operators (`<`, `<=`, `>`, `>=`). Note that there is no inequality (`!=`) operator. You can prepend the `NOT` operator to an expression to negate it. * A date field value must be written in `yyyy-mm-dd` form. Fields with date and time use the RFC3339 time format. Leading zeros are required for one-digit months and days. The valid relational operators for date fields are the equality operator (`=`) , along with the less than/greater than operators (`<`, `<=`, `>`, `>=`). Note that there is no inequality (`!=`) operator. You can prepend the `NOT` operator to an expression to negate it. * Multiple field query expressions can be combined in one query by adding `AND` or `OR` operators between the expressions. If a boolean operator appears within a quoted string, it is not treated as special, it's just another part of the character string to be matched. You can prepend the `NOT` operator to an expression to negate it. Fields/functions available for filtering are: * `message_type`, from the MSH-9.1 field. For example, `NOT message_type = "ADT"`. * `send_date` or `sendDate`, the YYYY-MM-DD date the message was sent in the dataset's time_zone, from the MSH-7 segment. For example, `send_date < "2017-01-02"`. * `send_time`, the timestamp when the message was sent, using the RFC3339 time format for comparisons, from the MSH-7 segment. For example, `send_time < "2017-01-02T00:00:00-05:00"`. * `create_time`, the timestamp when the message was created in the HL7v2 store. Use the RFC3339 time format for comparisons. For example, `create_time < "2017-01-02T00:00:00-05:00"`. * `send_facility`, the care center that the message came from, from the MSH-4 segment. For example, `send_facility = "ABC"`. * `PatientId(value, type)`, which matches if the message lists a patient having an ID of the given value and type in the PID-2, PID-3, or PID-4 segments. For example, `PatientId("123456", "MRN")`. * `labels.x`, a string value of the label with key `x` as set using the Message.labels map. For example, `labels."priority"="high"`. The operator `:*` can be used to assert the existence of a label. For example, `labels."priority":*`.
	Filter *string `pulumi:"filter"`
	// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. The notification is a `PubsubMessage` with the following fields: * `PubsubMessage.Data` contains the resource name. * `PubsubMessage.MessageId` is the ID of this notification. It is guaranteed to be unique within the topic. * `PubsubMessage.PublishTime` is the time when the message was published. Note that notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging. For more information, see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging).
	PubsubTopic *string `pulumi:"pubsubTopic"`
}

// Hl7V2NotificationConfigInput is an input type that accepts Hl7V2NotificationConfigArgs and Hl7V2NotificationConfigOutput values.
// You can construct a concrete instance of `Hl7V2NotificationConfigInput` via:
//
//	Hl7V2NotificationConfigArgs{...}
type Hl7V2NotificationConfigInput interface {
	pulumi.Input

	ToHl7V2NotificationConfigOutput() Hl7V2NotificationConfigOutput
	ToHl7V2NotificationConfigOutputWithContext(context.Context) Hl7V2NotificationConfigOutput
}

// Specifies where and whether to send notifications upon changes to a data store.
type Hl7V2NotificationConfigArgs struct {
	// Restricts notifications sent for messages matching a filter. If this is empty, all messages are matched. The following syntax is available: * A string field value can be written as text inside quotation marks, for example `"query text"`. The only valid relational operation for text fields is equality (`=`), where text is searched within the field, rather than having the field be equal to the text. For example, `"Comment = great"` returns messages with `great` in the comment field. * A number field value can be written as an integer, a decimal, or an exponential. The valid relational operators for number fields are the equality operator (`=`), along with the less than/greater than operators (`<`, `<=`, `>`, `>=`). Note that there is no inequality (`!=`) operator. You can prepend the `NOT` operator to an expression to negate it. * A date field value must be written in `yyyy-mm-dd` form. Fields with date and time use the RFC3339 time format. Leading zeros are required for one-digit months and days. The valid relational operators for date fields are the equality operator (`=`) , along with the less than/greater than operators (`<`, `<=`, `>`, `>=`). Note that there is no inequality (`!=`) operator. You can prepend the `NOT` operator to an expression to negate it. * Multiple field query expressions can be combined in one query by adding `AND` or `OR` operators between the expressions. If a boolean operator appears within a quoted string, it is not treated as special, it's just another part of the character string to be matched. You can prepend the `NOT` operator to an expression to negate it. Fields/functions available for filtering are: * `message_type`, from the MSH-9.1 field. For example, `NOT message_type = "ADT"`. * `send_date` or `sendDate`, the YYYY-MM-DD date the message was sent in the dataset's time_zone, from the MSH-7 segment. For example, `send_date < "2017-01-02"`. * `send_time`, the timestamp when the message was sent, using the RFC3339 time format for comparisons, from the MSH-7 segment. For example, `send_time < "2017-01-02T00:00:00-05:00"`. * `create_time`, the timestamp when the message was created in the HL7v2 store. Use the RFC3339 time format for comparisons. For example, `create_time < "2017-01-02T00:00:00-05:00"`. * `send_facility`, the care center that the message came from, from the MSH-4 segment. For example, `send_facility = "ABC"`. * `PatientId(value, type)`, which matches if the message lists a patient having an ID of the given value and type in the PID-2, PID-3, or PID-4 segments. For example, `PatientId("123456", "MRN")`. * `labels.x`, a string value of the label with key `x` as set using the Message.labels map. For example, `labels."priority"="high"`. The operator `:*` can be used to assert the existence of a label. For example, `labels."priority":*`.
	Filter pulumi.StringPtrInput `pulumi:"filter"`
	// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. The notification is a `PubsubMessage` with the following fields: * `PubsubMessage.Data` contains the resource name. * `PubsubMessage.MessageId` is the ID of this notification. It is guaranteed to be unique within the topic. * `PubsubMessage.PublishTime` is the time when the message was published. Note that notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging. For more information, see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging).
	PubsubTopic pulumi.StringPtrInput `pulumi:"pubsubTopic"`
}

func (Hl7V2NotificationConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Hl7V2NotificationConfig)(nil)).Elem()
}

func (i Hl7V2NotificationConfigArgs) ToHl7V2NotificationConfigOutput() Hl7V2NotificationConfigOutput {
	return i.ToHl7V2NotificationConfigOutputWithContext(context.Background())
}

func (i Hl7V2NotificationConfigArgs) ToHl7V2NotificationConfigOutputWithContext(ctx context.Context) Hl7V2NotificationConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(Hl7V2NotificationConfigOutput)
}

// Hl7V2NotificationConfigArrayInput is an input type that accepts Hl7V2NotificationConfigArray and Hl7V2NotificationConfigArrayOutput values.
// You can construct a concrete instance of `Hl7V2NotificationConfigArrayInput` via:
//
//	Hl7V2NotificationConfigArray{ Hl7V2NotificationConfigArgs{...} }
type Hl7V2NotificationConfigArrayInput interface {
	pulumi.Input

	ToHl7V2NotificationConfigArrayOutput() Hl7V2NotificationConfigArrayOutput
	ToHl7V2NotificationConfigArrayOutputWithContext(context.Context) Hl7V2NotificationConfigArrayOutput
}

type Hl7V2NotificationConfigArray []Hl7V2NotificationConfigInput

func (Hl7V2NotificationConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Hl7V2NotificationConfig)(nil)).Elem()
}

func (i Hl7V2NotificationConfigArray) ToHl7V2NotificationConfigArrayOutput() Hl7V2NotificationConfigArrayOutput {
	return i.ToHl7V2NotificationConfigArrayOutputWithContext(context.Background())
}

func (i Hl7V2NotificationConfigArray) ToHl7V2NotificationConfigArrayOutputWithContext(ctx context.Context) Hl7V2NotificationConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(Hl7V2NotificationConfigArrayOutput)
}

// Specifies where and whether to send notifications upon changes to a data store.
type Hl7V2NotificationConfigOutput struct{ *pulumi.OutputState }

func (Hl7V2NotificationConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Hl7V2NotificationConfig)(nil)).Elem()
}

func (o Hl7V2NotificationConfigOutput) ToHl7V2NotificationConfigOutput() Hl7V2NotificationConfigOutput {
	return o
}

func (o Hl7V2NotificationConfigOutput) ToHl7V2NotificationConfigOutputWithContext(ctx context.Context) Hl7V2NotificationConfigOutput {
	return o
}

// Restricts notifications sent for messages matching a filter. If this is empty, all messages are matched. The following syntax is available: * A string field value can be written as text inside quotation marks, for example `"query text"`. The only valid relational operation for text fields is equality (`=`), where text is searched within the field, rather than having the field be equal to the text. For example, `"Comment = great"` returns messages with `great` in the comment field. * A number field value can be written as an integer, a decimal, or an exponential. The valid relational operators for number fields are the equality operator (`=`), along with the less than/greater than operators (`<`, `<=`, `>`, `>=`). Note that there is no inequality (`!=`) operator. You can prepend the `NOT` operator to an expression to negate it. * A date field value must be written in `yyyy-mm-dd` form. Fields with date and time use the RFC3339 time format. Leading zeros are required for one-digit months and days. The valid relational operators for date fields are the equality operator (`=`) , along with the less than/greater than operators (`<`, `<=`, `>`, `>=`). Note that there is no inequality (`!=`) operator. You can prepend the `NOT` operator to an expression to negate it. * Multiple field query expressions can be combined in one query by adding `AND` or `OR` operators between the expressions. If a boolean operator appears within a quoted string, it is not treated as special, it's just another part of the character string to be matched. You can prepend the `NOT` operator to an expression to negate it. Fields/functions available for filtering are: * `message_type`, from the MSH-9.1 field. For example, `NOT message_type = "ADT"`. * `send_date` or `sendDate`, the YYYY-MM-DD date the message was sent in the dataset's time_zone, from the MSH-7 segment. For example, `send_date < "2017-01-02"`. * `send_time`, the timestamp when the message was sent, using the RFC3339 time format for comparisons, from the MSH-7 segment. For example, `send_time < "2017-01-02T00:00:00-05:00"`. * `create_time`, the timestamp when the message was created in the HL7v2 store. Use the RFC3339 time format for comparisons. For example, `create_time < "2017-01-02T00:00:00-05:00"`. * `send_facility`, the care center that the message came from, from the MSH-4 segment. For example, `send_facility = "ABC"`. * `PatientId(value, type)`, which matches if the message lists a patient having an ID of the given value and type in the PID-2, PID-3, or PID-4 segments. For example, `PatientId("123456", "MRN")`. * `labels.x`, a string value of the label with key `x` as set using the Message.labels map. For example, `labels."priority"="high"`. The operator `:*` can be used to assert the existence of a label. For example, `labels."priority":*`.
func (o Hl7V2NotificationConfigOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Hl7V2NotificationConfig) *string { return v.Filter }).(pulumi.StringPtrOutput)
}

// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. The notification is a `PubsubMessage` with the following fields: * `PubsubMessage.Data` contains the resource name. * `PubsubMessage.MessageId` is the ID of this notification. It is guaranteed to be unique within the topic. * `PubsubMessage.PublishTime` is the time when the message was published. Note that notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging. For more information, see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging).
func (o Hl7V2NotificationConfigOutput) PubsubTopic() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Hl7V2NotificationConfig) *string { return v.PubsubTopic }).(pulumi.StringPtrOutput)
}

type Hl7V2NotificationConfigArrayOutput struct{ *pulumi.OutputState }

func (Hl7V2NotificationConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Hl7V2NotificationConfig)(nil)).Elem()
}

func (o Hl7V2NotificationConfigArrayOutput) ToHl7V2NotificationConfigArrayOutput() Hl7V2NotificationConfigArrayOutput {
	return o
}

func (o Hl7V2NotificationConfigArrayOutput) ToHl7V2NotificationConfigArrayOutputWithContext(ctx context.Context) Hl7V2NotificationConfigArrayOutput {
	return o
}

func (o Hl7V2NotificationConfigArrayOutput) Index(i pulumi.IntInput) Hl7V2NotificationConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Hl7V2NotificationConfig {
		return vs[0].([]Hl7V2NotificationConfig)[vs[1].(int)]
	}).(Hl7V2NotificationConfigOutput)
}

// Specifies where and whether to send notifications upon changes to a data store.
type Hl7V2NotificationConfigResponse struct {
	// Restricts notifications sent for messages matching a filter. If this is empty, all messages are matched. The following syntax is available: * A string field value can be written as text inside quotation marks, for example `"query text"`. The only valid relational operation for text fields is equality (`=`), where text is searched within the field, rather than having the field be equal to the text. For example, `"Comment = great"` returns messages with `great` in the comment field. * A number field value can be written as an integer, a decimal, or an exponential. The valid relational operators for number fields are the equality operator (`=`), along with the less than/greater than operators (`<`, `<=`, `>`, `>=`). Note that there is no inequality (`!=`) operator. You can prepend the `NOT` operator to an expression to negate it. * A date field value must be written in `yyyy-mm-dd` form. Fields with date and time use the RFC3339 time format. Leading zeros are required for one-digit months and days. The valid relational operators for date fields are the equality operator (`=`) , along with the less than/greater than operators (`<`, `<=`, `>`, `>=`). Note that there is no inequality (`!=`) operator. You can prepend the `NOT` operator to an expression to negate it. * Multiple field query expressions can be combined in one query by adding `AND` or `OR` operators between the expressions. If a boolean operator appears within a quoted string, it is not treated as special, it's just another part of the character string to be matched. You can prepend the `NOT` operator to an expression to negate it. Fields/functions available for filtering are: * `message_type`, from the MSH-9.1 field. For example, `NOT message_type = "ADT"`. * `send_date` or `sendDate`, the YYYY-MM-DD date the message was sent in the dataset's time_zone, from the MSH-7 segment. For example, `send_date < "2017-01-02"`. * `send_time`, the timestamp when the message was sent, using the RFC3339 time format for comparisons, from the MSH-7 segment. For example, `send_time < "2017-01-02T00:00:00-05:00"`. * `create_time`, the timestamp when the message was created in the HL7v2 store. Use the RFC3339 time format for comparisons. For example, `create_time < "2017-01-02T00:00:00-05:00"`. * `send_facility`, the care center that the message came from, from the MSH-4 segment. For example, `send_facility = "ABC"`. * `PatientId(value, type)`, which matches if the message lists a patient having an ID of the given value and type in the PID-2, PID-3, or PID-4 segments. For example, `PatientId("123456", "MRN")`. * `labels.x`, a string value of the label with key `x` as set using the Message.labels map. For example, `labels."priority"="high"`. The operator `:*` can be used to assert the existence of a label. For example, `labels."priority":*`.
	Filter string `pulumi:"filter"`
	// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. The notification is a `PubsubMessage` with the following fields: * `PubsubMessage.Data` contains the resource name. * `PubsubMessage.MessageId` is the ID of this notification. It is guaranteed to be unique within the topic. * `PubsubMessage.PublishTime` is the time when the message was published. Note that notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging. For more information, see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging).
	PubsubTopic string `pulumi:"pubsubTopic"`
}

// Specifies where and whether to send notifications upon changes to a data store.
type Hl7V2NotificationConfigResponseOutput struct{ *pulumi.OutputState }

func (Hl7V2NotificationConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Hl7V2NotificationConfigResponse)(nil)).Elem()
}

func (o Hl7V2NotificationConfigResponseOutput) ToHl7V2NotificationConfigResponseOutput() Hl7V2NotificationConfigResponseOutput {
	return o
}

func (o Hl7V2NotificationConfigResponseOutput) ToHl7V2NotificationConfigResponseOutputWithContext(ctx context.Context) Hl7V2NotificationConfigResponseOutput {
	return o
}

// Restricts notifications sent for messages matching a filter. If this is empty, all messages are matched. The following syntax is available: * A string field value can be written as text inside quotation marks, for example `"query text"`. The only valid relational operation for text fields is equality (`=`), where text is searched within the field, rather than having the field be equal to the text. For example, `"Comment = great"` returns messages with `great` in the comment field. * A number field value can be written as an integer, a decimal, or an exponential. The valid relational operators for number fields are the equality operator (`=`), along with the less than/greater than operators (`<`, `<=`, `>`, `>=`). Note that there is no inequality (`!=`) operator. You can prepend the `NOT` operator to an expression to negate it. * A date field value must be written in `yyyy-mm-dd` form. Fields with date and time use the RFC3339 time format. Leading zeros are required for one-digit months and days. The valid relational operators for date fields are the equality operator (`=`) , along with the less than/greater than operators (`<`, `<=`, `>`, `>=`). Note that there is no inequality (`!=`) operator. You can prepend the `NOT` operator to an expression to negate it. * Multiple field query expressions can be combined in one query by adding `AND` or `OR` operators between the expressions. If a boolean operator appears within a quoted string, it is not treated as special, it's just another part of the character string to be matched. You can prepend the `NOT` operator to an expression to negate it. Fields/functions available for filtering are: * `message_type`, from the MSH-9.1 field. For example, `NOT message_type = "ADT"`. * `send_date` or `sendDate`, the YYYY-MM-DD date the message was sent in the dataset's time_zone, from the MSH-7 segment. For example, `send_date < "2017-01-02"`. * `send_time`, the timestamp when the message was sent, using the RFC3339 time format for comparisons, from the MSH-7 segment. For example, `send_time < "2017-01-02T00:00:00-05:00"`. * `create_time`, the timestamp when the message was created in the HL7v2 store. Use the RFC3339 time format for comparisons. For example, `create_time < "2017-01-02T00:00:00-05:00"`. * `send_facility`, the care center that the message came from, from the MSH-4 segment. For example, `send_facility = "ABC"`. * `PatientId(value, type)`, which matches if the message lists a patient having an ID of the given value and type in the PID-2, PID-3, or PID-4 segments. For example, `PatientId("123456", "MRN")`. * `labels.x`, a string value of the label with key `x` as set using the Message.labels map. For example, `labels."priority"="high"`. The operator `:*` can be used to assert the existence of a label. For example, `labels."priority":*`.
func (o Hl7V2NotificationConfigResponseOutput) Filter() pulumi.StringOutput {
	return o.ApplyT(func(v Hl7V2NotificationConfigResponse) string { return v.Filter }).(pulumi.StringOutput)
}

// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. The notification is a `PubsubMessage` with the following fields: * `PubsubMessage.Data` contains the resource name. * `PubsubMessage.MessageId` is the ID of this notification. It is guaranteed to be unique within the topic. * `PubsubMessage.PublishTime` is the time when the message was published. Note that notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging. For more information, see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging).
func (o Hl7V2NotificationConfigResponseOutput) PubsubTopic() pulumi.StringOutput {
	return o.ApplyT(func(v Hl7V2NotificationConfigResponse) string { return v.PubsubTopic }).(pulumi.StringOutput)
}

type Hl7V2NotificationConfigResponseArrayOutput struct{ *pulumi.OutputState }

func (Hl7V2NotificationConfigResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Hl7V2NotificationConfigResponse)(nil)).Elem()
}

func (o Hl7V2NotificationConfigResponseArrayOutput) ToHl7V2NotificationConfigResponseArrayOutput() Hl7V2NotificationConfigResponseArrayOutput {
	return o
}

func (o Hl7V2NotificationConfigResponseArrayOutput) ToHl7V2NotificationConfigResponseArrayOutputWithContext(ctx context.Context) Hl7V2NotificationConfigResponseArrayOutput {
	return o
}

func (o Hl7V2NotificationConfigResponseArrayOutput) Index(i pulumi.IntInput) Hl7V2NotificationConfigResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Hl7V2NotificationConfigResponse {
		return vs[0].([]Hl7V2NotificationConfigResponse)[vs[1].(int)]
	}).(Hl7V2NotificationConfigResponseOutput)
}

// Raw bytes representing consent artifact content.
type Image struct {
	// Input only. Points to a Cloud Storage URI containing the consent artifact content. The URI must be in the following format: `gs://{bucket_id}/{object_id}`. The Cloud Healthcare API service account must have the `roles/storage.objectViewer` Cloud IAM role for this Cloud Storage location. The consent artifact content at this URI is copied to a Cloud Storage location managed by the Cloud Healthcare API. Responses to fetching requests return the consent artifact content in raw_bytes.
	GcsUri *string `pulumi:"gcsUri"`
	// Consent artifact content represented as a stream of bytes. This field is populated when returned in GetConsentArtifact response, but not included in CreateConsentArtifact and ListConsentArtifact response.
	RawBytes *string `pulumi:"rawBytes"`
}

// ImageInput is an input type that accepts ImageArgs and ImageOutput values.
// You can construct a concrete instance of `ImageInput` via:
//
//	ImageArgs{...}
type ImageInput interface {
	pulumi.Input

	ToImageOutput() ImageOutput
	ToImageOutputWithContext(context.Context) ImageOutput
}

// Raw bytes representing consent artifact content.
type ImageArgs struct {
	// Input only. Points to a Cloud Storage URI containing the consent artifact content. The URI must be in the following format: `gs://{bucket_id}/{object_id}`. The Cloud Healthcare API service account must have the `roles/storage.objectViewer` Cloud IAM role for this Cloud Storage location. The consent artifact content at this URI is copied to a Cloud Storage location managed by the Cloud Healthcare API. Responses to fetching requests return the consent artifact content in raw_bytes.
	GcsUri pulumi.StringPtrInput `pulumi:"gcsUri"`
	// Consent artifact content represented as a stream of bytes. This field is populated when returned in GetConsentArtifact response, but not included in CreateConsentArtifact and ListConsentArtifact response.
	RawBytes pulumi.StringPtrInput `pulumi:"rawBytes"`
}

func (ImageArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Image)(nil)).Elem()
}

func (i ImageArgs) ToImageOutput() ImageOutput {
	return i.ToImageOutputWithContext(context.Background())
}

func (i ImageArgs) ToImageOutputWithContext(ctx context.Context) ImageOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageOutput)
}

func (i ImageArgs) ToImagePtrOutput() ImagePtrOutput {
	return i.ToImagePtrOutputWithContext(context.Background())
}

func (i ImageArgs) ToImagePtrOutputWithContext(ctx context.Context) ImagePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageOutput).ToImagePtrOutputWithContext(ctx)
}

// ImagePtrInput is an input type that accepts ImageArgs, ImagePtr and ImagePtrOutput values.
// You can construct a concrete instance of `ImagePtrInput` via:
//
//	        ImageArgs{...}
//
//	or:
//
//	        nil
type ImagePtrInput interface {
	pulumi.Input

	ToImagePtrOutput() ImagePtrOutput
	ToImagePtrOutputWithContext(context.Context) ImagePtrOutput
}

type imagePtrType ImageArgs

func ImagePtr(v *ImageArgs) ImagePtrInput {
	return (*imagePtrType)(v)
}

func (*imagePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Image)(nil)).Elem()
}

func (i *imagePtrType) ToImagePtrOutput() ImagePtrOutput {
	return i.ToImagePtrOutputWithContext(context.Background())
}

func (i *imagePtrType) ToImagePtrOutputWithContext(ctx context.Context) ImagePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImagePtrOutput)
}

// ImageArrayInput is an input type that accepts ImageArray and ImageArrayOutput values.
// You can construct a concrete instance of `ImageArrayInput` via:
//
//	ImageArray{ ImageArgs{...} }
type ImageArrayInput interface {
	pulumi.Input

	ToImageArrayOutput() ImageArrayOutput
	ToImageArrayOutputWithContext(context.Context) ImageArrayOutput
}

type ImageArray []ImageInput

func (ImageArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Image)(nil)).Elem()
}

func (i ImageArray) ToImageArrayOutput() ImageArrayOutput {
	return i.ToImageArrayOutputWithContext(context.Background())
}

func (i ImageArray) ToImageArrayOutputWithContext(ctx context.Context) ImageArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageArrayOutput)
}

// Raw bytes representing consent artifact content.
type ImageOutput struct{ *pulumi.OutputState }

func (ImageOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Image)(nil)).Elem()
}

func (o ImageOutput) ToImageOutput() ImageOutput {
	return o
}

func (o ImageOutput) ToImageOutputWithContext(ctx context.Context) ImageOutput {
	return o
}

func (o ImageOutput) ToImagePtrOutput() ImagePtrOutput {
	return o.ToImagePtrOutputWithContext(context.Background())
}

func (o ImageOutput) ToImagePtrOutputWithContext(ctx context.Context) ImagePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Image) *Image {
		return &v
	}).(ImagePtrOutput)
}

// Input only. Points to a Cloud Storage URI containing the consent artifact content. The URI must be in the following format: `gs://{bucket_id}/{object_id}`. The Cloud Healthcare API service account must have the `roles/storage.objectViewer` Cloud IAM role for this Cloud Storage location. The consent artifact content at this URI is copied to a Cloud Storage location managed by the Cloud Healthcare API. Responses to fetching requests return the consent artifact content in raw_bytes.
func (o ImageOutput) GcsUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Image) *string { return v.GcsUri }).(pulumi.StringPtrOutput)
}

// Consent artifact content represented as a stream of bytes. This field is populated when returned in GetConsentArtifact response, but not included in CreateConsentArtifact and ListConsentArtifact response.
func (o ImageOutput) RawBytes() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Image) *string { return v.RawBytes }).(pulumi.StringPtrOutput)
}

type ImagePtrOutput struct{ *pulumi.OutputState }

func (ImagePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Image)(nil)).Elem()
}

func (o ImagePtrOutput) ToImagePtrOutput() ImagePtrOutput {
	return o
}

func (o ImagePtrOutput) ToImagePtrOutputWithContext(ctx context.Context) ImagePtrOutput {
	return o
}

func (o ImagePtrOutput) Elem() ImageOutput {
	return o.ApplyT(func(v *Image) Image {
		if v != nil {
			return *v
		}
		var ret Image
		return ret
	}).(ImageOutput)
}

// Input only. Points to a Cloud Storage URI containing the consent artifact content. The URI must be in the following format: `gs://{bucket_id}/{object_id}`. The Cloud Healthcare API service account must have the `roles/storage.objectViewer` Cloud IAM role for this Cloud Storage location. The consent artifact content at this URI is copied to a Cloud Storage location managed by the Cloud Healthcare API. Responses to fetching requests return the consent artifact content in raw_bytes.
func (o ImagePtrOutput) GcsUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Image) *string {
		if v == nil {
			return nil
		}
		return v.GcsUri
	}).(pulumi.StringPtrOutput)
}

// Consent artifact content represented as a stream of bytes. This field is populated when returned in GetConsentArtifact response, but not included in CreateConsentArtifact and ListConsentArtifact response.
func (o ImagePtrOutput) RawBytes() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Image) *string {
		if v == nil {
			return nil
		}
		return v.RawBytes
	}).(pulumi.StringPtrOutput)
}

type ImageArrayOutput struct{ *pulumi.OutputState }

func (ImageArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Image)(nil)).Elem()
}

func (o ImageArrayOutput) ToImageArrayOutput() ImageArrayOutput {
	return o
}

func (o ImageArrayOutput) ToImageArrayOutputWithContext(ctx context.Context) ImageArrayOutput {
	return o
}

func (o ImageArrayOutput) Index(i pulumi.IntInput) ImageOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Image {
		return vs[0].([]Image)[vs[1].(int)]
	}).(ImageOutput)
}

// Image annotation.
type ImageAnnotation struct {
	// The list of polygons outlining the sensitive regions in the image.
	BoundingPolys []BoundingPoly `pulumi:"boundingPolys"`
	// 0-based index of the image frame. For example, an image frame in a DICOM instance.
	FrameIndex *int `pulumi:"frameIndex"`
}

// ImageAnnotationInput is an input type that accepts ImageAnnotationArgs and ImageAnnotationOutput values.
// You can construct a concrete instance of `ImageAnnotationInput` via:
//
//	ImageAnnotationArgs{...}
type ImageAnnotationInput interface {
	pulumi.Input

	ToImageAnnotationOutput() ImageAnnotationOutput
	ToImageAnnotationOutputWithContext(context.Context) ImageAnnotationOutput
}

// Image annotation.
type ImageAnnotationArgs struct {
	// The list of polygons outlining the sensitive regions in the image.
	BoundingPolys BoundingPolyArrayInput `pulumi:"boundingPolys"`
	// 0-based index of the image frame. For example, an image frame in a DICOM instance.
	FrameIndex pulumi.IntPtrInput `pulumi:"frameIndex"`
}

func (ImageAnnotationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ImageAnnotation)(nil)).Elem()
}

func (i ImageAnnotationArgs) ToImageAnnotationOutput() ImageAnnotationOutput {
	return i.ToImageAnnotationOutputWithContext(context.Background())
}

func (i ImageAnnotationArgs) ToImageAnnotationOutputWithContext(ctx context.Context) ImageAnnotationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageAnnotationOutput)
}

func (i ImageAnnotationArgs) ToImageAnnotationPtrOutput() ImageAnnotationPtrOutput {
	return i.ToImageAnnotationPtrOutputWithContext(context.Background())
}

func (i ImageAnnotationArgs) ToImageAnnotationPtrOutputWithContext(ctx context.Context) ImageAnnotationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageAnnotationOutput).ToImageAnnotationPtrOutputWithContext(ctx)
}

// ImageAnnotationPtrInput is an input type that accepts ImageAnnotationArgs, ImageAnnotationPtr and ImageAnnotationPtrOutput values.
// You can construct a concrete instance of `ImageAnnotationPtrInput` via:
//
//	        ImageAnnotationArgs{...}
//
//	or:
//
//	        nil
type ImageAnnotationPtrInput interface {
	pulumi.Input

	ToImageAnnotationPtrOutput() ImageAnnotationPtrOutput
	ToImageAnnotationPtrOutputWithContext(context.Context) ImageAnnotationPtrOutput
}

type imageAnnotationPtrType ImageAnnotationArgs

func ImageAnnotationPtr(v *ImageAnnotationArgs) ImageAnnotationPtrInput {
	return (*imageAnnotationPtrType)(v)
}

func (*imageAnnotationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ImageAnnotation)(nil)).Elem()
}

func (i *imageAnnotationPtrType) ToImageAnnotationPtrOutput() ImageAnnotationPtrOutput {
	return i.ToImageAnnotationPtrOutputWithContext(context.Background())
}

func (i *imageAnnotationPtrType) ToImageAnnotationPtrOutputWithContext(ctx context.Context) ImageAnnotationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageAnnotationPtrOutput)
}

// Image annotation.
type ImageAnnotationOutput struct{ *pulumi.OutputState }

func (ImageAnnotationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ImageAnnotation)(nil)).Elem()
}

func (o ImageAnnotationOutput) ToImageAnnotationOutput() ImageAnnotationOutput {
	return o
}

func (o ImageAnnotationOutput) ToImageAnnotationOutputWithContext(ctx context.Context) ImageAnnotationOutput {
	return o
}

func (o ImageAnnotationOutput) ToImageAnnotationPtrOutput() ImageAnnotationPtrOutput {
	return o.ToImageAnnotationPtrOutputWithContext(context.Background())
}

func (o ImageAnnotationOutput) ToImageAnnotationPtrOutputWithContext(ctx context.Context) ImageAnnotationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ImageAnnotation) *ImageAnnotation {
		return &v
	}).(ImageAnnotationPtrOutput)
}

// The list of polygons outlining the sensitive regions in the image.
func (o ImageAnnotationOutput) BoundingPolys() BoundingPolyArrayOutput {
	return o.ApplyT(func(v ImageAnnotation) []BoundingPoly { return v.BoundingPolys }).(BoundingPolyArrayOutput)
}

// 0-based index of the image frame. For example, an image frame in a DICOM instance.
func (o ImageAnnotationOutput) FrameIndex() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ImageAnnotation) *int { return v.FrameIndex }).(pulumi.IntPtrOutput)
}

type ImageAnnotationPtrOutput struct{ *pulumi.OutputState }

func (ImageAnnotationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ImageAnnotation)(nil)).Elem()
}

func (o ImageAnnotationPtrOutput) ToImageAnnotationPtrOutput() ImageAnnotationPtrOutput {
	return o
}

func (o ImageAnnotationPtrOutput) ToImageAnnotationPtrOutputWithContext(ctx context.Context) ImageAnnotationPtrOutput {
	return o
}

func (o ImageAnnotationPtrOutput) Elem() ImageAnnotationOutput {
	return o.ApplyT(func(v *ImageAnnotation) ImageAnnotation {
		if v != nil {
			return *v
		}
		var ret ImageAnnotation
		return ret
	}).(ImageAnnotationOutput)
}

// The list of polygons outlining the sensitive regions in the image.
func (o ImageAnnotationPtrOutput) BoundingPolys() BoundingPolyArrayOutput {
	return o.ApplyT(func(v *ImageAnnotation) []BoundingPoly {
		if v == nil {
			return nil
		}
		return v.BoundingPolys
	}).(BoundingPolyArrayOutput)
}

// 0-based index of the image frame. For example, an image frame in a DICOM instance.
func (o ImageAnnotationPtrOutput) FrameIndex() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ImageAnnotation) *int {
		if v == nil {
			return nil
		}
		return v.FrameIndex
	}).(pulumi.IntPtrOutput)
}

// Image annotation.
type ImageAnnotationResponse struct {
	// The list of polygons outlining the sensitive regions in the image.
	BoundingPolys []BoundingPolyResponse `pulumi:"boundingPolys"`
	// 0-based index of the image frame. For example, an image frame in a DICOM instance.
	FrameIndex int `pulumi:"frameIndex"`
}

// Image annotation.
type ImageAnnotationResponseOutput struct{ *pulumi.OutputState }

func (ImageAnnotationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ImageAnnotationResponse)(nil)).Elem()
}

func (o ImageAnnotationResponseOutput) ToImageAnnotationResponseOutput() ImageAnnotationResponseOutput {
	return o
}

func (o ImageAnnotationResponseOutput) ToImageAnnotationResponseOutputWithContext(ctx context.Context) ImageAnnotationResponseOutput {
	return o
}

// The list of polygons outlining the sensitive regions in the image.
func (o ImageAnnotationResponseOutput) BoundingPolys() BoundingPolyResponseArrayOutput {
	return o.ApplyT(func(v ImageAnnotationResponse) []BoundingPolyResponse { return v.BoundingPolys }).(BoundingPolyResponseArrayOutput)
}

// 0-based index of the image frame. For example, an image frame in a DICOM instance.
func (o ImageAnnotationResponseOutput) FrameIndex() pulumi.IntOutput {
	return o.ApplyT(func(v ImageAnnotationResponse) int { return v.FrameIndex }).(pulumi.IntOutput)
}

// Specifies how to handle de-identification of image pixels.
type ImageConfig struct {
	// Additional InfoTypes to redact in the images in addition to those used by `text_redaction_mode`. Can only be used when `text_redaction_mode` is set to `REDACT_SENSITIVE_TEXT`, `REDACT_SENSITIVE_TEXT_CLEAN_DESCRIPTORS` or `TEXT_REDACTION_MODE_UNSPECIFIED`.
	AdditionalInfoTypes []string `pulumi:"additionalInfoTypes"`
	// InfoTypes to skip redacting, overriding those used by `text_redaction_mode`. Can only be used when `text_redaction_mode` is set to `REDACT_SENSITIVE_TEXT` or `REDACT_SENSITIVE_TEXT_CLEAN_DESCRIPTORS`.
	ExcludeInfoTypes []string `pulumi:"excludeInfoTypes"`
	// Determines how to redact text from image.
	TextRedactionMode *ImageConfigTextRedactionMode `pulumi:"textRedactionMode"`
}

// ImageConfigInput is an input type that accepts ImageConfigArgs and ImageConfigOutput values.
// You can construct a concrete instance of `ImageConfigInput` via:
//
//	ImageConfigArgs{...}
type ImageConfigInput interface {
	pulumi.Input

	ToImageConfigOutput() ImageConfigOutput
	ToImageConfigOutputWithContext(context.Context) ImageConfigOutput
}

// Specifies how to handle de-identification of image pixels.
type ImageConfigArgs struct {
	// Additional InfoTypes to redact in the images in addition to those used by `text_redaction_mode`. Can only be used when `text_redaction_mode` is set to `REDACT_SENSITIVE_TEXT`, `REDACT_SENSITIVE_TEXT_CLEAN_DESCRIPTORS` or `TEXT_REDACTION_MODE_UNSPECIFIED`.
	AdditionalInfoTypes pulumi.StringArrayInput `pulumi:"additionalInfoTypes"`
	// InfoTypes to skip redacting, overriding those used by `text_redaction_mode`. Can only be used when `text_redaction_mode` is set to `REDACT_SENSITIVE_TEXT` or `REDACT_SENSITIVE_TEXT_CLEAN_DESCRIPTORS`.
	ExcludeInfoTypes pulumi.StringArrayInput `pulumi:"excludeInfoTypes"`
	// Determines how to redact text from image.
	TextRedactionMode ImageConfigTextRedactionModePtrInput `pulumi:"textRedactionMode"`
}

func (ImageConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ImageConfig)(nil)).Elem()
}

func (i ImageConfigArgs) ToImageConfigOutput() ImageConfigOutput {
	return i.ToImageConfigOutputWithContext(context.Background())
}

func (i ImageConfigArgs) ToImageConfigOutputWithContext(ctx context.Context) ImageConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageConfigOutput)
}

func (i ImageConfigArgs) ToImageConfigPtrOutput() ImageConfigPtrOutput {
	return i.ToImageConfigPtrOutputWithContext(context.Background())
}

func (i ImageConfigArgs) ToImageConfigPtrOutputWithContext(ctx context.Context) ImageConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageConfigOutput).ToImageConfigPtrOutputWithContext(ctx)
}

// ImageConfigPtrInput is an input type that accepts ImageConfigArgs, ImageConfigPtr and ImageConfigPtrOutput values.
// You can construct a concrete instance of `ImageConfigPtrInput` via:
//
//	        ImageConfigArgs{...}
//
//	or:
//
//	        nil
type ImageConfigPtrInput interface {
	pulumi.Input

	ToImageConfigPtrOutput() ImageConfigPtrOutput
	ToImageConfigPtrOutputWithContext(context.Context) ImageConfigPtrOutput
}

type imageConfigPtrType ImageConfigArgs

func ImageConfigPtr(v *ImageConfigArgs) ImageConfigPtrInput {
	return (*imageConfigPtrType)(v)
}

func (*imageConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ImageConfig)(nil)).Elem()
}

func (i *imageConfigPtrType) ToImageConfigPtrOutput() ImageConfigPtrOutput {
	return i.ToImageConfigPtrOutputWithContext(context.Background())
}

func (i *imageConfigPtrType) ToImageConfigPtrOutputWithContext(ctx context.Context) ImageConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ImageConfigPtrOutput)
}

// Specifies how to handle de-identification of image pixels.
type ImageConfigOutput struct{ *pulumi.OutputState }

func (ImageConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ImageConfig)(nil)).Elem()
}

func (o ImageConfigOutput) ToImageConfigOutput() ImageConfigOutput {
	return o
}

func (o ImageConfigOutput) ToImageConfigOutputWithContext(ctx context.Context) ImageConfigOutput {
	return o
}

func (o ImageConfigOutput) ToImageConfigPtrOutput() ImageConfigPtrOutput {
	return o.ToImageConfigPtrOutputWithContext(context.Background())
}

func (o ImageConfigOutput) ToImageConfigPtrOutputWithContext(ctx context.Context) ImageConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ImageConfig) *ImageConfig {
		return &v
	}).(ImageConfigPtrOutput)
}

// Additional InfoTypes to redact in the images in addition to those used by `text_redaction_mode`. Can only be used when `text_redaction_mode` is set to `REDACT_SENSITIVE_TEXT`, `REDACT_SENSITIVE_TEXT_CLEAN_DESCRIPTORS` or `TEXT_REDACTION_MODE_UNSPECIFIED`.
func (o ImageConfigOutput) AdditionalInfoTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ImageConfig) []string { return v.AdditionalInfoTypes }).(pulumi.StringArrayOutput)
}

// InfoTypes to skip redacting, overriding those used by `text_redaction_mode`. Can only be used when `text_redaction_mode` is set to `REDACT_SENSITIVE_TEXT` or `REDACT_SENSITIVE_TEXT_CLEAN_DESCRIPTORS`.
func (o ImageConfigOutput) ExcludeInfoTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ImageConfig) []string { return v.ExcludeInfoTypes }).(pulumi.StringArrayOutput)
}

// Determines how to redact text from image.
func (o ImageConfigOutput) TextRedactionMode() ImageConfigTextRedactionModePtrOutput {
	return o.ApplyT(func(v ImageConfig) *ImageConfigTextRedactionMode { return v.TextRedactionMode }).(ImageConfigTextRedactionModePtrOutput)
}

type ImageConfigPtrOutput struct{ *pulumi.OutputState }

func (ImageConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ImageConfig)(nil)).Elem()
}

func (o ImageConfigPtrOutput) ToImageConfigPtrOutput() ImageConfigPtrOutput {
	return o
}

func (o ImageConfigPtrOutput) ToImageConfigPtrOutputWithContext(ctx context.Context) ImageConfigPtrOutput {
	return o
}

func (o ImageConfigPtrOutput) Elem() ImageConfigOutput {
	return o.ApplyT(func(v *ImageConfig) ImageConfig {
		if v != nil {
			return *v
		}
		var ret ImageConfig
		return ret
	}).(ImageConfigOutput)
}

// Additional InfoTypes to redact in the images in addition to those used by `text_redaction_mode`. Can only be used when `text_redaction_mode` is set to `REDACT_SENSITIVE_TEXT`, `REDACT_SENSITIVE_TEXT_CLEAN_DESCRIPTORS` or `TEXT_REDACTION_MODE_UNSPECIFIED`.
func (o ImageConfigPtrOutput) AdditionalInfoTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ImageConfig) []string {
		if v == nil {
			return nil
		}
		return v.AdditionalInfoTypes
	}).(pulumi.StringArrayOutput)
}

// InfoTypes to skip redacting, overriding those used by `text_redaction_mode`. Can only be used when `text_redaction_mode` is set to `REDACT_SENSITIVE_TEXT` or `REDACT_SENSITIVE_TEXT_CLEAN_DESCRIPTORS`.
func (o ImageConfigPtrOutput) ExcludeInfoTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ImageConfig) []string {
		if v == nil {
			return nil
		}
		return v.ExcludeInfoTypes
	}).(pulumi.StringArrayOutput)
}

// Determines how to redact text from image.
func (o ImageConfigPtrOutput) TextRedactionMode() ImageConfigTextRedactionModePtrOutput {
	return o.ApplyT(func(v *ImageConfig) *ImageConfigTextRedactionMode {
		if v == nil {
			return nil
		}
		return v.TextRedactionMode
	}).(ImageConfigTextRedactionModePtrOutput)
}

// Specifies how to handle de-identification of image pixels.
type ImageConfigResponse struct {
	// Additional InfoTypes to redact in the images in addition to those used by `text_redaction_mode`. Can only be used when `text_redaction_mode` is set to `REDACT_SENSITIVE_TEXT`, `REDACT_SENSITIVE_TEXT_CLEAN_DESCRIPTORS` or `TEXT_REDACTION_MODE_UNSPECIFIED`.
	AdditionalInfoTypes []string `pulumi:"additionalInfoTypes"`
	// InfoTypes to skip redacting, overriding those used by `text_redaction_mode`. Can only be used when `text_redaction_mode` is set to `REDACT_SENSITIVE_TEXT` or `REDACT_SENSITIVE_TEXT_CLEAN_DESCRIPTORS`.
	ExcludeInfoTypes []string `pulumi:"excludeInfoTypes"`
	// Determines how to redact text from image.
	TextRedactionMode string `pulumi:"textRedactionMode"`
}

// Specifies how to handle de-identification of image pixels.
type ImageConfigResponseOutput struct{ *pulumi.OutputState }

func (ImageConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ImageConfigResponse)(nil)).Elem()
}

func (o ImageConfigResponseOutput) ToImageConfigResponseOutput() ImageConfigResponseOutput {
	return o
}

func (o ImageConfigResponseOutput) ToImageConfigResponseOutputWithContext(ctx context.Context) ImageConfigResponseOutput {
	return o
}

// Additional InfoTypes to redact in the images in addition to those used by `text_redaction_mode`. Can only be used when `text_redaction_mode` is set to `REDACT_SENSITIVE_TEXT`, `REDACT_SENSITIVE_TEXT_CLEAN_DESCRIPTORS` or `TEXT_REDACTION_MODE_UNSPECIFIED`.
func (o ImageConfigResponseOutput) AdditionalInfoTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ImageConfigResponse) []string { return v.AdditionalInfoTypes }).(pulumi.StringArrayOutput)
}

// InfoTypes to skip redacting, overriding those used by `text_redaction_mode`. Can only be used when `text_redaction_mode` is set to `REDACT_SENSITIVE_TEXT` or `REDACT_SENSITIVE_TEXT_CLEAN_DESCRIPTORS`.
func (o ImageConfigResponseOutput) ExcludeInfoTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ImageConfigResponse) []string { return v.ExcludeInfoTypes }).(pulumi.StringArrayOutput)
}

// Determines how to redact text from image.
func (o ImageConfigResponseOutput) TextRedactionMode() pulumi.StringOutput {
	return o.ApplyT(func(v ImageConfigResponse) string { return v.TextRedactionMode }).(pulumi.StringOutput)
}

// Raw bytes representing consent artifact content.
type ImageResponse struct {
	// Input only. Points to a Cloud Storage URI containing the consent artifact content. The URI must be in the following format: `gs://{bucket_id}/{object_id}`. The Cloud Healthcare API service account must have the `roles/storage.objectViewer` Cloud IAM role for this Cloud Storage location. The consent artifact content at this URI is copied to a Cloud Storage location managed by the Cloud Healthcare API. Responses to fetching requests return the consent artifact content in raw_bytes.
	GcsUri string `pulumi:"gcsUri"`
	// Consent artifact content represented as a stream of bytes. This field is populated when returned in GetConsentArtifact response, but not included in CreateConsentArtifact and ListConsentArtifact response.
	RawBytes string `pulumi:"rawBytes"`
}

// Raw bytes representing consent artifact content.
type ImageResponseOutput struct{ *pulumi.OutputState }

func (ImageResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ImageResponse)(nil)).Elem()
}

func (o ImageResponseOutput) ToImageResponseOutput() ImageResponseOutput {
	return o
}

func (o ImageResponseOutput) ToImageResponseOutputWithContext(ctx context.Context) ImageResponseOutput {
	return o
}

// Input only. Points to a Cloud Storage URI containing the consent artifact content. The URI must be in the following format: `gs://{bucket_id}/{object_id}`. The Cloud Healthcare API service account must have the `roles/storage.objectViewer` Cloud IAM role for this Cloud Storage location. The consent artifact content at this URI is copied to a Cloud Storage location managed by the Cloud Healthcare API. Responses to fetching requests return the consent artifact content in raw_bytes.
func (o ImageResponseOutput) GcsUri() pulumi.StringOutput {
	return o.ApplyT(func(v ImageResponse) string { return v.GcsUri }).(pulumi.StringOutput)
}

// Consent artifact content represented as a stream of bytes. This field is populated when returned in GetConsentArtifact response, but not included in CreateConsentArtifact and ListConsentArtifact response.
func (o ImageResponseOutput) RawBytes() pulumi.StringOutput {
	return o.ApplyT(func(v ImageResponse) string { return v.RawBytes }).(pulumi.StringOutput)
}

type ImageResponseArrayOutput struct{ *pulumi.OutputState }

func (ImageResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ImageResponse)(nil)).Elem()
}

func (o ImageResponseArrayOutput) ToImageResponseArrayOutput() ImageResponseArrayOutput {
	return o
}

func (o ImageResponseArrayOutput) ToImageResponseArrayOutputWithContext(ctx context.Context) ImageResponseArrayOutput {
	return o
}

func (o ImageResponseArrayOutput) Index(i pulumi.IntInput) ImageResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ImageResponse {
		return vs[0].([]ImageResponse)[vs[1].(int)]
	}).(ImageResponseOutput)
}

// A transformation to apply to text that is identified as a specific info_type.
type InfoTypeTransformation struct {
	// Config for character mask.
	CharacterMaskConfig *CharacterMaskConfig `pulumi:"characterMaskConfig"`
	// Config for crypto hash.
	CryptoHashConfig *CryptoHashConfig `pulumi:"cryptoHashConfig"`
	// Config for date shift.
	DateShiftConfig *DateShiftConfig `pulumi:"dateShiftConfig"`
	// `InfoTypes` to apply this transformation to. If this is not specified, this transformation becomes the default transformation, and is used for any `info_type` that is not specified in another transformation.
	InfoTypes []string `pulumi:"infoTypes"`
	// Config for text redaction.
	RedactConfig *RedactConfig `pulumi:"redactConfig"`
	// Config for replace with InfoType.
	ReplaceWithInfoTypeConfig *ReplaceWithInfoTypeConfig `pulumi:"replaceWithInfoTypeConfig"`
}

// InfoTypeTransformationInput is an input type that accepts InfoTypeTransformationArgs and InfoTypeTransformationOutput values.
// You can construct a concrete instance of `InfoTypeTransformationInput` via:
//
//	InfoTypeTransformationArgs{...}
type InfoTypeTransformationInput interface {
	pulumi.Input

	ToInfoTypeTransformationOutput() InfoTypeTransformationOutput
	ToInfoTypeTransformationOutputWithContext(context.Context) InfoTypeTransformationOutput
}

// A transformation to apply to text that is identified as a specific info_type.
type InfoTypeTransformationArgs struct {
	// Config for character mask.
	CharacterMaskConfig CharacterMaskConfigPtrInput `pulumi:"characterMaskConfig"`
	// Config for crypto hash.
	CryptoHashConfig CryptoHashConfigPtrInput `pulumi:"cryptoHashConfig"`
	// Config for date shift.
	DateShiftConfig DateShiftConfigPtrInput `pulumi:"dateShiftConfig"`
	// `InfoTypes` to apply this transformation to. If this is not specified, this transformation becomes the default transformation, and is used for any `info_type` that is not specified in another transformation.
	InfoTypes pulumi.StringArrayInput `pulumi:"infoTypes"`
	// Config for text redaction.
	RedactConfig RedactConfigPtrInput `pulumi:"redactConfig"`
	// Config for replace with InfoType.
	ReplaceWithInfoTypeConfig ReplaceWithInfoTypeConfigPtrInput `pulumi:"replaceWithInfoTypeConfig"`
}

func (InfoTypeTransformationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InfoTypeTransformation)(nil)).Elem()
}

func (i InfoTypeTransformationArgs) ToInfoTypeTransformationOutput() InfoTypeTransformationOutput {
	return i.ToInfoTypeTransformationOutputWithContext(context.Background())
}

func (i InfoTypeTransformationArgs) ToInfoTypeTransformationOutputWithContext(ctx context.Context) InfoTypeTransformationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InfoTypeTransformationOutput)
}

// InfoTypeTransformationArrayInput is an input type that accepts InfoTypeTransformationArray and InfoTypeTransformationArrayOutput values.
// You can construct a concrete instance of `InfoTypeTransformationArrayInput` via:
//
//	InfoTypeTransformationArray{ InfoTypeTransformationArgs{...} }
type InfoTypeTransformationArrayInput interface {
	pulumi.Input

	ToInfoTypeTransformationArrayOutput() InfoTypeTransformationArrayOutput
	ToInfoTypeTransformationArrayOutputWithContext(context.Context) InfoTypeTransformationArrayOutput
}

type InfoTypeTransformationArray []InfoTypeTransformationInput

func (InfoTypeTransformationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InfoTypeTransformation)(nil)).Elem()
}

func (i InfoTypeTransformationArray) ToInfoTypeTransformationArrayOutput() InfoTypeTransformationArrayOutput {
	return i.ToInfoTypeTransformationArrayOutputWithContext(context.Background())
}

func (i InfoTypeTransformationArray) ToInfoTypeTransformationArrayOutputWithContext(ctx context.Context) InfoTypeTransformationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InfoTypeTransformationArrayOutput)
}

// A transformation to apply to text that is identified as a specific info_type.
type InfoTypeTransformationOutput struct{ *pulumi.OutputState }

func (InfoTypeTransformationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InfoTypeTransformation)(nil)).Elem()
}

func (o InfoTypeTransformationOutput) ToInfoTypeTransformationOutput() InfoTypeTransformationOutput {
	return o
}

func (o InfoTypeTransformationOutput) ToInfoTypeTransformationOutputWithContext(ctx context.Context) InfoTypeTransformationOutput {
	return o
}

// Config for character mask.
func (o InfoTypeTransformationOutput) CharacterMaskConfig() CharacterMaskConfigPtrOutput {
	return o.ApplyT(func(v InfoTypeTransformation) *CharacterMaskConfig { return v.CharacterMaskConfig }).(CharacterMaskConfigPtrOutput)
}

// Config for crypto hash.
func (o InfoTypeTransformationOutput) CryptoHashConfig() CryptoHashConfigPtrOutput {
	return o.ApplyT(func(v InfoTypeTransformation) *CryptoHashConfig { return v.CryptoHashConfig }).(CryptoHashConfigPtrOutput)
}

// Config for date shift.
func (o InfoTypeTransformationOutput) DateShiftConfig() DateShiftConfigPtrOutput {
	return o.ApplyT(func(v InfoTypeTransformation) *DateShiftConfig { return v.DateShiftConfig }).(DateShiftConfigPtrOutput)
}

// `InfoTypes` to apply this transformation to. If this is not specified, this transformation becomes the default transformation, and is used for any `info_type` that is not specified in another transformation.
func (o InfoTypeTransformationOutput) InfoTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v InfoTypeTransformation) []string { return v.InfoTypes }).(pulumi.StringArrayOutput)
}

// Config for text redaction.
func (o InfoTypeTransformationOutput) RedactConfig() RedactConfigPtrOutput {
	return o.ApplyT(func(v InfoTypeTransformation) *RedactConfig { return v.RedactConfig }).(RedactConfigPtrOutput)
}

// Config for replace with InfoType.
func (o InfoTypeTransformationOutput) ReplaceWithInfoTypeConfig() ReplaceWithInfoTypeConfigPtrOutput {
	return o.ApplyT(func(v InfoTypeTransformation) *ReplaceWithInfoTypeConfig { return v.ReplaceWithInfoTypeConfig }).(ReplaceWithInfoTypeConfigPtrOutput)
}

type InfoTypeTransformationArrayOutput struct{ *pulumi.OutputState }

func (InfoTypeTransformationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InfoTypeTransformation)(nil)).Elem()
}

func (o InfoTypeTransformationArrayOutput) ToInfoTypeTransformationArrayOutput() InfoTypeTransformationArrayOutput {
	return o
}

func (o InfoTypeTransformationArrayOutput) ToInfoTypeTransformationArrayOutputWithContext(ctx context.Context) InfoTypeTransformationArrayOutput {
	return o
}

func (o InfoTypeTransformationArrayOutput) Index(i pulumi.IntInput) InfoTypeTransformationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) InfoTypeTransformation {
		return vs[0].([]InfoTypeTransformation)[vs[1].(int)]
	}).(InfoTypeTransformationOutput)
}

// A transformation to apply to text that is identified as a specific info_type.
type InfoTypeTransformationResponse struct {
	// Config for character mask.
	CharacterMaskConfig CharacterMaskConfigResponse `pulumi:"characterMaskConfig"`
	// Config for crypto hash.
	CryptoHashConfig CryptoHashConfigResponse `pulumi:"cryptoHashConfig"`
	// Config for date shift.
	DateShiftConfig DateShiftConfigResponse `pulumi:"dateShiftConfig"`
	// `InfoTypes` to apply this transformation to. If this is not specified, this transformation becomes the default transformation, and is used for any `info_type` that is not specified in another transformation.
	InfoTypes []string `pulumi:"infoTypes"`
	// Config for text redaction.
	RedactConfig RedactConfigResponse `pulumi:"redactConfig"`
	// Config for replace with InfoType.
	ReplaceWithInfoTypeConfig ReplaceWithInfoTypeConfigResponse `pulumi:"replaceWithInfoTypeConfig"`
}

// A transformation to apply to text that is identified as a specific info_type.
type InfoTypeTransformationResponseOutput struct{ *pulumi.OutputState }

func (InfoTypeTransformationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InfoTypeTransformationResponse)(nil)).Elem()
}

func (o InfoTypeTransformationResponseOutput) ToInfoTypeTransformationResponseOutput() InfoTypeTransformationResponseOutput {
	return o
}

func (o InfoTypeTransformationResponseOutput) ToInfoTypeTransformationResponseOutputWithContext(ctx context.Context) InfoTypeTransformationResponseOutput {
	return o
}

// Config for character mask.
func (o InfoTypeTransformationResponseOutput) CharacterMaskConfig() CharacterMaskConfigResponseOutput {
	return o.ApplyT(func(v InfoTypeTransformationResponse) CharacterMaskConfigResponse { return v.CharacterMaskConfig }).(CharacterMaskConfigResponseOutput)
}

// Config for crypto hash.
func (o InfoTypeTransformationResponseOutput) CryptoHashConfig() CryptoHashConfigResponseOutput {
	return o.ApplyT(func(v InfoTypeTransformationResponse) CryptoHashConfigResponse { return v.CryptoHashConfig }).(CryptoHashConfigResponseOutput)
}

// Config for date shift.
func (o InfoTypeTransformationResponseOutput) DateShiftConfig() DateShiftConfigResponseOutput {
	return o.ApplyT(func(v InfoTypeTransformationResponse) DateShiftConfigResponse { return v.DateShiftConfig }).(DateShiftConfigResponseOutput)
}

// `InfoTypes` to apply this transformation to. If this is not specified, this transformation becomes the default transformation, and is used for any `info_type` that is not specified in another transformation.
func (o InfoTypeTransformationResponseOutput) InfoTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v InfoTypeTransformationResponse) []string { return v.InfoTypes }).(pulumi.StringArrayOutput)
}

// Config for text redaction.
func (o InfoTypeTransformationResponseOutput) RedactConfig() RedactConfigResponseOutput {
	return o.ApplyT(func(v InfoTypeTransformationResponse) RedactConfigResponse { return v.RedactConfig }).(RedactConfigResponseOutput)
}

// Config for replace with InfoType.
func (o InfoTypeTransformationResponseOutput) ReplaceWithInfoTypeConfig() ReplaceWithInfoTypeConfigResponseOutput {
	return o.ApplyT(func(v InfoTypeTransformationResponse) ReplaceWithInfoTypeConfigResponse {
		return v.ReplaceWithInfoTypeConfig
	}).(ReplaceWithInfoTypeConfigResponseOutput)
}

type InfoTypeTransformationResponseArrayOutput struct{ *pulumi.OutputState }

func (InfoTypeTransformationResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InfoTypeTransformationResponse)(nil)).Elem()
}

func (o InfoTypeTransformationResponseArrayOutput) ToInfoTypeTransformationResponseArrayOutput() InfoTypeTransformationResponseArrayOutput {
	return o
}

func (o InfoTypeTransformationResponseArrayOutput) ToInfoTypeTransformationResponseArrayOutputWithContext(ctx context.Context) InfoTypeTransformationResponseArrayOutput {
	return o
}

func (o InfoTypeTransformationResponseArrayOutput) Index(i pulumi.IntInput) InfoTypeTransformationResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) InfoTypeTransformationResponse {
		return vs[0].([]InfoTypeTransformationResponse)[vs[1].(int)]
	}).(InfoTypeTransformationResponseOutput)
}

// The behavior for handling FHIR extensions that aren't otherwise specified for de-identification. If provided, all extensions are preserved during de-identification by default. If unspecified, all extensions are removed during de-identification by default.
type KeepExtensionsConfig struct {
}

// KeepExtensionsConfigInput is an input type that accepts KeepExtensionsConfigArgs and KeepExtensionsConfigOutput values.
// You can construct a concrete instance of `KeepExtensionsConfigInput` via:
//
//	KeepExtensionsConfigArgs{...}
type KeepExtensionsConfigInput interface {
	pulumi.Input

	ToKeepExtensionsConfigOutput() KeepExtensionsConfigOutput
	ToKeepExtensionsConfigOutputWithContext(context.Context) KeepExtensionsConfigOutput
}

// The behavior for handling FHIR extensions that aren't otherwise specified for de-identification. If provided, all extensions are preserved during de-identification by default. If unspecified, all extensions are removed during de-identification by default.
type KeepExtensionsConfigArgs struct {
}

func (KeepExtensionsConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KeepExtensionsConfig)(nil)).Elem()
}

func (i KeepExtensionsConfigArgs) ToKeepExtensionsConfigOutput() KeepExtensionsConfigOutput {
	return i.ToKeepExtensionsConfigOutputWithContext(context.Background())
}

func (i KeepExtensionsConfigArgs) ToKeepExtensionsConfigOutputWithContext(ctx context.Context) KeepExtensionsConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeepExtensionsConfigOutput)
}

func (i KeepExtensionsConfigArgs) ToKeepExtensionsConfigPtrOutput() KeepExtensionsConfigPtrOutput {
	return i.ToKeepExtensionsConfigPtrOutputWithContext(context.Background())
}

func (i KeepExtensionsConfigArgs) ToKeepExtensionsConfigPtrOutputWithContext(ctx context.Context) KeepExtensionsConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeepExtensionsConfigOutput).ToKeepExtensionsConfigPtrOutputWithContext(ctx)
}

// KeepExtensionsConfigPtrInput is an input type that accepts KeepExtensionsConfigArgs, KeepExtensionsConfigPtr and KeepExtensionsConfigPtrOutput values.
// You can construct a concrete instance of `KeepExtensionsConfigPtrInput` via:
//
//	        KeepExtensionsConfigArgs{...}
//
//	or:
//
//	        nil
type KeepExtensionsConfigPtrInput interface {
	pulumi.Input

	ToKeepExtensionsConfigPtrOutput() KeepExtensionsConfigPtrOutput
	ToKeepExtensionsConfigPtrOutputWithContext(context.Context) KeepExtensionsConfigPtrOutput
}

type keepExtensionsConfigPtrType KeepExtensionsConfigArgs

func KeepExtensionsConfigPtr(v *KeepExtensionsConfigArgs) KeepExtensionsConfigPtrInput {
	return (*keepExtensionsConfigPtrType)(v)
}

func (*keepExtensionsConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KeepExtensionsConfig)(nil)).Elem()
}

func (i *keepExtensionsConfigPtrType) ToKeepExtensionsConfigPtrOutput() KeepExtensionsConfigPtrOutput {
	return i.ToKeepExtensionsConfigPtrOutputWithContext(context.Background())
}

func (i *keepExtensionsConfigPtrType) ToKeepExtensionsConfigPtrOutputWithContext(ctx context.Context) KeepExtensionsConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeepExtensionsConfigPtrOutput)
}

// The behavior for handling FHIR extensions that aren't otherwise specified for de-identification. If provided, all extensions are preserved during de-identification by default. If unspecified, all extensions are removed during de-identification by default.
type KeepExtensionsConfigOutput struct{ *pulumi.OutputState }

func (KeepExtensionsConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KeepExtensionsConfig)(nil)).Elem()
}

func (o KeepExtensionsConfigOutput) ToKeepExtensionsConfigOutput() KeepExtensionsConfigOutput {
	return o
}

func (o KeepExtensionsConfigOutput) ToKeepExtensionsConfigOutputWithContext(ctx context.Context) KeepExtensionsConfigOutput {
	return o
}

func (o KeepExtensionsConfigOutput) ToKeepExtensionsConfigPtrOutput() KeepExtensionsConfigPtrOutput {
	return o.ToKeepExtensionsConfigPtrOutputWithContext(context.Background())
}

func (o KeepExtensionsConfigOutput) ToKeepExtensionsConfigPtrOutputWithContext(ctx context.Context) KeepExtensionsConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KeepExtensionsConfig) *KeepExtensionsConfig {
		return &v
	}).(KeepExtensionsConfigPtrOutput)
}

type KeepExtensionsConfigPtrOutput struct{ *pulumi.OutputState }

func (KeepExtensionsConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KeepExtensionsConfig)(nil)).Elem()
}

func (o KeepExtensionsConfigPtrOutput) ToKeepExtensionsConfigPtrOutput() KeepExtensionsConfigPtrOutput {
	return o
}

func (o KeepExtensionsConfigPtrOutput) ToKeepExtensionsConfigPtrOutputWithContext(ctx context.Context) KeepExtensionsConfigPtrOutput {
	return o
}

func (o KeepExtensionsConfigPtrOutput) Elem() KeepExtensionsConfigOutput {
	return o.ApplyT(func(v *KeepExtensionsConfig) KeepExtensionsConfig {
		if v != nil {
			return *v
		}
		var ret KeepExtensionsConfig
		return ret
	}).(KeepExtensionsConfigOutput)
}

// The behavior for handling FHIR extensions that aren't otherwise specified for de-identification. If provided, all extensions are preserved during de-identification by default. If unspecified, all extensions are removed during de-identification by default.
type KeepExtensionsConfigResponse struct {
}

// The behavior for handling FHIR extensions that aren't otherwise specified for de-identification. If provided, all extensions are preserved during de-identification by default. If unspecified, all extensions are removed during de-identification by default.
type KeepExtensionsConfigResponseOutput struct{ *pulumi.OutputState }

func (KeepExtensionsConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KeepExtensionsConfigResponse)(nil)).Elem()
}

func (o KeepExtensionsConfigResponseOutput) ToKeepExtensionsConfigResponseOutput() KeepExtensionsConfigResponseOutput {
	return o
}

func (o KeepExtensionsConfigResponseOutput) ToKeepExtensionsConfigResponseOutputWithContext(ctx context.Context) KeepExtensionsConfigResponseOutput {
	return o
}

// Keep field unchanged.
type KeepField struct {
}

// KeepFieldInput is an input type that accepts KeepFieldArgs and KeepFieldOutput values.
// You can construct a concrete instance of `KeepFieldInput` via:
//
//	KeepFieldArgs{...}
type KeepFieldInput interface {
	pulumi.Input

	ToKeepFieldOutput() KeepFieldOutput
	ToKeepFieldOutputWithContext(context.Context) KeepFieldOutput
}

// Keep field unchanged.
type KeepFieldArgs struct {
}

func (KeepFieldArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KeepField)(nil)).Elem()
}

func (i KeepFieldArgs) ToKeepFieldOutput() KeepFieldOutput {
	return i.ToKeepFieldOutputWithContext(context.Background())
}

func (i KeepFieldArgs) ToKeepFieldOutputWithContext(ctx context.Context) KeepFieldOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeepFieldOutput)
}

func (i KeepFieldArgs) ToKeepFieldPtrOutput() KeepFieldPtrOutput {
	return i.ToKeepFieldPtrOutputWithContext(context.Background())
}

func (i KeepFieldArgs) ToKeepFieldPtrOutputWithContext(ctx context.Context) KeepFieldPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeepFieldOutput).ToKeepFieldPtrOutputWithContext(ctx)
}

// KeepFieldPtrInput is an input type that accepts KeepFieldArgs, KeepFieldPtr and KeepFieldPtrOutput values.
// You can construct a concrete instance of `KeepFieldPtrInput` via:
//
//	        KeepFieldArgs{...}
//
//	or:
//
//	        nil
type KeepFieldPtrInput interface {
	pulumi.Input

	ToKeepFieldPtrOutput() KeepFieldPtrOutput
	ToKeepFieldPtrOutputWithContext(context.Context) KeepFieldPtrOutput
}

type keepFieldPtrType KeepFieldArgs

func KeepFieldPtr(v *KeepFieldArgs) KeepFieldPtrInput {
	return (*keepFieldPtrType)(v)
}

func (*keepFieldPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KeepField)(nil)).Elem()
}

func (i *keepFieldPtrType) ToKeepFieldPtrOutput() KeepFieldPtrOutput {
	return i.ToKeepFieldPtrOutputWithContext(context.Background())
}

func (i *keepFieldPtrType) ToKeepFieldPtrOutputWithContext(ctx context.Context) KeepFieldPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeepFieldPtrOutput)
}

// Keep field unchanged.
type KeepFieldOutput struct{ *pulumi.OutputState }

func (KeepFieldOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KeepField)(nil)).Elem()
}

func (o KeepFieldOutput) ToKeepFieldOutput() KeepFieldOutput {
	return o
}

func (o KeepFieldOutput) ToKeepFieldOutputWithContext(ctx context.Context) KeepFieldOutput {
	return o
}

func (o KeepFieldOutput) ToKeepFieldPtrOutput() KeepFieldPtrOutput {
	return o.ToKeepFieldPtrOutputWithContext(context.Background())
}

func (o KeepFieldOutput) ToKeepFieldPtrOutputWithContext(ctx context.Context) KeepFieldPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KeepField) *KeepField {
		return &v
	}).(KeepFieldPtrOutput)
}

type KeepFieldPtrOutput struct{ *pulumi.OutputState }

func (KeepFieldPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KeepField)(nil)).Elem()
}

func (o KeepFieldPtrOutput) ToKeepFieldPtrOutput() KeepFieldPtrOutput {
	return o
}

func (o KeepFieldPtrOutput) ToKeepFieldPtrOutputWithContext(ctx context.Context) KeepFieldPtrOutput {
	return o
}

func (o KeepFieldPtrOutput) Elem() KeepFieldOutput {
	return o.ApplyT(func(v *KeepField) KeepField {
		if v != nil {
			return *v
		}
		var ret KeepField
		return ret
	}).(KeepFieldOutput)
}

// Keep field unchanged.
type KeepFieldResponse struct {
}

// Keep field unchanged.
type KeepFieldResponseOutput struct{ *pulumi.OutputState }

func (KeepFieldResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KeepFieldResponse)(nil)).Elem()
}

func (o KeepFieldResponseOutput) ToKeepFieldResponseOutput() KeepFieldResponseOutput {
	return o
}

func (o KeepFieldResponseOutput) ToKeepFieldResponseOutputWithContext(ctx context.Context) KeepFieldResponseOutput {
	return o
}

// Keep tag unchanged.
type KeepTag struct {
}

// KeepTagInput is an input type that accepts KeepTagArgs and KeepTagOutput values.
// You can construct a concrete instance of `KeepTagInput` via:
//
//	KeepTagArgs{...}
type KeepTagInput interface {
	pulumi.Input

	ToKeepTagOutput() KeepTagOutput
	ToKeepTagOutputWithContext(context.Context) KeepTagOutput
}

// Keep tag unchanged.
type KeepTagArgs struct {
}

func (KeepTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KeepTag)(nil)).Elem()
}

func (i KeepTagArgs) ToKeepTagOutput() KeepTagOutput {
	return i.ToKeepTagOutputWithContext(context.Background())
}

func (i KeepTagArgs) ToKeepTagOutputWithContext(ctx context.Context) KeepTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeepTagOutput)
}

func (i KeepTagArgs) ToKeepTagPtrOutput() KeepTagPtrOutput {
	return i.ToKeepTagPtrOutputWithContext(context.Background())
}

func (i KeepTagArgs) ToKeepTagPtrOutputWithContext(ctx context.Context) KeepTagPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeepTagOutput).ToKeepTagPtrOutputWithContext(ctx)
}

// KeepTagPtrInput is an input type that accepts KeepTagArgs, KeepTagPtr and KeepTagPtrOutput values.
// You can construct a concrete instance of `KeepTagPtrInput` via:
//
//	        KeepTagArgs{...}
//
//	or:
//
//	        nil
type KeepTagPtrInput interface {
	pulumi.Input

	ToKeepTagPtrOutput() KeepTagPtrOutput
	ToKeepTagPtrOutputWithContext(context.Context) KeepTagPtrOutput
}

type keepTagPtrType KeepTagArgs

func KeepTagPtr(v *KeepTagArgs) KeepTagPtrInput {
	return (*keepTagPtrType)(v)
}

func (*keepTagPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KeepTag)(nil)).Elem()
}

func (i *keepTagPtrType) ToKeepTagPtrOutput() KeepTagPtrOutput {
	return i.ToKeepTagPtrOutputWithContext(context.Background())
}

func (i *keepTagPtrType) ToKeepTagPtrOutputWithContext(ctx context.Context) KeepTagPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeepTagPtrOutput)
}

// Keep tag unchanged.
type KeepTagOutput struct{ *pulumi.OutputState }

func (KeepTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KeepTag)(nil)).Elem()
}

func (o KeepTagOutput) ToKeepTagOutput() KeepTagOutput {
	return o
}

func (o KeepTagOutput) ToKeepTagOutputWithContext(ctx context.Context) KeepTagOutput {
	return o
}

func (o KeepTagOutput) ToKeepTagPtrOutput() KeepTagPtrOutput {
	return o.ToKeepTagPtrOutputWithContext(context.Background())
}

func (o KeepTagOutput) ToKeepTagPtrOutputWithContext(ctx context.Context) KeepTagPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KeepTag) *KeepTag {
		return &v
	}).(KeepTagPtrOutput)
}

type KeepTagPtrOutput struct{ *pulumi.OutputState }

func (KeepTagPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KeepTag)(nil)).Elem()
}

func (o KeepTagPtrOutput) ToKeepTagPtrOutput() KeepTagPtrOutput {
	return o
}

func (o KeepTagPtrOutput) ToKeepTagPtrOutputWithContext(ctx context.Context) KeepTagPtrOutput {
	return o
}

func (o KeepTagPtrOutput) Elem() KeepTagOutput {
	return o.ApplyT(func(v *KeepTag) KeepTag {
		if v != nil {
			return *v
		}
		var ret KeepTag
		return ret
	}).(KeepTagOutput)
}

// Keep tag unchanged.
type KeepTagResponse struct {
}

// Keep tag unchanged.
type KeepTagResponseOutput struct{ *pulumi.OutputState }

func (KeepTagResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KeepTagResponse)(nil)).Elem()
}

func (o KeepTagResponseOutput) ToKeepTagResponseOutput() KeepTagResponseOutput {
	return o
}

func (o KeepTagResponseOutput) ToKeepTagResponseOutputWithContext(ctx context.Context) KeepTagResponseOutput {
	return o
}

// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. The key must grant the Cloud IAM permission `cloudkms.cryptoKeyVersions.useToDecrypt` to the project's Cloud Healthcare Service Agent service account. For more information, see [Creating a wrapped key] (https://cloud.google.com/dlp/docs/create-wrapped-key).
type KmsWrappedCryptoKey struct {
	// The resource name of the KMS CryptoKey to use for unwrapping. For example, `projects/{project_id}/locations/{location_id}/keyRings/{keyring}/cryptoKeys/{key}`.
	CryptoKey string `pulumi:"cryptoKey"`
	// The wrapped data crypto key.
	WrappedKey string `pulumi:"wrappedKey"`
}

// KmsWrappedCryptoKeyInput is an input type that accepts KmsWrappedCryptoKeyArgs and KmsWrappedCryptoKeyOutput values.
// You can construct a concrete instance of `KmsWrappedCryptoKeyInput` via:
//
//	KmsWrappedCryptoKeyArgs{...}
type KmsWrappedCryptoKeyInput interface {
	pulumi.Input

	ToKmsWrappedCryptoKeyOutput() KmsWrappedCryptoKeyOutput
	ToKmsWrappedCryptoKeyOutputWithContext(context.Context) KmsWrappedCryptoKeyOutput
}

// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. The key must grant the Cloud IAM permission `cloudkms.cryptoKeyVersions.useToDecrypt` to the project's Cloud Healthcare Service Agent service account. For more information, see [Creating a wrapped key] (https://cloud.google.com/dlp/docs/create-wrapped-key).
type KmsWrappedCryptoKeyArgs struct {
	// The resource name of the KMS CryptoKey to use for unwrapping. For example, `projects/{project_id}/locations/{location_id}/keyRings/{keyring}/cryptoKeys/{key}`.
	CryptoKey pulumi.StringInput `pulumi:"cryptoKey"`
	// The wrapped data crypto key.
	WrappedKey pulumi.StringInput `pulumi:"wrappedKey"`
}

func (KmsWrappedCryptoKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KmsWrappedCryptoKey)(nil)).Elem()
}

func (i KmsWrappedCryptoKeyArgs) ToKmsWrappedCryptoKeyOutput() KmsWrappedCryptoKeyOutput {
	return i.ToKmsWrappedCryptoKeyOutputWithContext(context.Background())
}

func (i KmsWrappedCryptoKeyArgs) ToKmsWrappedCryptoKeyOutputWithContext(ctx context.Context) KmsWrappedCryptoKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KmsWrappedCryptoKeyOutput)
}

func (i KmsWrappedCryptoKeyArgs) ToKmsWrappedCryptoKeyPtrOutput() KmsWrappedCryptoKeyPtrOutput {
	return i.ToKmsWrappedCryptoKeyPtrOutputWithContext(context.Background())
}

func (i KmsWrappedCryptoKeyArgs) ToKmsWrappedCryptoKeyPtrOutputWithContext(ctx context.Context) KmsWrappedCryptoKeyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KmsWrappedCryptoKeyOutput).ToKmsWrappedCryptoKeyPtrOutputWithContext(ctx)
}

// KmsWrappedCryptoKeyPtrInput is an input type that accepts KmsWrappedCryptoKeyArgs, KmsWrappedCryptoKeyPtr and KmsWrappedCryptoKeyPtrOutput values.
// You can construct a concrete instance of `KmsWrappedCryptoKeyPtrInput` via:
//
//	        KmsWrappedCryptoKeyArgs{...}
//
//	or:
//
//	        nil
type KmsWrappedCryptoKeyPtrInput interface {
	pulumi.Input

	ToKmsWrappedCryptoKeyPtrOutput() KmsWrappedCryptoKeyPtrOutput
	ToKmsWrappedCryptoKeyPtrOutputWithContext(context.Context) KmsWrappedCryptoKeyPtrOutput
}

type kmsWrappedCryptoKeyPtrType KmsWrappedCryptoKeyArgs

func KmsWrappedCryptoKeyPtr(v *KmsWrappedCryptoKeyArgs) KmsWrappedCryptoKeyPtrInput {
	return (*kmsWrappedCryptoKeyPtrType)(v)
}

func (*kmsWrappedCryptoKeyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KmsWrappedCryptoKey)(nil)).Elem()
}

func (i *kmsWrappedCryptoKeyPtrType) ToKmsWrappedCryptoKeyPtrOutput() KmsWrappedCryptoKeyPtrOutput {
	return i.ToKmsWrappedCryptoKeyPtrOutputWithContext(context.Background())
}

func (i *kmsWrappedCryptoKeyPtrType) ToKmsWrappedCryptoKeyPtrOutputWithContext(ctx context.Context) KmsWrappedCryptoKeyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KmsWrappedCryptoKeyPtrOutput)
}

// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. The key must grant the Cloud IAM permission `cloudkms.cryptoKeyVersions.useToDecrypt` to the project's Cloud Healthcare Service Agent service account. For more information, see [Creating a wrapped key] (https://cloud.google.com/dlp/docs/create-wrapped-key).
type KmsWrappedCryptoKeyOutput struct{ *pulumi.OutputState }

func (KmsWrappedCryptoKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KmsWrappedCryptoKey)(nil)).Elem()
}

func (o KmsWrappedCryptoKeyOutput) ToKmsWrappedCryptoKeyOutput() KmsWrappedCryptoKeyOutput {
	return o
}

func (o KmsWrappedCryptoKeyOutput) ToKmsWrappedCryptoKeyOutputWithContext(ctx context.Context) KmsWrappedCryptoKeyOutput {
	return o
}

func (o KmsWrappedCryptoKeyOutput) ToKmsWrappedCryptoKeyPtrOutput() KmsWrappedCryptoKeyPtrOutput {
	return o.ToKmsWrappedCryptoKeyPtrOutputWithContext(context.Background())
}

func (o KmsWrappedCryptoKeyOutput) ToKmsWrappedCryptoKeyPtrOutputWithContext(ctx context.Context) KmsWrappedCryptoKeyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KmsWrappedCryptoKey) *KmsWrappedCryptoKey {
		return &v
	}).(KmsWrappedCryptoKeyPtrOutput)
}

// The resource name of the KMS CryptoKey to use for unwrapping. For example, `projects/{project_id}/locations/{location_id}/keyRings/{keyring}/cryptoKeys/{key}`.
func (o KmsWrappedCryptoKeyOutput) CryptoKey() pulumi.StringOutput {
	return o.ApplyT(func(v KmsWrappedCryptoKey) string { return v.CryptoKey }).(pulumi.StringOutput)
}

// The wrapped data crypto key.
func (o KmsWrappedCryptoKeyOutput) WrappedKey() pulumi.StringOutput {
	return o.ApplyT(func(v KmsWrappedCryptoKey) string { return v.WrappedKey }).(pulumi.StringOutput)
}

type KmsWrappedCryptoKeyPtrOutput struct{ *pulumi.OutputState }

func (KmsWrappedCryptoKeyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KmsWrappedCryptoKey)(nil)).Elem()
}

func (o KmsWrappedCryptoKeyPtrOutput) ToKmsWrappedCryptoKeyPtrOutput() KmsWrappedCryptoKeyPtrOutput {
	return o
}

func (o KmsWrappedCryptoKeyPtrOutput) ToKmsWrappedCryptoKeyPtrOutputWithContext(ctx context.Context) KmsWrappedCryptoKeyPtrOutput {
	return o
}

func (o KmsWrappedCryptoKeyPtrOutput) Elem() KmsWrappedCryptoKeyOutput {
	return o.ApplyT(func(v *KmsWrappedCryptoKey) KmsWrappedCryptoKey {
		if v != nil {
			return *v
		}
		var ret KmsWrappedCryptoKey
		return ret
	}).(KmsWrappedCryptoKeyOutput)
}

// The resource name of the KMS CryptoKey to use for unwrapping. For example, `projects/{project_id}/locations/{location_id}/keyRings/{keyring}/cryptoKeys/{key}`.
func (o KmsWrappedCryptoKeyPtrOutput) CryptoKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KmsWrappedCryptoKey) *string {
		if v == nil {
			return nil
		}
		return &v.CryptoKey
	}).(pulumi.StringPtrOutput)
}

// The wrapped data crypto key.
func (o KmsWrappedCryptoKeyPtrOutput) WrappedKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KmsWrappedCryptoKey) *string {
		if v == nil {
			return nil
		}
		return &v.WrappedKey
	}).(pulumi.StringPtrOutput)
}

// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. The key must grant the Cloud IAM permission `cloudkms.cryptoKeyVersions.useToDecrypt` to the project's Cloud Healthcare Service Agent service account. For more information, see [Creating a wrapped key] (https://cloud.google.com/dlp/docs/create-wrapped-key).
type KmsWrappedCryptoKeyResponse struct {
	// The resource name of the KMS CryptoKey to use for unwrapping. For example, `projects/{project_id}/locations/{location_id}/keyRings/{keyring}/cryptoKeys/{key}`.
	CryptoKey string `pulumi:"cryptoKey"`
	// The wrapped data crypto key.
	WrappedKey string `pulumi:"wrappedKey"`
}

// Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. The key must grant the Cloud IAM permission `cloudkms.cryptoKeyVersions.useToDecrypt` to the project's Cloud Healthcare Service Agent service account. For more information, see [Creating a wrapped key] (https://cloud.google.com/dlp/docs/create-wrapped-key).
type KmsWrappedCryptoKeyResponseOutput struct{ *pulumi.OutputState }

func (KmsWrappedCryptoKeyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KmsWrappedCryptoKeyResponse)(nil)).Elem()
}

func (o KmsWrappedCryptoKeyResponseOutput) ToKmsWrappedCryptoKeyResponseOutput() KmsWrappedCryptoKeyResponseOutput {
	return o
}

func (o KmsWrappedCryptoKeyResponseOutput) ToKmsWrappedCryptoKeyResponseOutputWithContext(ctx context.Context) KmsWrappedCryptoKeyResponseOutput {
	return o
}

// The resource name of the KMS CryptoKey to use for unwrapping. For example, `projects/{project_id}/locations/{location_id}/keyRings/{keyring}/cryptoKeys/{key}`.
func (o KmsWrappedCryptoKeyResponseOutput) CryptoKey() pulumi.StringOutput {
	return o.ApplyT(func(v KmsWrappedCryptoKeyResponse) string { return v.CryptoKey }).(pulumi.StringOutput)
}

// The wrapped data crypto key.
func (o KmsWrappedCryptoKeyResponseOutput) WrappedKey() pulumi.StringOutput {
	return o.ApplyT(func(v KmsWrappedCryptoKeyResponse) string { return v.WrappedKey }).(pulumi.StringOutput)
}

// Specifies where to send notifications upon changes to a data store.
type NotificationConfig struct {
	// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. PubsubMessage.Data contains the resource name. PubsubMessage.MessageId is the ID of this message. It is guaranteed to be unique within the topic. PubsubMessage.PublishTime is the time at which the message was published. Notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)). If the number of errors exceeds a certain rate, some aren't submitted. Note that not all operations trigger notifications, see [Configuring Pub/Sub notifications](https://cloud.google.com/healthcare/docs/how-tos/pubsub) for specific details.
	PubsubTopic *string `pulumi:"pubsubTopic"`
	// Indicates whether or not to send Pub/Sub notifications on bulk import. Only supported for DICOM imports.
	SendForBulkImport *bool `pulumi:"sendForBulkImport"`
}

// NotificationConfigInput is an input type that accepts NotificationConfigArgs and NotificationConfigOutput values.
// You can construct a concrete instance of `NotificationConfigInput` via:
//
//	NotificationConfigArgs{...}
type NotificationConfigInput interface {
	pulumi.Input

	ToNotificationConfigOutput() NotificationConfigOutput
	ToNotificationConfigOutputWithContext(context.Context) NotificationConfigOutput
}

// Specifies where to send notifications upon changes to a data store.
type NotificationConfigArgs struct {
	// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. PubsubMessage.Data contains the resource name. PubsubMessage.MessageId is the ID of this message. It is guaranteed to be unique within the topic. PubsubMessage.PublishTime is the time at which the message was published. Notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)). If the number of errors exceeds a certain rate, some aren't submitted. Note that not all operations trigger notifications, see [Configuring Pub/Sub notifications](https://cloud.google.com/healthcare/docs/how-tos/pubsub) for specific details.
	PubsubTopic pulumi.StringPtrInput `pulumi:"pubsubTopic"`
	// Indicates whether or not to send Pub/Sub notifications on bulk import. Only supported for DICOM imports.
	SendForBulkImport pulumi.BoolPtrInput `pulumi:"sendForBulkImport"`
}

func (NotificationConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NotificationConfig)(nil)).Elem()
}

func (i NotificationConfigArgs) ToNotificationConfigOutput() NotificationConfigOutput {
	return i.ToNotificationConfigOutputWithContext(context.Background())
}

func (i NotificationConfigArgs) ToNotificationConfigOutputWithContext(ctx context.Context) NotificationConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationConfigOutput)
}

func (i NotificationConfigArgs) ToNotificationConfigPtrOutput() NotificationConfigPtrOutput {
	return i.ToNotificationConfigPtrOutputWithContext(context.Background())
}

func (i NotificationConfigArgs) ToNotificationConfigPtrOutputWithContext(ctx context.Context) NotificationConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationConfigOutput).ToNotificationConfigPtrOutputWithContext(ctx)
}

// NotificationConfigPtrInput is an input type that accepts NotificationConfigArgs, NotificationConfigPtr and NotificationConfigPtrOutput values.
// You can construct a concrete instance of `NotificationConfigPtrInput` via:
//
//	        NotificationConfigArgs{...}
//
//	or:
//
//	        nil
type NotificationConfigPtrInput interface {
	pulumi.Input

	ToNotificationConfigPtrOutput() NotificationConfigPtrOutput
	ToNotificationConfigPtrOutputWithContext(context.Context) NotificationConfigPtrOutput
}

type notificationConfigPtrType NotificationConfigArgs

func NotificationConfigPtr(v *NotificationConfigArgs) NotificationConfigPtrInput {
	return (*notificationConfigPtrType)(v)
}

func (*notificationConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NotificationConfig)(nil)).Elem()
}

func (i *notificationConfigPtrType) ToNotificationConfigPtrOutput() NotificationConfigPtrOutput {
	return i.ToNotificationConfigPtrOutputWithContext(context.Background())
}

func (i *notificationConfigPtrType) ToNotificationConfigPtrOutputWithContext(ctx context.Context) NotificationConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NotificationConfigPtrOutput)
}

// Specifies where to send notifications upon changes to a data store.
type NotificationConfigOutput struct{ *pulumi.OutputState }

func (NotificationConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NotificationConfig)(nil)).Elem()
}

func (o NotificationConfigOutput) ToNotificationConfigOutput() NotificationConfigOutput {
	return o
}

func (o NotificationConfigOutput) ToNotificationConfigOutputWithContext(ctx context.Context) NotificationConfigOutput {
	return o
}

func (o NotificationConfigOutput) ToNotificationConfigPtrOutput() NotificationConfigPtrOutput {
	return o.ToNotificationConfigPtrOutputWithContext(context.Background())
}

func (o NotificationConfigOutput) ToNotificationConfigPtrOutputWithContext(ctx context.Context) NotificationConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v NotificationConfig) *NotificationConfig {
		return &v
	}).(NotificationConfigPtrOutput)
}

// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. PubsubMessage.Data contains the resource name. PubsubMessage.MessageId is the ID of this message. It is guaranteed to be unique within the topic. PubsubMessage.PublishTime is the time at which the message was published. Notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)). If the number of errors exceeds a certain rate, some aren't submitted. Note that not all operations trigger notifications, see [Configuring Pub/Sub notifications](https://cloud.google.com/healthcare/docs/how-tos/pubsub) for specific details.
func (o NotificationConfigOutput) PubsubTopic() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NotificationConfig) *string { return v.PubsubTopic }).(pulumi.StringPtrOutput)
}

// Indicates whether or not to send Pub/Sub notifications on bulk import. Only supported for DICOM imports.
func (o NotificationConfigOutput) SendForBulkImport() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v NotificationConfig) *bool { return v.SendForBulkImport }).(pulumi.BoolPtrOutput)
}

type NotificationConfigPtrOutput struct{ *pulumi.OutputState }

func (NotificationConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NotificationConfig)(nil)).Elem()
}

func (o NotificationConfigPtrOutput) ToNotificationConfigPtrOutput() NotificationConfigPtrOutput {
	return o
}

func (o NotificationConfigPtrOutput) ToNotificationConfigPtrOutputWithContext(ctx context.Context) NotificationConfigPtrOutput {
	return o
}

func (o NotificationConfigPtrOutput) Elem() NotificationConfigOutput {
	return o.ApplyT(func(v *NotificationConfig) NotificationConfig {
		if v != nil {
			return *v
		}
		var ret NotificationConfig
		return ret
	}).(NotificationConfigOutput)
}

// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. PubsubMessage.Data contains the resource name. PubsubMessage.MessageId is the ID of this message. It is guaranteed to be unique within the topic. PubsubMessage.PublishTime is the time at which the message was published. Notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)). If the number of errors exceeds a certain rate, some aren't submitted. Note that not all operations trigger notifications, see [Configuring Pub/Sub notifications](https://cloud.google.com/healthcare/docs/how-tos/pubsub) for specific details.
func (o NotificationConfigPtrOutput) PubsubTopic() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NotificationConfig) *string {
		if v == nil {
			return nil
		}
		return v.PubsubTopic
	}).(pulumi.StringPtrOutput)
}

// Indicates whether or not to send Pub/Sub notifications on bulk import. Only supported for DICOM imports.
func (o NotificationConfigPtrOutput) SendForBulkImport() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *NotificationConfig) *bool {
		if v == nil {
			return nil
		}
		return v.SendForBulkImport
	}).(pulumi.BoolPtrOutput)
}

// Specifies where to send notifications upon changes to a data store.
type NotificationConfigResponse struct {
	// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. PubsubMessage.Data contains the resource name. PubsubMessage.MessageId is the ID of this message. It is guaranteed to be unique within the topic. PubsubMessage.PublishTime is the time at which the message was published. Notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)). If the number of errors exceeds a certain rate, some aren't submitted. Note that not all operations trigger notifications, see [Configuring Pub/Sub notifications](https://cloud.google.com/healthcare/docs/how-tos/pubsub) for specific details.
	PubsubTopic string `pulumi:"pubsubTopic"`
	// Indicates whether or not to send Pub/Sub notifications on bulk import. Only supported for DICOM imports.
	SendForBulkImport bool `pulumi:"sendForBulkImport"`
}

// Specifies where to send notifications upon changes to a data store.
type NotificationConfigResponseOutput struct{ *pulumi.OutputState }

func (NotificationConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NotificationConfigResponse)(nil)).Elem()
}

func (o NotificationConfigResponseOutput) ToNotificationConfigResponseOutput() NotificationConfigResponseOutput {
	return o
}

func (o NotificationConfigResponseOutput) ToNotificationConfigResponseOutputWithContext(ctx context.Context) NotificationConfigResponseOutput {
	return o
}

// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that notifications of changes are published on. Supplied by the client. PubsubMessage.Data contains the resource name. PubsubMessage.MessageId is the ID of this message. It is guaranteed to be unique within the topic. PubsubMessage.PublishTime is the time at which the message was published. Notifications are only sent if the topic is non-empty. [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be scoped to a project. Cloud Healthcare API service account must have publisher permissions on the given Pub/Sub topic. Not having adequate permissions causes the calls that send notifications to fail. If a notification can't be published to Pub/Sub, errors are logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)). If the number of errors exceeds a certain rate, some aren't submitted. Note that not all operations trigger notifications, see [Configuring Pub/Sub notifications](https://cloud.google.com/healthcare/docs/how-tos/pubsub) for specific details.
func (o NotificationConfigResponseOutput) PubsubTopic() pulumi.StringOutput {
	return o.ApplyT(func(v NotificationConfigResponse) string { return v.PubsubTopic }).(pulumi.StringOutput)
}

// Indicates whether or not to send Pub/Sub notifications on bulk import. Only supported for DICOM imports.
func (o NotificationConfigResponseOutput) SendForBulkImport() pulumi.BoolOutput {
	return o.ApplyT(func(v NotificationConfigResponse) bool { return v.SendForBulkImport }).(pulumi.BoolOutput)
}

// Specifies additional options to apply to the base profile.
type Options struct {
	// Set Clean Descriptors Option.
	CleanDescriptors *CleanDescriptorsOption `pulumi:"cleanDescriptors"`
	// Apply `Action.clean_image` to [`PixelData`](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part06/chapter_6.html) as configured.
	CleanImage *ImageConfig `pulumi:"cleanImage"`
	// Set `Action` for [`StudyInstanceUID`, `SeriesInstanceUID`, `SOPInstanceUID`, and `MediaStorageSOPInstanceUID`](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part06/chapter_6.html).
	PrimaryIds *OptionsPrimaryIds `pulumi:"primaryIds"`
}

// OptionsInput is an input type that accepts OptionsArgs and OptionsOutput values.
// You can construct a concrete instance of `OptionsInput` via:
//
//	OptionsArgs{...}
type OptionsInput interface {
	pulumi.Input

	ToOptionsOutput() OptionsOutput
	ToOptionsOutputWithContext(context.Context) OptionsOutput
}

// Specifies additional options to apply to the base profile.
type OptionsArgs struct {
	// Set Clean Descriptors Option.
	CleanDescriptors CleanDescriptorsOptionPtrInput `pulumi:"cleanDescriptors"`
	// Apply `Action.clean_image` to [`PixelData`](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part06/chapter_6.html) as configured.
	CleanImage ImageConfigPtrInput `pulumi:"cleanImage"`
	// Set `Action` for [`StudyInstanceUID`, `SeriesInstanceUID`, `SOPInstanceUID`, and `MediaStorageSOPInstanceUID`](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part06/chapter_6.html).
	PrimaryIds OptionsPrimaryIdsPtrInput `pulumi:"primaryIds"`
}

func (OptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Options)(nil)).Elem()
}

func (i OptionsArgs) ToOptionsOutput() OptionsOutput {
	return i.ToOptionsOutputWithContext(context.Background())
}

func (i OptionsArgs) ToOptionsOutputWithContext(ctx context.Context) OptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OptionsOutput)
}

func (i OptionsArgs) ToOptionsPtrOutput() OptionsPtrOutput {
	return i.ToOptionsPtrOutputWithContext(context.Background())
}

func (i OptionsArgs) ToOptionsPtrOutputWithContext(ctx context.Context) OptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OptionsOutput).ToOptionsPtrOutputWithContext(ctx)
}

// OptionsPtrInput is an input type that accepts OptionsArgs, OptionsPtr and OptionsPtrOutput values.
// You can construct a concrete instance of `OptionsPtrInput` via:
//
//	        OptionsArgs{...}
//
//	or:
//
//	        nil
type OptionsPtrInput interface {
	pulumi.Input

	ToOptionsPtrOutput() OptionsPtrOutput
	ToOptionsPtrOutputWithContext(context.Context) OptionsPtrOutput
}

type optionsPtrType OptionsArgs

func OptionsPtr(v *OptionsArgs) OptionsPtrInput {
	return (*optionsPtrType)(v)
}

func (*optionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Options)(nil)).Elem()
}

func (i *optionsPtrType) ToOptionsPtrOutput() OptionsPtrOutput {
	return i.ToOptionsPtrOutputWithContext(context.Background())
}

func (i *optionsPtrType) ToOptionsPtrOutputWithContext(ctx context.Context) OptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OptionsPtrOutput)
}

// Specifies additional options to apply to the base profile.
type OptionsOutput struct{ *pulumi.OutputState }

func (OptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Options)(nil)).Elem()
}

func (o OptionsOutput) ToOptionsOutput() OptionsOutput {
	return o
}

func (o OptionsOutput) ToOptionsOutputWithContext(ctx context.Context) OptionsOutput {
	return o
}

func (o OptionsOutput) ToOptionsPtrOutput() OptionsPtrOutput {
	return o.ToOptionsPtrOutputWithContext(context.Background())
}

func (o OptionsOutput) ToOptionsPtrOutputWithContext(ctx context.Context) OptionsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Options) *Options {
		return &v
	}).(OptionsPtrOutput)
}

// Set Clean Descriptors Option.
func (o OptionsOutput) CleanDescriptors() CleanDescriptorsOptionPtrOutput {
	return o.ApplyT(func(v Options) *CleanDescriptorsOption { return v.CleanDescriptors }).(CleanDescriptorsOptionPtrOutput)
}

// Apply `Action.clean_image` to [`PixelData`](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part06/chapter_6.html) as configured.
func (o OptionsOutput) CleanImage() ImageConfigPtrOutput {
	return o.ApplyT(func(v Options) *ImageConfig { return v.CleanImage }).(ImageConfigPtrOutput)
}

// Set `Action` for [`StudyInstanceUID`, `SeriesInstanceUID`, `SOPInstanceUID`, and `MediaStorageSOPInstanceUID`](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part06/chapter_6.html).
func (o OptionsOutput) PrimaryIds() OptionsPrimaryIdsPtrOutput {
	return o.ApplyT(func(v Options) *OptionsPrimaryIds { return v.PrimaryIds }).(OptionsPrimaryIdsPtrOutput)
}

type OptionsPtrOutput struct{ *pulumi.OutputState }

func (OptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Options)(nil)).Elem()
}

func (o OptionsPtrOutput) ToOptionsPtrOutput() OptionsPtrOutput {
	return o
}

func (o OptionsPtrOutput) ToOptionsPtrOutputWithContext(ctx context.Context) OptionsPtrOutput {
	return o
}

func (o OptionsPtrOutput) Elem() OptionsOutput {
	return o.ApplyT(func(v *Options) Options {
		if v != nil {
			return *v
		}
		var ret Options
		return ret
	}).(OptionsOutput)
}

// Set Clean Descriptors Option.
func (o OptionsPtrOutput) CleanDescriptors() CleanDescriptorsOptionPtrOutput {
	return o.ApplyT(func(v *Options) *CleanDescriptorsOption {
		if v == nil {
			return nil
		}
		return v.CleanDescriptors
	}).(CleanDescriptorsOptionPtrOutput)
}

// Apply `Action.clean_image` to [`PixelData`](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part06/chapter_6.html) as configured.
func (o OptionsPtrOutput) CleanImage() ImageConfigPtrOutput {
	return o.ApplyT(func(v *Options) *ImageConfig {
		if v == nil {
			return nil
		}
		return v.CleanImage
	}).(ImageConfigPtrOutput)
}

// Set `Action` for [`StudyInstanceUID`, `SeriesInstanceUID`, `SOPInstanceUID`, and `MediaStorageSOPInstanceUID`](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part06/chapter_6.html).
func (o OptionsPtrOutput) PrimaryIds() OptionsPrimaryIdsPtrOutput {
	return o.ApplyT(func(v *Options) *OptionsPrimaryIds {
		if v == nil {
			return nil
		}
		return v.PrimaryIds
	}).(OptionsPrimaryIdsPtrOutput)
}

// Specifies additional options to apply to the base profile.
type OptionsResponse struct {
	// Set Clean Descriptors Option.
	CleanDescriptors CleanDescriptorsOptionResponse `pulumi:"cleanDescriptors"`
	// Apply `Action.clean_image` to [`PixelData`](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part06/chapter_6.html) as configured.
	CleanImage ImageConfigResponse `pulumi:"cleanImage"`
	// Set `Action` for [`StudyInstanceUID`, `SeriesInstanceUID`, `SOPInstanceUID`, and `MediaStorageSOPInstanceUID`](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part06/chapter_6.html).
	PrimaryIds string `pulumi:"primaryIds"`
}

// Specifies additional options to apply to the base profile.
type OptionsResponseOutput struct{ *pulumi.OutputState }

func (OptionsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OptionsResponse)(nil)).Elem()
}

func (o OptionsResponseOutput) ToOptionsResponseOutput() OptionsResponseOutput {
	return o
}

func (o OptionsResponseOutput) ToOptionsResponseOutputWithContext(ctx context.Context) OptionsResponseOutput {
	return o
}

// Set Clean Descriptors Option.
func (o OptionsResponseOutput) CleanDescriptors() CleanDescriptorsOptionResponseOutput {
	return o.ApplyT(func(v OptionsResponse) CleanDescriptorsOptionResponse { return v.CleanDescriptors }).(CleanDescriptorsOptionResponseOutput)
}

// Apply `Action.clean_image` to [`PixelData`](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part06/chapter_6.html) as configured.
func (o OptionsResponseOutput) CleanImage() ImageConfigResponseOutput {
	return o.ApplyT(func(v OptionsResponse) ImageConfigResponse { return v.CleanImage }).(ImageConfigResponseOutput)
}

// Set `Action` for [`StudyInstanceUID`, `SeriesInstanceUID`, `SOPInstanceUID`, and `MediaStorageSOPInstanceUID`](http://dicom.nema.org/medical/dicom/2018e/output/chtml/part06/chapter_6.html).
func (o OptionsResponseOutput) PrimaryIds() pulumi.StringOutput {
	return o.ApplyT(func(v OptionsResponse) string { return v.PrimaryIds }).(pulumi.StringOutput)
}

// The content of an HL7v2 message in a structured format.
type ParsedDataResponse struct {
	Segments []SegmentResponse `pulumi:"segments"`
}

// The content of an HL7v2 message in a structured format.
type ParsedDataResponseOutput struct{ *pulumi.OutputState }

func (ParsedDataResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ParsedDataResponse)(nil)).Elem()
}

func (o ParsedDataResponseOutput) ToParsedDataResponseOutput() ParsedDataResponseOutput {
	return o
}

func (o ParsedDataResponseOutput) ToParsedDataResponseOutputWithContext(ctx context.Context) ParsedDataResponseOutput {
	return o
}

func (o ParsedDataResponseOutput) Segments() SegmentResponseArrayOutput {
	return o.ApplyT(func(v ParsedDataResponse) []SegmentResponse { return v.Segments }).(SegmentResponseArrayOutput)
}

// The configuration for the parser. It determines how the server parses the messages.
type ParserConfig struct {
	// Determines whether messages with no header are allowed.
	AllowNullHeader *bool `pulumi:"allowNullHeader"`
	// Schemas used to parse messages in this store, if schematized parsing is desired.
	Schema *SchemaPackage `pulumi:"schema"`
	// Byte(s) to use as the segment terminator. If this is unset, '\r' is used as segment terminator, matching the HL7 version 2 specification.
	SegmentTerminator *string `pulumi:"segmentTerminator"`
	// Immutable. Determines the version of both the default parser to be used when `schema` is not given, as well as the schematized parser used when `schema` is specified. This field is immutable after HL7v2 store creation.
	Version *ParserConfigVersion `pulumi:"version"`
}

// ParserConfigInput is an input type that accepts ParserConfigArgs and ParserConfigOutput values.
// You can construct a concrete instance of `ParserConfigInput` via:
//
//	ParserConfigArgs{...}
type ParserConfigInput interface {
	pulumi.Input

	ToParserConfigOutput() ParserConfigOutput
	ToParserConfigOutputWithContext(context.Context) ParserConfigOutput
}

// The configuration for the parser. It determines how the server parses the messages.
type ParserConfigArgs struct {
	// Determines whether messages with no header are allowed.
	AllowNullHeader pulumi.BoolPtrInput `pulumi:"allowNullHeader"`
	// Schemas used to parse messages in this store, if schematized parsing is desired.
	Schema SchemaPackagePtrInput `pulumi:"schema"`
	// Byte(s) to use as the segment terminator. If this is unset, '\r' is used as segment terminator, matching the HL7 version 2 specification.
	SegmentTerminator pulumi.StringPtrInput `pulumi:"segmentTerminator"`
	// Immutable. Determines the version of both the default parser to be used when `schema` is not given, as well as the schematized parser used when `schema` is specified. This field is immutable after HL7v2 store creation.
	Version ParserConfigVersionPtrInput `pulumi:"version"`
}

func (ParserConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ParserConfig)(nil)).Elem()
}

func (i ParserConfigArgs) ToParserConfigOutput() ParserConfigOutput {
	return i.ToParserConfigOutputWithContext(context.Background())
}

func (i ParserConfigArgs) ToParserConfigOutputWithContext(ctx context.Context) ParserConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ParserConfigOutput)
}

func (i ParserConfigArgs) ToParserConfigPtrOutput() ParserConfigPtrOutput {
	return i.ToParserConfigPtrOutputWithContext(context.Background())
}

func (i ParserConfigArgs) ToParserConfigPtrOutputWithContext(ctx context.Context) ParserConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ParserConfigOutput).ToParserConfigPtrOutputWithContext(ctx)
}

// ParserConfigPtrInput is an input type that accepts ParserConfigArgs, ParserConfigPtr and ParserConfigPtrOutput values.
// You can construct a concrete instance of `ParserConfigPtrInput` via:
//
//	        ParserConfigArgs{...}
//
//	or:
//
//	        nil
type ParserConfigPtrInput interface {
	pulumi.Input

	ToParserConfigPtrOutput() ParserConfigPtrOutput
	ToParserConfigPtrOutputWithContext(context.Context) ParserConfigPtrOutput
}

type parserConfigPtrType ParserConfigArgs

func ParserConfigPtr(v *ParserConfigArgs) ParserConfigPtrInput {
	return (*parserConfigPtrType)(v)
}

func (*parserConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ParserConfig)(nil)).Elem()
}

func (i *parserConfigPtrType) ToParserConfigPtrOutput() ParserConfigPtrOutput {
	return i.ToParserConfigPtrOutputWithContext(context.Background())
}

func (i *parserConfigPtrType) ToParserConfigPtrOutputWithContext(ctx context.Context) ParserConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ParserConfigPtrOutput)
}

// The configuration for the parser. It determines how the server parses the messages.
type ParserConfigOutput struct{ *pulumi.OutputState }

func (ParserConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ParserConfig)(nil)).Elem()
}

func (o ParserConfigOutput) ToParserConfigOutput() ParserConfigOutput {
	return o
}

func (o ParserConfigOutput) ToParserConfigOutputWithContext(ctx context.Context) ParserConfigOutput {
	return o
}

func (o ParserConfigOutput) ToParserConfigPtrOutput() ParserConfigPtrOutput {
	return o.ToParserConfigPtrOutputWithContext(context.Background())
}

func (o ParserConfigOutput) ToParserConfigPtrOutputWithContext(ctx context.Context) ParserConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ParserConfig) *ParserConfig {
		return &v
	}).(ParserConfigPtrOutput)
}

// Determines whether messages with no header are allowed.
func (o ParserConfigOutput) AllowNullHeader() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ParserConfig) *bool { return v.AllowNullHeader }).(pulumi.BoolPtrOutput)
}

// Schemas used to parse messages in this store, if schematized parsing is desired.
func (o ParserConfigOutput) Schema() SchemaPackagePtrOutput {
	return o.ApplyT(func(v ParserConfig) *SchemaPackage { return v.Schema }).(SchemaPackagePtrOutput)
}

// Byte(s) to use as the segment terminator. If this is unset, '\r' is used as segment terminator, matching the HL7 version 2 specification.
func (o ParserConfigOutput) SegmentTerminator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ParserConfig) *string { return v.SegmentTerminator }).(pulumi.StringPtrOutput)
}

// Immutable. Determines the version of both the default parser to be used when `schema` is not given, as well as the schematized parser used when `schema` is specified. This field is immutable after HL7v2 store creation.
func (o ParserConfigOutput) Version() ParserConfigVersionPtrOutput {
	return o.ApplyT(func(v ParserConfig) *ParserConfigVersion { return v.Version }).(ParserConfigVersionPtrOutput)
}

type ParserConfigPtrOutput struct{ *pulumi.OutputState }

func (ParserConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ParserConfig)(nil)).Elem()
}

func (o ParserConfigPtrOutput) ToParserConfigPtrOutput() ParserConfigPtrOutput {
	return o
}

func (o ParserConfigPtrOutput) ToParserConfigPtrOutputWithContext(ctx context.Context) ParserConfigPtrOutput {
	return o
}

func (o ParserConfigPtrOutput) Elem() ParserConfigOutput {
	return o.ApplyT(func(v *ParserConfig) ParserConfig {
		if v != nil {
			return *v
		}
		var ret ParserConfig
		return ret
	}).(ParserConfigOutput)
}

// Determines whether messages with no header are allowed.
func (o ParserConfigPtrOutput) AllowNullHeader() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ParserConfig) *bool {
		if v == nil {
			return nil
		}
		return v.AllowNullHeader
	}).(pulumi.BoolPtrOutput)
}

// Schemas used to parse messages in this store, if schematized parsing is desired.
func (o ParserConfigPtrOutput) Schema() SchemaPackagePtrOutput {
	return o.ApplyT(func(v *ParserConfig) *SchemaPackage {
		if v == nil {
			return nil
		}
		return v.Schema
	}).(SchemaPackagePtrOutput)
}

// Byte(s) to use as the segment terminator. If this is unset, '\r' is used as segment terminator, matching the HL7 version 2 specification.
func (o ParserConfigPtrOutput) SegmentTerminator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ParserConfig) *string {
		if v == nil {
			return nil
		}
		return v.SegmentTerminator
	}).(pulumi.StringPtrOutput)
}

// Immutable. Determines the version of both the default parser to be used when `schema` is not given, as well as the schematized parser used when `schema` is specified. This field is immutable after HL7v2 store creation.
func (o ParserConfigPtrOutput) Version() ParserConfigVersionPtrOutput {
	return o.ApplyT(func(v *ParserConfig) *ParserConfigVersion {
		if v == nil {
			return nil
		}
		return v.Version
	}).(ParserConfigVersionPtrOutput)
}

// The configuration for the parser. It determines how the server parses the messages.
type ParserConfigResponse struct {
	// Determines whether messages with no header are allowed.
	AllowNullHeader bool `pulumi:"allowNullHeader"`
	// Schemas used to parse messages in this store, if schematized parsing is desired.
	Schema SchemaPackageResponse `pulumi:"schema"`
	// Byte(s) to use as the segment terminator. If this is unset, '\r' is used as segment terminator, matching the HL7 version 2 specification.
	SegmentTerminator string `pulumi:"segmentTerminator"`
	// Immutable. Determines the version of both the default parser to be used when `schema` is not given, as well as the schematized parser used when `schema` is specified. This field is immutable after HL7v2 store creation.
	Version string `pulumi:"version"`
}

// The configuration for the parser. It determines how the server parses the messages.
type ParserConfigResponseOutput struct{ *pulumi.OutputState }

func (ParserConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ParserConfigResponse)(nil)).Elem()
}

func (o ParserConfigResponseOutput) ToParserConfigResponseOutput() ParserConfigResponseOutput {
	return o
}

func (o ParserConfigResponseOutput) ToParserConfigResponseOutputWithContext(ctx context.Context) ParserConfigResponseOutput {
	return o
}

// Determines whether messages with no header are allowed.
func (o ParserConfigResponseOutput) AllowNullHeader() pulumi.BoolOutput {
	return o.ApplyT(func(v ParserConfigResponse) bool { return v.AllowNullHeader }).(pulumi.BoolOutput)
}

// Schemas used to parse messages in this store, if schematized parsing is desired.
func (o ParserConfigResponseOutput) Schema() SchemaPackageResponseOutput {
	return o.ApplyT(func(v ParserConfigResponse) SchemaPackageResponse { return v.Schema }).(SchemaPackageResponseOutput)
}

// Byte(s) to use as the segment terminator. If this is unset, '\r' is used as segment terminator, matching the HL7 version 2 specification.
func (o ParserConfigResponseOutput) SegmentTerminator() pulumi.StringOutput {
	return o.ApplyT(func(v ParserConfigResponse) string { return v.SegmentTerminator }).(pulumi.StringOutput)
}

// Immutable. Determines the version of both the default parser to be used when `schema` is not given, as well as the schematized parser used when `schema` is specified. This field is immutable after HL7v2 store creation.
func (o ParserConfigResponseOutput) Version() pulumi.StringOutput {
	return o.ApplyT(func(v ParserConfigResponse) string { return v.Version }).(pulumi.StringOutput)
}

// A patient identifier and associated type.
type PatientId struct {
	// ID type. For example, MRN or NHS.
	Type *string `pulumi:"type"`
	// The patient's unique identifier.
	Value *string `pulumi:"value"`
}

// PatientIdInput is an input type that accepts PatientIdArgs and PatientIdOutput values.
// You can construct a concrete instance of `PatientIdInput` via:
//
//	PatientIdArgs{...}
type PatientIdInput interface {
	pulumi.Input

	ToPatientIdOutput() PatientIdOutput
	ToPatientIdOutputWithContext(context.Context) PatientIdOutput
}

// A patient identifier and associated type.
type PatientIdArgs struct {
	// ID type. For example, MRN or NHS.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// The patient's unique identifier.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (PatientIdArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PatientId)(nil)).Elem()
}

func (i PatientIdArgs) ToPatientIdOutput() PatientIdOutput {
	return i.ToPatientIdOutputWithContext(context.Background())
}

func (i PatientIdArgs) ToPatientIdOutputWithContext(ctx context.Context) PatientIdOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PatientIdOutput)
}

// PatientIdArrayInput is an input type that accepts PatientIdArray and PatientIdArrayOutput values.
// You can construct a concrete instance of `PatientIdArrayInput` via:
//
//	PatientIdArray{ PatientIdArgs{...} }
type PatientIdArrayInput interface {
	pulumi.Input

	ToPatientIdArrayOutput() PatientIdArrayOutput
	ToPatientIdArrayOutputWithContext(context.Context) PatientIdArrayOutput
}

type PatientIdArray []PatientIdInput

func (PatientIdArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PatientId)(nil)).Elem()
}

func (i PatientIdArray) ToPatientIdArrayOutput() PatientIdArrayOutput {
	return i.ToPatientIdArrayOutputWithContext(context.Background())
}

func (i PatientIdArray) ToPatientIdArrayOutputWithContext(ctx context.Context) PatientIdArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PatientIdArrayOutput)
}

// A patient identifier and associated type.
type PatientIdOutput struct{ *pulumi.OutputState }

func (PatientIdOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PatientId)(nil)).Elem()
}

func (o PatientIdOutput) ToPatientIdOutput() PatientIdOutput {
	return o
}

func (o PatientIdOutput) ToPatientIdOutputWithContext(ctx context.Context) PatientIdOutput {
	return o
}

// ID type. For example, MRN or NHS.
func (o PatientIdOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PatientId) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// The patient's unique identifier.
func (o PatientIdOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PatientId) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type PatientIdArrayOutput struct{ *pulumi.OutputState }

func (PatientIdArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PatientId)(nil)).Elem()
}

func (o PatientIdArrayOutput) ToPatientIdArrayOutput() PatientIdArrayOutput {
	return o
}

func (o PatientIdArrayOutput) ToPatientIdArrayOutputWithContext(ctx context.Context) PatientIdArrayOutput {
	return o
}

func (o PatientIdArrayOutput) Index(i pulumi.IntInput) PatientIdOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PatientId {
		return vs[0].([]PatientId)[vs[1].(int)]
	}).(PatientIdOutput)
}

// A patient identifier and associated type.
type PatientIdResponse struct {
	// ID type. For example, MRN or NHS.
	Type string `pulumi:"type"`
	// The patient's unique identifier.
	Value string `pulumi:"value"`
}

// A patient identifier and associated type.
type PatientIdResponseOutput struct{ *pulumi.OutputState }

func (PatientIdResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PatientIdResponse)(nil)).Elem()
}

func (o PatientIdResponseOutput) ToPatientIdResponseOutput() PatientIdResponseOutput {
	return o
}

func (o PatientIdResponseOutput) ToPatientIdResponseOutputWithContext(ctx context.Context) PatientIdResponseOutput {
	return o
}

// ID type. For example, MRN or NHS.
func (o PatientIdResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v PatientIdResponse) string { return v.Type }).(pulumi.StringOutput)
}

// The patient's unique identifier.
func (o PatientIdResponseOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v PatientIdResponse) string { return v.Value }).(pulumi.StringOutput)
}

type PatientIdResponseArrayOutput struct{ *pulumi.OutputState }

func (PatientIdResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PatientIdResponse)(nil)).Elem()
}

func (o PatientIdResponseArrayOutput) ToPatientIdResponseArrayOutput() PatientIdResponseArrayOutput {
	return o
}

func (o PatientIdResponseArrayOutput) ToPatientIdResponseArrayOutputWithContext(ctx context.Context) PatientIdResponseArrayOutput {
	return o
}

func (o PatientIdResponseArrayOutput) Index(i pulumi.IntInput) PatientIdResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PatientIdResponse {
		return vs[0].([]PatientIdResponse)[vs[1].(int)]
	}).(PatientIdResponseOutput)
}

// Recursively apply DICOM de-id to tags nested in a sequence. Supported [Value Representation] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): SQ
type RecurseTag struct {
}

// RecurseTagInput is an input type that accepts RecurseTagArgs and RecurseTagOutput values.
// You can construct a concrete instance of `RecurseTagInput` via:
//
//	RecurseTagArgs{...}
type RecurseTagInput interface {
	pulumi.Input

	ToRecurseTagOutput() RecurseTagOutput
	ToRecurseTagOutputWithContext(context.Context) RecurseTagOutput
}

// Recursively apply DICOM de-id to tags nested in a sequence. Supported [Value Representation] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): SQ
type RecurseTagArgs struct {
}

func (RecurseTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RecurseTag)(nil)).Elem()
}

func (i RecurseTagArgs) ToRecurseTagOutput() RecurseTagOutput {
	return i.ToRecurseTagOutputWithContext(context.Background())
}

func (i RecurseTagArgs) ToRecurseTagOutputWithContext(ctx context.Context) RecurseTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecurseTagOutput)
}

func (i RecurseTagArgs) ToRecurseTagPtrOutput() RecurseTagPtrOutput {
	return i.ToRecurseTagPtrOutputWithContext(context.Background())
}

func (i RecurseTagArgs) ToRecurseTagPtrOutputWithContext(ctx context.Context) RecurseTagPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecurseTagOutput).ToRecurseTagPtrOutputWithContext(ctx)
}

// RecurseTagPtrInput is an input type that accepts RecurseTagArgs, RecurseTagPtr and RecurseTagPtrOutput values.
// You can construct a concrete instance of `RecurseTagPtrInput` via:
//
//	        RecurseTagArgs{...}
//
//	or:
//
//	        nil
type RecurseTagPtrInput interface {
	pulumi.Input

	ToRecurseTagPtrOutput() RecurseTagPtrOutput
	ToRecurseTagPtrOutputWithContext(context.Context) RecurseTagPtrOutput
}

type recurseTagPtrType RecurseTagArgs

func RecurseTagPtr(v *RecurseTagArgs) RecurseTagPtrInput {
	return (*recurseTagPtrType)(v)
}

func (*recurseTagPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RecurseTag)(nil)).Elem()
}

func (i *recurseTagPtrType) ToRecurseTagPtrOutput() RecurseTagPtrOutput {
	return i.ToRecurseTagPtrOutputWithContext(context.Background())
}

func (i *recurseTagPtrType) ToRecurseTagPtrOutputWithContext(ctx context.Context) RecurseTagPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecurseTagPtrOutput)
}

// Recursively apply DICOM de-id to tags nested in a sequence. Supported [Value Representation] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): SQ
type RecurseTagOutput struct{ *pulumi.OutputState }

func (RecurseTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RecurseTag)(nil)).Elem()
}

func (o RecurseTagOutput) ToRecurseTagOutput() RecurseTagOutput {
	return o
}

func (o RecurseTagOutput) ToRecurseTagOutputWithContext(ctx context.Context) RecurseTagOutput {
	return o
}

func (o RecurseTagOutput) ToRecurseTagPtrOutput() RecurseTagPtrOutput {
	return o.ToRecurseTagPtrOutputWithContext(context.Background())
}

func (o RecurseTagOutput) ToRecurseTagPtrOutputWithContext(ctx context.Context) RecurseTagPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RecurseTag) *RecurseTag {
		return &v
	}).(RecurseTagPtrOutput)
}

type RecurseTagPtrOutput struct{ *pulumi.OutputState }

func (RecurseTagPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RecurseTag)(nil)).Elem()
}

func (o RecurseTagPtrOutput) ToRecurseTagPtrOutput() RecurseTagPtrOutput {
	return o
}

func (o RecurseTagPtrOutput) ToRecurseTagPtrOutputWithContext(ctx context.Context) RecurseTagPtrOutput {
	return o
}

func (o RecurseTagPtrOutput) Elem() RecurseTagOutput {
	return o.ApplyT(func(v *RecurseTag) RecurseTag {
		if v != nil {
			return *v
		}
		var ret RecurseTag
		return ret
	}).(RecurseTagOutput)
}

// Recursively apply DICOM de-id to tags nested in a sequence. Supported [Value Representation] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): SQ
type RecurseTagResponse struct {
}

// Recursively apply DICOM de-id to tags nested in a sequence. Supported [Value Representation] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): SQ
type RecurseTagResponseOutput struct{ *pulumi.OutputState }

func (RecurseTagResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RecurseTagResponse)(nil)).Elem()
}

func (o RecurseTagResponseOutput) ToRecurseTagResponseOutput() RecurseTagResponseOutput {
	return o
}

func (o RecurseTagResponseOutput) ToRecurseTagResponseOutputWithContext(ctx context.Context) RecurseTagResponseOutput {
	return o
}

// Define how to redact sensitive values. Default behaviour is erase. For example, "My name is Jane." becomes "My name is ."
type RedactConfig struct {
}

// RedactConfigInput is an input type that accepts RedactConfigArgs and RedactConfigOutput values.
// You can construct a concrete instance of `RedactConfigInput` via:
//
//	RedactConfigArgs{...}
type RedactConfigInput interface {
	pulumi.Input

	ToRedactConfigOutput() RedactConfigOutput
	ToRedactConfigOutputWithContext(context.Context) RedactConfigOutput
}

// Define how to redact sensitive values. Default behaviour is erase. For example, "My name is Jane." becomes "My name is ."
type RedactConfigArgs struct {
}

func (RedactConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RedactConfig)(nil)).Elem()
}

func (i RedactConfigArgs) ToRedactConfigOutput() RedactConfigOutput {
	return i.ToRedactConfigOutputWithContext(context.Background())
}

func (i RedactConfigArgs) ToRedactConfigOutputWithContext(ctx context.Context) RedactConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RedactConfigOutput)
}

func (i RedactConfigArgs) ToRedactConfigPtrOutput() RedactConfigPtrOutput {
	return i.ToRedactConfigPtrOutputWithContext(context.Background())
}

func (i RedactConfigArgs) ToRedactConfigPtrOutputWithContext(ctx context.Context) RedactConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RedactConfigOutput).ToRedactConfigPtrOutputWithContext(ctx)
}

// RedactConfigPtrInput is an input type that accepts RedactConfigArgs, RedactConfigPtr and RedactConfigPtrOutput values.
// You can construct a concrete instance of `RedactConfigPtrInput` via:
//
//	        RedactConfigArgs{...}
//
//	or:
//
//	        nil
type RedactConfigPtrInput interface {
	pulumi.Input

	ToRedactConfigPtrOutput() RedactConfigPtrOutput
	ToRedactConfigPtrOutputWithContext(context.Context) RedactConfigPtrOutput
}

type redactConfigPtrType RedactConfigArgs

func RedactConfigPtr(v *RedactConfigArgs) RedactConfigPtrInput {
	return (*redactConfigPtrType)(v)
}

func (*redactConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RedactConfig)(nil)).Elem()
}

func (i *redactConfigPtrType) ToRedactConfigPtrOutput() RedactConfigPtrOutput {
	return i.ToRedactConfigPtrOutputWithContext(context.Background())
}

func (i *redactConfigPtrType) ToRedactConfigPtrOutputWithContext(ctx context.Context) RedactConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RedactConfigPtrOutput)
}

// Define how to redact sensitive values. Default behaviour is erase. For example, "My name is Jane." becomes "My name is ."
type RedactConfigOutput struct{ *pulumi.OutputState }

func (RedactConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RedactConfig)(nil)).Elem()
}

func (o RedactConfigOutput) ToRedactConfigOutput() RedactConfigOutput {
	return o
}

func (o RedactConfigOutput) ToRedactConfigOutputWithContext(ctx context.Context) RedactConfigOutput {
	return o
}

func (o RedactConfigOutput) ToRedactConfigPtrOutput() RedactConfigPtrOutput {
	return o.ToRedactConfigPtrOutputWithContext(context.Background())
}

func (o RedactConfigOutput) ToRedactConfigPtrOutputWithContext(ctx context.Context) RedactConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RedactConfig) *RedactConfig {
		return &v
	}).(RedactConfigPtrOutput)
}

type RedactConfigPtrOutput struct{ *pulumi.OutputState }

func (RedactConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RedactConfig)(nil)).Elem()
}

func (o RedactConfigPtrOutput) ToRedactConfigPtrOutput() RedactConfigPtrOutput {
	return o
}

func (o RedactConfigPtrOutput) ToRedactConfigPtrOutputWithContext(ctx context.Context) RedactConfigPtrOutput {
	return o
}

func (o RedactConfigPtrOutput) Elem() RedactConfigOutput {
	return o.ApplyT(func(v *RedactConfig) RedactConfig {
		if v != nil {
			return *v
		}
		var ret RedactConfig
		return ret
	}).(RedactConfigOutput)
}

// Define how to redact sensitive values. Default behaviour is erase. For example, "My name is Jane." becomes "My name is ."
type RedactConfigResponse struct {
}

// Define how to redact sensitive values. Default behaviour is erase. For example, "My name is Jane." becomes "My name is ."
type RedactConfigResponseOutput struct{ *pulumi.OutputState }

func (RedactConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RedactConfigResponse)(nil)).Elem()
}

func (o RedactConfigResponseOutput) ToRedactConfigResponseOutput() RedactConfigResponseOutput {
	return o
}

func (o RedactConfigResponseOutput) ToRedactConfigResponseOutputWithContext(ctx context.Context) RedactConfigResponseOutput {
	return o
}

// Replace UID with a new generated UID. Supported [Value Representation] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): UI
type RegenUidTag struct {
}

// RegenUidTagInput is an input type that accepts RegenUidTagArgs and RegenUidTagOutput values.
// You can construct a concrete instance of `RegenUidTagInput` via:
//
//	RegenUidTagArgs{...}
type RegenUidTagInput interface {
	pulumi.Input

	ToRegenUidTagOutput() RegenUidTagOutput
	ToRegenUidTagOutputWithContext(context.Context) RegenUidTagOutput
}

// Replace UID with a new generated UID. Supported [Value Representation] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): UI
type RegenUidTagArgs struct {
}

func (RegenUidTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RegenUidTag)(nil)).Elem()
}

func (i RegenUidTagArgs) ToRegenUidTagOutput() RegenUidTagOutput {
	return i.ToRegenUidTagOutputWithContext(context.Background())
}

func (i RegenUidTagArgs) ToRegenUidTagOutputWithContext(ctx context.Context) RegenUidTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegenUidTagOutput)
}

func (i RegenUidTagArgs) ToRegenUidTagPtrOutput() RegenUidTagPtrOutput {
	return i.ToRegenUidTagPtrOutputWithContext(context.Background())
}

func (i RegenUidTagArgs) ToRegenUidTagPtrOutputWithContext(ctx context.Context) RegenUidTagPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegenUidTagOutput).ToRegenUidTagPtrOutputWithContext(ctx)
}

// RegenUidTagPtrInput is an input type that accepts RegenUidTagArgs, RegenUidTagPtr and RegenUidTagPtrOutput values.
// You can construct a concrete instance of `RegenUidTagPtrInput` via:
//
//	        RegenUidTagArgs{...}
//
//	or:
//
//	        nil
type RegenUidTagPtrInput interface {
	pulumi.Input

	ToRegenUidTagPtrOutput() RegenUidTagPtrOutput
	ToRegenUidTagPtrOutputWithContext(context.Context) RegenUidTagPtrOutput
}

type regenUidTagPtrType RegenUidTagArgs

func RegenUidTagPtr(v *RegenUidTagArgs) RegenUidTagPtrInput {
	return (*regenUidTagPtrType)(v)
}

func (*regenUidTagPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RegenUidTag)(nil)).Elem()
}

func (i *regenUidTagPtrType) ToRegenUidTagPtrOutput() RegenUidTagPtrOutput {
	return i.ToRegenUidTagPtrOutputWithContext(context.Background())
}

func (i *regenUidTagPtrType) ToRegenUidTagPtrOutputWithContext(ctx context.Context) RegenUidTagPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegenUidTagPtrOutput)
}

// Replace UID with a new generated UID. Supported [Value Representation] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): UI
type RegenUidTagOutput struct{ *pulumi.OutputState }

func (RegenUidTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RegenUidTag)(nil)).Elem()
}

func (o RegenUidTagOutput) ToRegenUidTagOutput() RegenUidTagOutput {
	return o
}

func (o RegenUidTagOutput) ToRegenUidTagOutputWithContext(ctx context.Context) RegenUidTagOutput {
	return o
}

func (o RegenUidTagOutput) ToRegenUidTagPtrOutput() RegenUidTagPtrOutput {
	return o.ToRegenUidTagPtrOutputWithContext(context.Background())
}

func (o RegenUidTagOutput) ToRegenUidTagPtrOutputWithContext(ctx context.Context) RegenUidTagPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RegenUidTag) *RegenUidTag {
		return &v
	}).(RegenUidTagPtrOutput)
}

type RegenUidTagPtrOutput struct{ *pulumi.OutputState }

func (RegenUidTagPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RegenUidTag)(nil)).Elem()
}

func (o RegenUidTagPtrOutput) ToRegenUidTagPtrOutput() RegenUidTagPtrOutput {
	return o
}

func (o RegenUidTagPtrOutput) ToRegenUidTagPtrOutputWithContext(ctx context.Context) RegenUidTagPtrOutput {
	return o
}

func (o RegenUidTagPtrOutput) Elem() RegenUidTagOutput {
	return o.ApplyT(func(v *RegenUidTag) RegenUidTag {
		if v != nil {
			return *v
		}
		var ret RegenUidTag
		return ret
	}).(RegenUidTagOutput)
}

// Replace UID with a new generated UID. Supported [Value Representation] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): UI
type RegenUidTagResponse struct {
}

// Replace UID with a new generated UID. Supported [Value Representation] (http://dicom.nema.org/medical/dicom/2018e/output/chtml/part05/sect_6.2.html#table_6.2-1): UI
type RegenUidTagResponseOutput struct{ *pulumi.OutputState }

func (RegenUidTagResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RegenUidTagResponse)(nil)).Elem()
}

func (o RegenUidTagResponseOutput) ToRegenUidTagResponseOutput() RegenUidTagResponseOutput {
	return o
}

func (o RegenUidTagResponseOutput) ToRegenUidTagResponseOutputWithContext(ctx context.Context) RegenUidTagResponseOutput {
	return o
}

// Remove field.
type RemoveField struct {
}

// RemoveFieldInput is an input type that accepts RemoveFieldArgs and RemoveFieldOutput values.
// You can construct a concrete instance of `RemoveFieldInput` via:
//
//	RemoveFieldArgs{...}
type RemoveFieldInput interface {
	pulumi.Input

	ToRemoveFieldOutput() RemoveFieldOutput
	ToRemoveFieldOutputWithContext(context.Context) RemoveFieldOutput
}

// Remove field.
type RemoveFieldArgs struct {
}

func (RemoveFieldArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RemoveField)(nil)).Elem()
}

func (i RemoveFieldArgs) ToRemoveFieldOutput() RemoveFieldOutput {
	return i.ToRemoveFieldOutputWithContext(context.Background())
}

func (i RemoveFieldArgs) ToRemoveFieldOutputWithContext(ctx context.Context) RemoveFieldOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RemoveFieldOutput)
}

func (i RemoveFieldArgs) ToRemoveFieldPtrOutput() RemoveFieldPtrOutput {
	return i.ToRemoveFieldPtrOutputWithContext(context.Background())
}

func (i RemoveFieldArgs) ToRemoveFieldPtrOutputWithContext(ctx context.Context) RemoveFieldPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RemoveFieldOutput).ToRemoveFieldPtrOutputWithContext(ctx)
}

// RemoveFieldPtrInput is an input type that accepts RemoveFieldArgs, RemoveFieldPtr and RemoveFieldPtrOutput values.
// You can construct a concrete instance of `RemoveFieldPtrInput` via:
//
//	        RemoveFieldArgs{...}
//
//	or:
//
//	        nil
type RemoveFieldPtrInput interface {
	pulumi.Input

	ToRemoveFieldPtrOutput() RemoveFieldPtrOutput
	ToRemoveFieldPtrOutputWithContext(context.Context) RemoveFieldPtrOutput
}

type removeFieldPtrType RemoveFieldArgs

func RemoveFieldPtr(v *RemoveFieldArgs) RemoveFieldPtrInput {
	return (*removeFieldPtrType)(v)
}

func (*removeFieldPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RemoveField)(nil)).Elem()
}

func (i *removeFieldPtrType) ToRemoveFieldPtrOutput() RemoveFieldPtrOutput {
	return i.ToRemoveFieldPtrOutputWithContext(context.Background())
}

func (i *removeFieldPtrType) ToRemoveFieldPtrOutputWithContext(ctx context.Context) RemoveFieldPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RemoveFieldPtrOutput)
}

// Remove field.
type RemoveFieldOutput struct{ *pulumi.OutputState }

func (RemoveFieldOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RemoveField)(nil)).Elem()
}

func (o RemoveFieldOutput) ToRemoveFieldOutput() RemoveFieldOutput {
	return o
}

func (o RemoveFieldOutput) ToRemoveFieldOutputWithContext(ctx context.Context) RemoveFieldOutput {
	return o
}

func (o RemoveFieldOutput) ToRemoveFieldPtrOutput() RemoveFieldPtrOutput {
	return o.ToRemoveFieldPtrOutputWithContext(context.Background())
}

func (o RemoveFieldOutput) ToRemoveFieldPtrOutputWithContext(ctx context.Context) RemoveFieldPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RemoveField) *RemoveField {
		return &v
	}).(RemoveFieldPtrOutput)
}

type RemoveFieldPtrOutput struct{ *pulumi.OutputState }

func (RemoveFieldPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RemoveField)(nil)).Elem()
}

func (o RemoveFieldPtrOutput) ToRemoveFieldPtrOutput() RemoveFieldPtrOutput {
	return o
}

func (o RemoveFieldPtrOutput) ToRemoveFieldPtrOutputWithContext(ctx context.Context) RemoveFieldPtrOutput {
	return o
}

func (o RemoveFieldPtrOutput) Elem() RemoveFieldOutput {
	return o.ApplyT(func(v *RemoveField) RemoveField {
		if v != nil {
			return *v
		}
		var ret RemoveField
		return ret
	}).(RemoveFieldOutput)
}

// Remove field.
type RemoveFieldResponse struct {
}

// Remove field.
type RemoveFieldResponseOutput struct{ *pulumi.OutputState }

func (RemoveFieldResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RemoveFieldResponse)(nil)).Elem()
}

func (o RemoveFieldResponseOutput) ToRemoveFieldResponseOutput() RemoveFieldResponseOutput {
	return o
}

func (o RemoveFieldResponseOutput) ToRemoveFieldResponseOutputWithContext(ctx context.Context) RemoveFieldResponseOutput {
	return o
}

// Replace with empty tag.
type RemoveTag struct {
}

// RemoveTagInput is an input type that accepts RemoveTagArgs and RemoveTagOutput values.
// You can construct a concrete instance of `RemoveTagInput` via:
//
//	RemoveTagArgs{...}
type RemoveTagInput interface {
	pulumi.Input

	ToRemoveTagOutput() RemoveTagOutput
	ToRemoveTagOutputWithContext(context.Context) RemoveTagOutput
}

// Replace with empty tag.
type RemoveTagArgs struct {
}

func (RemoveTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RemoveTag)(nil)).Elem()
}

func (i RemoveTagArgs) ToRemoveTagOutput() RemoveTagOutput {
	return i.ToRemoveTagOutputWithContext(context.Background())
}

func (i RemoveTagArgs) ToRemoveTagOutputWithContext(ctx context.Context) RemoveTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RemoveTagOutput)
}

func (i RemoveTagArgs) ToRemoveTagPtrOutput() RemoveTagPtrOutput {
	return i.ToRemoveTagPtrOutputWithContext(context.Background())
}

func (i RemoveTagArgs) ToRemoveTagPtrOutputWithContext(ctx context.Context) RemoveTagPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RemoveTagOutput).ToRemoveTagPtrOutputWithContext(ctx)
}

// RemoveTagPtrInput is an input type that accepts RemoveTagArgs, RemoveTagPtr and RemoveTagPtrOutput values.
// You can construct a concrete instance of `RemoveTagPtrInput` via:
//
//	        RemoveTagArgs{...}
//
//	or:
//
//	        nil
type RemoveTagPtrInput interface {
	pulumi.Input

	ToRemoveTagPtrOutput() RemoveTagPtrOutput
	ToRemoveTagPtrOutputWithContext(context.Context) RemoveTagPtrOutput
}

type removeTagPtrType RemoveTagArgs

func RemoveTagPtr(v *RemoveTagArgs) RemoveTagPtrInput {
	return (*removeTagPtrType)(v)
}

func (*removeTagPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RemoveTag)(nil)).Elem()
}

func (i *removeTagPtrType) ToRemoveTagPtrOutput() RemoveTagPtrOutput {
	return i.ToRemoveTagPtrOutputWithContext(context.Background())
}

func (i *removeTagPtrType) ToRemoveTagPtrOutputWithContext(ctx context.Context) RemoveTagPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RemoveTagPtrOutput)
}

// Replace with empty tag.
type RemoveTagOutput struct{ *pulumi.OutputState }

func (RemoveTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RemoveTag)(nil)).Elem()
}

func (o RemoveTagOutput) ToRemoveTagOutput() RemoveTagOutput {
	return o
}

func (o RemoveTagOutput) ToRemoveTagOutputWithContext(ctx context.Context) RemoveTagOutput {
	return o
}

func (o RemoveTagOutput) ToRemoveTagPtrOutput() RemoveTagPtrOutput {
	return o.ToRemoveTagPtrOutputWithContext(context.Background())
}

func (o RemoveTagOutput) ToRemoveTagPtrOutputWithContext(ctx context.Context) RemoveTagPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RemoveTag) *RemoveTag {
		return &v
	}).(RemoveTagPtrOutput)
}

type RemoveTagPtrOutput struct{ *pulumi.OutputState }

func (RemoveTagPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RemoveTag)(nil)).Elem()
}

func (o RemoveTagPtrOutput) ToRemoveTagPtrOutput() RemoveTagPtrOutput {
	return o
}

func (o RemoveTagPtrOutput) ToRemoveTagPtrOutputWithContext(ctx context.Context) RemoveTagPtrOutput {
	return o
}

func (o RemoveTagPtrOutput) Elem() RemoveTagOutput {
	return o.ApplyT(func(v *RemoveTag) RemoveTag {
		if v != nil {
			return *v
		}
		var ret RemoveTag
		return ret
	}).(RemoveTagOutput)
}

// Replace with empty tag.
type RemoveTagResponse struct {
}

// Replace with empty tag.
type RemoveTagResponseOutput struct{ *pulumi.OutputState }

func (RemoveTagResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RemoveTagResponse)(nil)).Elem()
}

func (o RemoveTagResponseOutput) ToRemoveTagResponseOutput() RemoveTagResponseOutput {
	return o
}

func (o RemoveTagResponseOutput) ToRemoveTagResponseOutputWithContext(ctx context.Context) RemoveTagResponseOutput {
	return o
}

// When using the INSPECT_AND_TRANSFORM action, each match is replaced with the name of the info_type. For example, "My name is Jane" becomes "My name is [PERSON_NAME]." The TRANSFORM action is equivalent to redacting.
type ReplaceWithInfoTypeConfig struct {
}

// ReplaceWithInfoTypeConfigInput is an input type that accepts ReplaceWithInfoTypeConfigArgs and ReplaceWithInfoTypeConfigOutput values.
// You can construct a concrete instance of `ReplaceWithInfoTypeConfigInput` via:
//
//	ReplaceWithInfoTypeConfigArgs{...}
type ReplaceWithInfoTypeConfigInput interface {
	pulumi.Input

	ToReplaceWithInfoTypeConfigOutput() ReplaceWithInfoTypeConfigOutput
	ToReplaceWithInfoTypeConfigOutputWithContext(context.Context) ReplaceWithInfoTypeConfigOutput
}

// When using the INSPECT_AND_TRANSFORM action, each match is replaced with the name of the info_type. For example, "My name is Jane" becomes "My name is [PERSON_NAME]." The TRANSFORM action is equivalent to redacting.
type ReplaceWithInfoTypeConfigArgs struct {
}

func (ReplaceWithInfoTypeConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ReplaceWithInfoTypeConfig)(nil)).Elem()
}

func (i ReplaceWithInfoTypeConfigArgs) ToReplaceWithInfoTypeConfigOutput() ReplaceWithInfoTypeConfigOutput {
	return i.ToReplaceWithInfoTypeConfigOutputWithContext(context.Background())
}

func (i ReplaceWithInfoTypeConfigArgs) ToReplaceWithInfoTypeConfigOutputWithContext(ctx context.Context) ReplaceWithInfoTypeConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplaceWithInfoTypeConfigOutput)
}

func (i ReplaceWithInfoTypeConfigArgs) ToReplaceWithInfoTypeConfigPtrOutput() ReplaceWithInfoTypeConfigPtrOutput {
	return i.ToReplaceWithInfoTypeConfigPtrOutputWithContext(context.Background())
}

func (i ReplaceWithInfoTypeConfigArgs) ToReplaceWithInfoTypeConfigPtrOutputWithContext(ctx context.Context) ReplaceWithInfoTypeConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplaceWithInfoTypeConfigOutput).ToReplaceWithInfoTypeConfigPtrOutputWithContext(ctx)
}

// ReplaceWithInfoTypeConfigPtrInput is an input type that accepts ReplaceWithInfoTypeConfigArgs, ReplaceWithInfoTypeConfigPtr and ReplaceWithInfoTypeConfigPtrOutput values.
// You can construct a concrete instance of `ReplaceWithInfoTypeConfigPtrInput` via:
//
//	        ReplaceWithInfoTypeConfigArgs{...}
//
//	or:
//
//	        nil
type ReplaceWithInfoTypeConfigPtrInput interface {
	pulumi.Input

	ToReplaceWithInfoTypeConfigPtrOutput() ReplaceWithInfoTypeConfigPtrOutput
	ToReplaceWithInfoTypeConfigPtrOutputWithContext(context.Context) ReplaceWithInfoTypeConfigPtrOutput
}

type replaceWithInfoTypeConfigPtrType ReplaceWithInfoTypeConfigArgs

func ReplaceWithInfoTypeConfigPtr(v *ReplaceWithInfoTypeConfigArgs) ReplaceWithInfoTypeConfigPtrInput {
	return (*replaceWithInfoTypeConfigPtrType)(v)
}

func (*replaceWithInfoTypeConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ReplaceWithInfoTypeConfig)(nil)).Elem()
}

func (i *replaceWithInfoTypeConfigPtrType) ToReplaceWithInfoTypeConfigPtrOutput() ReplaceWithInfoTypeConfigPtrOutput {
	return i.ToReplaceWithInfoTypeConfigPtrOutputWithContext(context.Background())
}

func (i *replaceWithInfoTypeConfigPtrType) ToReplaceWithInfoTypeConfigPtrOutputWithContext(ctx context.Context) ReplaceWithInfoTypeConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplaceWithInfoTypeConfigPtrOutput)
}

// When using the INSPECT_AND_TRANSFORM action, each match is replaced with the name of the info_type. For example, "My name is Jane" becomes "My name is [PERSON_NAME]." The TRANSFORM action is equivalent to redacting.
type ReplaceWithInfoTypeConfigOutput struct{ *pulumi.OutputState }

func (ReplaceWithInfoTypeConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ReplaceWithInfoTypeConfig)(nil)).Elem()
}

func (o ReplaceWithInfoTypeConfigOutput) ToReplaceWithInfoTypeConfigOutput() ReplaceWithInfoTypeConfigOutput {
	return o
}

func (o ReplaceWithInfoTypeConfigOutput) ToReplaceWithInfoTypeConfigOutputWithContext(ctx context.Context) ReplaceWithInfoTypeConfigOutput {
	return o
}

func (o ReplaceWithInfoTypeConfigOutput) ToReplaceWithInfoTypeConfigPtrOutput() ReplaceWithInfoTypeConfigPtrOutput {
	return o.ToReplaceWithInfoTypeConfigPtrOutputWithContext(context.Background())
}

func (o ReplaceWithInfoTypeConfigOutput) ToReplaceWithInfoTypeConfigPtrOutputWithContext(ctx context.Context) ReplaceWithInfoTypeConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ReplaceWithInfoTypeConfig) *ReplaceWithInfoTypeConfig {
		return &v
	}).(ReplaceWithInfoTypeConfigPtrOutput)
}

type ReplaceWithInfoTypeConfigPtrOutput struct{ *pulumi.OutputState }

func (ReplaceWithInfoTypeConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ReplaceWithInfoTypeConfig)(nil)).Elem()
}

func (o ReplaceWithInfoTypeConfigPtrOutput) ToReplaceWithInfoTypeConfigPtrOutput() ReplaceWithInfoTypeConfigPtrOutput {
	return o
}

func (o ReplaceWithInfoTypeConfigPtrOutput) ToReplaceWithInfoTypeConfigPtrOutputWithContext(ctx context.Context) ReplaceWithInfoTypeConfigPtrOutput {
	return o
}

func (o ReplaceWithInfoTypeConfigPtrOutput) Elem() ReplaceWithInfoTypeConfigOutput {
	return o.ApplyT(func(v *ReplaceWithInfoTypeConfig) ReplaceWithInfoTypeConfig {
		if v != nil {
			return *v
		}
		var ret ReplaceWithInfoTypeConfig
		return ret
	}).(ReplaceWithInfoTypeConfigOutput)
}

// When using the INSPECT_AND_TRANSFORM action, each match is replaced with the name of the info_type. For example, "My name is Jane" becomes "My name is [PERSON_NAME]." The TRANSFORM action is equivalent to redacting.
type ReplaceWithInfoTypeConfigResponse struct {
}

// When using the INSPECT_AND_TRANSFORM action, each match is replaced with the name of the info_type. For example, "My name is Jane" becomes "My name is [PERSON_NAME]." The TRANSFORM action is equivalent to redacting.
type ReplaceWithInfoTypeConfigResponseOutput struct{ *pulumi.OutputState }

func (ReplaceWithInfoTypeConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ReplaceWithInfoTypeConfigResponse)(nil)).Elem()
}

func (o ReplaceWithInfoTypeConfigResponseOutput) ToReplaceWithInfoTypeConfigResponseOutput() ReplaceWithInfoTypeConfigResponseOutput {
	return o
}

func (o ReplaceWithInfoTypeConfigResponseOutput) ToReplaceWithInfoTypeConfigResponseOutputWithContext(ctx context.Context) ReplaceWithInfoTypeConfigResponseOutput {
	return o
}

// Reset tag to a placeholder value.
type ResetTag struct {
}

// ResetTagInput is an input type that accepts ResetTagArgs and ResetTagOutput values.
// You can construct a concrete instance of `ResetTagInput` via:
//
//	ResetTagArgs{...}
type ResetTagInput interface {
	pulumi.Input

	ToResetTagOutput() ResetTagOutput
	ToResetTagOutputWithContext(context.Context) ResetTagOutput
}

// Reset tag to a placeholder value.
type ResetTagArgs struct {
}

func (ResetTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResetTag)(nil)).Elem()
}

func (i ResetTagArgs) ToResetTagOutput() ResetTagOutput {
	return i.ToResetTagOutputWithContext(context.Background())
}

func (i ResetTagArgs) ToResetTagOutputWithContext(ctx context.Context) ResetTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResetTagOutput)
}

func (i ResetTagArgs) ToResetTagPtrOutput() ResetTagPtrOutput {
	return i.ToResetTagPtrOutputWithContext(context.Background())
}

func (i ResetTagArgs) ToResetTagPtrOutputWithContext(ctx context.Context) ResetTagPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResetTagOutput).ToResetTagPtrOutputWithContext(ctx)
}

// ResetTagPtrInput is an input type that accepts ResetTagArgs, ResetTagPtr and ResetTagPtrOutput values.
// You can construct a concrete instance of `ResetTagPtrInput` via:
//
//	        ResetTagArgs{...}
//
//	or:
//
//	        nil
type ResetTagPtrInput interface {
	pulumi.Input

	ToResetTagPtrOutput() ResetTagPtrOutput
	ToResetTagPtrOutputWithContext(context.Context) ResetTagPtrOutput
}

type resetTagPtrType ResetTagArgs

func ResetTagPtr(v *ResetTagArgs) ResetTagPtrInput {
	return (*resetTagPtrType)(v)
}

func (*resetTagPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ResetTag)(nil)).Elem()
}

func (i *resetTagPtrType) ToResetTagPtrOutput() ResetTagPtrOutput {
	return i.ToResetTagPtrOutputWithContext(context.Background())
}

func (i *resetTagPtrType) ToResetTagPtrOutputWithContext(ctx context.Context) ResetTagPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResetTagPtrOutput)
}

// Reset tag to a placeholder value.
type ResetTagOutput struct{ *pulumi.OutputState }

func (ResetTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResetTag)(nil)).Elem()
}

func (o ResetTagOutput) ToResetTagOutput() ResetTagOutput {
	return o
}

func (o ResetTagOutput) ToResetTagOutputWithContext(ctx context.Context) ResetTagOutput {
	return o
}

func (o ResetTagOutput) ToResetTagPtrOutput() ResetTagPtrOutput {
	return o.ToResetTagPtrOutputWithContext(context.Background())
}

func (o ResetTagOutput) ToResetTagPtrOutputWithContext(ctx context.Context) ResetTagPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ResetTag) *ResetTag {
		return &v
	}).(ResetTagPtrOutput)
}

type ResetTagPtrOutput struct{ *pulumi.OutputState }

func (ResetTagPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResetTag)(nil)).Elem()
}

func (o ResetTagPtrOutput) ToResetTagPtrOutput() ResetTagPtrOutput {
	return o
}

func (o ResetTagPtrOutput) ToResetTagPtrOutputWithContext(ctx context.Context) ResetTagPtrOutput {
	return o
}

func (o ResetTagPtrOutput) Elem() ResetTagOutput {
	return o.ApplyT(func(v *ResetTag) ResetTag {
		if v != nil {
			return *v
		}
		var ret ResetTag
		return ret
	}).(ResetTagOutput)
}

// Reset tag to a placeholder value.
type ResetTagResponse struct {
}

// Reset tag to a placeholder value.
type ResetTagResponseOutput struct{ *pulumi.OutputState }

func (ResetTagResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResetTagResponse)(nil)).Elem()
}

func (o ResetTagResponseOutput) ToResetTagResponseOutput() ResetTagResponseOutput {
	return o
}

func (o ResetTagResponseOutput) ToResetTagResponseOutputWithContext(ctx context.Context) ResetTagResponseOutput {
	return o
}

// Resource level annotation.
type ResourceAnnotation struct {
	// A description of the annotation record.
	Label *string `pulumi:"label"`
}

// ResourceAnnotationInput is an input type that accepts ResourceAnnotationArgs and ResourceAnnotationOutput values.
// You can construct a concrete instance of `ResourceAnnotationInput` via:
//
//	ResourceAnnotationArgs{...}
type ResourceAnnotationInput interface {
	pulumi.Input

	ToResourceAnnotationOutput() ResourceAnnotationOutput
	ToResourceAnnotationOutputWithContext(context.Context) ResourceAnnotationOutput
}

// Resource level annotation.
type ResourceAnnotationArgs struct {
	// A description of the annotation record.
	Label pulumi.StringPtrInput `pulumi:"label"`
}

func (ResourceAnnotationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceAnnotation)(nil)).Elem()
}

func (i ResourceAnnotationArgs) ToResourceAnnotationOutput() ResourceAnnotationOutput {
	return i.ToResourceAnnotationOutputWithContext(context.Background())
}

func (i ResourceAnnotationArgs) ToResourceAnnotationOutputWithContext(ctx context.Context) ResourceAnnotationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceAnnotationOutput)
}

func (i ResourceAnnotationArgs) ToResourceAnnotationPtrOutput() ResourceAnnotationPtrOutput {
	return i.ToResourceAnnotationPtrOutputWithContext(context.Background())
}

func (i ResourceAnnotationArgs) ToResourceAnnotationPtrOutputWithContext(ctx context.Context) ResourceAnnotationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceAnnotationOutput).ToResourceAnnotationPtrOutputWithContext(ctx)
}

// ResourceAnnotationPtrInput is an input type that accepts ResourceAnnotationArgs, ResourceAnnotationPtr and ResourceAnnotationPtrOutput values.
// You can construct a concrete instance of `ResourceAnnotationPtrInput` via:
//
//	        ResourceAnnotationArgs{...}
//
//	or:
//
//	        nil
type ResourceAnnotationPtrInput interface {
	pulumi.Input

	ToResourceAnnotationPtrOutput() ResourceAnnotationPtrOutput
	ToResourceAnnotationPtrOutputWithContext(context.Context) ResourceAnnotationPtrOutput
}

type resourceAnnotationPtrType ResourceAnnotationArgs

func ResourceAnnotationPtr(v *ResourceAnnotationArgs) ResourceAnnotationPtrInput {
	return (*resourceAnnotationPtrType)(v)
}

func (*resourceAnnotationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceAnnotation)(nil)).Elem()
}

func (i *resourceAnnotationPtrType) ToResourceAnnotationPtrOutput() ResourceAnnotationPtrOutput {
	return i.ToResourceAnnotationPtrOutputWithContext(context.Background())
}

func (i *resourceAnnotationPtrType) ToResourceAnnotationPtrOutputWithContext(ctx context.Context) ResourceAnnotationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceAnnotationPtrOutput)
}

// Resource level annotation.
type ResourceAnnotationOutput struct{ *pulumi.OutputState }

func (ResourceAnnotationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceAnnotation)(nil)).Elem()
}

func (o ResourceAnnotationOutput) ToResourceAnnotationOutput() ResourceAnnotationOutput {
	return o
}

func (o ResourceAnnotationOutput) ToResourceAnnotationOutputWithContext(ctx context.Context) ResourceAnnotationOutput {
	return o
}

func (o ResourceAnnotationOutput) ToResourceAnnotationPtrOutput() ResourceAnnotationPtrOutput {
	return o.ToResourceAnnotationPtrOutputWithContext(context.Background())
}

func (o ResourceAnnotationOutput) ToResourceAnnotationPtrOutputWithContext(ctx context.Context) ResourceAnnotationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ResourceAnnotation) *ResourceAnnotation {
		return &v
	}).(ResourceAnnotationPtrOutput)
}

// A description of the annotation record.
func (o ResourceAnnotationOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceAnnotation) *string { return v.Label }).(pulumi.StringPtrOutput)
}

type ResourceAnnotationPtrOutput struct{ *pulumi.OutputState }

func (ResourceAnnotationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceAnnotation)(nil)).Elem()
}

func (o ResourceAnnotationPtrOutput) ToResourceAnnotationPtrOutput() ResourceAnnotationPtrOutput {
	return o
}

func (o ResourceAnnotationPtrOutput) ToResourceAnnotationPtrOutputWithContext(ctx context.Context) ResourceAnnotationPtrOutput {
	return o
}

func (o ResourceAnnotationPtrOutput) Elem() ResourceAnnotationOutput {
	return o.ApplyT(func(v *ResourceAnnotation) ResourceAnnotation {
		if v != nil {
			return *v
		}
		var ret ResourceAnnotation
		return ret
	}).(ResourceAnnotationOutput)
}

// A description of the annotation record.
func (o ResourceAnnotationPtrOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourceAnnotation) *string {
		if v == nil {
			return nil
		}
		return v.Label
	}).(pulumi.StringPtrOutput)
}

// Resource level annotation.
type ResourceAnnotationResponse struct {
	// A description of the annotation record.
	Label string `pulumi:"label"`
}

// Resource level annotation.
type ResourceAnnotationResponseOutput struct{ *pulumi.OutputState }

func (ResourceAnnotationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceAnnotationResponse)(nil)).Elem()
}

func (o ResourceAnnotationResponseOutput) ToResourceAnnotationResponseOutput() ResourceAnnotationResponseOutput {
	return o
}

func (o ResourceAnnotationResponseOutput) ToResourceAnnotationResponseOutputWithContext(ctx context.Context) ResourceAnnotationResponseOutput {
	return o
}

// A description of the annotation record.
func (o ResourceAnnotationResponseOutput) Label() pulumi.StringOutput {
	return o.ApplyT(func(v ResourceAnnotationResponse) string { return v.Label }).(pulumi.StringOutput)
}

// Configuration for the FHIR BigQuery schema. Determines how the server generates the schema.
type SchemaConfig struct {
	// The configuration for exported BigQuery tables to be partitioned by FHIR resource's last updated time column.
	LastUpdatedPartitionConfig *TimePartitioning `pulumi:"lastUpdatedPartitionConfig"`
	// The depth for all recursive structures in the output analytics schema. For example, `concept` in the CodeSystem resource is a recursive structure; when the depth is 2, the CodeSystem table will have a column called `concept.concept` but not `concept.concept.concept`. If not specified or set to 0, the server will use the default value 2. The maximum depth allowed is 5.
	RecursiveStructureDepth *string `pulumi:"recursiveStructureDepth"`
	// Specifies the output schema type. Schema type is required.
	SchemaType *SchemaConfigSchemaType `pulumi:"schemaType"`
}

// SchemaConfigInput is an input type that accepts SchemaConfigArgs and SchemaConfigOutput values.
// You can construct a concrete instance of `SchemaConfigInput` via:
//
//	SchemaConfigArgs{...}
type SchemaConfigInput interface {
	pulumi.Input

	ToSchemaConfigOutput() SchemaConfigOutput
	ToSchemaConfigOutputWithContext(context.Context) SchemaConfigOutput
}

// Configuration for the FHIR BigQuery schema. Determines how the server generates the schema.
type SchemaConfigArgs struct {
	// The configuration for exported BigQuery tables to be partitioned by FHIR resource's last updated time column.
	LastUpdatedPartitionConfig TimePartitioningPtrInput `pulumi:"lastUpdatedPartitionConfig"`
	// The depth for all recursive structures in the output analytics schema. For example, `concept` in the CodeSystem resource is a recursive structure; when the depth is 2, the CodeSystem table will have a column called `concept.concept` but not `concept.concept.concept`. If not specified or set to 0, the server will use the default value 2. The maximum depth allowed is 5.
	RecursiveStructureDepth pulumi.StringPtrInput `pulumi:"recursiveStructureDepth"`
	// Specifies the output schema type. Schema type is required.
	SchemaType SchemaConfigSchemaTypePtrInput `pulumi:"schemaType"`
}

func (SchemaConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SchemaConfig)(nil)).Elem()
}

func (i SchemaConfigArgs) ToSchemaConfigOutput() SchemaConfigOutput {
	return i.ToSchemaConfigOutputWithContext(context.Background())
}

func (i SchemaConfigArgs) ToSchemaConfigOutputWithContext(ctx context.Context) SchemaConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaConfigOutput)
}

func (i SchemaConfigArgs) ToSchemaConfigPtrOutput() SchemaConfigPtrOutput {
	return i.ToSchemaConfigPtrOutputWithContext(context.Background())
}

func (i SchemaConfigArgs) ToSchemaConfigPtrOutputWithContext(ctx context.Context) SchemaConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaConfigOutput).ToSchemaConfigPtrOutputWithContext(ctx)
}

// SchemaConfigPtrInput is an input type that accepts SchemaConfigArgs, SchemaConfigPtr and SchemaConfigPtrOutput values.
// You can construct a concrete instance of `SchemaConfigPtrInput` via:
//
//	        SchemaConfigArgs{...}
//
//	or:
//
//	        nil
type SchemaConfigPtrInput interface {
	pulumi.Input

	ToSchemaConfigPtrOutput() SchemaConfigPtrOutput
	ToSchemaConfigPtrOutputWithContext(context.Context) SchemaConfigPtrOutput
}

type schemaConfigPtrType SchemaConfigArgs

func SchemaConfigPtr(v *SchemaConfigArgs) SchemaConfigPtrInput {
	return (*schemaConfigPtrType)(v)
}

func (*schemaConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SchemaConfig)(nil)).Elem()
}

func (i *schemaConfigPtrType) ToSchemaConfigPtrOutput() SchemaConfigPtrOutput {
	return i.ToSchemaConfigPtrOutputWithContext(context.Background())
}

func (i *schemaConfigPtrType) ToSchemaConfigPtrOutputWithContext(ctx context.Context) SchemaConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaConfigPtrOutput)
}

// Configuration for the FHIR BigQuery schema. Determines how the server generates the schema.
type SchemaConfigOutput struct{ *pulumi.OutputState }

func (SchemaConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SchemaConfig)(nil)).Elem()
}

func (o SchemaConfigOutput) ToSchemaConfigOutput() SchemaConfigOutput {
	return o
}

func (o SchemaConfigOutput) ToSchemaConfigOutputWithContext(ctx context.Context) SchemaConfigOutput {
	return o
}

func (o SchemaConfigOutput) ToSchemaConfigPtrOutput() SchemaConfigPtrOutput {
	return o.ToSchemaConfigPtrOutputWithContext(context.Background())
}

func (o SchemaConfigOutput) ToSchemaConfigPtrOutputWithContext(ctx context.Context) SchemaConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v SchemaConfig) *SchemaConfig {
		return &v
	}).(SchemaConfigPtrOutput)
}

// The configuration for exported BigQuery tables to be partitioned by FHIR resource's last updated time column.
func (o SchemaConfigOutput) LastUpdatedPartitionConfig() TimePartitioningPtrOutput {
	return o.ApplyT(func(v SchemaConfig) *TimePartitioning { return v.LastUpdatedPartitionConfig }).(TimePartitioningPtrOutput)
}

// The depth for all recursive structures in the output analytics schema. For example, `concept` in the CodeSystem resource is a recursive structure; when the depth is 2, the CodeSystem table will have a column called `concept.concept` but not `concept.concept.concept`. If not specified or set to 0, the server will use the default value 2. The maximum depth allowed is 5.
func (o SchemaConfigOutput) RecursiveStructureDepth() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SchemaConfig) *string { return v.RecursiveStructureDepth }).(pulumi.StringPtrOutput)
}

// Specifies the output schema type. Schema type is required.
func (o SchemaConfigOutput) SchemaType() SchemaConfigSchemaTypePtrOutput {
	return o.ApplyT(func(v SchemaConfig) *SchemaConfigSchemaType { return v.SchemaType }).(SchemaConfigSchemaTypePtrOutput)
}

type SchemaConfigPtrOutput struct{ *pulumi.OutputState }

func (SchemaConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SchemaConfig)(nil)).Elem()
}

func (o SchemaConfigPtrOutput) ToSchemaConfigPtrOutput() SchemaConfigPtrOutput {
	return o
}

func (o SchemaConfigPtrOutput) ToSchemaConfigPtrOutputWithContext(ctx context.Context) SchemaConfigPtrOutput {
	return o
}

func (o SchemaConfigPtrOutput) Elem() SchemaConfigOutput {
	return o.ApplyT(func(v *SchemaConfig) SchemaConfig {
		if v != nil {
			return *v
		}
		var ret SchemaConfig
		return ret
	}).(SchemaConfigOutput)
}

// The configuration for exported BigQuery tables to be partitioned by FHIR resource's last updated time column.
func (o SchemaConfigPtrOutput) LastUpdatedPartitionConfig() TimePartitioningPtrOutput {
	return o.ApplyT(func(v *SchemaConfig) *TimePartitioning {
		if v == nil {
			return nil
		}
		return v.LastUpdatedPartitionConfig
	}).(TimePartitioningPtrOutput)
}

// The depth for all recursive structures in the output analytics schema. For example, `concept` in the CodeSystem resource is a recursive structure; when the depth is 2, the CodeSystem table will have a column called `concept.concept` but not `concept.concept.concept`. If not specified or set to 0, the server will use the default value 2. The maximum depth allowed is 5.
func (o SchemaConfigPtrOutput) RecursiveStructureDepth() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SchemaConfig) *string {
		if v == nil {
			return nil
		}
		return v.RecursiveStructureDepth
	}).(pulumi.StringPtrOutput)
}

// Specifies the output schema type. Schema type is required.
func (o SchemaConfigPtrOutput) SchemaType() SchemaConfigSchemaTypePtrOutput {
	return o.ApplyT(func(v *SchemaConfig) *SchemaConfigSchemaType {
		if v == nil {
			return nil
		}
		return v.SchemaType
	}).(SchemaConfigSchemaTypePtrOutput)
}

// Configuration for the FHIR BigQuery schema. Determines how the server generates the schema.
type SchemaConfigResponse struct {
	// The configuration for exported BigQuery tables to be partitioned by FHIR resource's last updated time column.
	LastUpdatedPartitionConfig TimePartitioningResponse `pulumi:"lastUpdatedPartitionConfig"`
	// The depth for all recursive structures in the output analytics schema. For example, `concept` in the CodeSystem resource is a recursive structure; when the depth is 2, the CodeSystem table will have a column called `concept.concept` but not `concept.concept.concept`. If not specified or set to 0, the server will use the default value 2. The maximum depth allowed is 5.
	RecursiveStructureDepth string `pulumi:"recursiveStructureDepth"`
	// Specifies the output schema type. Schema type is required.
	SchemaType string `pulumi:"schemaType"`
}

// Configuration for the FHIR BigQuery schema. Determines how the server generates the schema.
type SchemaConfigResponseOutput struct{ *pulumi.OutputState }

func (SchemaConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SchemaConfigResponse)(nil)).Elem()
}

func (o SchemaConfigResponseOutput) ToSchemaConfigResponseOutput() SchemaConfigResponseOutput {
	return o
}

func (o SchemaConfigResponseOutput) ToSchemaConfigResponseOutputWithContext(ctx context.Context) SchemaConfigResponseOutput {
	return o
}

// The configuration for exported BigQuery tables to be partitioned by FHIR resource's last updated time column.
func (o SchemaConfigResponseOutput) LastUpdatedPartitionConfig() TimePartitioningResponseOutput {
	return o.ApplyT(func(v SchemaConfigResponse) TimePartitioningResponse { return v.LastUpdatedPartitionConfig }).(TimePartitioningResponseOutput)
}

// The depth for all recursive structures in the output analytics schema. For example, `concept` in the CodeSystem resource is a recursive structure; when the depth is 2, the CodeSystem table will have a column called `concept.concept` but not `concept.concept.concept`. If not specified or set to 0, the server will use the default value 2. The maximum depth allowed is 5.
func (o SchemaConfigResponseOutput) RecursiveStructureDepth() pulumi.StringOutput {
	return o.ApplyT(func(v SchemaConfigResponse) string { return v.RecursiveStructureDepth }).(pulumi.StringOutput)
}

// Specifies the output schema type. Schema type is required.
func (o SchemaConfigResponseOutput) SchemaType() pulumi.StringOutput {
	return o.ApplyT(func(v SchemaConfigResponse) string { return v.SchemaType }).(pulumi.StringOutput)
}

// An HL7v2 logical group construct.
type SchemaGroup struct {
	// True indicates that this is a choice group, meaning that only one of its segments can exist in a given message.
	Choice *bool `pulumi:"choice"`
	// The maximum number of times this group can be repeated. 0 or -1 means unbounded.
	MaxOccurs *int `pulumi:"maxOccurs"`
	// Nested groups and/or segments.
	Members []GroupOrSegment `pulumi:"members"`
	// The minimum number of times this group must be present/repeated.
	MinOccurs *int `pulumi:"minOccurs"`
	// The name of this group. For example, "ORDER_DETAIL".
	Name *string `pulumi:"name"`
}

// SchemaGroupInput is an input type that accepts SchemaGroupArgs and SchemaGroupOutput values.
// You can construct a concrete instance of `SchemaGroupInput` via:
//
//	SchemaGroupArgs{...}
type SchemaGroupInput interface {
	pulumi.Input

	ToSchemaGroupOutput() SchemaGroupOutput
	ToSchemaGroupOutputWithContext(context.Context) SchemaGroupOutput
}

// An HL7v2 logical group construct.
type SchemaGroupArgs struct {
	// True indicates that this is a choice group, meaning that only one of its segments can exist in a given message.
	Choice pulumi.BoolPtrInput `pulumi:"choice"`
	// The maximum number of times this group can be repeated. 0 or -1 means unbounded.
	MaxOccurs pulumi.IntPtrInput `pulumi:"maxOccurs"`
	// Nested groups and/or segments.
	Members GroupOrSegmentArrayInput `pulumi:"members"`
	// The minimum number of times this group must be present/repeated.
	MinOccurs pulumi.IntPtrInput `pulumi:"minOccurs"`
	// The name of this group. For example, "ORDER_DETAIL".
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (SchemaGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SchemaGroup)(nil)).Elem()
}

func (i SchemaGroupArgs) ToSchemaGroupOutput() SchemaGroupOutput {
	return i.ToSchemaGroupOutputWithContext(context.Background())
}

func (i SchemaGroupArgs) ToSchemaGroupOutputWithContext(ctx context.Context) SchemaGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaGroupOutput)
}

func (i SchemaGroupArgs) ToSchemaGroupPtrOutput() SchemaGroupPtrOutput {
	return i.ToSchemaGroupPtrOutputWithContext(context.Background())
}

func (i SchemaGroupArgs) ToSchemaGroupPtrOutputWithContext(ctx context.Context) SchemaGroupPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaGroupOutput).ToSchemaGroupPtrOutputWithContext(ctx)
}

// SchemaGroupPtrInput is an input type that accepts SchemaGroupArgs, SchemaGroupPtr and SchemaGroupPtrOutput values.
// You can construct a concrete instance of `SchemaGroupPtrInput` via:
//
//	        SchemaGroupArgs{...}
//
//	or:
//
//	        nil
type SchemaGroupPtrInput interface {
	pulumi.Input

	ToSchemaGroupPtrOutput() SchemaGroupPtrOutput
	ToSchemaGroupPtrOutputWithContext(context.Context) SchemaGroupPtrOutput
}

type schemaGroupPtrType SchemaGroupArgs

func SchemaGroupPtr(v *SchemaGroupArgs) SchemaGroupPtrInput {
	return (*schemaGroupPtrType)(v)
}

func (*schemaGroupPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SchemaGroup)(nil)).Elem()
}

func (i *schemaGroupPtrType) ToSchemaGroupPtrOutput() SchemaGroupPtrOutput {
	return i.ToSchemaGroupPtrOutputWithContext(context.Background())
}

func (i *schemaGroupPtrType) ToSchemaGroupPtrOutputWithContext(ctx context.Context) SchemaGroupPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaGroupPtrOutput)
}

// SchemaGroupMapInput is an input type that accepts SchemaGroupMap and SchemaGroupMapOutput values.
// You can construct a concrete instance of `SchemaGroupMapInput` via:
//
//	SchemaGroupMap{ "key": SchemaGroupArgs{...} }
type SchemaGroupMapInput interface {
	pulumi.Input

	ToSchemaGroupMapOutput() SchemaGroupMapOutput
	ToSchemaGroupMapOutputWithContext(context.Context) SchemaGroupMapOutput
}

type SchemaGroupMap map[string]SchemaGroupInput

func (SchemaGroupMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]SchemaGroup)(nil)).Elem()
}

func (i SchemaGroupMap) ToSchemaGroupMapOutput() SchemaGroupMapOutput {
	return i.ToSchemaGroupMapOutputWithContext(context.Background())
}

func (i SchemaGroupMap) ToSchemaGroupMapOutputWithContext(ctx context.Context) SchemaGroupMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaGroupMapOutput)
}

// An HL7v2 logical group construct.
type SchemaGroupOutput struct{ *pulumi.OutputState }

func (SchemaGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SchemaGroup)(nil)).Elem()
}

func (o SchemaGroupOutput) ToSchemaGroupOutput() SchemaGroupOutput {
	return o
}

func (o SchemaGroupOutput) ToSchemaGroupOutputWithContext(ctx context.Context) SchemaGroupOutput {
	return o
}

func (o SchemaGroupOutput) ToSchemaGroupPtrOutput() SchemaGroupPtrOutput {
	return o.ToSchemaGroupPtrOutputWithContext(context.Background())
}

func (o SchemaGroupOutput) ToSchemaGroupPtrOutputWithContext(ctx context.Context) SchemaGroupPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v SchemaGroup) *SchemaGroup {
		return &v
	}).(SchemaGroupPtrOutput)
}

// True indicates that this is a choice group, meaning that only one of its segments can exist in a given message.
func (o SchemaGroupOutput) Choice() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SchemaGroup) *bool { return v.Choice }).(pulumi.BoolPtrOutput)
}

// The maximum number of times this group can be repeated. 0 or -1 means unbounded.
func (o SchemaGroupOutput) MaxOccurs() pulumi.IntPtrOutput {
	return o.ApplyT(func(v SchemaGroup) *int { return v.MaxOccurs }).(pulumi.IntPtrOutput)
}

// Nested groups and/or segments.
func (o SchemaGroupOutput) Members() GroupOrSegmentArrayOutput {
	return o.ApplyT(func(v SchemaGroup) []GroupOrSegment { return v.Members }).(GroupOrSegmentArrayOutput)
}

// The minimum number of times this group must be present/repeated.
func (o SchemaGroupOutput) MinOccurs() pulumi.IntPtrOutput {
	return o.ApplyT(func(v SchemaGroup) *int { return v.MinOccurs }).(pulumi.IntPtrOutput)
}

// The name of this group. For example, "ORDER_DETAIL".
func (o SchemaGroupOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SchemaGroup) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type SchemaGroupPtrOutput struct{ *pulumi.OutputState }

func (SchemaGroupPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SchemaGroup)(nil)).Elem()
}

func (o SchemaGroupPtrOutput) ToSchemaGroupPtrOutput() SchemaGroupPtrOutput {
	return o
}

func (o SchemaGroupPtrOutput) ToSchemaGroupPtrOutputWithContext(ctx context.Context) SchemaGroupPtrOutput {
	return o
}

func (o SchemaGroupPtrOutput) Elem() SchemaGroupOutput {
	return o.ApplyT(func(v *SchemaGroup) SchemaGroup {
		if v != nil {
			return *v
		}
		var ret SchemaGroup
		return ret
	}).(SchemaGroupOutput)
}

// True indicates that this is a choice group, meaning that only one of its segments can exist in a given message.
func (o SchemaGroupPtrOutput) Choice() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SchemaGroup) *bool {
		if v == nil {
			return nil
		}
		return v.Choice
	}).(pulumi.BoolPtrOutput)
}

// The maximum number of times this group can be repeated. 0 or -1 means unbounded.
func (o SchemaGroupPtrOutput) MaxOccurs() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *SchemaGroup) *int {
		if v == nil {
			return nil
		}
		return v.MaxOccurs
	}).(pulumi.IntPtrOutput)
}

// Nested groups and/or segments.
func (o SchemaGroupPtrOutput) Members() GroupOrSegmentArrayOutput {
	return o.ApplyT(func(v *SchemaGroup) []GroupOrSegment {
		if v == nil {
			return nil
		}
		return v.Members
	}).(GroupOrSegmentArrayOutput)
}

// The minimum number of times this group must be present/repeated.
func (o SchemaGroupPtrOutput) MinOccurs() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *SchemaGroup) *int {
		if v == nil {
			return nil
		}
		return v.MinOccurs
	}).(pulumi.IntPtrOutput)
}

// The name of this group. For example, "ORDER_DETAIL".
func (o SchemaGroupPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SchemaGroup) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

type SchemaGroupMapOutput struct{ *pulumi.OutputState }

func (SchemaGroupMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]SchemaGroup)(nil)).Elem()
}

func (o SchemaGroupMapOutput) ToSchemaGroupMapOutput() SchemaGroupMapOutput {
	return o
}

func (o SchemaGroupMapOutput) ToSchemaGroupMapOutputWithContext(ctx context.Context) SchemaGroupMapOutput {
	return o
}

func (o SchemaGroupMapOutput) MapIndex(k pulumi.StringInput) SchemaGroupOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) SchemaGroup {
		return vs[0].(map[string]SchemaGroup)[vs[1].(string)]
	}).(SchemaGroupOutput)
}

// An HL7v2 logical group construct.
type SchemaGroupResponse struct {
	// True indicates that this is a choice group, meaning that only one of its segments can exist in a given message.
	Choice bool `pulumi:"choice"`
	// The maximum number of times this group can be repeated. 0 or -1 means unbounded.
	MaxOccurs int `pulumi:"maxOccurs"`
	// Nested groups and/or segments.
	Members []GroupOrSegmentResponse `pulumi:"members"`
	// The minimum number of times this group must be present/repeated.
	MinOccurs int `pulumi:"minOccurs"`
	// The name of this group. For example, "ORDER_DETAIL".
	Name string `pulumi:"name"`
}

// An HL7v2 logical group construct.
type SchemaGroupResponseOutput struct{ *pulumi.OutputState }

func (SchemaGroupResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SchemaGroupResponse)(nil)).Elem()
}

func (o SchemaGroupResponseOutput) ToSchemaGroupResponseOutput() SchemaGroupResponseOutput {
	return o
}

func (o SchemaGroupResponseOutput) ToSchemaGroupResponseOutputWithContext(ctx context.Context) SchemaGroupResponseOutput {
	return o
}

// True indicates that this is a choice group, meaning that only one of its segments can exist in a given message.
func (o SchemaGroupResponseOutput) Choice() pulumi.BoolOutput {
	return o.ApplyT(func(v SchemaGroupResponse) bool { return v.Choice }).(pulumi.BoolOutput)
}

// The maximum number of times this group can be repeated. 0 or -1 means unbounded.
func (o SchemaGroupResponseOutput) MaxOccurs() pulumi.IntOutput {
	return o.ApplyT(func(v SchemaGroupResponse) int { return v.MaxOccurs }).(pulumi.IntOutput)
}

// Nested groups and/or segments.
func (o SchemaGroupResponseOutput) Members() GroupOrSegmentResponseArrayOutput {
	return o.ApplyT(func(v SchemaGroupResponse) []GroupOrSegmentResponse { return v.Members }).(GroupOrSegmentResponseArrayOutput)
}

// The minimum number of times this group must be present/repeated.
func (o SchemaGroupResponseOutput) MinOccurs() pulumi.IntOutput {
	return o.ApplyT(func(v SchemaGroupResponse) int { return v.MinOccurs }).(pulumi.IntOutput)
}

// The name of this group. For example, "ORDER_DETAIL".
func (o SchemaGroupResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v SchemaGroupResponse) string { return v.Name }).(pulumi.StringOutput)
}

type SchemaGroupResponseMapOutput struct{ *pulumi.OutputState }

func (SchemaGroupResponseMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]SchemaGroupResponse)(nil)).Elem()
}

func (o SchemaGroupResponseMapOutput) ToSchemaGroupResponseMapOutput() SchemaGroupResponseMapOutput {
	return o
}

func (o SchemaGroupResponseMapOutput) ToSchemaGroupResponseMapOutputWithContext(ctx context.Context) SchemaGroupResponseMapOutput {
	return o
}

func (o SchemaGroupResponseMapOutput) MapIndex(k pulumi.StringInput) SchemaGroupResponseOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) SchemaGroupResponse {
		return vs[0].(map[string]SchemaGroupResponse)[vs[1].(string)]
	}).(SchemaGroupResponseOutput)
}

// A schema package contains a set of schemas and type definitions.
type SchemaPackage struct {
	// Flag to ignore all min_occurs restrictions in the schema. This means that incoming messages can omit any group, segment, field, component, or subcomponent.
	IgnoreMinOccurs *bool `pulumi:"ignoreMinOccurs"`
	// Schema configs that are layered based on their VersionSources that match the incoming message. Schema configs present in higher indices override those in lower indices with the same message type and trigger event if their VersionSources all match an incoming message.
	Schemas []Hl7SchemaConfig `pulumi:"schemas"`
	// Determines how messages that fail to parse are handled.
	SchematizedParsingType *SchemaPackageSchematizedParsingType `pulumi:"schematizedParsingType"`
	// Schema type definitions that are layered based on their VersionSources that match the incoming message. Type definitions present in higher indices override those in lower indices with the same type name if their VersionSources all match an incoming message.
	Types []Hl7TypesConfig `pulumi:"types"`
	// Determines how unexpected segments (segments not matched to the schema) are handled.
	UnexpectedSegmentHandling *SchemaPackageUnexpectedSegmentHandling `pulumi:"unexpectedSegmentHandling"`
}

// SchemaPackageInput is an input type that accepts SchemaPackageArgs and SchemaPackageOutput values.
// You can construct a concrete instance of `SchemaPackageInput` via:
//
//	SchemaPackageArgs{...}
type SchemaPackageInput interface {
	pulumi.Input

	ToSchemaPackageOutput() SchemaPackageOutput
	ToSchemaPackageOutputWithContext(context.Context) SchemaPackageOutput
}

// A schema package contains a set of schemas and type definitions.
type SchemaPackageArgs struct {
	// Flag to ignore all min_occurs restrictions in the schema. This means that incoming messages can omit any group, segment, field, component, or subcomponent.
	IgnoreMinOccurs pulumi.BoolPtrInput `pulumi:"ignoreMinOccurs"`
	// Schema configs that are layered based on their VersionSources that match the incoming message. Schema configs present in higher indices override those in lower indices with the same message type and trigger event if their VersionSources all match an incoming message.
	Schemas Hl7SchemaConfigArrayInput `pulumi:"schemas"`
	// Determines how messages that fail to parse are handled.
	SchematizedParsingType SchemaPackageSchematizedParsingTypePtrInput `pulumi:"schematizedParsingType"`
	// Schema type definitions that are layered based on their VersionSources that match the incoming message. Type definitions present in higher indices override those in lower indices with the same type name if their VersionSources all match an incoming message.
	Types Hl7TypesConfigArrayInput `pulumi:"types"`
	// Determines how unexpected segments (segments not matched to the schema) are handled.
	UnexpectedSegmentHandling SchemaPackageUnexpectedSegmentHandlingPtrInput `pulumi:"unexpectedSegmentHandling"`
}

func (SchemaPackageArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SchemaPackage)(nil)).Elem()
}

func (i SchemaPackageArgs) ToSchemaPackageOutput() SchemaPackageOutput {
	return i.ToSchemaPackageOutputWithContext(context.Background())
}

func (i SchemaPackageArgs) ToSchemaPackageOutputWithContext(ctx context.Context) SchemaPackageOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaPackageOutput)
}

func (i SchemaPackageArgs) ToSchemaPackagePtrOutput() SchemaPackagePtrOutput {
	return i.ToSchemaPackagePtrOutputWithContext(context.Background())
}

func (i SchemaPackageArgs) ToSchemaPackagePtrOutputWithContext(ctx context.Context) SchemaPackagePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaPackageOutput).ToSchemaPackagePtrOutputWithContext(ctx)
}

// SchemaPackagePtrInput is an input type that accepts SchemaPackageArgs, SchemaPackagePtr and SchemaPackagePtrOutput values.
// You can construct a concrete instance of `SchemaPackagePtrInput` via:
//
//	        SchemaPackageArgs{...}
//
//	or:
//
//	        nil
type SchemaPackagePtrInput interface {
	pulumi.Input

	ToSchemaPackagePtrOutput() SchemaPackagePtrOutput
	ToSchemaPackagePtrOutputWithContext(context.Context) SchemaPackagePtrOutput
}

type schemaPackagePtrType SchemaPackageArgs

func SchemaPackagePtr(v *SchemaPackageArgs) SchemaPackagePtrInput {
	return (*schemaPackagePtrType)(v)
}

func (*schemaPackagePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SchemaPackage)(nil)).Elem()
}

func (i *schemaPackagePtrType) ToSchemaPackagePtrOutput() SchemaPackagePtrOutput {
	return i.ToSchemaPackagePtrOutputWithContext(context.Background())
}

func (i *schemaPackagePtrType) ToSchemaPackagePtrOutputWithContext(ctx context.Context) SchemaPackagePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaPackagePtrOutput)
}

// A schema package contains a set of schemas and type definitions.
type SchemaPackageOutput struct{ *pulumi.OutputState }

func (SchemaPackageOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SchemaPackage)(nil)).Elem()
}

func (o SchemaPackageOutput) ToSchemaPackageOutput() SchemaPackageOutput {
	return o
}

func (o SchemaPackageOutput) ToSchemaPackageOutputWithContext(ctx context.Context) SchemaPackageOutput {
	return o
}

func (o SchemaPackageOutput) ToSchemaPackagePtrOutput() SchemaPackagePtrOutput {
	return o.ToSchemaPackagePtrOutputWithContext(context.Background())
}

func (o SchemaPackageOutput) ToSchemaPackagePtrOutputWithContext(ctx context.Context) SchemaPackagePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v SchemaPackage) *SchemaPackage {
		return &v
	}).(SchemaPackagePtrOutput)
}

// Flag to ignore all min_occurs restrictions in the schema. This means that incoming messages can omit any group, segment, field, component, or subcomponent.
func (o SchemaPackageOutput) IgnoreMinOccurs() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SchemaPackage) *bool { return v.IgnoreMinOccurs }).(pulumi.BoolPtrOutput)
}

// Schema configs that are layered based on their VersionSources that match the incoming message. Schema configs present in higher indices override those in lower indices with the same message type and trigger event if their VersionSources all match an incoming message.
func (o SchemaPackageOutput) Schemas() Hl7SchemaConfigArrayOutput {
	return o.ApplyT(func(v SchemaPackage) []Hl7SchemaConfig { return v.Schemas }).(Hl7SchemaConfigArrayOutput)
}

// Determines how messages that fail to parse are handled.
func (o SchemaPackageOutput) SchematizedParsingType() SchemaPackageSchematizedParsingTypePtrOutput {
	return o.ApplyT(func(v SchemaPackage) *SchemaPackageSchematizedParsingType { return v.SchematizedParsingType }).(SchemaPackageSchematizedParsingTypePtrOutput)
}

// Schema type definitions that are layered based on their VersionSources that match the incoming message. Type definitions present in higher indices override those in lower indices with the same type name if their VersionSources all match an incoming message.
func (o SchemaPackageOutput) Types() Hl7TypesConfigArrayOutput {
	return o.ApplyT(func(v SchemaPackage) []Hl7TypesConfig { return v.Types }).(Hl7TypesConfigArrayOutput)
}

// Determines how unexpected segments (segments not matched to the schema) are handled.
func (o SchemaPackageOutput) UnexpectedSegmentHandling() SchemaPackageUnexpectedSegmentHandlingPtrOutput {
	return o.ApplyT(func(v SchemaPackage) *SchemaPackageUnexpectedSegmentHandling { return v.UnexpectedSegmentHandling }).(SchemaPackageUnexpectedSegmentHandlingPtrOutput)
}

type SchemaPackagePtrOutput struct{ *pulumi.OutputState }

func (SchemaPackagePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SchemaPackage)(nil)).Elem()
}

func (o SchemaPackagePtrOutput) ToSchemaPackagePtrOutput() SchemaPackagePtrOutput {
	return o
}

func (o SchemaPackagePtrOutput) ToSchemaPackagePtrOutputWithContext(ctx context.Context) SchemaPackagePtrOutput {
	return o
}

func (o SchemaPackagePtrOutput) Elem() SchemaPackageOutput {
	return o.ApplyT(func(v *SchemaPackage) SchemaPackage {
		if v != nil {
			return *v
		}
		var ret SchemaPackage
		return ret
	}).(SchemaPackageOutput)
}

// Flag to ignore all min_occurs restrictions in the schema. This means that incoming messages can omit any group, segment, field, component, or subcomponent.
func (o SchemaPackagePtrOutput) IgnoreMinOccurs() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SchemaPackage) *bool {
		if v == nil {
			return nil
		}
		return v.IgnoreMinOccurs
	}).(pulumi.BoolPtrOutput)
}

// Schema configs that are layered based on their VersionSources that match the incoming message. Schema configs present in higher indices override those in lower indices with the same message type and trigger event if their VersionSources all match an incoming message.
func (o SchemaPackagePtrOutput) Schemas() Hl7SchemaConfigArrayOutput {
	return o.ApplyT(func(v *SchemaPackage) []Hl7SchemaConfig {
		if v == nil {
			return nil
		}
		return v.Schemas
	}).(Hl7SchemaConfigArrayOutput)
}

// Determines how messages that fail to parse are handled.
func (o SchemaPackagePtrOutput) SchematizedParsingType() SchemaPackageSchematizedParsingTypePtrOutput {
	return o.ApplyT(func(v *SchemaPackage) *SchemaPackageSchematizedParsingType {
		if v == nil {
			return nil
		}
		return v.SchematizedParsingType
	}).(SchemaPackageSchematizedParsingTypePtrOutput)
}

// Schema type definitions that are layered based on their VersionSources that match the incoming message. Type definitions present in higher indices override those in lower indices with the same type name if their VersionSources all match an incoming message.
func (o SchemaPackagePtrOutput) Types() Hl7TypesConfigArrayOutput {
	return o.ApplyT(func(v *SchemaPackage) []Hl7TypesConfig {
		if v == nil {
			return nil
		}
		return v.Types
	}).(Hl7TypesConfigArrayOutput)
}

// Determines how unexpected segments (segments not matched to the schema) are handled.
func (o SchemaPackagePtrOutput) UnexpectedSegmentHandling() SchemaPackageUnexpectedSegmentHandlingPtrOutput {
	return o.ApplyT(func(v *SchemaPackage) *SchemaPackageUnexpectedSegmentHandling {
		if v == nil {
			return nil
		}
		return v.UnexpectedSegmentHandling
	}).(SchemaPackageUnexpectedSegmentHandlingPtrOutput)
}

// A schema package contains a set of schemas and type definitions.
type SchemaPackageResponse struct {
	// Flag to ignore all min_occurs restrictions in the schema. This means that incoming messages can omit any group, segment, field, component, or subcomponent.
	IgnoreMinOccurs bool `pulumi:"ignoreMinOccurs"`
	// Schema configs that are layered based on their VersionSources that match the incoming message. Schema configs present in higher indices override those in lower indices with the same message type and trigger event if their VersionSources all match an incoming message.
	Schemas []Hl7SchemaConfigResponse `pulumi:"schemas"`
	// Determines how messages that fail to parse are handled.
	SchematizedParsingType string `pulumi:"schematizedParsingType"`
	// Schema type definitions that are layered based on their VersionSources that match the incoming message. Type definitions present in higher indices override those in lower indices with the same type name if their VersionSources all match an incoming message.
	Types []Hl7TypesConfigResponse `pulumi:"types"`
	// Determines how unexpected segments (segments not matched to the schema) are handled.
	UnexpectedSegmentHandling string `pulumi:"unexpectedSegmentHandling"`
}

// A schema package contains a set of schemas and type definitions.
type SchemaPackageResponseOutput struct{ *pulumi.OutputState }

func (SchemaPackageResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SchemaPackageResponse)(nil)).Elem()
}

func (o SchemaPackageResponseOutput) ToSchemaPackageResponseOutput() SchemaPackageResponseOutput {
	return o
}

func (o SchemaPackageResponseOutput) ToSchemaPackageResponseOutputWithContext(ctx context.Context) SchemaPackageResponseOutput {
	return o
}

// Flag to ignore all min_occurs restrictions in the schema. This means that incoming messages can omit any group, segment, field, component, or subcomponent.
func (o SchemaPackageResponseOutput) IgnoreMinOccurs() pulumi.BoolOutput {
	return o.ApplyT(func(v SchemaPackageResponse) bool { return v.IgnoreMinOccurs }).(pulumi.BoolOutput)
}

// Schema configs that are layered based on their VersionSources that match the incoming message. Schema configs present in higher indices override those in lower indices with the same message type and trigger event if their VersionSources all match an incoming message.
func (o SchemaPackageResponseOutput) Schemas() Hl7SchemaConfigResponseArrayOutput {
	return o.ApplyT(func(v SchemaPackageResponse) []Hl7SchemaConfigResponse { return v.Schemas }).(Hl7SchemaConfigResponseArrayOutput)
}

// Determines how messages that fail to parse are handled.
func (o SchemaPackageResponseOutput) SchematizedParsingType() pulumi.StringOutput {
	return o.ApplyT(func(v SchemaPackageResponse) string { return v.SchematizedParsingType }).(pulumi.StringOutput)
}

// Schema type definitions that are layered based on their VersionSources that match the incoming message. Type definitions present in higher indices override those in lower indices with the same type name if their VersionSources all match an incoming message.
func (o SchemaPackageResponseOutput) Types() Hl7TypesConfigResponseArrayOutput {
	return o.ApplyT(func(v SchemaPackageResponse) []Hl7TypesConfigResponse { return v.Types }).(Hl7TypesConfigResponseArrayOutput)
}

// Determines how unexpected segments (segments not matched to the schema) are handled.
func (o SchemaPackageResponseOutput) UnexpectedSegmentHandling() pulumi.StringOutput {
	return o.ApplyT(func(v SchemaPackageResponse) string { return v.UnexpectedSegmentHandling }).(pulumi.StringOutput)
}

// An HL7v2 Segment.
type SchemaSegment struct {
	// The maximum number of times this segment can be present in this group. 0 or -1 means unbounded.
	MaxOccurs *int `pulumi:"maxOccurs"`
	// The minimum number of times this segment can be present in this group.
	MinOccurs *int `pulumi:"minOccurs"`
	// The Segment type. For example, "PID".
	Type *string `pulumi:"type"`
}

// SchemaSegmentInput is an input type that accepts SchemaSegmentArgs and SchemaSegmentOutput values.
// You can construct a concrete instance of `SchemaSegmentInput` via:
//
//	SchemaSegmentArgs{...}
type SchemaSegmentInput interface {
	pulumi.Input

	ToSchemaSegmentOutput() SchemaSegmentOutput
	ToSchemaSegmentOutputWithContext(context.Context) SchemaSegmentOutput
}

// An HL7v2 Segment.
type SchemaSegmentArgs struct {
	// The maximum number of times this segment can be present in this group. 0 or -1 means unbounded.
	MaxOccurs pulumi.IntPtrInput `pulumi:"maxOccurs"`
	// The minimum number of times this segment can be present in this group.
	MinOccurs pulumi.IntPtrInput `pulumi:"minOccurs"`
	// The Segment type. For example, "PID".
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (SchemaSegmentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SchemaSegment)(nil)).Elem()
}

func (i SchemaSegmentArgs) ToSchemaSegmentOutput() SchemaSegmentOutput {
	return i.ToSchemaSegmentOutputWithContext(context.Background())
}

func (i SchemaSegmentArgs) ToSchemaSegmentOutputWithContext(ctx context.Context) SchemaSegmentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaSegmentOutput)
}

func (i SchemaSegmentArgs) ToSchemaSegmentPtrOutput() SchemaSegmentPtrOutput {
	return i.ToSchemaSegmentPtrOutputWithContext(context.Background())
}

func (i SchemaSegmentArgs) ToSchemaSegmentPtrOutputWithContext(ctx context.Context) SchemaSegmentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaSegmentOutput).ToSchemaSegmentPtrOutputWithContext(ctx)
}

// SchemaSegmentPtrInput is an input type that accepts SchemaSegmentArgs, SchemaSegmentPtr and SchemaSegmentPtrOutput values.
// You can construct a concrete instance of `SchemaSegmentPtrInput` via:
//
//	        SchemaSegmentArgs{...}
//
//	or:
//
//	        nil
type SchemaSegmentPtrInput interface {
	pulumi.Input

	ToSchemaSegmentPtrOutput() SchemaSegmentPtrOutput
	ToSchemaSegmentPtrOutputWithContext(context.Context) SchemaSegmentPtrOutput
}

type schemaSegmentPtrType SchemaSegmentArgs

func SchemaSegmentPtr(v *SchemaSegmentArgs) SchemaSegmentPtrInput {
	return (*schemaSegmentPtrType)(v)
}

func (*schemaSegmentPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SchemaSegment)(nil)).Elem()
}

func (i *schemaSegmentPtrType) ToSchemaSegmentPtrOutput() SchemaSegmentPtrOutput {
	return i.ToSchemaSegmentPtrOutputWithContext(context.Background())
}

func (i *schemaSegmentPtrType) ToSchemaSegmentPtrOutputWithContext(ctx context.Context) SchemaSegmentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaSegmentPtrOutput)
}

// An HL7v2 Segment.
type SchemaSegmentOutput struct{ *pulumi.OutputState }

func (SchemaSegmentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SchemaSegment)(nil)).Elem()
}

func (o SchemaSegmentOutput) ToSchemaSegmentOutput() SchemaSegmentOutput {
	return o
}

func (o SchemaSegmentOutput) ToSchemaSegmentOutputWithContext(ctx context.Context) SchemaSegmentOutput {
	return o
}

func (o SchemaSegmentOutput) ToSchemaSegmentPtrOutput() SchemaSegmentPtrOutput {
	return o.ToSchemaSegmentPtrOutputWithContext(context.Background())
}

func (o SchemaSegmentOutput) ToSchemaSegmentPtrOutputWithContext(ctx context.Context) SchemaSegmentPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v SchemaSegment) *SchemaSegment {
		return &v
	}).(SchemaSegmentPtrOutput)
}

// The maximum number of times this segment can be present in this group. 0 or -1 means unbounded.
func (o SchemaSegmentOutput) MaxOccurs() pulumi.IntPtrOutput {
	return o.ApplyT(func(v SchemaSegment) *int { return v.MaxOccurs }).(pulumi.IntPtrOutput)
}

// The minimum number of times this segment can be present in this group.
func (o SchemaSegmentOutput) MinOccurs() pulumi.IntPtrOutput {
	return o.ApplyT(func(v SchemaSegment) *int { return v.MinOccurs }).(pulumi.IntPtrOutput)
}

// The Segment type. For example, "PID".
func (o SchemaSegmentOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SchemaSegment) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type SchemaSegmentPtrOutput struct{ *pulumi.OutputState }

func (SchemaSegmentPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SchemaSegment)(nil)).Elem()
}

func (o SchemaSegmentPtrOutput) ToSchemaSegmentPtrOutput() SchemaSegmentPtrOutput {
	return o
}

func (o SchemaSegmentPtrOutput) ToSchemaSegmentPtrOutputWithContext(ctx context.Context) SchemaSegmentPtrOutput {
	return o
}

func (o SchemaSegmentPtrOutput) Elem() SchemaSegmentOutput {
	return o.ApplyT(func(v *SchemaSegment) SchemaSegment {
		if v != nil {
			return *v
		}
		var ret SchemaSegment
		return ret
	}).(SchemaSegmentOutput)
}

// The maximum number of times this segment can be present in this group. 0 or -1 means unbounded.
func (o SchemaSegmentPtrOutput) MaxOccurs() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *SchemaSegment) *int {
		if v == nil {
			return nil
		}
		return v.MaxOccurs
	}).(pulumi.IntPtrOutput)
}

// The minimum number of times this segment can be present in this group.
func (o SchemaSegmentPtrOutput) MinOccurs() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *SchemaSegment) *int {
		if v == nil {
			return nil
		}
		return v.MinOccurs
	}).(pulumi.IntPtrOutput)
}

// The Segment type. For example, "PID".
func (o SchemaSegmentPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SchemaSegment) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// An HL7v2 Segment.
type SchemaSegmentResponse struct {
	// The maximum number of times this segment can be present in this group. 0 or -1 means unbounded.
	MaxOccurs int `pulumi:"maxOccurs"`
	// The minimum number of times this segment can be present in this group.
	MinOccurs int `pulumi:"minOccurs"`
	// The Segment type. For example, "PID".
	Type string `pulumi:"type"`
}

// An HL7v2 Segment.
type SchemaSegmentResponseOutput struct{ *pulumi.OutputState }

func (SchemaSegmentResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SchemaSegmentResponse)(nil)).Elem()
}

func (o SchemaSegmentResponseOutput) ToSchemaSegmentResponseOutput() SchemaSegmentResponseOutput {
	return o
}

func (o SchemaSegmentResponseOutput) ToSchemaSegmentResponseOutputWithContext(ctx context.Context) SchemaSegmentResponseOutput {
	return o
}

// The maximum number of times this segment can be present in this group. 0 or -1 means unbounded.
func (o SchemaSegmentResponseOutput) MaxOccurs() pulumi.IntOutput {
	return o.ApplyT(func(v SchemaSegmentResponse) int { return v.MaxOccurs }).(pulumi.IntOutput)
}

// The minimum number of times this segment can be present in this group.
func (o SchemaSegmentResponseOutput) MinOccurs() pulumi.IntOutput {
	return o.ApplyT(func(v SchemaSegmentResponse) int { return v.MinOccurs }).(pulumi.IntOutput)
}

// The Segment type. For example, "PID".
func (o SchemaSegmentResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v SchemaSegmentResponse) string { return v.Type }).(pulumi.StringOutput)
}

// The content of an HL7v2 message in a structured format as specified by a schema.
type SchematizedData struct {
	// JSON output of the parser.
	Data *string `pulumi:"data"`
	// The error output of the parser.
	Error *string `pulumi:"error"`
}

// SchematizedDataInput is an input type that accepts SchematizedDataArgs and SchematizedDataOutput values.
// You can construct a concrete instance of `SchematizedDataInput` via:
//
//	SchematizedDataArgs{...}
type SchematizedDataInput interface {
	pulumi.Input

	ToSchematizedDataOutput() SchematizedDataOutput
	ToSchematizedDataOutputWithContext(context.Context) SchematizedDataOutput
}

// The content of an HL7v2 message in a structured format as specified by a schema.
type SchematizedDataArgs struct {
	// JSON output of the parser.
	Data pulumi.StringPtrInput `pulumi:"data"`
	// The error output of the parser.
	Error pulumi.StringPtrInput `pulumi:"error"`
}

func (SchematizedDataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SchematizedData)(nil)).Elem()
}

func (i SchematizedDataArgs) ToSchematizedDataOutput() SchematizedDataOutput {
	return i.ToSchematizedDataOutputWithContext(context.Background())
}

func (i SchematizedDataArgs) ToSchematizedDataOutputWithContext(ctx context.Context) SchematizedDataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchematizedDataOutput)
}

func (i SchematizedDataArgs) ToSchematizedDataPtrOutput() SchematizedDataPtrOutput {
	return i.ToSchematizedDataPtrOutputWithContext(context.Background())
}

func (i SchematizedDataArgs) ToSchematizedDataPtrOutputWithContext(ctx context.Context) SchematizedDataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchematizedDataOutput).ToSchematizedDataPtrOutputWithContext(ctx)
}

// SchematizedDataPtrInput is an input type that accepts SchematizedDataArgs, SchematizedDataPtr and SchematizedDataPtrOutput values.
// You can construct a concrete instance of `SchematizedDataPtrInput` via:
//
//	        SchematizedDataArgs{...}
//
//	or:
//
//	        nil
type SchematizedDataPtrInput interface {
	pulumi.Input

	ToSchematizedDataPtrOutput() SchematizedDataPtrOutput
	ToSchematizedDataPtrOutputWithContext(context.Context) SchematizedDataPtrOutput
}

type schematizedDataPtrType SchematizedDataArgs

func SchematizedDataPtr(v *SchematizedDataArgs) SchematizedDataPtrInput {
	return (*schematizedDataPtrType)(v)
}

func (*schematizedDataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SchematizedData)(nil)).Elem()
}

func (i *schematizedDataPtrType) ToSchematizedDataPtrOutput() SchematizedDataPtrOutput {
	return i.ToSchematizedDataPtrOutputWithContext(context.Background())
}

func (i *schematizedDataPtrType) ToSchematizedDataPtrOutputWithContext(ctx context.Context) SchematizedDataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchematizedDataPtrOutput)
}

// The content of an HL7v2 message in a structured format as specified by a schema.
type SchematizedDataOutput struct{ *pulumi.OutputState }

func (SchematizedDataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SchematizedData)(nil)).Elem()
}

func (o SchematizedDataOutput) ToSchematizedDataOutput() SchematizedDataOutput {
	return o
}

func (o SchematizedDataOutput) ToSchematizedDataOutputWithContext(ctx context.Context) SchematizedDataOutput {
	return o
}

func (o SchematizedDataOutput) ToSchematizedDataPtrOutput() SchematizedDataPtrOutput {
	return o.ToSchematizedDataPtrOutputWithContext(context.Background())
}

func (o SchematizedDataOutput) ToSchematizedDataPtrOutputWithContext(ctx context.Context) SchematizedDataPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v SchematizedData) *SchematizedData {
		return &v
	}).(SchematizedDataPtrOutput)
}

// JSON output of the parser.
func (o SchematizedDataOutput) Data() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SchematizedData) *string { return v.Data }).(pulumi.StringPtrOutput)
}

// The error output of the parser.
func (o SchematizedDataOutput) Error() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SchematizedData) *string { return v.Error }).(pulumi.StringPtrOutput)
}

type SchematizedDataPtrOutput struct{ *pulumi.OutputState }

func (SchematizedDataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SchematizedData)(nil)).Elem()
}

func (o SchematizedDataPtrOutput) ToSchematizedDataPtrOutput() SchematizedDataPtrOutput {
	return o
}

func (o SchematizedDataPtrOutput) ToSchematizedDataPtrOutputWithContext(ctx context.Context) SchematizedDataPtrOutput {
	return o
}

func (o SchematizedDataPtrOutput) Elem() SchematizedDataOutput {
	return o.ApplyT(func(v *SchematizedData) SchematizedData {
		if v != nil {
			return *v
		}
		var ret SchematizedData
		return ret
	}).(SchematizedDataOutput)
}

// JSON output of the parser.
func (o SchematizedDataPtrOutput) Data() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SchematizedData) *string {
		if v == nil {
			return nil
		}
		return v.Data
	}).(pulumi.StringPtrOutput)
}

// The error output of the parser.
func (o SchematizedDataPtrOutput) Error() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SchematizedData) *string {
		if v == nil {
			return nil
		}
		return v.Error
	}).(pulumi.StringPtrOutput)
}

// The content of an HL7v2 message in a structured format as specified by a schema.
type SchematizedDataResponse struct {
	// JSON output of the parser.
	Data string `pulumi:"data"`
	// The error output of the parser.
	Error string `pulumi:"error"`
}

// The content of an HL7v2 message in a structured format as specified by a schema.
type SchematizedDataResponseOutput struct{ *pulumi.OutputState }

func (SchematizedDataResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SchematizedDataResponse)(nil)).Elem()
}

func (o SchematizedDataResponseOutput) ToSchematizedDataResponseOutput() SchematizedDataResponseOutput {
	return o
}

func (o SchematizedDataResponseOutput) ToSchematizedDataResponseOutputWithContext(ctx context.Context) SchematizedDataResponseOutput {
	return o
}

// JSON output of the parser.
func (o SchematizedDataResponseOutput) Data() pulumi.StringOutput {
	return o.ApplyT(func(v SchematizedDataResponse) string { return v.Data }).(pulumi.StringOutput)
}

// The error output of the parser.
func (o SchematizedDataResponseOutput) Error() pulumi.StringOutput {
	return o.ApplyT(func(v SchematizedDataResponse) string { return v.Error }).(pulumi.StringOutput)
}

// Contains the configuration for FHIR search.
type SearchConfig struct {
	// A list of search parameters in this FHIR store that are used to configure this FHIR store.
	SearchParameters []SearchParameter `pulumi:"searchParameters"`
}

// SearchConfigInput is an input type that accepts SearchConfigArgs and SearchConfigOutput values.
// You can construct a concrete instance of `SearchConfigInput` via:
//
//	SearchConfigArgs{...}
type SearchConfigInput interface {
	pulumi.Input

	ToSearchConfigOutput() SearchConfigOutput
	ToSearchConfigOutputWithContext(context.Context) SearchConfigOutput
}

// Contains the configuration for FHIR search.
type SearchConfigArgs struct {
	// A list of search parameters in this FHIR store that are used to configure this FHIR store.
	SearchParameters SearchParameterArrayInput `pulumi:"searchParameters"`
}

func (SearchConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SearchConfig)(nil)).Elem()
}

func (i SearchConfigArgs) ToSearchConfigOutput() SearchConfigOutput {
	return i.ToSearchConfigOutputWithContext(context.Background())
}

func (i SearchConfigArgs) ToSearchConfigOutputWithContext(ctx context.Context) SearchConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SearchConfigOutput)
}

func (i SearchConfigArgs) ToSearchConfigPtrOutput() SearchConfigPtrOutput {
	return i.ToSearchConfigPtrOutputWithContext(context.Background())
}

func (i SearchConfigArgs) ToSearchConfigPtrOutputWithContext(ctx context.Context) SearchConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SearchConfigOutput).ToSearchConfigPtrOutputWithContext(ctx)
}

// SearchConfigPtrInput is an input type that accepts SearchConfigArgs, SearchConfigPtr and SearchConfigPtrOutput values.
// You can construct a concrete instance of `SearchConfigPtrInput` via:
//
//	        SearchConfigArgs{...}
//
//	or:
//
//	        nil
type SearchConfigPtrInput interface {
	pulumi.Input

	ToSearchConfigPtrOutput() SearchConfigPtrOutput
	ToSearchConfigPtrOutputWithContext(context.Context) SearchConfigPtrOutput
}

type searchConfigPtrType SearchConfigArgs

func SearchConfigPtr(v *SearchConfigArgs) SearchConfigPtrInput {
	return (*searchConfigPtrType)(v)
}

func (*searchConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SearchConfig)(nil)).Elem()
}

func (i *searchConfigPtrType) ToSearchConfigPtrOutput() SearchConfigPtrOutput {
	return i.ToSearchConfigPtrOutputWithContext(context.Background())
}

func (i *searchConfigPtrType) ToSearchConfigPtrOutputWithContext(ctx context.Context) SearchConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SearchConfigPtrOutput)
}

// Contains the configuration for FHIR search.
type SearchConfigOutput struct{ *pulumi.OutputState }

func (SearchConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SearchConfig)(nil)).Elem()
}

func (o SearchConfigOutput) ToSearchConfigOutput() SearchConfigOutput {
	return o
}

func (o SearchConfigOutput) ToSearchConfigOutputWithContext(ctx context.Context) SearchConfigOutput {
	return o
}

func (o SearchConfigOutput) ToSearchConfigPtrOutput() SearchConfigPtrOutput {
	return o.ToSearchConfigPtrOutputWithContext(context.Background())
}

func (o SearchConfigOutput) ToSearchConfigPtrOutputWithContext(ctx context.Context) SearchConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v SearchConfig) *SearchConfig {
		return &v
	}).(SearchConfigPtrOutput)
}

// A list of search parameters in this FHIR store that are used to configure this FHIR store.
func (o SearchConfigOutput) SearchParameters() SearchParameterArrayOutput {
	return o.ApplyT(func(v SearchConfig) []SearchParameter { return v.SearchParameters }).(SearchParameterArrayOutput)
}

type SearchConfigPtrOutput struct{ *pulumi.OutputState }

func (SearchConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SearchConfig)(nil)).Elem()
}

func (o SearchConfigPtrOutput) ToSearchConfigPtrOutput() SearchConfigPtrOutput {
	return o
}

func (o SearchConfigPtrOutput) ToSearchConfigPtrOutputWithContext(ctx context.Context) SearchConfigPtrOutput {
	return o
}

func (o SearchConfigPtrOutput) Elem() SearchConfigOutput {
	return o.ApplyT(func(v *SearchConfig) SearchConfig {
		if v != nil {
			return *v
		}
		var ret SearchConfig
		return ret
	}).(SearchConfigOutput)
}

// A list of search parameters in this FHIR store that are used to configure this FHIR store.
func (o SearchConfigPtrOutput) SearchParameters() SearchParameterArrayOutput {
	return o.ApplyT(func(v *SearchConfig) []SearchParameter {
		if v == nil {
			return nil
		}
		return v.SearchParameters
	}).(SearchParameterArrayOutput)
}

// Contains the configuration for FHIR search.
type SearchConfigResponse struct {
	// A list of search parameters in this FHIR store that are used to configure this FHIR store.
	SearchParameters []SearchParameterResponse `pulumi:"searchParameters"`
}

// Contains the configuration for FHIR search.
type SearchConfigResponseOutput struct{ *pulumi.OutputState }

func (SearchConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SearchConfigResponse)(nil)).Elem()
}

func (o SearchConfigResponseOutput) ToSearchConfigResponseOutput() SearchConfigResponseOutput {
	return o
}

func (o SearchConfigResponseOutput) ToSearchConfigResponseOutputWithContext(ctx context.Context) SearchConfigResponseOutput {
	return o
}

// A list of search parameters in this FHIR store that are used to configure this FHIR store.
func (o SearchConfigResponseOutput) SearchParameters() SearchParameterResponseArrayOutput {
	return o.ApplyT(func(v SearchConfigResponse) []SearchParameterResponse { return v.SearchParameters }).(SearchParameterResponseArrayOutput)
}

// Contains the versioned name and the URL for one SearchParameter.
type SearchParameter struct {
	// The canonical url of the search parameter resource.
	CanonicalUrl *string `pulumi:"canonicalUrl"`
	// The versioned name of the search parameter resource. The format is projects/{project-id}/locations/{location}/datasets/{dataset-id}/fhirStores/{fhirStore-id}/fhir/SearchParameter/{resource-id}/_history/{version-id} For fhir stores with disable_resource_versioning=true, the format is projects/{project-id}/locations/{location}/datasets/{dataset-id}/fhirStores/{fhirStore-id}/fhir/SearchParameter/{resource-id}/
	Parameter *string `pulumi:"parameter"`
}

// SearchParameterInput is an input type that accepts SearchParameterArgs and SearchParameterOutput values.
// You can construct a concrete instance of `SearchParameterInput` via:
//
//	SearchParameterArgs{...}
type SearchParameterInput interface {
	pulumi.Input

	ToSearchParameterOutput() SearchParameterOutput
	ToSearchParameterOutputWithContext(context.Context) SearchParameterOutput
}

// Contains the versioned name and the URL for one SearchParameter.
type SearchParameterArgs struct {
	// The canonical url of the search parameter resource.
	CanonicalUrl pulumi.StringPtrInput `pulumi:"canonicalUrl"`
	// The versioned name of the search parameter resource. The format is projects/{project-id}/locations/{location}/datasets/{dataset-id}/fhirStores/{fhirStore-id}/fhir/SearchParameter/{resource-id}/_history/{version-id} For fhir stores with disable_resource_versioning=true, the format is projects/{project-id}/locations/{location}/datasets/{dataset-id}/fhirStores/{fhirStore-id}/fhir/SearchParameter/{resource-id}/
	Parameter pulumi.StringPtrInput `pulumi:"parameter"`
}

func (SearchParameterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SearchParameter)(nil)).Elem()
}

func (i SearchParameterArgs) ToSearchParameterOutput() SearchParameterOutput {
	return i.ToSearchParameterOutputWithContext(context.Background())
}

func (i SearchParameterArgs) ToSearchParameterOutputWithContext(ctx context.Context) SearchParameterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SearchParameterOutput)
}

// SearchParameterArrayInput is an input type that accepts SearchParameterArray and SearchParameterArrayOutput values.
// You can construct a concrete instance of `SearchParameterArrayInput` via:
//
//	SearchParameterArray{ SearchParameterArgs{...} }
type SearchParameterArrayInput interface {
	pulumi.Input

	ToSearchParameterArrayOutput() SearchParameterArrayOutput
	ToSearchParameterArrayOutputWithContext(context.Context) SearchParameterArrayOutput
}

type SearchParameterArray []SearchParameterInput

func (SearchParameterArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SearchParameter)(nil)).Elem()
}

func (i SearchParameterArray) ToSearchParameterArrayOutput() SearchParameterArrayOutput {
	return i.ToSearchParameterArrayOutputWithContext(context.Background())
}

func (i SearchParameterArray) ToSearchParameterArrayOutputWithContext(ctx context.Context) SearchParameterArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SearchParameterArrayOutput)
}

// Contains the versioned name and the URL for one SearchParameter.
type SearchParameterOutput struct{ *pulumi.OutputState }

func (SearchParameterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SearchParameter)(nil)).Elem()
}

func (o SearchParameterOutput) ToSearchParameterOutput() SearchParameterOutput {
	return o
}

func (o SearchParameterOutput) ToSearchParameterOutputWithContext(ctx context.Context) SearchParameterOutput {
	return o
}

// The canonical url of the search parameter resource.
func (o SearchParameterOutput) CanonicalUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SearchParameter) *string { return v.CanonicalUrl }).(pulumi.StringPtrOutput)
}

// The versioned name of the search parameter resource. The format is projects/{project-id}/locations/{location}/datasets/{dataset-id}/fhirStores/{fhirStore-id}/fhir/SearchParameter/{resource-id}/_history/{version-id} For fhir stores with disable_resource_versioning=true, the format is projects/{project-id}/locations/{location}/datasets/{dataset-id}/fhirStores/{fhirStore-id}/fhir/SearchParameter/{resource-id}/
func (o SearchParameterOutput) Parameter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SearchParameter) *string { return v.Parameter }).(pulumi.StringPtrOutput)
}

type SearchParameterArrayOutput struct{ *pulumi.OutputState }

func (SearchParameterArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SearchParameter)(nil)).Elem()
}

func (o SearchParameterArrayOutput) ToSearchParameterArrayOutput() SearchParameterArrayOutput {
	return o
}

func (o SearchParameterArrayOutput) ToSearchParameterArrayOutputWithContext(ctx context.Context) SearchParameterArrayOutput {
	return o
}

func (o SearchParameterArrayOutput) Index(i pulumi.IntInput) SearchParameterOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SearchParameter {
		return vs[0].([]SearchParameter)[vs[1].(int)]
	}).(SearchParameterOutput)
}

// Contains the versioned name and the URL for one SearchParameter.
type SearchParameterResponse struct {
	// The canonical url of the search parameter resource.
	CanonicalUrl string `pulumi:"canonicalUrl"`
	// The versioned name of the search parameter resource. The format is projects/{project-id}/locations/{location}/datasets/{dataset-id}/fhirStores/{fhirStore-id}/fhir/SearchParameter/{resource-id}/_history/{version-id} For fhir stores with disable_resource_versioning=true, the format is projects/{project-id}/locations/{location}/datasets/{dataset-id}/fhirStores/{fhirStore-id}/fhir/SearchParameter/{resource-id}/
	Parameter string `pulumi:"parameter"`
}

// Contains the versioned name and the URL for one SearchParameter.
type SearchParameterResponseOutput struct{ *pulumi.OutputState }

func (SearchParameterResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SearchParameterResponse)(nil)).Elem()
}

func (o SearchParameterResponseOutput) ToSearchParameterResponseOutput() SearchParameterResponseOutput {
	return o
}

func (o SearchParameterResponseOutput) ToSearchParameterResponseOutputWithContext(ctx context.Context) SearchParameterResponseOutput {
	return o
}

// The canonical url of the search parameter resource.
func (o SearchParameterResponseOutput) CanonicalUrl() pulumi.StringOutput {
	return o.ApplyT(func(v SearchParameterResponse) string { return v.CanonicalUrl }).(pulumi.StringOutput)
}

// The versioned name of the search parameter resource. The format is projects/{project-id}/locations/{location}/datasets/{dataset-id}/fhirStores/{fhirStore-id}/fhir/SearchParameter/{resource-id}/_history/{version-id} For fhir stores with disable_resource_versioning=true, the format is projects/{project-id}/locations/{location}/datasets/{dataset-id}/fhirStores/{fhirStore-id}/fhir/SearchParameter/{resource-id}/
func (o SearchParameterResponseOutput) Parameter() pulumi.StringOutput {
	return o.ApplyT(func(v SearchParameterResponse) string { return v.Parameter }).(pulumi.StringOutput)
}

type SearchParameterResponseArrayOutput struct{ *pulumi.OutputState }

func (SearchParameterResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SearchParameterResponse)(nil)).Elem()
}

func (o SearchParameterResponseArrayOutput) ToSearchParameterResponseArrayOutput() SearchParameterResponseArrayOutput {
	return o
}

func (o SearchParameterResponseArrayOutput) ToSearchParameterResponseArrayOutputWithContext(ctx context.Context) SearchParameterResponseArrayOutput {
	return o
}

func (o SearchParameterResponseArrayOutput) Index(i pulumi.IntInput) SearchParameterResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SearchParameterResponse {
		return vs[0].([]SearchParameterResponse)[vs[1].(int)]
	}).(SearchParameterResponseOutput)
}

// A segment in a structured format.
type SegmentResponse struct {
	// A mapping from the positional location to the value. The key string uses zero-based indexes separated by dots to identify Fields, components and sub-components. A bracket notation is also used to identify different instances of a repeated field. Regex for key: (\d+)(\[\d+\])?(.\d+)?(.\d+)? Examples of (key, value) pairs: * (0.1, "hemoglobin") denotes that the first component of Field 0 has the value "hemoglobin". * (1.1.2, "CBC") denotes that the second sub-component of the first component of Field 1 has the value "CBC". * (1[0].1, "HbA1c") denotes that the first component of the first Instance of Field 1, which is repeated, has the value "HbA1c".
	Fields map[string]string `pulumi:"fields"`
	// A string that indicates the type of segment. For example, EVN or PID.
	SegmentId string `pulumi:"segmentId"`
	// Set ID for segments that can be in a set. This can be empty if it's missing or isn't applicable.
	SetId string `pulumi:"setId"`
}

// A segment in a structured format.
type SegmentResponseOutput struct{ *pulumi.OutputState }

func (SegmentResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SegmentResponse)(nil)).Elem()
}

func (o SegmentResponseOutput) ToSegmentResponseOutput() SegmentResponseOutput {
	return o
}

func (o SegmentResponseOutput) ToSegmentResponseOutputWithContext(ctx context.Context) SegmentResponseOutput {
	return o
}

// A mapping from the positional location to the value. The key string uses zero-based indexes separated by dots to identify Fields, components and sub-components. A bracket notation is also used to identify different instances of a repeated field. Regex for key: (\d+)(\[\d+\])?(.\d+)?(.\d+)? Examples of (key, value) pairs: * (0.1, "hemoglobin") denotes that the first component of Field 0 has the value "hemoglobin". * (1.1.2, "CBC") denotes that the second sub-component of the first component of Field 1 has the value "CBC". * (1[0].1, "HbA1c") denotes that the first component of the first Instance of Field 1, which is repeated, has the value "HbA1c".
func (o SegmentResponseOutput) Fields() pulumi.StringMapOutput {
	return o.ApplyT(func(v SegmentResponse) map[string]string { return v.Fields }).(pulumi.StringMapOutput)
}

// A string that indicates the type of segment. For example, EVN or PID.
func (o SegmentResponseOutput) SegmentId() pulumi.StringOutput {
	return o.ApplyT(func(v SegmentResponse) string { return v.SegmentId }).(pulumi.StringOutput)
}

// Set ID for segments that can be in a set. This can be empty if it's missing or isn't applicable.
func (o SegmentResponseOutput) SetId() pulumi.StringOutput {
	return o.ApplyT(func(v SegmentResponse) string { return v.SetId }).(pulumi.StringOutput)
}

type SegmentResponseArrayOutput struct{ *pulumi.OutputState }

func (SegmentResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SegmentResponse)(nil)).Elem()
}

func (o SegmentResponseArrayOutput) ToSegmentResponseArrayOutput() SegmentResponseArrayOutput {
	return o
}

func (o SegmentResponseArrayOutput) ToSegmentResponseArrayOutputWithContext(ctx context.Context) SegmentResponseArrayOutput {
	return o
}

func (o SegmentResponseArrayOutput) Index(i pulumi.IntInput) SegmentResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SegmentResponse {
		return vs[0].([]SegmentResponse)[vs[1].(int)]
	}).(SegmentResponseOutput)
}

// A TextAnnotation specifies a text range that includes sensitive information.
type SensitiveTextAnnotation struct {
	// Maps from a resource slice. For example, FHIR resource field path to a set of sensitive text findings. For example, Appointment.Narrative text1 --> {findings_1, findings_2, findings_3}
	Details map[string]Detail `pulumi:"details"`
}

// SensitiveTextAnnotationInput is an input type that accepts SensitiveTextAnnotationArgs and SensitiveTextAnnotationOutput values.
// You can construct a concrete instance of `SensitiveTextAnnotationInput` via:
//
//	SensitiveTextAnnotationArgs{...}
type SensitiveTextAnnotationInput interface {
	pulumi.Input

	ToSensitiveTextAnnotationOutput() SensitiveTextAnnotationOutput
	ToSensitiveTextAnnotationOutputWithContext(context.Context) SensitiveTextAnnotationOutput
}

// A TextAnnotation specifies a text range that includes sensitive information.
type SensitiveTextAnnotationArgs struct {
	// Maps from a resource slice. For example, FHIR resource field path to a set of sensitive text findings. For example, Appointment.Narrative text1 --> {findings_1, findings_2, findings_3}
	Details DetailMapInput `pulumi:"details"`
}

func (SensitiveTextAnnotationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SensitiveTextAnnotation)(nil)).Elem()
}

func (i SensitiveTextAnnotationArgs) ToSensitiveTextAnnotationOutput() SensitiveTextAnnotationOutput {
	return i.ToSensitiveTextAnnotationOutputWithContext(context.Background())
}

func (i SensitiveTextAnnotationArgs) ToSensitiveTextAnnotationOutputWithContext(ctx context.Context) SensitiveTextAnnotationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SensitiveTextAnnotationOutput)
}

func (i SensitiveTextAnnotationArgs) ToSensitiveTextAnnotationPtrOutput() SensitiveTextAnnotationPtrOutput {
	return i.ToSensitiveTextAnnotationPtrOutputWithContext(context.Background())
}

func (i SensitiveTextAnnotationArgs) ToSensitiveTextAnnotationPtrOutputWithContext(ctx context.Context) SensitiveTextAnnotationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SensitiveTextAnnotationOutput).ToSensitiveTextAnnotationPtrOutputWithContext(ctx)
}

// SensitiveTextAnnotationPtrInput is an input type that accepts SensitiveTextAnnotationArgs, SensitiveTextAnnotationPtr and SensitiveTextAnnotationPtrOutput values.
// You can construct a concrete instance of `SensitiveTextAnnotationPtrInput` via:
//
//	        SensitiveTextAnnotationArgs{...}
//
//	or:
//
//	        nil
type SensitiveTextAnnotationPtrInput interface {
	pulumi.Input

	ToSensitiveTextAnnotationPtrOutput() SensitiveTextAnnotationPtrOutput
	ToSensitiveTextAnnotationPtrOutputWithContext(context.Context) SensitiveTextAnnotationPtrOutput
}

type sensitiveTextAnnotationPtrType SensitiveTextAnnotationArgs

func SensitiveTextAnnotationPtr(v *SensitiveTextAnnotationArgs) SensitiveTextAnnotationPtrInput {
	return (*sensitiveTextAnnotationPtrType)(v)
}

func (*sensitiveTextAnnotationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SensitiveTextAnnotation)(nil)).Elem()
}

func (i *sensitiveTextAnnotationPtrType) ToSensitiveTextAnnotationPtrOutput() SensitiveTextAnnotationPtrOutput {
	return i.ToSensitiveTextAnnotationPtrOutputWithContext(context.Background())
}

func (i *sensitiveTextAnnotationPtrType) ToSensitiveTextAnnotationPtrOutputWithContext(ctx context.Context) SensitiveTextAnnotationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SensitiveTextAnnotationPtrOutput)
}

// A TextAnnotation specifies a text range that includes sensitive information.
type SensitiveTextAnnotationOutput struct{ *pulumi.OutputState }

func (SensitiveTextAnnotationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SensitiveTextAnnotation)(nil)).Elem()
}

func (o SensitiveTextAnnotationOutput) ToSensitiveTextAnnotationOutput() SensitiveTextAnnotationOutput {
	return o
}

func (o SensitiveTextAnnotationOutput) ToSensitiveTextAnnotationOutputWithContext(ctx context.Context) SensitiveTextAnnotationOutput {
	return o
}

func (o SensitiveTextAnnotationOutput) ToSensitiveTextAnnotationPtrOutput() SensitiveTextAnnotationPtrOutput {
	return o.ToSensitiveTextAnnotationPtrOutputWithContext(context.Background())
}

func (o SensitiveTextAnnotationOutput) ToSensitiveTextAnnotationPtrOutputWithContext(ctx context.Context) SensitiveTextAnnotationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v SensitiveTextAnnotation) *SensitiveTextAnnotation {
		return &v
	}).(SensitiveTextAnnotationPtrOutput)
}

// Maps from a resource slice. For example, FHIR resource field path to a set of sensitive text findings. For example, Appointment.Narrative text1 --> {findings_1, findings_2, findings_3}
func (o SensitiveTextAnnotationOutput) Details() DetailMapOutput {
	return o.ApplyT(func(v SensitiveTextAnnotation) map[string]Detail { return v.Details }).(DetailMapOutput)
}

type SensitiveTextAnnotationPtrOutput struct{ *pulumi.OutputState }

func (SensitiveTextAnnotationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SensitiveTextAnnotation)(nil)).Elem()
}

func (o SensitiveTextAnnotationPtrOutput) ToSensitiveTextAnnotationPtrOutput() SensitiveTextAnnotationPtrOutput {
	return o
}

func (o SensitiveTextAnnotationPtrOutput) ToSensitiveTextAnnotationPtrOutputWithContext(ctx context.Context) SensitiveTextAnnotationPtrOutput {
	return o
}

func (o SensitiveTextAnnotationPtrOutput) Elem() SensitiveTextAnnotationOutput {
	return o.ApplyT(func(v *SensitiveTextAnnotation) SensitiveTextAnnotation {
		if v != nil {
			return *v
		}
		var ret SensitiveTextAnnotation
		return ret
	}).(SensitiveTextAnnotationOutput)
}

// Maps from a resource slice. For example, FHIR resource field path to a set of sensitive text findings. For example, Appointment.Narrative text1 --> {findings_1, findings_2, findings_3}
func (o SensitiveTextAnnotationPtrOutput) Details() DetailMapOutput {
	return o.ApplyT(func(v *SensitiveTextAnnotation) map[string]Detail {
		if v == nil {
			return nil
		}
		return v.Details
	}).(DetailMapOutput)
}

// A TextAnnotation specifies a text range that includes sensitive information.
type SensitiveTextAnnotationResponse struct {
	// Maps from a resource slice. For example, FHIR resource field path to a set of sensitive text findings. For example, Appointment.Narrative text1 --> {findings_1, findings_2, findings_3}
	Details map[string]DetailResponse `pulumi:"details"`
}

// A TextAnnotation specifies a text range that includes sensitive information.
type SensitiveTextAnnotationResponseOutput struct{ *pulumi.OutputState }

func (SensitiveTextAnnotationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SensitiveTextAnnotationResponse)(nil)).Elem()
}

func (o SensitiveTextAnnotationResponseOutput) ToSensitiveTextAnnotationResponseOutput() SensitiveTextAnnotationResponseOutput {
	return o
}

func (o SensitiveTextAnnotationResponseOutput) ToSensitiveTextAnnotationResponseOutputWithContext(ctx context.Context) SensitiveTextAnnotationResponseOutput {
	return o
}

// Maps from a resource slice. For example, FHIR resource field path to a set of sensitive text findings. For example, Appointment.Narrative text1 --> {findings_1, findings_2, findings_3}
func (o SensitiveTextAnnotationResponseOutput) Details() DetailResponseMapOutput {
	return o.ApplyT(func(v SensitiveTextAnnotationResponse) map[string]DetailResponse { return v.Details }).(DetailResponseMapOutput)
}

// User signature.
type Signature struct {
	// Optional. An image of the user's signature.
	Image *Image `pulumi:"image"`
	// Optional. Metadata associated with the user's signature. For example, the user's name or the user's title.
	Metadata map[string]string `pulumi:"metadata"`
	// Optional. Timestamp of the signature.
	SignatureTime *string `pulumi:"signatureTime"`
	// User's UUID provided by the client.
	UserId string `pulumi:"userId"`
}

// SignatureInput is an input type that accepts SignatureArgs and SignatureOutput values.
// You can construct a concrete instance of `SignatureInput` via:
//
//	SignatureArgs{...}
type SignatureInput interface {
	pulumi.Input

	ToSignatureOutput() SignatureOutput
	ToSignatureOutputWithContext(context.Context) SignatureOutput
}

// User signature.
type SignatureArgs struct {
	// Optional. An image of the user's signature.
	Image ImagePtrInput `pulumi:"image"`
	// Optional. Metadata associated with the user's signature. For example, the user's name or the user's title.
	Metadata pulumi.StringMapInput `pulumi:"metadata"`
	// Optional. Timestamp of the signature.
	SignatureTime pulumi.StringPtrInput `pulumi:"signatureTime"`
	// User's UUID provided by the client.
	UserId pulumi.StringInput `pulumi:"userId"`
}

func (SignatureArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Signature)(nil)).Elem()
}

func (i SignatureArgs) ToSignatureOutput() SignatureOutput {
	return i.ToSignatureOutputWithContext(context.Background())
}

func (i SignatureArgs) ToSignatureOutputWithContext(ctx context.Context) SignatureOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SignatureOutput)
}

func (i SignatureArgs) ToSignaturePtrOutput() SignaturePtrOutput {
	return i.ToSignaturePtrOutputWithContext(context.Background())
}

func (i SignatureArgs) ToSignaturePtrOutputWithContext(ctx context.Context) SignaturePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SignatureOutput).ToSignaturePtrOutputWithContext(ctx)
}

// SignaturePtrInput is an input type that accepts SignatureArgs, SignaturePtr and SignaturePtrOutput values.
// You can construct a concrete instance of `SignaturePtrInput` via:
//
//	        SignatureArgs{...}
//
//	or:
//
//	        nil
type SignaturePtrInput interface {
	pulumi.Input

	ToSignaturePtrOutput() SignaturePtrOutput
	ToSignaturePtrOutputWithContext(context.Context) SignaturePtrOutput
}

type signaturePtrType SignatureArgs

func SignaturePtr(v *SignatureArgs) SignaturePtrInput {
	return (*signaturePtrType)(v)
}

func (*signaturePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Signature)(nil)).Elem()
}

func (i *signaturePtrType) ToSignaturePtrOutput() SignaturePtrOutput {
	return i.ToSignaturePtrOutputWithContext(context.Background())
}

func (i *signaturePtrType) ToSignaturePtrOutputWithContext(ctx context.Context) SignaturePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SignaturePtrOutput)
}

// User signature.
type SignatureOutput struct{ *pulumi.OutputState }

func (SignatureOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Signature)(nil)).Elem()
}

func (o SignatureOutput) ToSignatureOutput() SignatureOutput {
	return o
}

func (o SignatureOutput) ToSignatureOutputWithContext(ctx context.Context) SignatureOutput {
	return o
}

func (o SignatureOutput) ToSignaturePtrOutput() SignaturePtrOutput {
	return o.ToSignaturePtrOutputWithContext(context.Background())
}

func (o SignatureOutput) ToSignaturePtrOutputWithContext(ctx context.Context) SignaturePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Signature) *Signature {
		return &v
	}).(SignaturePtrOutput)
}

// Optional. An image of the user's signature.
func (o SignatureOutput) Image() ImagePtrOutput {
	return o.ApplyT(func(v Signature) *Image { return v.Image }).(ImagePtrOutput)
}

// Optional. Metadata associated with the user's signature. For example, the user's name or the user's title.
func (o SignatureOutput) Metadata() pulumi.StringMapOutput {
	return o.ApplyT(func(v Signature) map[string]string { return v.Metadata }).(pulumi.StringMapOutput)
}

// Optional. Timestamp of the signature.
func (o SignatureOutput) SignatureTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Signature) *string { return v.SignatureTime }).(pulumi.StringPtrOutput)
}

// User's UUID provided by the client.
func (o SignatureOutput) UserId() pulumi.StringOutput {
	return o.ApplyT(func(v Signature) string { return v.UserId }).(pulumi.StringOutput)
}

type SignaturePtrOutput struct{ *pulumi.OutputState }

func (SignaturePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Signature)(nil)).Elem()
}

func (o SignaturePtrOutput) ToSignaturePtrOutput() SignaturePtrOutput {
	return o
}

func (o SignaturePtrOutput) ToSignaturePtrOutputWithContext(ctx context.Context) SignaturePtrOutput {
	return o
}

func (o SignaturePtrOutput) Elem() SignatureOutput {
	return o.ApplyT(func(v *Signature) Signature {
		if v != nil {
			return *v
		}
		var ret Signature
		return ret
	}).(SignatureOutput)
}

// Optional. An image of the user's signature.
func (o SignaturePtrOutput) Image() ImagePtrOutput {
	return o.ApplyT(func(v *Signature) *Image {
		if v == nil {
			return nil
		}
		return v.Image
	}).(ImagePtrOutput)
}

// Optional. Metadata associated with the user's signature. For example, the user's name or the user's title.
func (o SignaturePtrOutput) Metadata() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Signature) map[string]string {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(pulumi.StringMapOutput)
}

// Optional. Timestamp of the signature.
func (o SignaturePtrOutput) SignatureTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Signature) *string {
		if v == nil {
			return nil
		}
		return v.SignatureTime
	}).(pulumi.StringPtrOutput)
}

// User's UUID provided by the client.
func (o SignaturePtrOutput) UserId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Signature) *string {
		if v == nil {
			return nil
		}
		return &v.UserId
	}).(pulumi.StringPtrOutput)
}

// User signature.
type SignatureResponse struct {
	// Optional. An image of the user's signature.
	Image ImageResponse `pulumi:"image"`
	// Optional. Metadata associated with the user's signature. For example, the user's name or the user's title.
	Metadata map[string]string `pulumi:"metadata"`
	// Optional. Timestamp of the signature.
	SignatureTime string `pulumi:"signatureTime"`
	// User's UUID provided by the client.
	UserId string `pulumi:"userId"`
}

// User signature.
type SignatureResponseOutput struct{ *pulumi.OutputState }

func (SignatureResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SignatureResponse)(nil)).Elem()
}

func (o SignatureResponseOutput) ToSignatureResponseOutput() SignatureResponseOutput {
	return o
}

func (o SignatureResponseOutput) ToSignatureResponseOutputWithContext(ctx context.Context) SignatureResponseOutput {
	return o
}

// Optional. An image of the user's signature.
func (o SignatureResponseOutput) Image() ImageResponseOutput {
	return o.ApplyT(func(v SignatureResponse) ImageResponse { return v.Image }).(ImageResponseOutput)
}

// Optional. Metadata associated with the user's signature. For example, the user's name or the user's title.
func (o SignatureResponseOutput) Metadata() pulumi.StringMapOutput {
	return o.ApplyT(func(v SignatureResponse) map[string]string { return v.Metadata }).(pulumi.StringMapOutput)
}

// Optional. Timestamp of the signature.
func (o SignatureResponseOutput) SignatureTime() pulumi.StringOutput {
	return o.ApplyT(func(v SignatureResponse) string { return v.SignatureTime }).(pulumi.StringOutput)
}

// User's UUID provided by the client.
func (o SignatureResponseOutput) UserId() pulumi.StringOutput {
	return o.ApplyT(func(v SignatureResponse) string { return v.UserId }).(pulumi.StringOutput)
}

// Contains configuration for streaming FHIR export.
type StreamConfig struct {
	// The destination BigQuery structure that contains both the dataset location and corresponding schema config. The output is organized in one table per resource type. The server reuses the existing tables (if any) that are named after the resource types, e.g. "Patient", "Observation". When there is no existing table for a given resource type, the server attempts to create one. When a table schema doesn't align with the schema config, either because of existing incompatible schema or out of band incompatible modification, the server does not stream in new data. One resolution in this case is to delete the incompatible table and let the server recreate one, though the newly created table only contains data after the table recreation. BigQuery imposes a 1 MB limit on streaming insert row size, therefore any resource mutation that generates more than 1 MB of BigQuery data will not be streamed. Results are written to BigQuery tables according to the parameters in BigQueryDestination.WriteDisposition. Different versions of the same resource are distinguishable by the meta.versionId and meta.lastUpdated columns. The operation (CREATE/UPDATE/DELETE) that results in the new version is recorded in the meta.tag. The tables contain all historical resource versions since streaming was enabled. For query convenience, the server also creates one view per table of the same name containing only the current resource version. The streamed data in the BigQuery dataset is not guaranteed to be completely unique. The combination of the id and meta.versionId columns should ideally identify a single unique row. But in rare cases, duplicates may exist. At query time, users may use the SQL select statement to keep only one of the duplicate rows given an id and meta.versionId pair. Alternatively, the server created view mentioned above also filters out duplicates. If a resource mutation cannot be streamed to BigQuery, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
	BigqueryDestination *GoogleCloudHealthcareV1beta1FhirBigQueryDestination `pulumi:"bigqueryDestination"`
	// The destination FHIR store for de-identified resources. After this field is added, all subsequent creates/updates/patches to the source store will be de-identified using the provided configuration and applied to the destination store. Importing resources to the source store will not trigger the streaming. If the source store already contains resources when this option is enabled, those resources will not be copied to the destination store unless they are subsequently updated. This may result in invalid references in the destination store. Before adding this config, you must grant the healthcare.fhirResources.update permission on the destination store to your project's **Cloud Healthcare Service Agent** [service account](https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#the_cloud_healthcare_service_agent). The destination store must set enable_update_create to true. The destination store must have disable_referential_integrity set to true. If a resource cannot be de-identified, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
	DeidentifiedStoreDestination *DeidentifiedStoreDestination `pulumi:"deidentifiedStoreDestination"`
	// Supply a FHIR resource type (such as "Patient" or "Observation"). See https://www.hl7.org/fhir/valueset-resource-types.html for a list of all FHIR resource types. The server treats an empty list as an intent to stream all the supported resource types in this FHIR store.
	ResourceTypes []string `pulumi:"resourceTypes"`
}

// StreamConfigInput is an input type that accepts StreamConfigArgs and StreamConfigOutput values.
// You can construct a concrete instance of `StreamConfigInput` via:
//
//	StreamConfigArgs{...}
type StreamConfigInput interface {
	pulumi.Input

	ToStreamConfigOutput() StreamConfigOutput
	ToStreamConfigOutputWithContext(context.Context) StreamConfigOutput
}

// Contains configuration for streaming FHIR export.
type StreamConfigArgs struct {
	// The destination BigQuery structure that contains both the dataset location and corresponding schema config. The output is organized in one table per resource type. The server reuses the existing tables (if any) that are named after the resource types, e.g. "Patient", "Observation". When there is no existing table for a given resource type, the server attempts to create one. When a table schema doesn't align with the schema config, either because of existing incompatible schema or out of band incompatible modification, the server does not stream in new data. One resolution in this case is to delete the incompatible table and let the server recreate one, though the newly created table only contains data after the table recreation. BigQuery imposes a 1 MB limit on streaming insert row size, therefore any resource mutation that generates more than 1 MB of BigQuery data will not be streamed. Results are written to BigQuery tables according to the parameters in BigQueryDestination.WriteDisposition. Different versions of the same resource are distinguishable by the meta.versionId and meta.lastUpdated columns. The operation (CREATE/UPDATE/DELETE) that results in the new version is recorded in the meta.tag. The tables contain all historical resource versions since streaming was enabled. For query convenience, the server also creates one view per table of the same name containing only the current resource version. The streamed data in the BigQuery dataset is not guaranteed to be completely unique. The combination of the id and meta.versionId columns should ideally identify a single unique row. But in rare cases, duplicates may exist. At query time, users may use the SQL select statement to keep only one of the duplicate rows given an id and meta.versionId pair. Alternatively, the server created view mentioned above also filters out duplicates. If a resource mutation cannot be streamed to BigQuery, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
	BigqueryDestination GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrInput `pulumi:"bigqueryDestination"`
	// The destination FHIR store for de-identified resources. After this field is added, all subsequent creates/updates/patches to the source store will be de-identified using the provided configuration and applied to the destination store. Importing resources to the source store will not trigger the streaming. If the source store already contains resources when this option is enabled, those resources will not be copied to the destination store unless they are subsequently updated. This may result in invalid references in the destination store. Before adding this config, you must grant the healthcare.fhirResources.update permission on the destination store to your project's **Cloud Healthcare Service Agent** [service account](https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#the_cloud_healthcare_service_agent). The destination store must set enable_update_create to true. The destination store must have disable_referential_integrity set to true. If a resource cannot be de-identified, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
	DeidentifiedStoreDestination DeidentifiedStoreDestinationPtrInput `pulumi:"deidentifiedStoreDestination"`
	// Supply a FHIR resource type (such as "Patient" or "Observation"). See https://www.hl7.org/fhir/valueset-resource-types.html for a list of all FHIR resource types. The server treats an empty list as an intent to stream all the supported resource types in this FHIR store.
	ResourceTypes pulumi.StringArrayInput `pulumi:"resourceTypes"`
}

func (StreamConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamConfig)(nil)).Elem()
}

func (i StreamConfigArgs) ToStreamConfigOutput() StreamConfigOutput {
	return i.ToStreamConfigOutputWithContext(context.Background())
}

func (i StreamConfigArgs) ToStreamConfigOutputWithContext(ctx context.Context) StreamConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamConfigOutput)
}

// StreamConfigArrayInput is an input type that accepts StreamConfigArray and StreamConfigArrayOutput values.
// You can construct a concrete instance of `StreamConfigArrayInput` via:
//
//	StreamConfigArray{ StreamConfigArgs{...} }
type StreamConfigArrayInput interface {
	pulumi.Input

	ToStreamConfigArrayOutput() StreamConfigArrayOutput
	ToStreamConfigArrayOutputWithContext(context.Context) StreamConfigArrayOutput
}

type StreamConfigArray []StreamConfigInput

func (StreamConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StreamConfig)(nil)).Elem()
}

func (i StreamConfigArray) ToStreamConfigArrayOutput() StreamConfigArrayOutput {
	return i.ToStreamConfigArrayOutputWithContext(context.Background())
}

func (i StreamConfigArray) ToStreamConfigArrayOutputWithContext(ctx context.Context) StreamConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamConfigArrayOutput)
}

// Contains configuration for streaming FHIR export.
type StreamConfigOutput struct{ *pulumi.OutputState }

func (StreamConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamConfig)(nil)).Elem()
}

func (o StreamConfigOutput) ToStreamConfigOutput() StreamConfigOutput {
	return o
}

func (o StreamConfigOutput) ToStreamConfigOutputWithContext(ctx context.Context) StreamConfigOutput {
	return o
}

// The destination BigQuery structure that contains both the dataset location and corresponding schema config. The output is organized in one table per resource type. The server reuses the existing tables (if any) that are named after the resource types, e.g. "Patient", "Observation". When there is no existing table for a given resource type, the server attempts to create one. When a table schema doesn't align with the schema config, either because of existing incompatible schema or out of band incompatible modification, the server does not stream in new data. One resolution in this case is to delete the incompatible table and let the server recreate one, though the newly created table only contains data after the table recreation. BigQuery imposes a 1 MB limit on streaming insert row size, therefore any resource mutation that generates more than 1 MB of BigQuery data will not be streamed. Results are written to BigQuery tables according to the parameters in BigQueryDestination.WriteDisposition. Different versions of the same resource are distinguishable by the meta.versionId and meta.lastUpdated columns. The operation (CREATE/UPDATE/DELETE) that results in the new version is recorded in the meta.tag. The tables contain all historical resource versions since streaming was enabled. For query convenience, the server also creates one view per table of the same name containing only the current resource version. The streamed data in the BigQuery dataset is not guaranteed to be completely unique. The combination of the id and meta.versionId columns should ideally identify a single unique row. But in rare cases, duplicates may exist. At query time, users may use the SQL select statement to keep only one of the duplicate rows given an id and meta.versionId pair. Alternatively, the server created view mentioned above also filters out duplicates. If a resource mutation cannot be streamed to BigQuery, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
func (o StreamConfigOutput) BigqueryDestination() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput {
	return o.ApplyT(func(v StreamConfig) *GoogleCloudHealthcareV1beta1FhirBigQueryDestination {
		return v.BigqueryDestination
	}).(GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput)
}

// The destination FHIR store for de-identified resources. After this field is added, all subsequent creates/updates/patches to the source store will be de-identified using the provided configuration and applied to the destination store. Importing resources to the source store will not trigger the streaming. If the source store already contains resources when this option is enabled, those resources will not be copied to the destination store unless they are subsequently updated. This may result in invalid references in the destination store. Before adding this config, you must grant the healthcare.fhirResources.update permission on the destination store to your project's **Cloud Healthcare Service Agent** [service account](https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#the_cloud_healthcare_service_agent). The destination store must set enable_update_create to true. The destination store must have disable_referential_integrity set to true. If a resource cannot be de-identified, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
func (o StreamConfigOutput) DeidentifiedStoreDestination() DeidentifiedStoreDestinationPtrOutput {
	return o.ApplyT(func(v StreamConfig) *DeidentifiedStoreDestination { return v.DeidentifiedStoreDestination }).(DeidentifiedStoreDestinationPtrOutput)
}

// Supply a FHIR resource type (such as "Patient" or "Observation"). See https://www.hl7.org/fhir/valueset-resource-types.html for a list of all FHIR resource types. The server treats an empty list as an intent to stream all the supported resource types in this FHIR store.
func (o StreamConfigOutput) ResourceTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v StreamConfig) []string { return v.ResourceTypes }).(pulumi.StringArrayOutput)
}

type StreamConfigArrayOutput struct{ *pulumi.OutputState }

func (StreamConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StreamConfig)(nil)).Elem()
}

func (o StreamConfigArrayOutput) ToStreamConfigArrayOutput() StreamConfigArrayOutput {
	return o
}

func (o StreamConfigArrayOutput) ToStreamConfigArrayOutputWithContext(ctx context.Context) StreamConfigArrayOutput {
	return o
}

func (o StreamConfigArrayOutput) Index(i pulumi.IntInput) StreamConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StreamConfig {
		return vs[0].([]StreamConfig)[vs[1].(int)]
	}).(StreamConfigOutput)
}

// Contains configuration for streaming FHIR export.
type StreamConfigResponse struct {
	// The destination BigQuery structure that contains both the dataset location and corresponding schema config. The output is organized in one table per resource type. The server reuses the existing tables (if any) that are named after the resource types, e.g. "Patient", "Observation". When there is no existing table for a given resource type, the server attempts to create one. When a table schema doesn't align with the schema config, either because of existing incompatible schema or out of band incompatible modification, the server does not stream in new data. One resolution in this case is to delete the incompatible table and let the server recreate one, though the newly created table only contains data after the table recreation. BigQuery imposes a 1 MB limit on streaming insert row size, therefore any resource mutation that generates more than 1 MB of BigQuery data will not be streamed. Results are written to BigQuery tables according to the parameters in BigQueryDestination.WriteDisposition. Different versions of the same resource are distinguishable by the meta.versionId and meta.lastUpdated columns. The operation (CREATE/UPDATE/DELETE) that results in the new version is recorded in the meta.tag. The tables contain all historical resource versions since streaming was enabled. For query convenience, the server also creates one view per table of the same name containing only the current resource version. The streamed data in the BigQuery dataset is not guaranteed to be completely unique. The combination of the id and meta.versionId columns should ideally identify a single unique row. But in rare cases, duplicates may exist. At query time, users may use the SQL select statement to keep only one of the duplicate rows given an id and meta.versionId pair. Alternatively, the server created view mentioned above also filters out duplicates. If a resource mutation cannot be streamed to BigQuery, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
	BigqueryDestination GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponse `pulumi:"bigqueryDestination"`
	// The destination FHIR store for de-identified resources. After this field is added, all subsequent creates/updates/patches to the source store will be de-identified using the provided configuration and applied to the destination store. Importing resources to the source store will not trigger the streaming. If the source store already contains resources when this option is enabled, those resources will not be copied to the destination store unless they are subsequently updated. This may result in invalid references in the destination store. Before adding this config, you must grant the healthcare.fhirResources.update permission on the destination store to your project's **Cloud Healthcare Service Agent** [service account](https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#the_cloud_healthcare_service_agent). The destination store must set enable_update_create to true. The destination store must have disable_referential_integrity set to true. If a resource cannot be de-identified, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
	DeidentifiedStoreDestination DeidentifiedStoreDestinationResponse `pulumi:"deidentifiedStoreDestination"`
	// Supply a FHIR resource type (such as "Patient" or "Observation"). See https://www.hl7.org/fhir/valueset-resource-types.html for a list of all FHIR resource types. The server treats an empty list as an intent to stream all the supported resource types in this FHIR store.
	ResourceTypes []string `pulumi:"resourceTypes"`
}

// Contains configuration for streaming FHIR export.
type StreamConfigResponseOutput struct{ *pulumi.OutputState }

func (StreamConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StreamConfigResponse)(nil)).Elem()
}

func (o StreamConfigResponseOutput) ToStreamConfigResponseOutput() StreamConfigResponseOutput {
	return o
}

func (o StreamConfigResponseOutput) ToStreamConfigResponseOutputWithContext(ctx context.Context) StreamConfigResponseOutput {
	return o
}

// The destination BigQuery structure that contains both the dataset location and corresponding schema config. The output is organized in one table per resource type. The server reuses the existing tables (if any) that are named after the resource types, e.g. "Patient", "Observation". When there is no existing table for a given resource type, the server attempts to create one. When a table schema doesn't align with the schema config, either because of existing incompatible schema or out of band incompatible modification, the server does not stream in new data. One resolution in this case is to delete the incompatible table and let the server recreate one, though the newly created table only contains data after the table recreation. BigQuery imposes a 1 MB limit on streaming insert row size, therefore any resource mutation that generates more than 1 MB of BigQuery data will not be streamed. Results are written to BigQuery tables according to the parameters in BigQueryDestination.WriteDisposition. Different versions of the same resource are distinguishable by the meta.versionId and meta.lastUpdated columns. The operation (CREATE/UPDATE/DELETE) that results in the new version is recorded in the meta.tag. The tables contain all historical resource versions since streaming was enabled. For query convenience, the server also creates one view per table of the same name containing only the current resource version. The streamed data in the BigQuery dataset is not guaranteed to be completely unique. The combination of the id and meta.versionId columns should ideally identify a single unique row. But in rare cases, duplicates may exist. At query time, users may use the SQL select statement to keep only one of the duplicate rows given an id and meta.versionId pair. Alternatively, the server created view mentioned above also filters out duplicates. If a resource mutation cannot be streamed to BigQuery, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
func (o StreamConfigResponseOutput) BigqueryDestination() GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput {
	return o.ApplyT(func(v StreamConfigResponse) GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponse {
		return v.BigqueryDestination
	}).(GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput)
}

// The destination FHIR store for de-identified resources. After this field is added, all subsequent creates/updates/patches to the source store will be de-identified using the provided configuration and applied to the destination store. Importing resources to the source store will not trigger the streaming. If the source store already contains resources when this option is enabled, those resources will not be copied to the destination store unless they are subsequently updated. This may result in invalid references in the destination store. Before adding this config, you must grant the healthcare.fhirResources.update permission on the destination store to your project's **Cloud Healthcare Service Agent** [service account](https://cloud.google.com/healthcare/docs/how-tos/permissions-healthcare-api-gcp-products#the_cloud_healthcare_service_agent). The destination store must set enable_update_create to true. The destination store must have disable_referential_integrity set to true. If a resource cannot be de-identified, errors will be logged to Cloud Logging (see [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
func (o StreamConfigResponseOutput) DeidentifiedStoreDestination() DeidentifiedStoreDestinationResponseOutput {
	return o.ApplyT(func(v StreamConfigResponse) DeidentifiedStoreDestinationResponse {
		return v.DeidentifiedStoreDestination
	}).(DeidentifiedStoreDestinationResponseOutput)
}

// Supply a FHIR resource type (such as "Patient" or "Observation"). See https://www.hl7.org/fhir/valueset-resource-types.html for a list of all FHIR resource types. The server treats an empty list as an intent to stream all the supported resource types in this FHIR store.
func (o StreamConfigResponseOutput) ResourceTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v StreamConfigResponse) []string { return v.ResourceTypes }).(pulumi.StringArrayOutput)
}

type StreamConfigResponseArrayOutput struct{ *pulumi.OutputState }

func (StreamConfigResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]StreamConfigResponse)(nil)).Elem()
}

func (o StreamConfigResponseArrayOutput) ToStreamConfigResponseArrayOutput() StreamConfigResponseArrayOutput {
	return o
}

func (o StreamConfigResponseArrayOutput) ToStreamConfigResponseArrayOutputWithContext(ctx context.Context) StreamConfigResponseArrayOutput {
	return o
}

func (o StreamConfigResponseArrayOutput) Index(i pulumi.IntInput) StreamConfigResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) StreamConfigResponse {
		return vs[0].([]StreamConfigResponse)[vs[1].(int)]
	}).(StreamConfigResponseOutput)
}

// List of tags to be filtered.
type TagFilterList struct {
	// Tags to be filtered. Tags must be DICOM Data Elements, File Meta Elements, or Directory Structuring Elements, as defined at: http://dicom.nema.org/medical/dicom/current/output/html/part06.html#table_6-1,. They may be provided by "Keyword" or "Tag". For example, "PatientID", "00100010".
	Tags []string `pulumi:"tags"`
}

// TagFilterListInput is an input type that accepts TagFilterListArgs and TagFilterListOutput values.
// You can construct a concrete instance of `TagFilterListInput` via:
//
//	TagFilterListArgs{...}
type TagFilterListInput interface {
	pulumi.Input

	ToTagFilterListOutput() TagFilterListOutput
	ToTagFilterListOutputWithContext(context.Context) TagFilterListOutput
}

// List of tags to be filtered.
type TagFilterListArgs struct {
	// Tags to be filtered. Tags must be DICOM Data Elements, File Meta Elements, or Directory Structuring Elements, as defined at: http://dicom.nema.org/medical/dicom/current/output/html/part06.html#table_6-1,. They may be provided by "Keyword" or "Tag". For example, "PatientID", "00100010".
	Tags pulumi.StringArrayInput `pulumi:"tags"`
}

func (TagFilterListArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TagFilterList)(nil)).Elem()
}

func (i TagFilterListArgs) ToTagFilterListOutput() TagFilterListOutput {
	return i.ToTagFilterListOutputWithContext(context.Background())
}

func (i TagFilterListArgs) ToTagFilterListOutputWithContext(ctx context.Context) TagFilterListOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagFilterListOutput)
}

func (i TagFilterListArgs) ToTagFilterListPtrOutput() TagFilterListPtrOutput {
	return i.ToTagFilterListPtrOutputWithContext(context.Background())
}

func (i TagFilterListArgs) ToTagFilterListPtrOutputWithContext(ctx context.Context) TagFilterListPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagFilterListOutput).ToTagFilterListPtrOutputWithContext(ctx)
}

// TagFilterListPtrInput is an input type that accepts TagFilterListArgs, TagFilterListPtr and TagFilterListPtrOutput values.
// You can construct a concrete instance of `TagFilterListPtrInput` via:
//
//	        TagFilterListArgs{...}
//
//	or:
//
//	        nil
type TagFilterListPtrInput interface {
	pulumi.Input

	ToTagFilterListPtrOutput() TagFilterListPtrOutput
	ToTagFilterListPtrOutputWithContext(context.Context) TagFilterListPtrOutput
}

type tagFilterListPtrType TagFilterListArgs

func TagFilterListPtr(v *TagFilterListArgs) TagFilterListPtrInput {
	return (*tagFilterListPtrType)(v)
}

func (*tagFilterListPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TagFilterList)(nil)).Elem()
}

func (i *tagFilterListPtrType) ToTagFilterListPtrOutput() TagFilterListPtrOutput {
	return i.ToTagFilterListPtrOutputWithContext(context.Background())
}

func (i *tagFilterListPtrType) ToTagFilterListPtrOutputWithContext(ctx context.Context) TagFilterListPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TagFilterListPtrOutput)
}

// List of tags to be filtered.
type TagFilterListOutput struct{ *pulumi.OutputState }

func (TagFilterListOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TagFilterList)(nil)).Elem()
}

func (o TagFilterListOutput) ToTagFilterListOutput() TagFilterListOutput {
	return o
}

func (o TagFilterListOutput) ToTagFilterListOutputWithContext(ctx context.Context) TagFilterListOutput {
	return o
}

func (o TagFilterListOutput) ToTagFilterListPtrOutput() TagFilterListPtrOutput {
	return o.ToTagFilterListPtrOutputWithContext(context.Background())
}

func (o TagFilterListOutput) ToTagFilterListPtrOutputWithContext(ctx context.Context) TagFilterListPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TagFilterList) *TagFilterList {
		return &v
	}).(TagFilterListPtrOutput)
}

// Tags to be filtered. Tags must be DICOM Data Elements, File Meta Elements, or Directory Structuring Elements, as defined at: http://dicom.nema.org/medical/dicom/current/output/html/part06.html#table_6-1,. They may be provided by "Keyword" or "Tag". For example, "PatientID", "00100010".
func (o TagFilterListOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagFilterList) []string { return v.Tags }).(pulumi.StringArrayOutput)
}

type TagFilterListPtrOutput struct{ *pulumi.OutputState }

func (TagFilterListPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TagFilterList)(nil)).Elem()
}

func (o TagFilterListPtrOutput) ToTagFilterListPtrOutput() TagFilterListPtrOutput {
	return o
}

func (o TagFilterListPtrOutput) ToTagFilterListPtrOutputWithContext(ctx context.Context) TagFilterListPtrOutput {
	return o
}

func (o TagFilterListPtrOutput) Elem() TagFilterListOutput {
	return o.ApplyT(func(v *TagFilterList) TagFilterList {
		if v != nil {
			return *v
		}
		var ret TagFilterList
		return ret
	}).(TagFilterListOutput)
}

// Tags to be filtered. Tags must be DICOM Data Elements, File Meta Elements, or Directory Structuring Elements, as defined at: http://dicom.nema.org/medical/dicom/current/output/html/part06.html#table_6-1,. They may be provided by "Keyword" or "Tag". For example, "PatientID", "00100010".
func (o TagFilterListPtrOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TagFilterList) []string {
		if v == nil {
			return nil
		}
		return v.Tags
	}).(pulumi.StringArrayOutput)
}

// List of tags to be filtered.
type TagFilterListResponse struct {
	// Tags to be filtered. Tags must be DICOM Data Elements, File Meta Elements, or Directory Structuring Elements, as defined at: http://dicom.nema.org/medical/dicom/current/output/html/part06.html#table_6-1,. They may be provided by "Keyword" or "Tag". For example, "PatientID", "00100010".
	Tags []string `pulumi:"tags"`
}

// List of tags to be filtered.
type TagFilterListResponseOutput struct{ *pulumi.OutputState }

func (TagFilterListResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TagFilterListResponse)(nil)).Elem()
}

func (o TagFilterListResponseOutput) ToTagFilterListResponseOutput() TagFilterListResponseOutput {
	return o
}

func (o TagFilterListResponseOutput) ToTagFilterListResponseOutputWithContext(ctx context.Context) TagFilterListResponseOutput {
	return o
}

// Tags to be filtered. Tags must be DICOM Data Elements, File Meta Elements, or Directory Structuring Elements, as defined at: http://dicom.nema.org/medical/dicom/current/output/html/part06.html#table_6-1,. They may be provided by "Keyword" or "Tag". For example, "PatientID", "00100010".
func (o TagFilterListResponseOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TagFilterListResponse) []string { return v.Tags }).(pulumi.StringArrayOutput)
}

// Configures how to transform sensitive text `InfoTypes`.
type TextConfig struct {
	// Additional transformations to apply to the detected data, overriding `profile`.
	AdditionalTransformations []InfoTypeTransformation `pulumi:"additionalTransformations"`
	// InfoTypes to skip transforming, overriding `profile`.
	ExcludeInfoTypes []string `pulumi:"excludeInfoTypes"`
	// Base profile type for text transformation.
	ProfileType *TextConfigProfileType `pulumi:"profileType"`
	// The transformations to apply to the detected data. Deprecated. Use `additional_transformations` instead.
	//
	// Deprecated: The transformations to apply to the detected data. Deprecated. Use `additional_transformations` instead.
	Transformations []InfoTypeTransformation `pulumi:"transformations"`
}

// TextConfigInput is an input type that accepts TextConfigArgs and TextConfigOutput values.
// You can construct a concrete instance of `TextConfigInput` via:
//
//	TextConfigArgs{...}
type TextConfigInput interface {
	pulumi.Input

	ToTextConfigOutput() TextConfigOutput
	ToTextConfigOutputWithContext(context.Context) TextConfigOutput
}

// Configures how to transform sensitive text `InfoTypes`.
type TextConfigArgs struct {
	// Additional transformations to apply to the detected data, overriding `profile`.
	AdditionalTransformations InfoTypeTransformationArrayInput `pulumi:"additionalTransformations"`
	// InfoTypes to skip transforming, overriding `profile`.
	ExcludeInfoTypes pulumi.StringArrayInput `pulumi:"excludeInfoTypes"`
	// Base profile type for text transformation.
	ProfileType TextConfigProfileTypePtrInput `pulumi:"profileType"`
	// The transformations to apply to the detected data. Deprecated. Use `additional_transformations` instead.
	//
	// Deprecated: The transformations to apply to the detected data. Deprecated. Use `additional_transformations` instead.
	Transformations InfoTypeTransformationArrayInput `pulumi:"transformations"`
}

func (TextConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TextConfig)(nil)).Elem()
}

func (i TextConfigArgs) ToTextConfigOutput() TextConfigOutput {
	return i.ToTextConfigOutputWithContext(context.Background())
}

func (i TextConfigArgs) ToTextConfigOutputWithContext(ctx context.Context) TextConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TextConfigOutput)
}

func (i TextConfigArgs) ToTextConfigPtrOutput() TextConfigPtrOutput {
	return i.ToTextConfigPtrOutputWithContext(context.Background())
}

func (i TextConfigArgs) ToTextConfigPtrOutputWithContext(ctx context.Context) TextConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TextConfigOutput).ToTextConfigPtrOutputWithContext(ctx)
}

// TextConfigPtrInput is an input type that accepts TextConfigArgs, TextConfigPtr and TextConfigPtrOutput values.
// You can construct a concrete instance of `TextConfigPtrInput` via:
//
//	        TextConfigArgs{...}
//
//	or:
//
//	        nil
type TextConfigPtrInput interface {
	pulumi.Input

	ToTextConfigPtrOutput() TextConfigPtrOutput
	ToTextConfigPtrOutputWithContext(context.Context) TextConfigPtrOutput
}

type textConfigPtrType TextConfigArgs

func TextConfigPtr(v *TextConfigArgs) TextConfigPtrInput {
	return (*textConfigPtrType)(v)
}

func (*textConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TextConfig)(nil)).Elem()
}

func (i *textConfigPtrType) ToTextConfigPtrOutput() TextConfigPtrOutput {
	return i.ToTextConfigPtrOutputWithContext(context.Background())
}

func (i *textConfigPtrType) ToTextConfigPtrOutputWithContext(ctx context.Context) TextConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TextConfigPtrOutput)
}

// Configures how to transform sensitive text `InfoTypes`.
type TextConfigOutput struct{ *pulumi.OutputState }

func (TextConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TextConfig)(nil)).Elem()
}

func (o TextConfigOutput) ToTextConfigOutput() TextConfigOutput {
	return o
}

func (o TextConfigOutput) ToTextConfigOutputWithContext(ctx context.Context) TextConfigOutput {
	return o
}

func (o TextConfigOutput) ToTextConfigPtrOutput() TextConfigPtrOutput {
	return o.ToTextConfigPtrOutputWithContext(context.Background())
}

func (o TextConfigOutput) ToTextConfigPtrOutputWithContext(ctx context.Context) TextConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TextConfig) *TextConfig {
		return &v
	}).(TextConfigPtrOutput)
}

// Additional transformations to apply to the detected data, overriding `profile`.
func (o TextConfigOutput) AdditionalTransformations() InfoTypeTransformationArrayOutput {
	return o.ApplyT(func(v TextConfig) []InfoTypeTransformation { return v.AdditionalTransformations }).(InfoTypeTransformationArrayOutput)
}

// InfoTypes to skip transforming, overriding `profile`.
func (o TextConfigOutput) ExcludeInfoTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TextConfig) []string { return v.ExcludeInfoTypes }).(pulumi.StringArrayOutput)
}

// Base profile type for text transformation.
func (o TextConfigOutput) ProfileType() TextConfigProfileTypePtrOutput {
	return o.ApplyT(func(v TextConfig) *TextConfigProfileType { return v.ProfileType }).(TextConfigProfileTypePtrOutput)
}

// The transformations to apply to the detected data. Deprecated. Use `additional_transformations` instead.
//
// Deprecated: The transformations to apply to the detected data. Deprecated. Use `additional_transformations` instead.
func (o TextConfigOutput) Transformations() InfoTypeTransformationArrayOutput {
	return o.ApplyT(func(v TextConfig) []InfoTypeTransformation { return v.Transformations }).(InfoTypeTransformationArrayOutput)
}

type TextConfigPtrOutput struct{ *pulumi.OutputState }

func (TextConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TextConfig)(nil)).Elem()
}

func (o TextConfigPtrOutput) ToTextConfigPtrOutput() TextConfigPtrOutput {
	return o
}

func (o TextConfigPtrOutput) ToTextConfigPtrOutputWithContext(ctx context.Context) TextConfigPtrOutput {
	return o
}

func (o TextConfigPtrOutput) Elem() TextConfigOutput {
	return o.ApplyT(func(v *TextConfig) TextConfig {
		if v != nil {
			return *v
		}
		var ret TextConfig
		return ret
	}).(TextConfigOutput)
}

// Additional transformations to apply to the detected data, overriding `profile`.
func (o TextConfigPtrOutput) AdditionalTransformations() InfoTypeTransformationArrayOutput {
	return o.ApplyT(func(v *TextConfig) []InfoTypeTransformation {
		if v == nil {
			return nil
		}
		return v.AdditionalTransformations
	}).(InfoTypeTransformationArrayOutput)
}

// InfoTypes to skip transforming, overriding `profile`.
func (o TextConfigPtrOutput) ExcludeInfoTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TextConfig) []string {
		if v == nil {
			return nil
		}
		return v.ExcludeInfoTypes
	}).(pulumi.StringArrayOutput)
}

// Base profile type for text transformation.
func (o TextConfigPtrOutput) ProfileType() TextConfigProfileTypePtrOutput {
	return o.ApplyT(func(v *TextConfig) *TextConfigProfileType {
		if v == nil {
			return nil
		}
		return v.ProfileType
	}).(TextConfigProfileTypePtrOutput)
}

// The transformations to apply to the detected data. Deprecated. Use `additional_transformations` instead.
//
// Deprecated: The transformations to apply to the detected data. Deprecated. Use `additional_transformations` instead.
func (o TextConfigPtrOutput) Transformations() InfoTypeTransformationArrayOutput {
	return o.ApplyT(func(v *TextConfig) []InfoTypeTransformation {
		if v == nil {
			return nil
		}
		return v.Transformations
	}).(InfoTypeTransformationArrayOutput)
}

// Configures how to transform sensitive text `InfoTypes`.
type TextConfigResponse struct {
	// Additional transformations to apply to the detected data, overriding `profile`.
	AdditionalTransformations []InfoTypeTransformationResponse `pulumi:"additionalTransformations"`
	// InfoTypes to skip transforming, overriding `profile`.
	ExcludeInfoTypes []string `pulumi:"excludeInfoTypes"`
	// Base profile type for text transformation.
	ProfileType string `pulumi:"profileType"`
	// The transformations to apply to the detected data. Deprecated. Use `additional_transformations` instead.
	//
	// Deprecated: The transformations to apply to the detected data. Deprecated. Use `additional_transformations` instead.
	Transformations []InfoTypeTransformationResponse `pulumi:"transformations"`
}

// Configures how to transform sensitive text `InfoTypes`.
type TextConfigResponseOutput struct{ *pulumi.OutputState }

func (TextConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TextConfigResponse)(nil)).Elem()
}

func (o TextConfigResponseOutput) ToTextConfigResponseOutput() TextConfigResponseOutput {
	return o
}

func (o TextConfigResponseOutput) ToTextConfigResponseOutputWithContext(ctx context.Context) TextConfigResponseOutput {
	return o
}

// Additional transformations to apply to the detected data, overriding `profile`.
func (o TextConfigResponseOutput) AdditionalTransformations() InfoTypeTransformationResponseArrayOutput {
	return o.ApplyT(func(v TextConfigResponse) []InfoTypeTransformationResponse { return v.AdditionalTransformations }).(InfoTypeTransformationResponseArrayOutput)
}

// InfoTypes to skip transforming, overriding `profile`.
func (o TextConfigResponseOutput) ExcludeInfoTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TextConfigResponse) []string { return v.ExcludeInfoTypes }).(pulumi.StringArrayOutput)
}

// Base profile type for text transformation.
func (o TextConfigResponseOutput) ProfileType() pulumi.StringOutput {
	return o.ApplyT(func(v TextConfigResponse) string { return v.ProfileType }).(pulumi.StringOutput)
}

// The transformations to apply to the detected data. Deprecated. Use `additional_transformations` instead.
//
// Deprecated: The transformations to apply to the detected data. Deprecated. Use `additional_transformations` instead.
func (o TextConfigResponseOutput) Transformations() InfoTypeTransformationResponseArrayOutput {
	return o.ApplyT(func(v TextConfigResponse) []InfoTypeTransformationResponse { return v.Transformations }).(InfoTypeTransformationResponseArrayOutput)
}

// Configuration for FHIR BigQuery time-partitioned tables.
type TimePartitioning struct {
	// Number of milliseconds for which to keep the storage for a partition.
	ExpirationMs *string `pulumi:"expirationMs"`
	// Type of partitioning.
	Type *TimePartitioningType `pulumi:"type"`
}

// TimePartitioningInput is an input type that accepts TimePartitioningArgs and TimePartitioningOutput values.
// You can construct a concrete instance of `TimePartitioningInput` via:
//
//	TimePartitioningArgs{...}
type TimePartitioningInput interface {
	pulumi.Input

	ToTimePartitioningOutput() TimePartitioningOutput
	ToTimePartitioningOutputWithContext(context.Context) TimePartitioningOutput
}

// Configuration for FHIR BigQuery time-partitioned tables.
type TimePartitioningArgs struct {
	// Number of milliseconds for which to keep the storage for a partition.
	ExpirationMs pulumi.StringPtrInput `pulumi:"expirationMs"`
	// Type of partitioning.
	Type TimePartitioningTypePtrInput `pulumi:"type"`
}

func (TimePartitioningArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TimePartitioning)(nil)).Elem()
}

func (i TimePartitioningArgs) ToTimePartitioningOutput() TimePartitioningOutput {
	return i.ToTimePartitioningOutputWithContext(context.Background())
}

func (i TimePartitioningArgs) ToTimePartitioningOutputWithContext(ctx context.Context) TimePartitioningOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimePartitioningOutput)
}

func (i TimePartitioningArgs) ToTimePartitioningPtrOutput() TimePartitioningPtrOutput {
	return i.ToTimePartitioningPtrOutputWithContext(context.Background())
}

func (i TimePartitioningArgs) ToTimePartitioningPtrOutputWithContext(ctx context.Context) TimePartitioningPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimePartitioningOutput).ToTimePartitioningPtrOutputWithContext(ctx)
}

// TimePartitioningPtrInput is an input type that accepts TimePartitioningArgs, TimePartitioningPtr and TimePartitioningPtrOutput values.
// You can construct a concrete instance of `TimePartitioningPtrInput` via:
//
//	        TimePartitioningArgs{...}
//
//	or:
//
//	        nil
type TimePartitioningPtrInput interface {
	pulumi.Input

	ToTimePartitioningPtrOutput() TimePartitioningPtrOutput
	ToTimePartitioningPtrOutputWithContext(context.Context) TimePartitioningPtrOutput
}

type timePartitioningPtrType TimePartitioningArgs

func TimePartitioningPtr(v *TimePartitioningArgs) TimePartitioningPtrInput {
	return (*timePartitioningPtrType)(v)
}

func (*timePartitioningPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TimePartitioning)(nil)).Elem()
}

func (i *timePartitioningPtrType) ToTimePartitioningPtrOutput() TimePartitioningPtrOutput {
	return i.ToTimePartitioningPtrOutputWithContext(context.Background())
}

func (i *timePartitioningPtrType) ToTimePartitioningPtrOutputWithContext(ctx context.Context) TimePartitioningPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimePartitioningPtrOutput)
}

// Configuration for FHIR BigQuery time-partitioned tables.
type TimePartitioningOutput struct{ *pulumi.OutputState }

func (TimePartitioningOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimePartitioning)(nil)).Elem()
}

func (o TimePartitioningOutput) ToTimePartitioningOutput() TimePartitioningOutput {
	return o
}

func (o TimePartitioningOutput) ToTimePartitioningOutputWithContext(ctx context.Context) TimePartitioningOutput {
	return o
}

func (o TimePartitioningOutput) ToTimePartitioningPtrOutput() TimePartitioningPtrOutput {
	return o.ToTimePartitioningPtrOutputWithContext(context.Background())
}

func (o TimePartitioningOutput) ToTimePartitioningPtrOutputWithContext(ctx context.Context) TimePartitioningPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TimePartitioning) *TimePartitioning {
		return &v
	}).(TimePartitioningPtrOutput)
}

// Number of milliseconds for which to keep the storage for a partition.
func (o TimePartitioningOutput) ExpirationMs() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimePartitioning) *string { return v.ExpirationMs }).(pulumi.StringPtrOutput)
}

// Type of partitioning.
func (o TimePartitioningOutput) Type() TimePartitioningTypePtrOutput {
	return o.ApplyT(func(v TimePartitioning) *TimePartitioningType { return v.Type }).(TimePartitioningTypePtrOutput)
}

type TimePartitioningPtrOutput struct{ *pulumi.OutputState }

func (TimePartitioningPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TimePartitioning)(nil)).Elem()
}

func (o TimePartitioningPtrOutput) ToTimePartitioningPtrOutput() TimePartitioningPtrOutput {
	return o
}

func (o TimePartitioningPtrOutput) ToTimePartitioningPtrOutputWithContext(ctx context.Context) TimePartitioningPtrOutput {
	return o
}

func (o TimePartitioningPtrOutput) Elem() TimePartitioningOutput {
	return o.ApplyT(func(v *TimePartitioning) TimePartitioning {
		if v != nil {
			return *v
		}
		var ret TimePartitioning
		return ret
	}).(TimePartitioningOutput)
}

// Number of milliseconds for which to keep the storage for a partition.
func (o TimePartitioningPtrOutput) ExpirationMs() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimePartitioning) *string {
		if v == nil {
			return nil
		}
		return v.ExpirationMs
	}).(pulumi.StringPtrOutput)
}

// Type of partitioning.
func (o TimePartitioningPtrOutput) Type() TimePartitioningTypePtrOutput {
	return o.ApplyT(func(v *TimePartitioning) *TimePartitioningType {
		if v == nil {
			return nil
		}
		return v.Type
	}).(TimePartitioningTypePtrOutput)
}

// Configuration for FHIR BigQuery time-partitioned tables.
type TimePartitioningResponse struct {
	// Number of milliseconds for which to keep the storage for a partition.
	ExpirationMs string `pulumi:"expirationMs"`
	// Type of partitioning.
	Type string `pulumi:"type"`
}

// Configuration for FHIR BigQuery time-partitioned tables.
type TimePartitioningResponseOutput struct{ *pulumi.OutputState }

func (TimePartitioningResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimePartitioningResponse)(nil)).Elem()
}

func (o TimePartitioningResponseOutput) ToTimePartitioningResponseOutput() TimePartitioningResponseOutput {
	return o
}

func (o TimePartitioningResponseOutput) ToTimePartitioningResponseOutputWithContext(ctx context.Context) TimePartitioningResponseOutput {
	return o
}

// Number of milliseconds for which to keep the storage for a partition.
func (o TimePartitioningResponseOutput) ExpirationMs() pulumi.StringOutput {
	return o.ApplyT(func(v TimePartitioningResponse) string { return v.ExpirationMs }).(pulumi.StringOutput)
}

// Type of partitioning.
func (o TimePartitioningResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v TimePartitioningResponse) string { return v.Type }).(pulumi.StringOutput)
}

// A type definition for some HL7v2 type (incl. Segments and Datatypes).
type Type struct {
	// The (sub) fields this type has (if not primitive).
	Fields []Field `pulumi:"fields"`
	// The name of this type. This would be the segment or datatype name. For example, "PID" or "XPN".
	Name *string `pulumi:"name"`
	// If this is a primitive type then this field is the type of the primitive For example, STRING. Leave unspecified for composite types.
	Primitive *TypePrimitive `pulumi:"primitive"`
}

// TypeInput is an input type that accepts TypeArgs and TypeOutput values.
// You can construct a concrete instance of `TypeInput` via:
//
//	TypeArgs{...}
type TypeInput interface {
	pulumi.Input

	ToTypeOutput() TypeOutput
	ToTypeOutputWithContext(context.Context) TypeOutput
}

// A type definition for some HL7v2 type (incl. Segments and Datatypes).
type TypeArgs struct {
	// The (sub) fields this type has (if not primitive).
	Fields FieldArrayInput `pulumi:"fields"`
	// The name of this type. This would be the segment or datatype name. For example, "PID" or "XPN".
	Name pulumi.StringPtrInput `pulumi:"name"`
	// If this is a primitive type then this field is the type of the primitive For example, STRING. Leave unspecified for composite types.
	Primitive TypePrimitivePtrInput `pulumi:"primitive"`
}

func (TypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Type)(nil)).Elem()
}

func (i TypeArgs) ToTypeOutput() TypeOutput {
	return i.ToTypeOutputWithContext(context.Background())
}

func (i TypeArgs) ToTypeOutputWithContext(ctx context.Context) TypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TypeOutput)
}

// TypeArrayInput is an input type that accepts TypeArray and TypeArrayOutput values.
// You can construct a concrete instance of `TypeArrayInput` via:
//
//	TypeArray{ TypeArgs{...} }
type TypeArrayInput interface {
	pulumi.Input

	ToTypeArrayOutput() TypeArrayOutput
	ToTypeArrayOutputWithContext(context.Context) TypeArrayOutput
}

type TypeArray []TypeInput

func (TypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Type)(nil)).Elem()
}

func (i TypeArray) ToTypeArrayOutput() TypeArrayOutput {
	return i.ToTypeArrayOutputWithContext(context.Background())
}

func (i TypeArray) ToTypeArrayOutputWithContext(ctx context.Context) TypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TypeArrayOutput)
}

// A type definition for some HL7v2 type (incl. Segments and Datatypes).
type TypeOutput struct{ *pulumi.OutputState }

func (TypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Type)(nil)).Elem()
}

func (o TypeOutput) ToTypeOutput() TypeOutput {
	return o
}

func (o TypeOutput) ToTypeOutputWithContext(ctx context.Context) TypeOutput {
	return o
}

// The (sub) fields this type has (if not primitive).
func (o TypeOutput) Fields() FieldArrayOutput {
	return o.ApplyT(func(v Type) []Field { return v.Fields }).(FieldArrayOutput)
}

// The name of this type. This would be the segment or datatype name. For example, "PID" or "XPN".
func (o TypeOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Type) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// If this is a primitive type then this field is the type of the primitive For example, STRING. Leave unspecified for composite types.
func (o TypeOutput) Primitive() TypePrimitivePtrOutput {
	return o.ApplyT(func(v Type) *TypePrimitive { return v.Primitive }).(TypePrimitivePtrOutput)
}

type TypeArrayOutput struct{ *pulumi.OutputState }

func (TypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Type)(nil)).Elem()
}

func (o TypeArrayOutput) ToTypeArrayOutput() TypeArrayOutput {
	return o
}

func (o TypeArrayOutput) ToTypeArrayOutputWithContext(ctx context.Context) TypeArrayOutput {
	return o
}

func (o TypeArrayOutput) Index(i pulumi.IntInput) TypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Type {
		return vs[0].([]Type)[vs[1].(int)]
	}).(TypeOutput)
}

// A type definition for some HL7v2 type (incl. Segments and Datatypes).
type TypeResponse struct {
	// The (sub) fields this type has (if not primitive).
	Fields []FieldResponse `pulumi:"fields"`
	// The name of this type. This would be the segment or datatype name. For example, "PID" or "XPN".
	Name string `pulumi:"name"`
	// If this is a primitive type then this field is the type of the primitive For example, STRING. Leave unspecified for composite types.
	Primitive string `pulumi:"primitive"`
}

// A type definition for some HL7v2 type (incl. Segments and Datatypes).
type TypeResponseOutput struct{ *pulumi.OutputState }

func (TypeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TypeResponse)(nil)).Elem()
}

func (o TypeResponseOutput) ToTypeResponseOutput() TypeResponseOutput {
	return o
}

func (o TypeResponseOutput) ToTypeResponseOutputWithContext(ctx context.Context) TypeResponseOutput {
	return o
}

// The (sub) fields this type has (if not primitive).
func (o TypeResponseOutput) Fields() FieldResponseArrayOutput {
	return o.ApplyT(func(v TypeResponse) []FieldResponse { return v.Fields }).(FieldResponseArrayOutput)
}

// The name of this type. This would be the segment or datatype name. For example, "PID" or "XPN".
func (o TypeResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v TypeResponse) string { return v.Name }).(pulumi.StringOutput)
}

// If this is a primitive type then this field is the type of the primitive For example, STRING. Leave unspecified for composite types.
func (o TypeResponseOutput) Primitive() pulumi.StringOutput {
	return o.ApplyT(func(v TypeResponse) string { return v.Primitive }).(pulumi.StringOutput)
}

type TypeResponseArrayOutput struct{ *pulumi.OutputState }

func (TypeResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TypeResponse)(nil)).Elem()
}

func (o TypeResponseArrayOutput) ToTypeResponseArrayOutput() TypeResponseArrayOutput {
	return o
}

func (o TypeResponseArrayOutput) ToTypeResponseArrayOutputWithContext(ctx context.Context) TypeResponseArrayOutput {
	return o
}

func (o TypeResponseArrayOutput) Index(i pulumi.IntInput) TypeResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TypeResponse {
		return vs[0].([]TypeResponse)[vs[1].(int)]
	}).(TypeResponseOutput)
}

// Contains the configuration for FHIR profiles and validation.
type ValidationConfig struct {
	// Whether to disable FHIRPath validation for incoming resources. Set this to true to disable checking incoming resources for conformance against FHIRPath requirement defined in the FHIR specification. This property only affects resource types that do not have profiles configured for them, any rules in enabled implementation guides will still be enforced.
	DisableFhirpathValidation *bool `pulumi:"disableFhirpathValidation"`
	// Whether to disable profile validation for this FHIR store. Set this to true to disable checking incoming resources for conformance against StructureDefinitions in this FHIR store.
	DisableProfileValidation *bool `pulumi:"disableProfileValidation"`
	// Whether to disable reference type validation for incoming resources. Set this to true to disable checking incoming resources for conformance against reference type requirement defined in the FHIR specification. This property only affects resource types that do not have profiles configured for them, any rules in enabled implementation guides will still be enforced.
	DisableReferenceTypeValidation *bool `pulumi:"disableReferenceTypeValidation"`
	// Whether to disable required fields validation for incoming resources. Set this to true to disable checking incoming resources for conformance against required fields requirement defined in the FHIR specification. This property only affects resource types that do not have profiles configured for them, any rules in enabled implementation guides will still be enforced.
	DisableRequiredFieldValidation *bool `pulumi:"disableRequiredFieldValidation"`
	// A list of ImplementationGuide URLs in this FHIR store that are used to configure the profiles to use for validation. For example, to use the US Core profiles for validation, set `enabled_implementation_guides` to `["http://hl7.org/fhir/us/core/ImplementationGuide/ig"]`. If `enabled_implementation_guides` is empty or omitted, then incoming resources are only required to conform to the base FHIR profiles. Otherwise, a resource must conform to at least one profile listed in the `global` property of one of the enabled ImplementationGuides. The Cloud Healthcare API does not currently enforce all of the rules in a StructureDefinition. The following rules are supported: - min/max - minValue/maxValue - maxLength - type - fixed[x] - pattern[x] on simple types - slicing, when using "value" as the discriminator type When a URL cannot be resolved (for example, in a type assertion), the server does not return an error.
	EnabledImplementationGuides []string `pulumi:"enabledImplementationGuides"`
}

// ValidationConfigInput is an input type that accepts ValidationConfigArgs and ValidationConfigOutput values.
// You can construct a concrete instance of `ValidationConfigInput` via:
//
//	ValidationConfigArgs{...}
type ValidationConfigInput interface {
	pulumi.Input

	ToValidationConfigOutput() ValidationConfigOutput
	ToValidationConfigOutputWithContext(context.Context) ValidationConfigOutput
}

// Contains the configuration for FHIR profiles and validation.
type ValidationConfigArgs struct {
	// Whether to disable FHIRPath validation for incoming resources. Set this to true to disable checking incoming resources for conformance against FHIRPath requirement defined in the FHIR specification. This property only affects resource types that do not have profiles configured for them, any rules in enabled implementation guides will still be enforced.
	DisableFhirpathValidation pulumi.BoolPtrInput `pulumi:"disableFhirpathValidation"`
	// Whether to disable profile validation for this FHIR store. Set this to true to disable checking incoming resources for conformance against StructureDefinitions in this FHIR store.
	DisableProfileValidation pulumi.BoolPtrInput `pulumi:"disableProfileValidation"`
	// Whether to disable reference type validation for incoming resources. Set this to true to disable checking incoming resources for conformance against reference type requirement defined in the FHIR specification. This property only affects resource types that do not have profiles configured for them, any rules in enabled implementation guides will still be enforced.
	DisableReferenceTypeValidation pulumi.BoolPtrInput `pulumi:"disableReferenceTypeValidation"`
	// Whether to disable required fields validation for incoming resources. Set this to true to disable checking incoming resources for conformance against required fields requirement defined in the FHIR specification. This property only affects resource types that do not have profiles configured for them, any rules in enabled implementation guides will still be enforced.
	DisableRequiredFieldValidation pulumi.BoolPtrInput `pulumi:"disableRequiredFieldValidation"`
	// A list of ImplementationGuide URLs in this FHIR store that are used to configure the profiles to use for validation. For example, to use the US Core profiles for validation, set `enabled_implementation_guides` to `["http://hl7.org/fhir/us/core/ImplementationGuide/ig"]`. If `enabled_implementation_guides` is empty or omitted, then incoming resources are only required to conform to the base FHIR profiles. Otherwise, a resource must conform to at least one profile listed in the `global` property of one of the enabled ImplementationGuides. The Cloud Healthcare API does not currently enforce all of the rules in a StructureDefinition. The following rules are supported: - min/max - minValue/maxValue - maxLength - type - fixed[x] - pattern[x] on simple types - slicing, when using "value" as the discriminator type When a URL cannot be resolved (for example, in a type assertion), the server does not return an error.
	EnabledImplementationGuides pulumi.StringArrayInput `pulumi:"enabledImplementationGuides"`
}

func (ValidationConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ValidationConfig)(nil)).Elem()
}

func (i ValidationConfigArgs) ToValidationConfigOutput() ValidationConfigOutput {
	return i.ToValidationConfigOutputWithContext(context.Background())
}

func (i ValidationConfigArgs) ToValidationConfigOutputWithContext(ctx context.Context) ValidationConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ValidationConfigOutput)
}

func (i ValidationConfigArgs) ToValidationConfigPtrOutput() ValidationConfigPtrOutput {
	return i.ToValidationConfigPtrOutputWithContext(context.Background())
}

func (i ValidationConfigArgs) ToValidationConfigPtrOutputWithContext(ctx context.Context) ValidationConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ValidationConfigOutput).ToValidationConfigPtrOutputWithContext(ctx)
}

// ValidationConfigPtrInput is an input type that accepts ValidationConfigArgs, ValidationConfigPtr and ValidationConfigPtrOutput values.
// You can construct a concrete instance of `ValidationConfigPtrInput` via:
//
//	        ValidationConfigArgs{...}
//
//	or:
//
//	        nil
type ValidationConfigPtrInput interface {
	pulumi.Input

	ToValidationConfigPtrOutput() ValidationConfigPtrOutput
	ToValidationConfigPtrOutputWithContext(context.Context) ValidationConfigPtrOutput
}

type validationConfigPtrType ValidationConfigArgs

func ValidationConfigPtr(v *ValidationConfigArgs) ValidationConfigPtrInput {
	return (*validationConfigPtrType)(v)
}

func (*validationConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ValidationConfig)(nil)).Elem()
}

func (i *validationConfigPtrType) ToValidationConfigPtrOutput() ValidationConfigPtrOutput {
	return i.ToValidationConfigPtrOutputWithContext(context.Background())
}

func (i *validationConfigPtrType) ToValidationConfigPtrOutputWithContext(ctx context.Context) ValidationConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ValidationConfigPtrOutput)
}

// Contains the configuration for FHIR profiles and validation.
type ValidationConfigOutput struct{ *pulumi.OutputState }

func (ValidationConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ValidationConfig)(nil)).Elem()
}

func (o ValidationConfigOutput) ToValidationConfigOutput() ValidationConfigOutput {
	return o
}

func (o ValidationConfigOutput) ToValidationConfigOutputWithContext(ctx context.Context) ValidationConfigOutput {
	return o
}

func (o ValidationConfigOutput) ToValidationConfigPtrOutput() ValidationConfigPtrOutput {
	return o.ToValidationConfigPtrOutputWithContext(context.Background())
}

func (o ValidationConfigOutput) ToValidationConfigPtrOutputWithContext(ctx context.Context) ValidationConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ValidationConfig) *ValidationConfig {
		return &v
	}).(ValidationConfigPtrOutput)
}

// Whether to disable FHIRPath validation for incoming resources. Set this to true to disable checking incoming resources for conformance against FHIRPath requirement defined in the FHIR specification. This property only affects resource types that do not have profiles configured for them, any rules in enabled implementation guides will still be enforced.
func (o ValidationConfigOutput) DisableFhirpathValidation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ValidationConfig) *bool { return v.DisableFhirpathValidation }).(pulumi.BoolPtrOutput)
}

// Whether to disable profile validation for this FHIR store. Set this to true to disable checking incoming resources for conformance against StructureDefinitions in this FHIR store.
func (o ValidationConfigOutput) DisableProfileValidation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ValidationConfig) *bool { return v.DisableProfileValidation }).(pulumi.BoolPtrOutput)
}

// Whether to disable reference type validation for incoming resources. Set this to true to disable checking incoming resources for conformance against reference type requirement defined in the FHIR specification. This property only affects resource types that do not have profiles configured for them, any rules in enabled implementation guides will still be enforced.
func (o ValidationConfigOutput) DisableReferenceTypeValidation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ValidationConfig) *bool { return v.DisableReferenceTypeValidation }).(pulumi.BoolPtrOutput)
}

// Whether to disable required fields validation for incoming resources. Set this to true to disable checking incoming resources for conformance against required fields requirement defined in the FHIR specification. This property only affects resource types that do not have profiles configured for them, any rules in enabled implementation guides will still be enforced.
func (o ValidationConfigOutput) DisableRequiredFieldValidation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ValidationConfig) *bool { return v.DisableRequiredFieldValidation }).(pulumi.BoolPtrOutput)
}

// A list of ImplementationGuide URLs in this FHIR store that are used to configure the profiles to use for validation. For example, to use the US Core profiles for validation, set `enabled_implementation_guides` to `["http://hl7.org/fhir/us/core/ImplementationGuide/ig"]`. If `enabled_implementation_guides` is empty or omitted, then incoming resources are only required to conform to the base FHIR profiles. Otherwise, a resource must conform to at least one profile listed in the `global` property of one of the enabled ImplementationGuides. The Cloud Healthcare API does not currently enforce all of the rules in a StructureDefinition. The following rules are supported: - min/max - minValue/maxValue - maxLength - type - fixed[x] - pattern[x] on simple types - slicing, when using "value" as the discriminator type When a URL cannot be resolved (for example, in a type assertion), the server does not return an error.
func (o ValidationConfigOutput) EnabledImplementationGuides() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ValidationConfig) []string { return v.EnabledImplementationGuides }).(pulumi.StringArrayOutput)
}

type ValidationConfigPtrOutput struct{ *pulumi.OutputState }

func (ValidationConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ValidationConfig)(nil)).Elem()
}

func (o ValidationConfigPtrOutput) ToValidationConfigPtrOutput() ValidationConfigPtrOutput {
	return o
}

func (o ValidationConfigPtrOutput) ToValidationConfigPtrOutputWithContext(ctx context.Context) ValidationConfigPtrOutput {
	return o
}

func (o ValidationConfigPtrOutput) Elem() ValidationConfigOutput {
	return o.ApplyT(func(v *ValidationConfig) ValidationConfig {
		if v != nil {
			return *v
		}
		var ret ValidationConfig
		return ret
	}).(ValidationConfigOutput)
}

// Whether to disable FHIRPath validation for incoming resources. Set this to true to disable checking incoming resources for conformance against FHIRPath requirement defined in the FHIR specification. This property only affects resource types that do not have profiles configured for them, any rules in enabled implementation guides will still be enforced.
func (o ValidationConfigPtrOutput) DisableFhirpathValidation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ValidationConfig) *bool {
		if v == nil {
			return nil
		}
		return v.DisableFhirpathValidation
	}).(pulumi.BoolPtrOutput)
}

// Whether to disable profile validation for this FHIR store. Set this to true to disable checking incoming resources for conformance against StructureDefinitions in this FHIR store.
func (o ValidationConfigPtrOutput) DisableProfileValidation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ValidationConfig) *bool {
		if v == nil {
			return nil
		}
		return v.DisableProfileValidation
	}).(pulumi.BoolPtrOutput)
}

// Whether to disable reference type validation for incoming resources. Set this to true to disable checking incoming resources for conformance against reference type requirement defined in the FHIR specification. This property only affects resource types that do not have profiles configured for them, any rules in enabled implementation guides will still be enforced.
func (o ValidationConfigPtrOutput) DisableReferenceTypeValidation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ValidationConfig) *bool {
		if v == nil {
			return nil
		}
		return v.DisableReferenceTypeValidation
	}).(pulumi.BoolPtrOutput)
}

// Whether to disable required fields validation for incoming resources. Set this to true to disable checking incoming resources for conformance against required fields requirement defined in the FHIR specification. This property only affects resource types that do not have profiles configured for them, any rules in enabled implementation guides will still be enforced.
func (o ValidationConfigPtrOutput) DisableRequiredFieldValidation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ValidationConfig) *bool {
		if v == nil {
			return nil
		}
		return v.DisableRequiredFieldValidation
	}).(pulumi.BoolPtrOutput)
}

// A list of ImplementationGuide URLs in this FHIR store that are used to configure the profiles to use for validation. For example, to use the US Core profiles for validation, set `enabled_implementation_guides` to `["http://hl7.org/fhir/us/core/ImplementationGuide/ig"]`. If `enabled_implementation_guides` is empty or omitted, then incoming resources are only required to conform to the base FHIR profiles. Otherwise, a resource must conform to at least one profile listed in the `global` property of one of the enabled ImplementationGuides. The Cloud Healthcare API does not currently enforce all of the rules in a StructureDefinition. The following rules are supported: - min/max - minValue/maxValue - maxLength - type - fixed[x] - pattern[x] on simple types - slicing, when using "value" as the discriminator type When a URL cannot be resolved (for example, in a type assertion), the server does not return an error.
func (o ValidationConfigPtrOutput) EnabledImplementationGuides() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ValidationConfig) []string {
		if v == nil {
			return nil
		}
		return v.EnabledImplementationGuides
	}).(pulumi.StringArrayOutput)
}

// Contains the configuration for FHIR profiles and validation.
type ValidationConfigResponse struct {
	// Whether to disable FHIRPath validation for incoming resources. Set this to true to disable checking incoming resources for conformance against FHIRPath requirement defined in the FHIR specification. This property only affects resource types that do not have profiles configured for them, any rules in enabled implementation guides will still be enforced.
	DisableFhirpathValidation bool `pulumi:"disableFhirpathValidation"`
	// Whether to disable profile validation for this FHIR store. Set this to true to disable checking incoming resources for conformance against StructureDefinitions in this FHIR store.
	DisableProfileValidation bool `pulumi:"disableProfileValidation"`
	// Whether to disable reference type validation for incoming resources. Set this to true to disable checking incoming resources for conformance against reference type requirement defined in the FHIR specification. This property only affects resource types that do not have profiles configured for them, any rules in enabled implementation guides will still be enforced.
	DisableReferenceTypeValidation bool `pulumi:"disableReferenceTypeValidation"`
	// Whether to disable required fields validation for incoming resources. Set this to true to disable checking incoming resources for conformance against required fields requirement defined in the FHIR specification. This property only affects resource types that do not have profiles configured for them, any rules in enabled implementation guides will still be enforced.
	DisableRequiredFieldValidation bool `pulumi:"disableRequiredFieldValidation"`
	// A list of ImplementationGuide URLs in this FHIR store that are used to configure the profiles to use for validation. For example, to use the US Core profiles for validation, set `enabled_implementation_guides` to `["http://hl7.org/fhir/us/core/ImplementationGuide/ig"]`. If `enabled_implementation_guides` is empty or omitted, then incoming resources are only required to conform to the base FHIR profiles. Otherwise, a resource must conform to at least one profile listed in the `global` property of one of the enabled ImplementationGuides. The Cloud Healthcare API does not currently enforce all of the rules in a StructureDefinition. The following rules are supported: - min/max - minValue/maxValue - maxLength - type - fixed[x] - pattern[x] on simple types - slicing, when using "value" as the discriminator type When a URL cannot be resolved (for example, in a type assertion), the server does not return an error.
	EnabledImplementationGuides []string `pulumi:"enabledImplementationGuides"`
}

// Contains the configuration for FHIR profiles and validation.
type ValidationConfigResponseOutput struct{ *pulumi.OutputState }

func (ValidationConfigResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ValidationConfigResponse)(nil)).Elem()
}

func (o ValidationConfigResponseOutput) ToValidationConfigResponseOutput() ValidationConfigResponseOutput {
	return o
}

func (o ValidationConfigResponseOutput) ToValidationConfigResponseOutputWithContext(ctx context.Context) ValidationConfigResponseOutput {
	return o
}

// Whether to disable FHIRPath validation for incoming resources. Set this to true to disable checking incoming resources for conformance against FHIRPath requirement defined in the FHIR specification. This property only affects resource types that do not have profiles configured for them, any rules in enabled implementation guides will still be enforced.
func (o ValidationConfigResponseOutput) DisableFhirpathValidation() pulumi.BoolOutput {
	return o.ApplyT(func(v ValidationConfigResponse) bool { return v.DisableFhirpathValidation }).(pulumi.BoolOutput)
}

// Whether to disable profile validation for this FHIR store. Set this to true to disable checking incoming resources for conformance against StructureDefinitions in this FHIR store.
func (o ValidationConfigResponseOutput) DisableProfileValidation() pulumi.BoolOutput {
	return o.ApplyT(func(v ValidationConfigResponse) bool { return v.DisableProfileValidation }).(pulumi.BoolOutput)
}

// Whether to disable reference type validation for incoming resources. Set this to true to disable checking incoming resources for conformance against reference type requirement defined in the FHIR specification. This property only affects resource types that do not have profiles configured for them, any rules in enabled implementation guides will still be enforced.
func (o ValidationConfigResponseOutput) DisableReferenceTypeValidation() pulumi.BoolOutput {
	return o.ApplyT(func(v ValidationConfigResponse) bool { return v.DisableReferenceTypeValidation }).(pulumi.BoolOutput)
}

// Whether to disable required fields validation for incoming resources. Set this to true to disable checking incoming resources for conformance against required fields requirement defined in the FHIR specification. This property only affects resource types that do not have profiles configured for them, any rules in enabled implementation guides will still be enforced.
func (o ValidationConfigResponseOutput) DisableRequiredFieldValidation() pulumi.BoolOutput {
	return o.ApplyT(func(v ValidationConfigResponse) bool { return v.DisableRequiredFieldValidation }).(pulumi.BoolOutput)
}

// A list of ImplementationGuide URLs in this FHIR store that are used to configure the profiles to use for validation. For example, to use the US Core profiles for validation, set `enabled_implementation_guides` to `["http://hl7.org/fhir/us/core/ImplementationGuide/ig"]`. If `enabled_implementation_guides` is empty or omitted, then incoming resources are only required to conform to the base FHIR profiles. Otherwise, a resource must conform to at least one profile listed in the `global` property of one of the enabled ImplementationGuides. The Cloud Healthcare API does not currently enforce all of the rules in a StructureDefinition. The following rules are supported: - min/max - minValue/maxValue - maxLength - type - fixed[x] - pattern[x] on simple types - slicing, when using "value" as the discriminator type When a URL cannot be resolved (for example, in a type assertion), the server does not return an error.
func (o ValidationConfigResponseOutput) EnabledImplementationGuides() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ValidationConfigResponse) []string { return v.EnabledImplementationGuides }).(pulumi.StringArrayOutput)
}

// Describes a selector for extracting and matching an MSH field to a value.
type VersionSource struct {
	// The field to extract from the MSH segment. For example, "3.1" or "18[1].1".
	MshField *string `pulumi:"mshField"`
	// The value to match with the field. For example, "My Application Name" or "2.3".
	Value *string `pulumi:"value"`
}

// VersionSourceInput is an input type that accepts VersionSourceArgs and VersionSourceOutput values.
// You can construct a concrete instance of `VersionSourceInput` via:
//
//	VersionSourceArgs{...}
type VersionSourceInput interface {
	pulumi.Input

	ToVersionSourceOutput() VersionSourceOutput
	ToVersionSourceOutputWithContext(context.Context) VersionSourceOutput
}

// Describes a selector for extracting and matching an MSH field to a value.
type VersionSourceArgs struct {
	// The field to extract from the MSH segment. For example, "3.1" or "18[1].1".
	MshField pulumi.StringPtrInput `pulumi:"mshField"`
	// The value to match with the field. For example, "My Application Name" or "2.3".
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (VersionSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VersionSource)(nil)).Elem()
}

func (i VersionSourceArgs) ToVersionSourceOutput() VersionSourceOutput {
	return i.ToVersionSourceOutputWithContext(context.Background())
}

func (i VersionSourceArgs) ToVersionSourceOutputWithContext(ctx context.Context) VersionSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VersionSourceOutput)
}

// VersionSourceArrayInput is an input type that accepts VersionSourceArray and VersionSourceArrayOutput values.
// You can construct a concrete instance of `VersionSourceArrayInput` via:
//
//	VersionSourceArray{ VersionSourceArgs{...} }
type VersionSourceArrayInput interface {
	pulumi.Input

	ToVersionSourceArrayOutput() VersionSourceArrayOutput
	ToVersionSourceArrayOutputWithContext(context.Context) VersionSourceArrayOutput
}

type VersionSourceArray []VersionSourceInput

func (VersionSourceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VersionSource)(nil)).Elem()
}

func (i VersionSourceArray) ToVersionSourceArrayOutput() VersionSourceArrayOutput {
	return i.ToVersionSourceArrayOutputWithContext(context.Background())
}

func (i VersionSourceArray) ToVersionSourceArrayOutputWithContext(ctx context.Context) VersionSourceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VersionSourceArrayOutput)
}

// Describes a selector for extracting and matching an MSH field to a value.
type VersionSourceOutput struct{ *pulumi.OutputState }

func (VersionSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VersionSource)(nil)).Elem()
}

func (o VersionSourceOutput) ToVersionSourceOutput() VersionSourceOutput {
	return o
}

func (o VersionSourceOutput) ToVersionSourceOutputWithContext(ctx context.Context) VersionSourceOutput {
	return o
}

// The field to extract from the MSH segment. For example, "3.1" or "18[1].1".
func (o VersionSourceOutput) MshField() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VersionSource) *string { return v.MshField }).(pulumi.StringPtrOutput)
}

// The value to match with the field. For example, "My Application Name" or "2.3".
func (o VersionSourceOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VersionSource) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type VersionSourceArrayOutput struct{ *pulumi.OutputState }

func (VersionSourceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VersionSource)(nil)).Elem()
}

func (o VersionSourceArrayOutput) ToVersionSourceArrayOutput() VersionSourceArrayOutput {
	return o
}

func (o VersionSourceArrayOutput) ToVersionSourceArrayOutputWithContext(ctx context.Context) VersionSourceArrayOutput {
	return o
}

func (o VersionSourceArrayOutput) Index(i pulumi.IntInput) VersionSourceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VersionSource {
		return vs[0].([]VersionSource)[vs[1].(int)]
	}).(VersionSourceOutput)
}

// Describes a selector for extracting and matching an MSH field to a value.
type VersionSourceResponse struct {
	// The field to extract from the MSH segment. For example, "3.1" or "18[1].1".
	MshField string `pulumi:"mshField"`
	// The value to match with the field. For example, "My Application Name" or "2.3".
	Value string `pulumi:"value"`
}

// Describes a selector for extracting and matching an MSH field to a value.
type VersionSourceResponseOutput struct{ *pulumi.OutputState }

func (VersionSourceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VersionSourceResponse)(nil)).Elem()
}

func (o VersionSourceResponseOutput) ToVersionSourceResponseOutput() VersionSourceResponseOutput {
	return o
}

func (o VersionSourceResponseOutput) ToVersionSourceResponseOutputWithContext(ctx context.Context) VersionSourceResponseOutput {
	return o
}

// The field to extract from the MSH segment. For example, "3.1" or "18[1].1".
func (o VersionSourceResponseOutput) MshField() pulumi.StringOutput {
	return o.ApplyT(func(v VersionSourceResponse) string { return v.MshField }).(pulumi.StringOutput)
}

// The value to match with the field. For example, "My Application Name" or "2.3".
func (o VersionSourceResponseOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v VersionSourceResponse) string { return v.Value }).(pulumi.StringOutput)
}

type VersionSourceResponseArrayOutput struct{ *pulumi.OutputState }

func (VersionSourceResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VersionSourceResponse)(nil)).Elem()
}

func (o VersionSourceResponseArrayOutput) ToVersionSourceResponseArrayOutput() VersionSourceResponseArrayOutput {
	return o
}

func (o VersionSourceResponseArrayOutput) ToVersionSourceResponseArrayOutputWithContext(ctx context.Context) VersionSourceResponseArrayOutput {
	return o
}

func (o VersionSourceResponseArrayOutput) Index(i pulumi.IntInput) VersionSourceResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VersionSourceResponse {
		return vs[0].([]VersionSourceResponse)[vs[1].(int)]
	}).(VersionSourceResponseOutput)
}

// A 2D coordinate in an image. The origin is the top-left.
type Vertex struct {
	// X coordinate.
	X *float64 `pulumi:"x"`
	// Y coordinate.
	Y *float64 `pulumi:"y"`
}

// VertexInput is an input type that accepts VertexArgs and VertexOutput values.
// You can construct a concrete instance of `VertexInput` via:
//
//	VertexArgs{...}
type VertexInput interface {
	pulumi.Input

	ToVertexOutput() VertexOutput
	ToVertexOutputWithContext(context.Context) VertexOutput
}

// A 2D coordinate in an image. The origin is the top-left.
type VertexArgs struct {
	// X coordinate.
	X pulumi.Float64PtrInput `pulumi:"x"`
	// Y coordinate.
	Y pulumi.Float64PtrInput `pulumi:"y"`
}

func (VertexArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Vertex)(nil)).Elem()
}

func (i VertexArgs) ToVertexOutput() VertexOutput {
	return i.ToVertexOutputWithContext(context.Background())
}

func (i VertexArgs) ToVertexOutputWithContext(ctx context.Context) VertexOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VertexOutput)
}

// VertexArrayInput is an input type that accepts VertexArray and VertexArrayOutput values.
// You can construct a concrete instance of `VertexArrayInput` via:
//
//	VertexArray{ VertexArgs{...} }
type VertexArrayInput interface {
	pulumi.Input

	ToVertexArrayOutput() VertexArrayOutput
	ToVertexArrayOutputWithContext(context.Context) VertexArrayOutput
}

type VertexArray []VertexInput

func (VertexArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Vertex)(nil)).Elem()
}

func (i VertexArray) ToVertexArrayOutput() VertexArrayOutput {
	return i.ToVertexArrayOutputWithContext(context.Background())
}

func (i VertexArray) ToVertexArrayOutputWithContext(ctx context.Context) VertexArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VertexArrayOutput)
}

// A 2D coordinate in an image. The origin is the top-left.
type VertexOutput struct{ *pulumi.OutputState }

func (VertexOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Vertex)(nil)).Elem()
}

func (o VertexOutput) ToVertexOutput() VertexOutput {
	return o
}

func (o VertexOutput) ToVertexOutputWithContext(ctx context.Context) VertexOutput {
	return o
}

// X coordinate.
func (o VertexOutput) X() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Vertex) *float64 { return v.X }).(pulumi.Float64PtrOutput)
}

// Y coordinate.
func (o VertexOutput) Y() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Vertex) *float64 { return v.Y }).(pulumi.Float64PtrOutput)
}

type VertexArrayOutput struct{ *pulumi.OutputState }

func (VertexArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Vertex)(nil)).Elem()
}

func (o VertexArrayOutput) ToVertexArrayOutput() VertexArrayOutput {
	return o
}

func (o VertexArrayOutput) ToVertexArrayOutputWithContext(ctx context.Context) VertexArrayOutput {
	return o
}

func (o VertexArrayOutput) Index(i pulumi.IntInput) VertexOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Vertex {
		return vs[0].([]Vertex)[vs[1].(int)]
	}).(VertexOutput)
}

// A 2D coordinate in an image. The origin is the top-left.
type VertexResponse struct {
	// X coordinate.
	X float64 `pulumi:"x"`
	// Y coordinate.
	Y float64 `pulumi:"y"`
}

// A 2D coordinate in an image. The origin is the top-left.
type VertexResponseOutput struct{ *pulumi.OutputState }

func (VertexResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VertexResponse)(nil)).Elem()
}

func (o VertexResponseOutput) ToVertexResponseOutput() VertexResponseOutput {
	return o
}

func (o VertexResponseOutput) ToVertexResponseOutputWithContext(ctx context.Context) VertexResponseOutput {
	return o
}

// X coordinate.
func (o VertexResponseOutput) X() pulumi.Float64Output {
	return o.ApplyT(func(v VertexResponse) float64 { return v.X }).(pulumi.Float64Output)
}

// Y coordinate.
func (o VertexResponseOutput) Y() pulumi.Float64Output {
	return o.ApplyT(func(v VertexResponse) float64 { return v.Y }).(pulumi.Float64Output)
}

type VertexResponseArrayOutput struct{ *pulumi.OutputState }

func (VertexResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VertexResponse)(nil)).Elem()
}

func (o VertexResponseArrayOutput) ToVertexResponseArrayOutput() VertexResponseArrayOutput {
	return o
}

func (o VertexResponseArrayOutput) ToVertexResponseArrayOutputWithContext(ctx context.Context) VertexResponseArrayOutput {
	return o
}

func (o VertexResponseArrayOutput) Index(i pulumi.IntInput) VertexResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VertexResponse {
		return vs[0].([]VertexResponse)[vs[1].(int)]
	}).(VertexResponseOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AccessDeterminationLogConfigInput)(nil)).Elem(), AccessDeterminationLogConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AccessDeterminationLogConfigPtrInput)(nil)).Elem(), AccessDeterminationLogConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ActionInput)(nil)).Elem(), ActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ActionArrayInput)(nil)).Elem(), ActionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AnnotationConfigInput)(nil)).Elem(), AnnotationConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AnnotationConfigPtrInput)(nil)).Elem(), AnnotationConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AnnotationSourceInput)(nil)).Elem(), AnnotationSourceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AnnotationSourcePtrInput)(nil)).Elem(), AnnotationSourceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AttributeInput)(nil)).Elem(), AttributeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AttributeArrayInput)(nil)).Elem(), AttributeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AuditConfigInput)(nil)).Elem(), AuditConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AuditConfigArrayInput)(nil)).Elem(), AuditConfigArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AuditLogConfigInput)(nil)).Elem(), AuditLogConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AuditLogConfigArrayInput)(nil)).Elem(), AuditLogConfigArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*BindingInput)(nil)).Elem(), BindingArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BindingArrayInput)(nil)).Elem(), BindingArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*BoundingPolyInput)(nil)).Elem(), BoundingPolyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BoundingPolyArrayInput)(nil)).Elem(), BoundingPolyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CharacterMaskConfigInput)(nil)).Elem(), CharacterMaskConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CharacterMaskConfigPtrInput)(nil)).Elem(), CharacterMaskConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CharacterMaskFieldInput)(nil)).Elem(), CharacterMaskFieldArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CharacterMaskFieldPtrInput)(nil)).Elem(), CharacterMaskFieldArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CleanDescriptorsOptionInput)(nil)).Elem(), CleanDescriptorsOptionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CleanDescriptorsOptionPtrInput)(nil)).Elem(), CleanDescriptorsOptionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CleanTextFieldInput)(nil)).Elem(), CleanTextFieldArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CleanTextFieldPtrInput)(nil)).Elem(), CleanTextFieldArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CleanTextTagInput)(nil)).Elem(), CleanTextTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CleanTextTagPtrInput)(nil)).Elem(), CleanTextTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CloudHealthcareSourceInput)(nil)).Elem(), CloudHealthcareSourceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CloudHealthcareSourcePtrInput)(nil)).Elem(), CloudHealthcareSourceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConsentConfigInput)(nil)).Elem(), ConsentConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConsentConfigPtrInput)(nil)).Elem(), ConsentConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConsentHeaderHandlingInput)(nil)).Elem(), ConsentHeaderHandlingArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConsentHeaderHandlingPtrInput)(nil)).Elem(), ConsentHeaderHandlingArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContextualDeidConfigInput)(nil)).Elem(), ContextualDeidConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContextualDeidConfigPtrInput)(nil)).Elem(), ContextualDeidConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CryptoHashConfigInput)(nil)).Elem(), CryptoHashConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CryptoHashConfigPtrInput)(nil)).Elem(), CryptoHashConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CryptoHashFieldInput)(nil)).Elem(), CryptoHashFieldArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CryptoHashFieldPtrInput)(nil)).Elem(), CryptoHashFieldArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DateShiftConfigInput)(nil)).Elem(), DateShiftConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DateShiftConfigPtrInput)(nil)).Elem(), DateShiftConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DateShiftFieldInput)(nil)).Elem(), DateShiftFieldArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DateShiftFieldPtrInput)(nil)).Elem(), DateShiftFieldArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeidentifiedStoreDestinationInput)(nil)).Elem(), DeidentifiedStoreDestinationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeidentifiedStoreDestinationPtrInput)(nil)).Elem(), DeidentifiedStoreDestinationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeidentifyConfigInput)(nil)).Elem(), DeidentifyConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeidentifyConfigPtrInput)(nil)).Elem(), DeidentifyConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeidentifyOperationMetadataInput)(nil)).Elem(), DeidentifyOperationMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeidentifyOperationMetadataPtrInput)(nil)).Elem(), DeidentifyOperationMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeleteTagInput)(nil)).Elem(), DeleteTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DeleteTagPtrInput)(nil)).Elem(), DeleteTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DetailInput)(nil)).Elem(), DetailArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DetailMapInput)(nil)).Elem(), DetailMap{})
	pulumi.RegisterInputType(reflect.TypeOf((*DicomConfigInput)(nil)).Elem(), DicomConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DicomConfigPtrInput)(nil)).Elem(), DicomConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DicomTagConfigInput)(nil)).Elem(), DicomTagConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DicomTagConfigPtrInput)(nil)).Elem(), DicomTagConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ExprInput)(nil)).Elem(), ExprArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ExprPtrInput)(nil)).Elem(), ExprArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FhirConfigInput)(nil)).Elem(), FhirConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FhirConfigPtrInput)(nil)).Elem(), FhirConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FhirFieldConfigInput)(nil)).Elem(), FhirFieldConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FhirFieldConfigPtrInput)(nil)).Elem(), FhirFieldConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FhirNotificationConfigInput)(nil)).Elem(), FhirNotificationConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FhirNotificationConfigArrayInput)(nil)).Elem(), FhirNotificationConfigArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FhirOutputInput)(nil)).Elem(), FhirOutputArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FhirOutputPtrInput)(nil)).Elem(), FhirOutputArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FieldInput)(nil)).Elem(), FieldArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FieldArrayInput)(nil)).Elem(), FieldArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FieldMetadataInput)(nil)).Elem(), FieldMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FieldMetadataArrayInput)(nil)).Elem(), FieldMetadataArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FindingInput)(nil)).Elem(), FindingArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FindingArrayInput)(nil)).Elem(), FindingArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GoogleCloudHealthcareV1beta1ConsentPolicyInput)(nil)).Elem(), GoogleCloudHealthcareV1beta1ConsentPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GoogleCloudHealthcareV1beta1ConsentPolicyArrayInput)(nil)).Elem(), GoogleCloudHealthcareV1beta1ConsentPolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataInput)(nil)).Elem(), GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayInput)(nil)).Elem(), GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GoogleCloudHealthcareV1beta1DeidentifyOptionsInput)(nil)).Elem(), GoogleCloudHealthcareV1beta1DeidentifyOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrInput)(nil)).Elem(), GoogleCloudHealthcareV1beta1DeidentifyOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GoogleCloudHealthcareV1beta1DicomBigQueryDestinationInput)(nil)).Elem(), GoogleCloudHealthcareV1beta1DicomBigQueryDestinationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrInput)(nil)).Elem(), GoogleCloudHealthcareV1beta1DicomBigQueryDestinationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GoogleCloudHealthcareV1beta1DicomStreamConfigInput)(nil)).Elem(), GoogleCloudHealthcareV1beta1DicomStreamConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GoogleCloudHealthcareV1beta1DicomStreamConfigArrayInput)(nil)).Elem(), GoogleCloudHealthcareV1beta1DicomStreamConfigArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GoogleCloudHealthcareV1beta1FhirBigQueryDestinationInput)(nil)).Elem(), GoogleCloudHealthcareV1beta1FhirBigQueryDestinationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrInput)(nil)).Elem(), GoogleCloudHealthcareV1beta1FhirBigQueryDestinationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GroupOrSegmentInput)(nil)).Elem(), GroupOrSegmentArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GroupOrSegmentArrayInput)(nil)).Elem(), GroupOrSegmentArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*Hl7SchemaConfigInput)(nil)).Elem(), Hl7SchemaConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*Hl7SchemaConfigArrayInput)(nil)).Elem(), Hl7SchemaConfigArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*Hl7TypesConfigInput)(nil)).Elem(), Hl7TypesConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*Hl7TypesConfigArrayInput)(nil)).Elem(), Hl7TypesConfigArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*Hl7V2NotificationConfigInput)(nil)).Elem(), Hl7V2NotificationConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*Hl7V2NotificationConfigArrayInput)(nil)).Elem(), Hl7V2NotificationConfigArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ImageInput)(nil)).Elem(), ImageArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ImagePtrInput)(nil)).Elem(), ImageArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ImageArrayInput)(nil)).Elem(), ImageArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ImageAnnotationInput)(nil)).Elem(), ImageAnnotationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ImageAnnotationPtrInput)(nil)).Elem(), ImageAnnotationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ImageConfigInput)(nil)).Elem(), ImageConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ImageConfigPtrInput)(nil)).Elem(), ImageConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*InfoTypeTransformationInput)(nil)).Elem(), InfoTypeTransformationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*InfoTypeTransformationArrayInput)(nil)).Elem(), InfoTypeTransformationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KeepExtensionsConfigInput)(nil)).Elem(), KeepExtensionsConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KeepExtensionsConfigPtrInput)(nil)).Elem(), KeepExtensionsConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KeepFieldInput)(nil)).Elem(), KeepFieldArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KeepFieldPtrInput)(nil)).Elem(), KeepFieldArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KeepTagInput)(nil)).Elem(), KeepTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KeepTagPtrInput)(nil)).Elem(), KeepTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KmsWrappedCryptoKeyInput)(nil)).Elem(), KmsWrappedCryptoKeyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KmsWrappedCryptoKeyPtrInput)(nil)).Elem(), KmsWrappedCryptoKeyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NotificationConfigInput)(nil)).Elem(), NotificationConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NotificationConfigPtrInput)(nil)).Elem(), NotificationConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OptionsInput)(nil)).Elem(), OptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OptionsPtrInput)(nil)).Elem(), OptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ParserConfigInput)(nil)).Elem(), ParserConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ParserConfigPtrInput)(nil)).Elem(), ParserConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PatientIdInput)(nil)).Elem(), PatientIdArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PatientIdArrayInput)(nil)).Elem(), PatientIdArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RecurseTagInput)(nil)).Elem(), RecurseTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RecurseTagPtrInput)(nil)).Elem(), RecurseTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RedactConfigInput)(nil)).Elem(), RedactConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RedactConfigPtrInput)(nil)).Elem(), RedactConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RegenUidTagInput)(nil)).Elem(), RegenUidTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RegenUidTagPtrInput)(nil)).Elem(), RegenUidTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RemoveFieldInput)(nil)).Elem(), RemoveFieldArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RemoveFieldPtrInput)(nil)).Elem(), RemoveFieldArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RemoveTagInput)(nil)).Elem(), RemoveTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RemoveTagPtrInput)(nil)).Elem(), RemoveTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReplaceWithInfoTypeConfigInput)(nil)).Elem(), ReplaceWithInfoTypeConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReplaceWithInfoTypeConfigPtrInput)(nil)).Elem(), ReplaceWithInfoTypeConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResetTagInput)(nil)).Elem(), ResetTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResetTagPtrInput)(nil)).Elem(), ResetTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceAnnotationInput)(nil)).Elem(), ResourceAnnotationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceAnnotationPtrInput)(nil)).Elem(), ResourceAnnotationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SchemaConfigInput)(nil)).Elem(), SchemaConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SchemaConfigPtrInput)(nil)).Elem(), SchemaConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SchemaGroupInput)(nil)).Elem(), SchemaGroupArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SchemaGroupPtrInput)(nil)).Elem(), SchemaGroupArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SchemaGroupMapInput)(nil)).Elem(), SchemaGroupMap{})
	pulumi.RegisterInputType(reflect.TypeOf((*SchemaPackageInput)(nil)).Elem(), SchemaPackageArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SchemaPackagePtrInput)(nil)).Elem(), SchemaPackageArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SchemaSegmentInput)(nil)).Elem(), SchemaSegmentArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SchemaSegmentPtrInput)(nil)).Elem(), SchemaSegmentArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SchematizedDataInput)(nil)).Elem(), SchematizedDataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SchematizedDataPtrInput)(nil)).Elem(), SchematizedDataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SearchConfigInput)(nil)).Elem(), SearchConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SearchConfigPtrInput)(nil)).Elem(), SearchConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SearchParameterInput)(nil)).Elem(), SearchParameterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SearchParameterArrayInput)(nil)).Elem(), SearchParameterArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SensitiveTextAnnotationInput)(nil)).Elem(), SensitiveTextAnnotationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SensitiveTextAnnotationPtrInput)(nil)).Elem(), SensitiveTextAnnotationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SignatureInput)(nil)).Elem(), SignatureArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SignaturePtrInput)(nil)).Elem(), SignatureArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*StreamConfigInput)(nil)).Elem(), StreamConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*StreamConfigArrayInput)(nil)).Elem(), StreamConfigArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagFilterListInput)(nil)).Elem(), TagFilterListArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TagFilterListPtrInput)(nil)).Elem(), TagFilterListArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TextConfigInput)(nil)).Elem(), TextConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TextConfigPtrInput)(nil)).Elem(), TextConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TimePartitioningInput)(nil)).Elem(), TimePartitioningArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TimePartitioningPtrInput)(nil)).Elem(), TimePartitioningArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TypeInput)(nil)).Elem(), TypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TypeArrayInput)(nil)).Elem(), TypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ValidationConfigInput)(nil)).Elem(), ValidationConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ValidationConfigPtrInput)(nil)).Elem(), ValidationConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VersionSourceInput)(nil)).Elem(), VersionSourceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VersionSourceArrayInput)(nil)).Elem(), VersionSourceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VertexInput)(nil)).Elem(), VertexArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VertexArrayInput)(nil)).Elem(), VertexArray{})
	pulumi.RegisterOutputType(AccessDeterminationLogConfigOutput{})
	pulumi.RegisterOutputType(AccessDeterminationLogConfigPtrOutput{})
	pulumi.RegisterOutputType(AccessDeterminationLogConfigResponseOutput{})
	pulumi.RegisterOutputType(ActionOutput{})
	pulumi.RegisterOutputType(ActionArrayOutput{})
	pulumi.RegisterOutputType(ActionResponseOutput{})
	pulumi.RegisterOutputType(ActionResponseArrayOutput{})
	pulumi.RegisterOutputType(AnnotationConfigOutput{})
	pulumi.RegisterOutputType(AnnotationConfigPtrOutput{})
	pulumi.RegisterOutputType(AnnotationConfigResponseOutput{})
	pulumi.RegisterOutputType(AnnotationSourceOutput{})
	pulumi.RegisterOutputType(AnnotationSourcePtrOutput{})
	pulumi.RegisterOutputType(AnnotationSourceResponseOutput{})
	pulumi.RegisterOutputType(AttributeOutput{})
	pulumi.RegisterOutputType(AttributeArrayOutput{})
	pulumi.RegisterOutputType(AttributeResponseOutput{})
	pulumi.RegisterOutputType(AttributeResponseArrayOutput{})
	pulumi.RegisterOutputType(AuditConfigOutput{})
	pulumi.RegisterOutputType(AuditConfigArrayOutput{})
	pulumi.RegisterOutputType(AuditConfigResponseOutput{})
	pulumi.RegisterOutputType(AuditConfigResponseArrayOutput{})
	pulumi.RegisterOutputType(AuditLogConfigOutput{})
	pulumi.RegisterOutputType(AuditLogConfigArrayOutput{})
	pulumi.RegisterOutputType(AuditLogConfigResponseOutput{})
	pulumi.RegisterOutputType(AuditLogConfigResponseArrayOutput{})
	pulumi.RegisterOutputType(BindingOutput{})
	pulumi.RegisterOutputType(BindingArrayOutput{})
	pulumi.RegisterOutputType(BindingResponseOutput{})
	pulumi.RegisterOutputType(BindingResponseArrayOutput{})
	pulumi.RegisterOutputType(BoundingPolyOutput{})
	pulumi.RegisterOutputType(BoundingPolyArrayOutput{})
	pulumi.RegisterOutputType(BoundingPolyResponseOutput{})
	pulumi.RegisterOutputType(BoundingPolyResponseArrayOutput{})
	pulumi.RegisterOutputType(CharacterMaskConfigOutput{})
	pulumi.RegisterOutputType(CharacterMaskConfigPtrOutput{})
	pulumi.RegisterOutputType(CharacterMaskConfigResponseOutput{})
	pulumi.RegisterOutputType(CharacterMaskFieldOutput{})
	pulumi.RegisterOutputType(CharacterMaskFieldPtrOutput{})
	pulumi.RegisterOutputType(CharacterMaskFieldResponseOutput{})
	pulumi.RegisterOutputType(CleanDescriptorsOptionOutput{})
	pulumi.RegisterOutputType(CleanDescriptorsOptionPtrOutput{})
	pulumi.RegisterOutputType(CleanDescriptorsOptionResponseOutput{})
	pulumi.RegisterOutputType(CleanTextFieldOutput{})
	pulumi.RegisterOutputType(CleanTextFieldPtrOutput{})
	pulumi.RegisterOutputType(CleanTextFieldResponseOutput{})
	pulumi.RegisterOutputType(CleanTextTagOutput{})
	pulumi.RegisterOutputType(CleanTextTagPtrOutput{})
	pulumi.RegisterOutputType(CleanTextTagResponseOutput{})
	pulumi.RegisterOutputType(CloudHealthcareSourceOutput{})
	pulumi.RegisterOutputType(CloudHealthcareSourcePtrOutput{})
	pulumi.RegisterOutputType(CloudHealthcareSourceResponseOutput{})
	pulumi.RegisterOutputType(ConsentConfigOutput{})
	pulumi.RegisterOutputType(ConsentConfigPtrOutput{})
	pulumi.RegisterOutputType(ConsentConfigResponseOutput{})
	pulumi.RegisterOutputType(ConsentHeaderHandlingOutput{})
	pulumi.RegisterOutputType(ConsentHeaderHandlingPtrOutput{})
	pulumi.RegisterOutputType(ConsentHeaderHandlingResponseOutput{})
	pulumi.RegisterOutputType(ContextualDeidConfigOutput{})
	pulumi.RegisterOutputType(ContextualDeidConfigPtrOutput{})
	pulumi.RegisterOutputType(ContextualDeidConfigResponseOutput{})
	pulumi.RegisterOutputType(CryptoHashConfigOutput{})
	pulumi.RegisterOutputType(CryptoHashConfigPtrOutput{})
	pulumi.RegisterOutputType(CryptoHashConfigResponseOutput{})
	pulumi.RegisterOutputType(CryptoHashFieldOutput{})
	pulumi.RegisterOutputType(CryptoHashFieldPtrOutput{})
	pulumi.RegisterOutputType(CryptoHashFieldResponseOutput{})
	pulumi.RegisterOutputType(DateShiftConfigOutput{})
	pulumi.RegisterOutputType(DateShiftConfigPtrOutput{})
	pulumi.RegisterOutputType(DateShiftConfigResponseOutput{})
	pulumi.RegisterOutputType(DateShiftFieldOutput{})
	pulumi.RegisterOutputType(DateShiftFieldPtrOutput{})
	pulumi.RegisterOutputType(DateShiftFieldResponseOutput{})
	pulumi.RegisterOutputType(DeidentifiedStoreDestinationOutput{})
	pulumi.RegisterOutputType(DeidentifiedStoreDestinationPtrOutput{})
	pulumi.RegisterOutputType(DeidentifiedStoreDestinationResponseOutput{})
	pulumi.RegisterOutputType(DeidentifyConfigOutput{})
	pulumi.RegisterOutputType(DeidentifyConfigPtrOutput{})
	pulumi.RegisterOutputType(DeidentifyConfigResponseOutput{})
	pulumi.RegisterOutputType(DeidentifyOperationMetadataOutput{})
	pulumi.RegisterOutputType(DeidentifyOperationMetadataPtrOutput{})
	pulumi.RegisterOutputType(DeidentifyOperationMetadataResponseOutput{})
	pulumi.RegisterOutputType(DeleteTagOutput{})
	pulumi.RegisterOutputType(DeleteTagPtrOutput{})
	pulumi.RegisterOutputType(DeleteTagResponseOutput{})
	pulumi.RegisterOutputType(DetailOutput{})
	pulumi.RegisterOutputType(DetailMapOutput{})
	pulumi.RegisterOutputType(DetailResponseOutput{})
	pulumi.RegisterOutputType(DetailResponseMapOutput{})
	pulumi.RegisterOutputType(DicomConfigOutput{})
	pulumi.RegisterOutputType(DicomConfigPtrOutput{})
	pulumi.RegisterOutputType(DicomConfigResponseOutput{})
	pulumi.RegisterOutputType(DicomTagConfigOutput{})
	pulumi.RegisterOutputType(DicomTagConfigPtrOutput{})
	pulumi.RegisterOutputType(DicomTagConfigResponseOutput{})
	pulumi.RegisterOutputType(ExprOutput{})
	pulumi.RegisterOutputType(ExprPtrOutput{})
	pulumi.RegisterOutputType(ExprResponseOutput{})
	pulumi.RegisterOutputType(FhirConfigOutput{})
	pulumi.RegisterOutputType(FhirConfigPtrOutput{})
	pulumi.RegisterOutputType(FhirConfigResponseOutput{})
	pulumi.RegisterOutputType(FhirFieldConfigOutput{})
	pulumi.RegisterOutputType(FhirFieldConfigPtrOutput{})
	pulumi.RegisterOutputType(FhirFieldConfigResponseOutput{})
	pulumi.RegisterOutputType(FhirNotificationConfigOutput{})
	pulumi.RegisterOutputType(FhirNotificationConfigArrayOutput{})
	pulumi.RegisterOutputType(FhirNotificationConfigResponseOutput{})
	pulumi.RegisterOutputType(FhirNotificationConfigResponseArrayOutput{})
	pulumi.RegisterOutputType(FhirOutputOutput{})
	pulumi.RegisterOutputType(FhirOutputPtrOutput{})
	pulumi.RegisterOutputType(FhirOutputResponseOutput{})
	pulumi.RegisterOutputType(FieldOutput{})
	pulumi.RegisterOutputType(FieldArrayOutput{})
	pulumi.RegisterOutputType(FieldMetadataOutput{})
	pulumi.RegisterOutputType(FieldMetadataArrayOutput{})
	pulumi.RegisterOutputType(FieldMetadataResponseOutput{})
	pulumi.RegisterOutputType(FieldMetadataResponseArrayOutput{})
	pulumi.RegisterOutputType(FieldResponseOutput{})
	pulumi.RegisterOutputType(FieldResponseArrayOutput{})
	pulumi.RegisterOutputType(FindingOutput{})
	pulumi.RegisterOutputType(FindingArrayOutput{})
	pulumi.RegisterOutputType(FindingResponseOutput{})
	pulumi.RegisterOutputType(FindingResponseArrayOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1ConsentPolicyOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1ConsentPolicyArrayOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1ConsentPolicyResponseOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1ConsentPolicyResponseArrayOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataArrayOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1DeidentifyFieldMetadataResponseArrayOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1DeidentifyOptionsOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1DeidentifyOptionsPtrOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1DeidentifyOptionsResponseOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1DicomBigQueryDestinationOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1DicomBigQueryDestinationPtrOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1DicomBigQueryDestinationResponseOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1DicomStreamConfigOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1DicomStreamConfigArrayOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1DicomStreamConfigResponseOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1DicomStreamConfigResponseArrayOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1FhirBigQueryDestinationOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1FhirBigQueryDestinationPtrOutput{})
	pulumi.RegisterOutputType(GoogleCloudHealthcareV1beta1FhirBigQueryDestinationResponseOutput{})
	pulumi.RegisterOutputType(GroupOrSegmentOutput{})
	pulumi.RegisterOutputType(GroupOrSegmentArrayOutput{})
	pulumi.RegisterOutputType(GroupOrSegmentResponseOutput{})
	pulumi.RegisterOutputType(GroupOrSegmentResponseArrayOutput{})
	pulumi.RegisterOutputType(Hl7SchemaConfigOutput{})
	pulumi.RegisterOutputType(Hl7SchemaConfigArrayOutput{})
	pulumi.RegisterOutputType(Hl7SchemaConfigResponseOutput{})
	pulumi.RegisterOutputType(Hl7SchemaConfigResponseArrayOutput{})
	pulumi.RegisterOutputType(Hl7TypesConfigOutput{})
	pulumi.RegisterOutputType(Hl7TypesConfigArrayOutput{})
	pulumi.RegisterOutputType(Hl7TypesConfigResponseOutput{})
	pulumi.RegisterOutputType(Hl7TypesConfigResponseArrayOutput{})
	pulumi.RegisterOutputType(Hl7V2NotificationConfigOutput{})
	pulumi.RegisterOutputType(Hl7V2NotificationConfigArrayOutput{})
	pulumi.RegisterOutputType(Hl7V2NotificationConfigResponseOutput{})
	pulumi.RegisterOutputType(Hl7V2NotificationConfigResponseArrayOutput{})
	pulumi.RegisterOutputType(ImageOutput{})
	pulumi.RegisterOutputType(ImagePtrOutput{})
	pulumi.RegisterOutputType(ImageArrayOutput{})
	pulumi.RegisterOutputType(ImageAnnotationOutput{})
	pulumi.RegisterOutputType(ImageAnnotationPtrOutput{})
	pulumi.RegisterOutputType(ImageAnnotationResponseOutput{})
	pulumi.RegisterOutputType(ImageConfigOutput{})
	pulumi.RegisterOutputType(ImageConfigPtrOutput{})
	pulumi.RegisterOutputType(ImageConfigResponseOutput{})
	pulumi.RegisterOutputType(ImageResponseOutput{})
	pulumi.RegisterOutputType(ImageResponseArrayOutput{})
	pulumi.RegisterOutputType(InfoTypeTransformationOutput{})
	pulumi.RegisterOutputType(InfoTypeTransformationArrayOutput{})
	pulumi.RegisterOutputType(InfoTypeTransformationResponseOutput{})
	pulumi.RegisterOutputType(InfoTypeTransformationResponseArrayOutput{})
	pulumi.RegisterOutputType(KeepExtensionsConfigOutput{})
	pulumi.RegisterOutputType(KeepExtensionsConfigPtrOutput{})
	pulumi.RegisterOutputType(KeepExtensionsConfigResponseOutput{})
	pulumi.RegisterOutputType(KeepFieldOutput{})
	pulumi.RegisterOutputType(KeepFieldPtrOutput{})
	pulumi.RegisterOutputType(KeepFieldResponseOutput{})
	pulumi.RegisterOutputType(KeepTagOutput{})
	pulumi.RegisterOutputType(KeepTagPtrOutput{})
	pulumi.RegisterOutputType(KeepTagResponseOutput{})
	pulumi.RegisterOutputType(KmsWrappedCryptoKeyOutput{})
	pulumi.RegisterOutputType(KmsWrappedCryptoKeyPtrOutput{})
	pulumi.RegisterOutputType(KmsWrappedCryptoKeyResponseOutput{})
	pulumi.RegisterOutputType(NotificationConfigOutput{})
	pulumi.RegisterOutputType(NotificationConfigPtrOutput{})
	pulumi.RegisterOutputType(NotificationConfigResponseOutput{})
	pulumi.RegisterOutputType(OptionsOutput{})
	pulumi.RegisterOutputType(OptionsPtrOutput{})
	pulumi.RegisterOutputType(OptionsResponseOutput{})
	pulumi.RegisterOutputType(ParsedDataResponseOutput{})
	pulumi.RegisterOutputType(ParserConfigOutput{})
	pulumi.RegisterOutputType(ParserConfigPtrOutput{})
	pulumi.RegisterOutputType(ParserConfigResponseOutput{})
	pulumi.RegisterOutputType(PatientIdOutput{})
	pulumi.RegisterOutputType(PatientIdArrayOutput{})
	pulumi.RegisterOutputType(PatientIdResponseOutput{})
	pulumi.RegisterOutputType(PatientIdResponseArrayOutput{})
	pulumi.RegisterOutputType(RecurseTagOutput{})
	pulumi.RegisterOutputType(RecurseTagPtrOutput{})
	pulumi.RegisterOutputType(RecurseTagResponseOutput{})
	pulumi.RegisterOutputType(RedactConfigOutput{})
	pulumi.RegisterOutputType(RedactConfigPtrOutput{})
	pulumi.RegisterOutputType(RedactConfigResponseOutput{})
	pulumi.RegisterOutputType(RegenUidTagOutput{})
	pulumi.RegisterOutputType(RegenUidTagPtrOutput{})
	pulumi.RegisterOutputType(RegenUidTagResponseOutput{})
	pulumi.RegisterOutputType(RemoveFieldOutput{})
	pulumi.RegisterOutputType(RemoveFieldPtrOutput{})
	pulumi.RegisterOutputType(RemoveFieldResponseOutput{})
	pulumi.RegisterOutputType(RemoveTagOutput{})
	pulumi.RegisterOutputType(RemoveTagPtrOutput{})
	pulumi.RegisterOutputType(RemoveTagResponseOutput{})
	pulumi.RegisterOutputType(ReplaceWithInfoTypeConfigOutput{})
	pulumi.RegisterOutputType(ReplaceWithInfoTypeConfigPtrOutput{})
	pulumi.RegisterOutputType(ReplaceWithInfoTypeConfigResponseOutput{})
	pulumi.RegisterOutputType(ResetTagOutput{})
	pulumi.RegisterOutputType(ResetTagPtrOutput{})
	pulumi.RegisterOutputType(ResetTagResponseOutput{})
	pulumi.RegisterOutputType(ResourceAnnotationOutput{})
	pulumi.RegisterOutputType(ResourceAnnotationPtrOutput{})
	pulumi.RegisterOutputType(ResourceAnnotationResponseOutput{})
	pulumi.RegisterOutputType(SchemaConfigOutput{})
	pulumi.RegisterOutputType(SchemaConfigPtrOutput{})
	pulumi.RegisterOutputType(SchemaConfigResponseOutput{})
	pulumi.RegisterOutputType(SchemaGroupOutput{})
	pulumi.RegisterOutputType(SchemaGroupPtrOutput{})
	pulumi.RegisterOutputType(SchemaGroupMapOutput{})
	pulumi.RegisterOutputType(SchemaGroupResponseOutput{})
	pulumi.RegisterOutputType(SchemaGroupResponseMapOutput{})
	pulumi.RegisterOutputType(SchemaPackageOutput{})
	pulumi.RegisterOutputType(SchemaPackagePtrOutput{})
	pulumi.RegisterOutputType(SchemaPackageResponseOutput{})
	pulumi.RegisterOutputType(SchemaSegmentOutput{})
	pulumi.RegisterOutputType(SchemaSegmentPtrOutput{})
	pulumi.RegisterOutputType(SchemaSegmentResponseOutput{})
	pulumi.RegisterOutputType(SchematizedDataOutput{})
	pulumi.RegisterOutputType(SchematizedDataPtrOutput{})
	pulumi.RegisterOutputType(SchematizedDataResponseOutput{})
	pulumi.RegisterOutputType(SearchConfigOutput{})
	pulumi.RegisterOutputType(SearchConfigPtrOutput{})
	pulumi.RegisterOutputType(SearchConfigResponseOutput{})
	pulumi.RegisterOutputType(SearchParameterOutput{})
	pulumi.RegisterOutputType(SearchParameterArrayOutput{})
	pulumi.RegisterOutputType(SearchParameterResponseOutput{})
	pulumi.RegisterOutputType(SearchParameterResponseArrayOutput{})
	pulumi.RegisterOutputType(SegmentResponseOutput{})
	pulumi.RegisterOutputType(SegmentResponseArrayOutput{})
	pulumi.RegisterOutputType(SensitiveTextAnnotationOutput{})
	pulumi.RegisterOutputType(SensitiveTextAnnotationPtrOutput{})
	pulumi.RegisterOutputType(SensitiveTextAnnotationResponseOutput{})
	pulumi.RegisterOutputType(SignatureOutput{})
	pulumi.RegisterOutputType(SignaturePtrOutput{})
	pulumi.RegisterOutputType(SignatureResponseOutput{})
	pulumi.RegisterOutputType(StreamConfigOutput{})
	pulumi.RegisterOutputType(StreamConfigArrayOutput{})
	pulumi.RegisterOutputType(StreamConfigResponseOutput{})
	pulumi.RegisterOutputType(StreamConfigResponseArrayOutput{})
	pulumi.RegisterOutputType(TagFilterListOutput{})
	pulumi.RegisterOutputType(TagFilterListPtrOutput{})
	pulumi.RegisterOutputType(TagFilterListResponseOutput{})
	pulumi.RegisterOutputType(TextConfigOutput{})
	pulumi.RegisterOutputType(TextConfigPtrOutput{})
	pulumi.RegisterOutputType(TextConfigResponseOutput{})
	pulumi.RegisterOutputType(TimePartitioningOutput{})
	pulumi.RegisterOutputType(TimePartitioningPtrOutput{})
	pulumi.RegisterOutputType(TimePartitioningResponseOutput{})
	pulumi.RegisterOutputType(TypeOutput{})
	pulumi.RegisterOutputType(TypeArrayOutput{})
	pulumi.RegisterOutputType(TypeResponseOutput{})
	pulumi.RegisterOutputType(TypeResponseArrayOutput{})
	pulumi.RegisterOutputType(ValidationConfigOutput{})
	pulumi.RegisterOutputType(ValidationConfigPtrOutput{})
	pulumi.RegisterOutputType(ValidationConfigResponseOutput{})
	pulumi.RegisterOutputType(VersionSourceOutput{})
	pulumi.RegisterOutputType(VersionSourceArrayOutput{})
	pulumi.RegisterOutputType(VersionSourceResponseOutput{})
	pulumi.RegisterOutputType(VersionSourceResponseArrayOutput{})
	pulumi.RegisterOutputType(VertexOutput{})
	pulumi.RegisterOutputType(VertexArrayOutput{})
	pulumi.RegisterOutputType(VertexResponseOutput{})
	pulumi.RegisterOutputType(VertexResponseArrayOutput{})
}
