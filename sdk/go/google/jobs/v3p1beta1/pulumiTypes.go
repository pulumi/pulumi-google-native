// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v3p1beta1

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

// Application related details of a job posting.
type ApplicationInfo struct {
	// Optional but at least one of uris, emails or instruction must be specified. Use this field to specify email address(es) to which resumes or applications can be sent. The maximum number of allowed characters for each entry is 255.
	Emails []string `pulumi:"emails"`
	// Optional but at least one of uris, emails or instruction must be specified. Use this field to provide instructions, such as "Mail your application to ...", that a candidate can follow to apply for the job. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 3,000.
	Instruction *string `pulumi:"instruction"`
	// Optional but at least one of uris, emails or instruction must be specified. Use this URI field to direct an applicant to a website, for example to link to an online application form. The maximum number of allowed characters for each entry is 2,000.
	Uris []string `pulumi:"uris"`
}

// ApplicationInfoInput is an input type that accepts ApplicationInfoArgs and ApplicationInfoOutput values.
// You can construct a concrete instance of `ApplicationInfoInput` via:
//
//          ApplicationInfoArgs{...}
type ApplicationInfoInput interface {
	pulumi.Input

	ToApplicationInfoOutput() ApplicationInfoOutput
	ToApplicationInfoOutputWithContext(context.Context) ApplicationInfoOutput
}

// Application related details of a job posting.
type ApplicationInfoArgs struct {
	// Optional but at least one of uris, emails or instruction must be specified. Use this field to specify email address(es) to which resumes or applications can be sent. The maximum number of allowed characters for each entry is 255.
	Emails pulumi.StringArrayInput `pulumi:"emails"`
	// Optional but at least one of uris, emails or instruction must be specified. Use this field to provide instructions, such as "Mail your application to ...", that a candidate can follow to apply for the job. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 3,000.
	Instruction pulumi.StringPtrInput `pulumi:"instruction"`
	// Optional but at least one of uris, emails or instruction must be specified. Use this URI field to direct an applicant to a website, for example to link to an online application form. The maximum number of allowed characters for each entry is 2,000.
	Uris pulumi.StringArrayInput `pulumi:"uris"`
}

func (ApplicationInfoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationInfo)(nil)).Elem()
}

func (i ApplicationInfoArgs) ToApplicationInfoOutput() ApplicationInfoOutput {
	return i.ToApplicationInfoOutputWithContext(context.Background())
}

func (i ApplicationInfoArgs) ToApplicationInfoOutputWithContext(ctx context.Context) ApplicationInfoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationInfoOutput)
}

func (i ApplicationInfoArgs) ToApplicationInfoPtrOutput() ApplicationInfoPtrOutput {
	return i.ToApplicationInfoPtrOutputWithContext(context.Background())
}

func (i ApplicationInfoArgs) ToApplicationInfoPtrOutputWithContext(ctx context.Context) ApplicationInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationInfoOutput).ToApplicationInfoPtrOutputWithContext(ctx)
}

// ApplicationInfoPtrInput is an input type that accepts ApplicationInfoArgs, ApplicationInfoPtr and ApplicationInfoPtrOutput values.
// You can construct a concrete instance of `ApplicationInfoPtrInput` via:
//
//          ApplicationInfoArgs{...}
//
//  or:
//
//          nil
type ApplicationInfoPtrInput interface {
	pulumi.Input

	ToApplicationInfoPtrOutput() ApplicationInfoPtrOutput
	ToApplicationInfoPtrOutputWithContext(context.Context) ApplicationInfoPtrOutput
}

type applicationInfoPtrType ApplicationInfoArgs

func ApplicationInfoPtr(v *ApplicationInfoArgs) ApplicationInfoPtrInput {
	return (*applicationInfoPtrType)(v)
}

func (*applicationInfoPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationInfo)(nil)).Elem()
}

func (i *applicationInfoPtrType) ToApplicationInfoPtrOutput() ApplicationInfoPtrOutput {
	return i.ToApplicationInfoPtrOutputWithContext(context.Background())
}

func (i *applicationInfoPtrType) ToApplicationInfoPtrOutputWithContext(ctx context.Context) ApplicationInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationInfoPtrOutput)
}

// Application related details of a job posting.
type ApplicationInfoOutput struct{ *pulumi.OutputState }

func (ApplicationInfoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationInfo)(nil)).Elem()
}

func (o ApplicationInfoOutput) ToApplicationInfoOutput() ApplicationInfoOutput {
	return o
}

func (o ApplicationInfoOutput) ToApplicationInfoOutputWithContext(ctx context.Context) ApplicationInfoOutput {
	return o
}

func (o ApplicationInfoOutput) ToApplicationInfoPtrOutput() ApplicationInfoPtrOutput {
	return o.ToApplicationInfoPtrOutputWithContext(context.Background())
}

func (o ApplicationInfoOutput) ToApplicationInfoPtrOutputWithContext(ctx context.Context) ApplicationInfoPtrOutput {
	return o.ApplyT(func(v ApplicationInfo) *ApplicationInfo {
		return &v
	}).(ApplicationInfoPtrOutput)
}

// Optional but at least one of uris, emails or instruction must be specified. Use this field to specify email address(es) to which resumes or applications can be sent. The maximum number of allowed characters for each entry is 255.
func (o ApplicationInfoOutput) Emails() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ApplicationInfo) []string { return v.Emails }).(pulumi.StringArrayOutput)
}

// Optional but at least one of uris, emails or instruction must be specified. Use this field to provide instructions, such as "Mail your application to ...", that a candidate can follow to apply for the job. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 3,000.
func (o ApplicationInfoOutput) Instruction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ApplicationInfo) *string { return v.Instruction }).(pulumi.StringPtrOutput)
}

// Optional but at least one of uris, emails or instruction must be specified. Use this URI field to direct an applicant to a website, for example to link to an online application form. The maximum number of allowed characters for each entry is 2,000.
func (o ApplicationInfoOutput) Uris() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ApplicationInfo) []string { return v.Uris }).(pulumi.StringArrayOutput)
}

type ApplicationInfoPtrOutput struct{ *pulumi.OutputState }

func (ApplicationInfoPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationInfo)(nil)).Elem()
}

func (o ApplicationInfoPtrOutput) ToApplicationInfoPtrOutput() ApplicationInfoPtrOutput {
	return o
}

func (o ApplicationInfoPtrOutput) ToApplicationInfoPtrOutputWithContext(ctx context.Context) ApplicationInfoPtrOutput {
	return o
}

func (o ApplicationInfoPtrOutput) Elem() ApplicationInfoOutput {
	return o.ApplyT(func(v *ApplicationInfo) ApplicationInfo { return *v }).(ApplicationInfoOutput)
}

// Optional but at least one of uris, emails or instruction must be specified. Use this field to specify email address(es) to which resumes or applications can be sent. The maximum number of allowed characters for each entry is 255.
func (o ApplicationInfoPtrOutput) Emails() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ApplicationInfo) []string {
		if v == nil {
			return nil
		}
		return v.Emails
	}).(pulumi.StringArrayOutput)
}

// Optional but at least one of uris, emails or instruction must be specified. Use this field to provide instructions, such as "Mail your application to ...", that a candidate can follow to apply for the job. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 3,000.
func (o ApplicationInfoPtrOutput) Instruction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ApplicationInfo) *string {
		if v == nil {
			return nil
		}
		return v.Instruction
	}).(pulumi.StringPtrOutput)
}

// Optional but at least one of uris, emails or instruction must be specified. Use this URI field to direct an applicant to a website, for example to link to an online application form. The maximum number of allowed characters for each entry is 2,000.
func (o ApplicationInfoPtrOutput) Uris() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ApplicationInfo) []string {
		if v == nil {
			return nil
		}
		return v.Uris
	}).(pulumi.StringArrayOutput)
}

// Application related details of a job posting.
type ApplicationInfoResponse struct {
	// Optional but at least one of uris, emails or instruction must be specified. Use this field to specify email address(es) to which resumes or applications can be sent. The maximum number of allowed characters for each entry is 255.
	Emails []string `pulumi:"emails"`
	// Optional but at least one of uris, emails or instruction must be specified. Use this field to provide instructions, such as "Mail your application to ...", that a candidate can follow to apply for the job. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 3,000.
	Instruction string `pulumi:"instruction"`
	// Optional but at least one of uris, emails or instruction must be specified. Use this URI field to direct an applicant to a website, for example to link to an online application form. The maximum number of allowed characters for each entry is 2,000.
	Uris []string `pulumi:"uris"`
}

// ApplicationInfoResponseInput is an input type that accepts ApplicationInfoResponseArgs and ApplicationInfoResponseOutput values.
// You can construct a concrete instance of `ApplicationInfoResponseInput` via:
//
//          ApplicationInfoResponseArgs{...}
type ApplicationInfoResponseInput interface {
	pulumi.Input

	ToApplicationInfoResponseOutput() ApplicationInfoResponseOutput
	ToApplicationInfoResponseOutputWithContext(context.Context) ApplicationInfoResponseOutput
}

// Application related details of a job posting.
type ApplicationInfoResponseArgs struct {
	// Optional but at least one of uris, emails or instruction must be specified. Use this field to specify email address(es) to which resumes or applications can be sent. The maximum number of allowed characters for each entry is 255.
	Emails pulumi.StringArrayInput `pulumi:"emails"`
	// Optional but at least one of uris, emails or instruction must be specified. Use this field to provide instructions, such as "Mail your application to ...", that a candidate can follow to apply for the job. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 3,000.
	Instruction pulumi.StringInput `pulumi:"instruction"`
	// Optional but at least one of uris, emails or instruction must be specified. Use this URI field to direct an applicant to a website, for example to link to an online application form. The maximum number of allowed characters for each entry is 2,000.
	Uris pulumi.StringArrayInput `pulumi:"uris"`
}

func (ApplicationInfoResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationInfoResponse)(nil)).Elem()
}

func (i ApplicationInfoResponseArgs) ToApplicationInfoResponseOutput() ApplicationInfoResponseOutput {
	return i.ToApplicationInfoResponseOutputWithContext(context.Background())
}

func (i ApplicationInfoResponseArgs) ToApplicationInfoResponseOutputWithContext(ctx context.Context) ApplicationInfoResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationInfoResponseOutput)
}

func (i ApplicationInfoResponseArgs) ToApplicationInfoResponsePtrOutput() ApplicationInfoResponsePtrOutput {
	return i.ToApplicationInfoResponsePtrOutputWithContext(context.Background())
}

func (i ApplicationInfoResponseArgs) ToApplicationInfoResponsePtrOutputWithContext(ctx context.Context) ApplicationInfoResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationInfoResponseOutput).ToApplicationInfoResponsePtrOutputWithContext(ctx)
}

// ApplicationInfoResponsePtrInput is an input type that accepts ApplicationInfoResponseArgs, ApplicationInfoResponsePtr and ApplicationInfoResponsePtrOutput values.
// You can construct a concrete instance of `ApplicationInfoResponsePtrInput` via:
//
//          ApplicationInfoResponseArgs{...}
//
//  or:
//
//          nil
type ApplicationInfoResponsePtrInput interface {
	pulumi.Input

	ToApplicationInfoResponsePtrOutput() ApplicationInfoResponsePtrOutput
	ToApplicationInfoResponsePtrOutputWithContext(context.Context) ApplicationInfoResponsePtrOutput
}

type applicationInfoResponsePtrType ApplicationInfoResponseArgs

func ApplicationInfoResponsePtr(v *ApplicationInfoResponseArgs) ApplicationInfoResponsePtrInput {
	return (*applicationInfoResponsePtrType)(v)
}

func (*applicationInfoResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationInfoResponse)(nil)).Elem()
}

func (i *applicationInfoResponsePtrType) ToApplicationInfoResponsePtrOutput() ApplicationInfoResponsePtrOutput {
	return i.ToApplicationInfoResponsePtrOutputWithContext(context.Background())
}

func (i *applicationInfoResponsePtrType) ToApplicationInfoResponsePtrOutputWithContext(ctx context.Context) ApplicationInfoResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationInfoResponsePtrOutput)
}

// Application related details of a job posting.
type ApplicationInfoResponseOutput struct{ *pulumi.OutputState }

func (ApplicationInfoResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationInfoResponse)(nil)).Elem()
}

func (o ApplicationInfoResponseOutput) ToApplicationInfoResponseOutput() ApplicationInfoResponseOutput {
	return o
}

func (o ApplicationInfoResponseOutput) ToApplicationInfoResponseOutputWithContext(ctx context.Context) ApplicationInfoResponseOutput {
	return o
}

func (o ApplicationInfoResponseOutput) ToApplicationInfoResponsePtrOutput() ApplicationInfoResponsePtrOutput {
	return o.ToApplicationInfoResponsePtrOutputWithContext(context.Background())
}

func (o ApplicationInfoResponseOutput) ToApplicationInfoResponsePtrOutputWithContext(ctx context.Context) ApplicationInfoResponsePtrOutput {
	return o.ApplyT(func(v ApplicationInfoResponse) *ApplicationInfoResponse {
		return &v
	}).(ApplicationInfoResponsePtrOutput)
}

// Optional but at least one of uris, emails or instruction must be specified. Use this field to specify email address(es) to which resumes or applications can be sent. The maximum number of allowed characters for each entry is 255.
func (o ApplicationInfoResponseOutput) Emails() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ApplicationInfoResponse) []string { return v.Emails }).(pulumi.StringArrayOutput)
}

// Optional but at least one of uris, emails or instruction must be specified. Use this field to provide instructions, such as "Mail your application to ...", that a candidate can follow to apply for the job. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 3,000.
func (o ApplicationInfoResponseOutput) Instruction() pulumi.StringOutput {
	return o.ApplyT(func(v ApplicationInfoResponse) string { return v.Instruction }).(pulumi.StringOutput)
}

// Optional but at least one of uris, emails or instruction must be specified. Use this URI field to direct an applicant to a website, for example to link to an online application form. The maximum number of allowed characters for each entry is 2,000.
func (o ApplicationInfoResponseOutput) Uris() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ApplicationInfoResponse) []string { return v.Uris }).(pulumi.StringArrayOutput)
}

type ApplicationInfoResponsePtrOutput struct{ *pulumi.OutputState }

func (ApplicationInfoResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationInfoResponse)(nil)).Elem()
}

func (o ApplicationInfoResponsePtrOutput) ToApplicationInfoResponsePtrOutput() ApplicationInfoResponsePtrOutput {
	return o
}

func (o ApplicationInfoResponsePtrOutput) ToApplicationInfoResponsePtrOutputWithContext(ctx context.Context) ApplicationInfoResponsePtrOutput {
	return o
}

func (o ApplicationInfoResponsePtrOutput) Elem() ApplicationInfoResponseOutput {
	return o.ApplyT(func(v *ApplicationInfoResponse) ApplicationInfoResponse { return *v }).(ApplicationInfoResponseOutput)
}

// Optional but at least one of uris, emails or instruction must be specified. Use this field to specify email address(es) to which resumes or applications can be sent. The maximum number of allowed characters for each entry is 255.
func (o ApplicationInfoResponsePtrOutput) Emails() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ApplicationInfoResponse) []string {
		if v == nil {
			return nil
		}
		return v.Emails
	}).(pulumi.StringArrayOutput)
}

// Optional but at least one of uris, emails or instruction must be specified. Use this field to provide instructions, such as "Mail your application to ...", that a candidate can follow to apply for the job. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 3,000.
func (o ApplicationInfoResponsePtrOutput) Instruction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ApplicationInfoResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Instruction
	}).(pulumi.StringPtrOutput)
}

// Optional but at least one of uris, emails or instruction must be specified. Use this URI field to direct an applicant to a website, for example to link to an online application form. The maximum number of allowed characters for each entry is 2,000.
func (o ApplicationInfoResponsePtrOutput) Uris() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ApplicationInfoResponse) []string {
		if v == nil {
			return nil
		}
		return v.Uris
	}).(pulumi.StringArrayOutput)
}

// An event issued when an end user interacts with the application that implements Cloud Talent Solution. Providing this information improves the quality of search and recommendation for the API clients, enabling the service to perform optimally. The number of events sent must be consistent with other calls, such as job searches, issued to the service by the client.
type ClientEventType struct {
	// Required. The timestamp of the event.
	CreateTime *string `pulumi:"createTime"`
	// Required. A unique identifier, generated by the client application. This `event_id` is used to establish the relationship between different events (see parent_event_id).
	EventId *string `pulumi:"eventId"`
	// Optional. Extra information about this event. Used for storing information with no matching field in event payload, for example, user application specific context or details. At most 20 keys are supported. The maximum total size of all keys and values is 2 KB.
	ExtraInfo map[string]string `pulumi:"extraInfo"`
	// A event issued when a job seeker interacts with the application that implements Cloud Talent Solution.
	JobEvent *JobEvent `pulumi:"jobEvent"`
	// Optional. The event_id of an event that resulted in the current event. For example, a Job view event usually follows a parent impression event: A job seeker first does a search where a list of jobs appears (impression). The job seeker then selects a result and views the description of a particular job (Job view).
	ParentEventId *string `pulumi:"parentEventId"`
	// Required. A unique ID generated in the API responses. It can be found in ResponseMetadata.request_id.
	RequestId *string `pulumi:"requestId"`
}

// ClientEventTypeInput is an input type that accepts ClientEventTypeArgs and ClientEventTypeOutput values.
// You can construct a concrete instance of `ClientEventTypeInput` via:
//
//          ClientEventTypeArgs{...}
type ClientEventTypeInput interface {
	pulumi.Input

	ToClientEventTypeOutput() ClientEventTypeOutput
	ToClientEventTypeOutputWithContext(context.Context) ClientEventTypeOutput
}

// An event issued when an end user interacts with the application that implements Cloud Talent Solution. Providing this information improves the quality of search and recommendation for the API clients, enabling the service to perform optimally. The number of events sent must be consistent with other calls, such as job searches, issued to the service by the client.
type ClientEventTypeArgs struct {
	// Required. The timestamp of the event.
	CreateTime pulumi.StringPtrInput `pulumi:"createTime"`
	// Required. A unique identifier, generated by the client application. This `event_id` is used to establish the relationship between different events (see parent_event_id).
	EventId pulumi.StringPtrInput `pulumi:"eventId"`
	// Optional. Extra information about this event. Used for storing information with no matching field in event payload, for example, user application specific context or details. At most 20 keys are supported. The maximum total size of all keys and values is 2 KB.
	ExtraInfo pulumi.StringMapInput `pulumi:"extraInfo"`
	// A event issued when a job seeker interacts with the application that implements Cloud Talent Solution.
	JobEvent JobEventPtrInput `pulumi:"jobEvent"`
	// Optional. The event_id of an event that resulted in the current event. For example, a Job view event usually follows a parent impression event: A job seeker first does a search where a list of jobs appears (impression). The job seeker then selects a result and views the description of a particular job (Job view).
	ParentEventId pulumi.StringPtrInput `pulumi:"parentEventId"`
	// Required. A unique ID generated in the API responses. It can be found in ResponseMetadata.request_id.
	RequestId pulumi.StringPtrInput `pulumi:"requestId"`
}

func (ClientEventTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClientEventType)(nil)).Elem()
}

func (i ClientEventTypeArgs) ToClientEventTypeOutput() ClientEventTypeOutput {
	return i.ToClientEventTypeOutputWithContext(context.Background())
}

func (i ClientEventTypeArgs) ToClientEventTypeOutputWithContext(ctx context.Context) ClientEventTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClientEventTypeOutput)
}

func (i ClientEventTypeArgs) ToClientEventTypePtrOutput() ClientEventTypePtrOutput {
	return i.ToClientEventTypePtrOutputWithContext(context.Background())
}

func (i ClientEventTypeArgs) ToClientEventTypePtrOutputWithContext(ctx context.Context) ClientEventTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClientEventTypeOutput).ToClientEventTypePtrOutputWithContext(ctx)
}

// ClientEventTypePtrInput is an input type that accepts ClientEventTypeArgs, ClientEventTypePtr and ClientEventTypePtrOutput values.
// You can construct a concrete instance of `ClientEventTypePtrInput` via:
//
//          ClientEventTypeArgs{...}
//
//  or:
//
//          nil
type ClientEventTypePtrInput interface {
	pulumi.Input

	ToClientEventTypePtrOutput() ClientEventTypePtrOutput
	ToClientEventTypePtrOutputWithContext(context.Context) ClientEventTypePtrOutput
}

type clientEventTypePtrType ClientEventTypeArgs

func ClientEventTypePtr(v *ClientEventTypeArgs) ClientEventTypePtrInput {
	return (*clientEventTypePtrType)(v)
}

func (*clientEventTypePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClientEventType)(nil)).Elem()
}

func (i *clientEventTypePtrType) ToClientEventTypePtrOutput() ClientEventTypePtrOutput {
	return i.ToClientEventTypePtrOutputWithContext(context.Background())
}

func (i *clientEventTypePtrType) ToClientEventTypePtrOutputWithContext(ctx context.Context) ClientEventTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClientEventTypePtrOutput)
}

// An event issued when an end user interacts with the application that implements Cloud Talent Solution. Providing this information improves the quality of search and recommendation for the API clients, enabling the service to perform optimally. The number of events sent must be consistent with other calls, such as job searches, issued to the service by the client.
type ClientEventTypeOutput struct{ *pulumi.OutputState }

func (ClientEventTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClientEventType)(nil)).Elem()
}

func (o ClientEventTypeOutput) ToClientEventTypeOutput() ClientEventTypeOutput {
	return o
}

func (o ClientEventTypeOutput) ToClientEventTypeOutputWithContext(ctx context.Context) ClientEventTypeOutput {
	return o
}

func (o ClientEventTypeOutput) ToClientEventTypePtrOutput() ClientEventTypePtrOutput {
	return o.ToClientEventTypePtrOutputWithContext(context.Background())
}

func (o ClientEventTypeOutput) ToClientEventTypePtrOutputWithContext(ctx context.Context) ClientEventTypePtrOutput {
	return o.ApplyT(func(v ClientEventType) *ClientEventType {
		return &v
	}).(ClientEventTypePtrOutput)
}

// Required. The timestamp of the event.
func (o ClientEventTypeOutput) CreateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClientEventType) *string { return v.CreateTime }).(pulumi.StringPtrOutput)
}

// Required. A unique identifier, generated by the client application. This `event_id` is used to establish the relationship between different events (see parent_event_id).
func (o ClientEventTypeOutput) EventId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClientEventType) *string { return v.EventId }).(pulumi.StringPtrOutput)
}

// Optional. Extra information about this event. Used for storing information with no matching field in event payload, for example, user application specific context or details. At most 20 keys are supported. The maximum total size of all keys and values is 2 KB.
func (o ClientEventTypeOutput) ExtraInfo() pulumi.StringMapOutput {
	return o.ApplyT(func(v ClientEventType) map[string]string { return v.ExtraInfo }).(pulumi.StringMapOutput)
}

// A event issued when a job seeker interacts with the application that implements Cloud Talent Solution.
func (o ClientEventTypeOutput) JobEvent() JobEventPtrOutput {
	return o.ApplyT(func(v ClientEventType) *JobEvent { return v.JobEvent }).(JobEventPtrOutput)
}

// Optional. The event_id of an event that resulted in the current event. For example, a Job view event usually follows a parent impression event: A job seeker first does a search where a list of jobs appears (impression). The job seeker then selects a result and views the description of a particular job (Job view).
func (o ClientEventTypeOutput) ParentEventId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClientEventType) *string { return v.ParentEventId }).(pulumi.StringPtrOutput)
}

// Required. A unique ID generated in the API responses. It can be found in ResponseMetadata.request_id.
func (o ClientEventTypeOutput) RequestId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClientEventType) *string { return v.RequestId }).(pulumi.StringPtrOutput)
}

type ClientEventTypePtrOutput struct{ *pulumi.OutputState }

func (ClientEventTypePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClientEventType)(nil)).Elem()
}

func (o ClientEventTypePtrOutput) ToClientEventTypePtrOutput() ClientEventTypePtrOutput {
	return o
}

func (o ClientEventTypePtrOutput) ToClientEventTypePtrOutputWithContext(ctx context.Context) ClientEventTypePtrOutput {
	return o
}

func (o ClientEventTypePtrOutput) Elem() ClientEventTypeOutput {
	return o.ApplyT(func(v *ClientEventType) ClientEventType { return *v }).(ClientEventTypeOutput)
}

// Required. The timestamp of the event.
func (o ClientEventTypePtrOutput) CreateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClientEventType) *string {
		if v == nil {
			return nil
		}
		return v.CreateTime
	}).(pulumi.StringPtrOutput)
}

// Required. A unique identifier, generated by the client application. This `event_id` is used to establish the relationship between different events (see parent_event_id).
func (o ClientEventTypePtrOutput) EventId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClientEventType) *string {
		if v == nil {
			return nil
		}
		return v.EventId
	}).(pulumi.StringPtrOutput)
}

// Optional. Extra information about this event. Used for storing information with no matching field in event payload, for example, user application specific context or details. At most 20 keys are supported. The maximum total size of all keys and values is 2 KB.
func (o ClientEventTypePtrOutput) ExtraInfo() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ClientEventType) map[string]string {
		if v == nil {
			return nil
		}
		return v.ExtraInfo
	}).(pulumi.StringMapOutput)
}

// A event issued when a job seeker interacts with the application that implements Cloud Talent Solution.
func (o ClientEventTypePtrOutput) JobEvent() JobEventPtrOutput {
	return o.ApplyT(func(v *ClientEventType) *JobEvent {
		if v == nil {
			return nil
		}
		return v.JobEvent
	}).(JobEventPtrOutput)
}

// Optional. The event_id of an event that resulted in the current event. For example, a Job view event usually follows a parent impression event: A job seeker first does a search where a list of jobs appears (impression). The job seeker then selects a result and views the description of a particular job (Job view).
func (o ClientEventTypePtrOutput) ParentEventId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClientEventType) *string {
		if v == nil {
			return nil
		}
		return v.ParentEventId
	}).(pulumi.StringPtrOutput)
}

// Required. A unique ID generated in the API responses. It can be found in ResponseMetadata.request_id.
func (o ClientEventTypePtrOutput) RequestId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClientEventType) *string {
		if v == nil {
			return nil
		}
		return v.RequestId
	}).(pulumi.StringPtrOutput)
}

// A Company resource represents a company in the service. A company is the entity that owns job postings, that is, the hiring entity responsible for employing applicants for the job position.
type CompanyType struct {
	// Optional. The URI to employer's career site or careers page on the employer's web site, for example, "https://careers.google.com".
	CareerSiteUri *string `pulumi:"careerSiteUri"`
	// Derived details about the company.
	DerivedInfo *CompanyDerivedInfo `pulumi:"derivedInfo"`
	// Required. The display name of the company, for example, "Google LLC".
	DisplayName *string `pulumi:"displayName"`
	// Optional. Equal Employment Opportunity legal disclaimer text to be associated with all jobs, and typically to be displayed in all roles. The maximum number of allowed characters is 500.
	EeoText *string `pulumi:"eeoText"`
	// Required. Client side company identifier, used to uniquely identify the company. The maximum number of allowed characters is 255.
	ExternalId *string `pulumi:"externalId"`
	// Optional. The street address of the company's main headquarters, which may be different from the job location. The service attempts to geolocate the provided address, and populates a more specific location wherever possible in DerivedInfo.headquarters_location.
	HeadquartersAddress *string `pulumi:"headquartersAddress"`
	// Optional. Set to true if it is the hiring agency that post jobs for other employers. Defaults to false if not provided.
	HiringAgency *bool `pulumi:"hiringAgency"`
	// Optional. A URI that hosts the employer's company logo.
	ImageUri *string `pulumi:"imageUri"`
	// Optional. A list of keys of filterable Job.custom_attributes, whose corresponding `string_values` are used in keyword search. Jobs with `string_values` under these specified field keys are returned if any of the values matches the search keyword. Custom field values with parenthesis, brackets and special symbols won't be properly searchable, and those keyword queries need to be surrounded by quotes.
	KeywordSearchableJobCustomAttributes []string `pulumi:"keywordSearchableJobCustomAttributes"`
	// Required during company update. The resource name for a company. This is generated by the service when a company is created. The format is "projects/{project_id}/companies/{company_id}", for example, "projects/api-test-project/companies/foo".
	Name *string `pulumi:"name"`
	// Optional. The employer's company size.
	Size *string `pulumi:"size"`
	// Indicates whether a company is flagged to be suspended from public availability by the service when job content appears suspicious, abusive, or spammy.
	Suspended *bool `pulumi:"suspended"`
	// Optional. The URI representing the company's primary web site or home page, for example, "https://www.google.com". The maximum number of allowed characters is 255.
	WebsiteUri *string `pulumi:"websiteUri"`
}

// CompanyTypeInput is an input type that accepts CompanyTypeArgs and CompanyTypeOutput values.
// You can construct a concrete instance of `CompanyTypeInput` via:
//
//          CompanyTypeArgs{...}
type CompanyTypeInput interface {
	pulumi.Input

	ToCompanyTypeOutput() CompanyTypeOutput
	ToCompanyTypeOutputWithContext(context.Context) CompanyTypeOutput
}

// A Company resource represents a company in the service. A company is the entity that owns job postings, that is, the hiring entity responsible for employing applicants for the job position.
type CompanyTypeArgs struct {
	// Optional. The URI to employer's career site or careers page on the employer's web site, for example, "https://careers.google.com".
	CareerSiteUri pulumi.StringPtrInput `pulumi:"careerSiteUri"`
	// Derived details about the company.
	DerivedInfo CompanyDerivedInfoPtrInput `pulumi:"derivedInfo"`
	// Required. The display name of the company, for example, "Google LLC".
	DisplayName pulumi.StringPtrInput `pulumi:"displayName"`
	// Optional. Equal Employment Opportunity legal disclaimer text to be associated with all jobs, and typically to be displayed in all roles. The maximum number of allowed characters is 500.
	EeoText pulumi.StringPtrInput `pulumi:"eeoText"`
	// Required. Client side company identifier, used to uniquely identify the company. The maximum number of allowed characters is 255.
	ExternalId pulumi.StringPtrInput `pulumi:"externalId"`
	// Optional. The street address of the company's main headquarters, which may be different from the job location. The service attempts to geolocate the provided address, and populates a more specific location wherever possible in DerivedInfo.headquarters_location.
	HeadquartersAddress pulumi.StringPtrInput `pulumi:"headquartersAddress"`
	// Optional. Set to true if it is the hiring agency that post jobs for other employers. Defaults to false if not provided.
	HiringAgency pulumi.BoolPtrInput `pulumi:"hiringAgency"`
	// Optional. A URI that hosts the employer's company logo.
	ImageUri pulumi.StringPtrInput `pulumi:"imageUri"`
	// Optional. A list of keys of filterable Job.custom_attributes, whose corresponding `string_values` are used in keyword search. Jobs with `string_values` under these specified field keys are returned if any of the values matches the search keyword. Custom field values with parenthesis, brackets and special symbols won't be properly searchable, and those keyword queries need to be surrounded by quotes.
	KeywordSearchableJobCustomAttributes pulumi.StringArrayInput `pulumi:"keywordSearchableJobCustomAttributes"`
	// Required during company update. The resource name for a company. This is generated by the service when a company is created. The format is "projects/{project_id}/companies/{company_id}", for example, "projects/api-test-project/companies/foo".
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Optional. The employer's company size.
	Size pulumi.StringPtrInput `pulumi:"size"`
	// Indicates whether a company is flagged to be suspended from public availability by the service when job content appears suspicious, abusive, or spammy.
	Suspended pulumi.BoolPtrInput `pulumi:"suspended"`
	// Optional. The URI representing the company's primary web site or home page, for example, "https://www.google.com". The maximum number of allowed characters is 255.
	WebsiteUri pulumi.StringPtrInput `pulumi:"websiteUri"`
}

func (CompanyTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CompanyType)(nil)).Elem()
}

func (i CompanyTypeArgs) ToCompanyTypeOutput() CompanyTypeOutput {
	return i.ToCompanyTypeOutputWithContext(context.Background())
}

func (i CompanyTypeArgs) ToCompanyTypeOutputWithContext(ctx context.Context) CompanyTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompanyTypeOutput)
}

func (i CompanyTypeArgs) ToCompanyTypePtrOutput() CompanyTypePtrOutput {
	return i.ToCompanyTypePtrOutputWithContext(context.Background())
}

func (i CompanyTypeArgs) ToCompanyTypePtrOutputWithContext(ctx context.Context) CompanyTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompanyTypeOutput).ToCompanyTypePtrOutputWithContext(ctx)
}

// CompanyTypePtrInput is an input type that accepts CompanyTypeArgs, CompanyTypePtr and CompanyTypePtrOutput values.
// You can construct a concrete instance of `CompanyTypePtrInput` via:
//
//          CompanyTypeArgs{...}
//
//  or:
//
//          nil
type CompanyTypePtrInput interface {
	pulumi.Input

	ToCompanyTypePtrOutput() CompanyTypePtrOutput
	ToCompanyTypePtrOutputWithContext(context.Context) CompanyTypePtrOutput
}

type companyTypePtrType CompanyTypeArgs

func CompanyTypePtr(v *CompanyTypeArgs) CompanyTypePtrInput {
	return (*companyTypePtrType)(v)
}

func (*companyTypePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CompanyType)(nil)).Elem()
}

func (i *companyTypePtrType) ToCompanyTypePtrOutput() CompanyTypePtrOutput {
	return i.ToCompanyTypePtrOutputWithContext(context.Background())
}

func (i *companyTypePtrType) ToCompanyTypePtrOutputWithContext(ctx context.Context) CompanyTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompanyTypePtrOutput)
}

// A Company resource represents a company in the service. A company is the entity that owns job postings, that is, the hiring entity responsible for employing applicants for the job position.
type CompanyTypeOutput struct{ *pulumi.OutputState }

func (CompanyTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompanyType)(nil)).Elem()
}

func (o CompanyTypeOutput) ToCompanyTypeOutput() CompanyTypeOutput {
	return o
}

func (o CompanyTypeOutput) ToCompanyTypeOutputWithContext(ctx context.Context) CompanyTypeOutput {
	return o
}

func (o CompanyTypeOutput) ToCompanyTypePtrOutput() CompanyTypePtrOutput {
	return o.ToCompanyTypePtrOutputWithContext(context.Background())
}

func (o CompanyTypeOutput) ToCompanyTypePtrOutputWithContext(ctx context.Context) CompanyTypePtrOutput {
	return o.ApplyT(func(v CompanyType) *CompanyType {
		return &v
	}).(CompanyTypePtrOutput)
}

// Optional. The URI to employer's career site or careers page on the employer's web site, for example, "https://careers.google.com".
func (o CompanyTypeOutput) CareerSiteUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CompanyType) *string { return v.CareerSiteUri }).(pulumi.StringPtrOutput)
}

// Derived details about the company.
func (o CompanyTypeOutput) DerivedInfo() CompanyDerivedInfoPtrOutput {
	return o.ApplyT(func(v CompanyType) *CompanyDerivedInfo { return v.DerivedInfo }).(CompanyDerivedInfoPtrOutput)
}

// Required. The display name of the company, for example, "Google LLC".
func (o CompanyTypeOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CompanyType) *string { return v.DisplayName }).(pulumi.StringPtrOutput)
}

// Optional. Equal Employment Opportunity legal disclaimer text to be associated with all jobs, and typically to be displayed in all roles. The maximum number of allowed characters is 500.
func (o CompanyTypeOutput) EeoText() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CompanyType) *string { return v.EeoText }).(pulumi.StringPtrOutput)
}

// Required. Client side company identifier, used to uniquely identify the company. The maximum number of allowed characters is 255.
func (o CompanyTypeOutput) ExternalId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CompanyType) *string { return v.ExternalId }).(pulumi.StringPtrOutput)
}

// Optional. The street address of the company's main headquarters, which may be different from the job location. The service attempts to geolocate the provided address, and populates a more specific location wherever possible in DerivedInfo.headquarters_location.
func (o CompanyTypeOutput) HeadquartersAddress() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CompanyType) *string { return v.HeadquartersAddress }).(pulumi.StringPtrOutput)
}

// Optional. Set to true if it is the hiring agency that post jobs for other employers. Defaults to false if not provided.
func (o CompanyTypeOutput) HiringAgency() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CompanyType) *bool { return v.HiringAgency }).(pulumi.BoolPtrOutput)
}

// Optional. A URI that hosts the employer's company logo.
func (o CompanyTypeOutput) ImageUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CompanyType) *string { return v.ImageUri }).(pulumi.StringPtrOutput)
}

// Optional. A list of keys of filterable Job.custom_attributes, whose corresponding `string_values` are used in keyword search. Jobs with `string_values` under these specified field keys are returned if any of the values matches the search keyword. Custom field values with parenthesis, brackets and special symbols won't be properly searchable, and those keyword queries need to be surrounded by quotes.
func (o CompanyTypeOutput) KeywordSearchableJobCustomAttributes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CompanyType) []string { return v.KeywordSearchableJobCustomAttributes }).(pulumi.StringArrayOutput)
}

// Required during company update. The resource name for a company. This is generated by the service when a company is created. The format is "projects/{project_id}/companies/{company_id}", for example, "projects/api-test-project/companies/foo".
func (o CompanyTypeOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CompanyType) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Optional. The employer's company size.
func (o CompanyTypeOutput) Size() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CompanyType) *string { return v.Size }).(pulumi.StringPtrOutput)
}

// Indicates whether a company is flagged to be suspended from public availability by the service when job content appears suspicious, abusive, or spammy.
func (o CompanyTypeOutput) Suspended() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CompanyType) *bool { return v.Suspended }).(pulumi.BoolPtrOutput)
}

// Optional. The URI representing the company's primary web site or home page, for example, "https://www.google.com". The maximum number of allowed characters is 255.
func (o CompanyTypeOutput) WebsiteUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CompanyType) *string { return v.WebsiteUri }).(pulumi.StringPtrOutput)
}

type CompanyTypePtrOutput struct{ *pulumi.OutputState }

func (CompanyTypePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CompanyType)(nil)).Elem()
}

func (o CompanyTypePtrOutput) ToCompanyTypePtrOutput() CompanyTypePtrOutput {
	return o
}

func (o CompanyTypePtrOutput) ToCompanyTypePtrOutputWithContext(ctx context.Context) CompanyTypePtrOutput {
	return o
}

func (o CompanyTypePtrOutput) Elem() CompanyTypeOutput {
	return o.ApplyT(func(v *CompanyType) CompanyType { return *v }).(CompanyTypeOutput)
}

// Optional. The URI to employer's career site or careers page on the employer's web site, for example, "https://careers.google.com".
func (o CompanyTypePtrOutput) CareerSiteUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CompanyType) *string {
		if v == nil {
			return nil
		}
		return v.CareerSiteUri
	}).(pulumi.StringPtrOutput)
}

// Derived details about the company.
func (o CompanyTypePtrOutput) DerivedInfo() CompanyDerivedInfoPtrOutput {
	return o.ApplyT(func(v *CompanyType) *CompanyDerivedInfo {
		if v == nil {
			return nil
		}
		return v.DerivedInfo
	}).(CompanyDerivedInfoPtrOutput)
}

// Required. The display name of the company, for example, "Google LLC".
func (o CompanyTypePtrOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CompanyType) *string {
		if v == nil {
			return nil
		}
		return v.DisplayName
	}).(pulumi.StringPtrOutput)
}

// Optional. Equal Employment Opportunity legal disclaimer text to be associated with all jobs, and typically to be displayed in all roles. The maximum number of allowed characters is 500.
func (o CompanyTypePtrOutput) EeoText() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CompanyType) *string {
		if v == nil {
			return nil
		}
		return v.EeoText
	}).(pulumi.StringPtrOutput)
}

// Required. Client side company identifier, used to uniquely identify the company. The maximum number of allowed characters is 255.
func (o CompanyTypePtrOutput) ExternalId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CompanyType) *string {
		if v == nil {
			return nil
		}
		return v.ExternalId
	}).(pulumi.StringPtrOutput)
}

// Optional. The street address of the company's main headquarters, which may be different from the job location. The service attempts to geolocate the provided address, and populates a more specific location wherever possible in DerivedInfo.headquarters_location.
func (o CompanyTypePtrOutput) HeadquartersAddress() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CompanyType) *string {
		if v == nil {
			return nil
		}
		return v.HeadquartersAddress
	}).(pulumi.StringPtrOutput)
}

// Optional. Set to true if it is the hiring agency that post jobs for other employers. Defaults to false if not provided.
func (o CompanyTypePtrOutput) HiringAgency() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CompanyType) *bool {
		if v == nil {
			return nil
		}
		return v.HiringAgency
	}).(pulumi.BoolPtrOutput)
}

// Optional. A URI that hosts the employer's company logo.
func (o CompanyTypePtrOutput) ImageUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CompanyType) *string {
		if v == nil {
			return nil
		}
		return v.ImageUri
	}).(pulumi.StringPtrOutput)
}

// Optional. A list of keys of filterable Job.custom_attributes, whose corresponding `string_values` are used in keyword search. Jobs with `string_values` under these specified field keys are returned if any of the values matches the search keyword. Custom field values with parenthesis, brackets and special symbols won't be properly searchable, and those keyword queries need to be surrounded by quotes.
func (o CompanyTypePtrOutput) KeywordSearchableJobCustomAttributes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CompanyType) []string {
		if v == nil {
			return nil
		}
		return v.KeywordSearchableJobCustomAttributes
	}).(pulumi.StringArrayOutput)
}

// Required during company update. The resource name for a company. This is generated by the service when a company is created. The format is "projects/{project_id}/companies/{company_id}", for example, "projects/api-test-project/companies/foo".
func (o CompanyTypePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CompanyType) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Optional. The employer's company size.
func (o CompanyTypePtrOutput) Size() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CompanyType) *string {
		if v == nil {
			return nil
		}
		return v.Size
	}).(pulumi.StringPtrOutput)
}

// Indicates whether a company is flagged to be suspended from public availability by the service when job content appears suspicious, abusive, or spammy.
func (o CompanyTypePtrOutput) Suspended() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CompanyType) *bool {
		if v == nil {
			return nil
		}
		return v.Suspended
	}).(pulumi.BoolPtrOutput)
}

// Optional. The URI representing the company's primary web site or home page, for example, "https://www.google.com". The maximum number of allowed characters is 255.
func (o CompanyTypePtrOutput) WebsiteUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CompanyType) *string {
		if v == nil {
			return nil
		}
		return v.WebsiteUri
	}).(pulumi.StringPtrOutput)
}

// Derived details about the company.
type CompanyDerivedInfo struct {
	// A structured headquarters location of the company, resolved from Company.hq_location if provided.
	HeadquartersLocation *Location `pulumi:"headquartersLocation"`
}

// CompanyDerivedInfoInput is an input type that accepts CompanyDerivedInfoArgs and CompanyDerivedInfoOutput values.
// You can construct a concrete instance of `CompanyDerivedInfoInput` via:
//
//          CompanyDerivedInfoArgs{...}
type CompanyDerivedInfoInput interface {
	pulumi.Input

	ToCompanyDerivedInfoOutput() CompanyDerivedInfoOutput
	ToCompanyDerivedInfoOutputWithContext(context.Context) CompanyDerivedInfoOutput
}

// Derived details about the company.
type CompanyDerivedInfoArgs struct {
	// A structured headquarters location of the company, resolved from Company.hq_location if provided.
	HeadquartersLocation LocationPtrInput `pulumi:"headquartersLocation"`
}

func (CompanyDerivedInfoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CompanyDerivedInfo)(nil)).Elem()
}

func (i CompanyDerivedInfoArgs) ToCompanyDerivedInfoOutput() CompanyDerivedInfoOutput {
	return i.ToCompanyDerivedInfoOutputWithContext(context.Background())
}

func (i CompanyDerivedInfoArgs) ToCompanyDerivedInfoOutputWithContext(ctx context.Context) CompanyDerivedInfoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompanyDerivedInfoOutput)
}

func (i CompanyDerivedInfoArgs) ToCompanyDerivedInfoPtrOutput() CompanyDerivedInfoPtrOutput {
	return i.ToCompanyDerivedInfoPtrOutputWithContext(context.Background())
}

func (i CompanyDerivedInfoArgs) ToCompanyDerivedInfoPtrOutputWithContext(ctx context.Context) CompanyDerivedInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompanyDerivedInfoOutput).ToCompanyDerivedInfoPtrOutputWithContext(ctx)
}

// CompanyDerivedInfoPtrInput is an input type that accepts CompanyDerivedInfoArgs, CompanyDerivedInfoPtr and CompanyDerivedInfoPtrOutput values.
// You can construct a concrete instance of `CompanyDerivedInfoPtrInput` via:
//
//          CompanyDerivedInfoArgs{...}
//
//  or:
//
//          nil
type CompanyDerivedInfoPtrInput interface {
	pulumi.Input

	ToCompanyDerivedInfoPtrOutput() CompanyDerivedInfoPtrOutput
	ToCompanyDerivedInfoPtrOutputWithContext(context.Context) CompanyDerivedInfoPtrOutput
}

type companyDerivedInfoPtrType CompanyDerivedInfoArgs

func CompanyDerivedInfoPtr(v *CompanyDerivedInfoArgs) CompanyDerivedInfoPtrInput {
	return (*companyDerivedInfoPtrType)(v)
}

func (*companyDerivedInfoPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CompanyDerivedInfo)(nil)).Elem()
}

func (i *companyDerivedInfoPtrType) ToCompanyDerivedInfoPtrOutput() CompanyDerivedInfoPtrOutput {
	return i.ToCompanyDerivedInfoPtrOutputWithContext(context.Background())
}

func (i *companyDerivedInfoPtrType) ToCompanyDerivedInfoPtrOutputWithContext(ctx context.Context) CompanyDerivedInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompanyDerivedInfoPtrOutput)
}

// Derived details about the company.
type CompanyDerivedInfoOutput struct{ *pulumi.OutputState }

func (CompanyDerivedInfoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompanyDerivedInfo)(nil)).Elem()
}

func (o CompanyDerivedInfoOutput) ToCompanyDerivedInfoOutput() CompanyDerivedInfoOutput {
	return o
}

func (o CompanyDerivedInfoOutput) ToCompanyDerivedInfoOutputWithContext(ctx context.Context) CompanyDerivedInfoOutput {
	return o
}

func (o CompanyDerivedInfoOutput) ToCompanyDerivedInfoPtrOutput() CompanyDerivedInfoPtrOutput {
	return o.ToCompanyDerivedInfoPtrOutputWithContext(context.Background())
}

func (o CompanyDerivedInfoOutput) ToCompanyDerivedInfoPtrOutputWithContext(ctx context.Context) CompanyDerivedInfoPtrOutput {
	return o.ApplyT(func(v CompanyDerivedInfo) *CompanyDerivedInfo {
		return &v
	}).(CompanyDerivedInfoPtrOutput)
}

// A structured headquarters location of the company, resolved from Company.hq_location if provided.
func (o CompanyDerivedInfoOutput) HeadquartersLocation() LocationPtrOutput {
	return o.ApplyT(func(v CompanyDerivedInfo) *Location { return v.HeadquartersLocation }).(LocationPtrOutput)
}

type CompanyDerivedInfoPtrOutput struct{ *pulumi.OutputState }

func (CompanyDerivedInfoPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CompanyDerivedInfo)(nil)).Elem()
}

func (o CompanyDerivedInfoPtrOutput) ToCompanyDerivedInfoPtrOutput() CompanyDerivedInfoPtrOutput {
	return o
}

func (o CompanyDerivedInfoPtrOutput) ToCompanyDerivedInfoPtrOutputWithContext(ctx context.Context) CompanyDerivedInfoPtrOutput {
	return o
}

func (o CompanyDerivedInfoPtrOutput) Elem() CompanyDerivedInfoOutput {
	return o.ApplyT(func(v *CompanyDerivedInfo) CompanyDerivedInfo { return *v }).(CompanyDerivedInfoOutput)
}

// A structured headquarters location of the company, resolved from Company.hq_location if provided.
func (o CompanyDerivedInfoPtrOutput) HeadquartersLocation() LocationPtrOutput {
	return o.ApplyT(func(v *CompanyDerivedInfo) *Location {
		if v == nil {
			return nil
		}
		return v.HeadquartersLocation
	}).(LocationPtrOutput)
}

// Derived details about the company.
type CompanyDerivedInfoResponse struct {
	// A structured headquarters location of the company, resolved from Company.hq_location if provided.
	HeadquartersLocation LocationResponse `pulumi:"headquartersLocation"`
}

// CompanyDerivedInfoResponseInput is an input type that accepts CompanyDerivedInfoResponseArgs and CompanyDerivedInfoResponseOutput values.
// You can construct a concrete instance of `CompanyDerivedInfoResponseInput` via:
//
//          CompanyDerivedInfoResponseArgs{...}
type CompanyDerivedInfoResponseInput interface {
	pulumi.Input

	ToCompanyDerivedInfoResponseOutput() CompanyDerivedInfoResponseOutput
	ToCompanyDerivedInfoResponseOutputWithContext(context.Context) CompanyDerivedInfoResponseOutput
}

// Derived details about the company.
type CompanyDerivedInfoResponseArgs struct {
	// A structured headquarters location of the company, resolved from Company.hq_location if provided.
	HeadquartersLocation LocationResponseInput `pulumi:"headquartersLocation"`
}

func (CompanyDerivedInfoResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CompanyDerivedInfoResponse)(nil)).Elem()
}

func (i CompanyDerivedInfoResponseArgs) ToCompanyDerivedInfoResponseOutput() CompanyDerivedInfoResponseOutput {
	return i.ToCompanyDerivedInfoResponseOutputWithContext(context.Background())
}

func (i CompanyDerivedInfoResponseArgs) ToCompanyDerivedInfoResponseOutputWithContext(ctx context.Context) CompanyDerivedInfoResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompanyDerivedInfoResponseOutput)
}

func (i CompanyDerivedInfoResponseArgs) ToCompanyDerivedInfoResponsePtrOutput() CompanyDerivedInfoResponsePtrOutput {
	return i.ToCompanyDerivedInfoResponsePtrOutputWithContext(context.Background())
}

func (i CompanyDerivedInfoResponseArgs) ToCompanyDerivedInfoResponsePtrOutputWithContext(ctx context.Context) CompanyDerivedInfoResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompanyDerivedInfoResponseOutput).ToCompanyDerivedInfoResponsePtrOutputWithContext(ctx)
}

// CompanyDerivedInfoResponsePtrInput is an input type that accepts CompanyDerivedInfoResponseArgs, CompanyDerivedInfoResponsePtr and CompanyDerivedInfoResponsePtrOutput values.
// You can construct a concrete instance of `CompanyDerivedInfoResponsePtrInput` via:
//
//          CompanyDerivedInfoResponseArgs{...}
//
//  or:
//
//          nil
type CompanyDerivedInfoResponsePtrInput interface {
	pulumi.Input

	ToCompanyDerivedInfoResponsePtrOutput() CompanyDerivedInfoResponsePtrOutput
	ToCompanyDerivedInfoResponsePtrOutputWithContext(context.Context) CompanyDerivedInfoResponsePtrOutput
}

type companyDerivedInfoResponsePtrType CompanyDerivedInfoResponseArgs

func CompanyDerivedInfoResponsePtr(v *CompanyDerivedInfoResponseArgs) CompanyDerivedInfoResponsePtrInput {
	return (*companyDerivedInfoResponsePtrType)(v)
}

func (*companyDerivedInfoResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CompanyDerivedInfoResponse)(nil)).Elem()
}

func (i *companyDerivedInfoResponsePtrType) ToCompanyDerivedInfoResponsePtrOutput() CompanyDerivedInfoResponsePtrOutput {
	return i.ToCompanyDerivedInfoResponsePtrOutputWithContext(context.Background())
}

func (i *companyDerivedInfoResponsePtrType) ToCompanyDerivedInfoResponsePtrOutputWithContext(ctx context.Context) CompanyDerivedInfoResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompanyDerivedInfoResponsePtrOutput)
}

// Derived details about the company.
type CompanyDerivedInfoResponseOutput struct{ *pulumi.OutputState }

func (CompanyDerivedInfoResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompanyDerivedInfoResponse)(nil)).Elem()
}

func (o CompanyDerivedInfoResponseOutput) ToCompanyDerivedInfoResponseOutput() CompanyDerivedInfoResponseOutput {
	return o
}

func (o CompanyDerivedInfoResponseOutput) ToCompanyDerivedInfoResponseOutputWithContext(ctx context.Context) CompanyDerivedInfoResponseOutput {
	return o
}

func (o CompanyDerivedInfoResponseOutput) ToCompanyDerivedInfoResponsePtrOutput() CompanyDerivedInfoResponsePtrOutput {
	return o.ToCompanyDerivedInfoResponsePtrOutputWithContext(context.Background())
}

func (o CompanyDerivedInfoResponseOutput) ToCompanyDerivedInfoResponsePtrOutputWithContext(ctx context.Context) CompanyDerivedInfoResponsePtrOutput {
	return o.ApplyT(func(v CompanyDerivedInfoResponse) *CompanyDerivedInfoResponse {
		return &v
	}).(CompanyDerivedInfoResponsePtrOutput)
}

// A structured headquarters location of the company, resolved from Company.hq_location if provided.
func (o CompanyDerivedInfoResponseOutput) HeadquartersLocation() LocationResponseOutput {
	return o.ApplyT(func(v CompanyDerivedInfoResponse) LocationResponse { return v.HeadquartersLocation }).(LocationResponseOutput)
}

type CompanyDerivedInfoResponsePtrOutput struct{ *pulumi.OutputState }

func (CompanyDerivedInfoResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CompanyDerivedInfoResponse)(nil)).Elem()
}

func (o CompanyDerivedInfoResponsePtrOutput) ToCompanyDerivedInfoResponsePtrOutput() CompanyDerivedInfoResponsePtrOutput {
	return o
}

func (o CompanyDerivedInfoResponsePtrOutput) ToCompanyDerivedInfoResponsePtrOutputWithContext(ctx context.Context) CompanyDerivedInfoResponsePtrOutput {
	return o
}

func (o CompanyDerivedInfoResponsePtrOutput) Elem() CompanyDerivedInfoResponseOutput {
	return o.ApplyT(func(v *CompanyDerivedInfoResponse) CompanyDerivedInfoResponse { return *v }).(CompanyDerivedInfoResponseOutput)
}

// A structured headquarters location of the company, resolved from Company.hq_location if provided.
func (o CompanyDerivedInfoResponsePtrOutput) HeadquartersLocation() LocationResponsePtrOutput {
	return o.ApplyT(func(v *CompanyDerivedInfoResponse) *LocationResponse {
		if v == nil {
			return nil
		}
		return &v.HeadquartersLocation
	}).(LocationResponsePtrOutput)
}

// A compensation entry that represents one component of compensation, such as base pay, bonus, or other compensation type. Annualization: One compensation entry can be annualized if - it contains valid amount or range. - and its expected_units_per_year is set or can be derived. Its annualized range is determined as (amount or range) times expected_units_per_year.
type CompensationEntry struct {
	// Optional. Compensation amount.
	Amount *Money `pulumi:"amount"`
	// Optional. Compensation description. For example, could indicate equity terms or provide additional context to an estimated bonus.
	Description *string `pulumi:"description"`
	// Optional. Expected number of units paid each year. If not specified, when Job.employment_types is FULLTIME, a default value is inferred based on unit. Default values: - HOURLY: 2080 - DAILY: 260 - WEEKLY: 52 - MONTHLY: 12 - ANNUAL: 1
	ExpectedUnitsPerYear *float64 `pulumi:"expectedUnitsPerYear"`
	// Optional. Compensation range.
	Range *CompensationRange `pulumi:"range"`
	// Optional. Compensation type. Default is CompensationUnit.COMPENSATION_TYPE_UNSPECIFIED.
	Type *string `pulumi:"type"`
	// Optional. Frequency of the specified amount. Default is CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED.
	Unit *string `pulumi:"unit"`
}

// CompensationEntryInput is an input type that accepts CompensationEntryArgs and CompensationEntryOutput values.
// You can construct a concrete instance of `CompensationEntryInput` via:
//
//          CompensationEntryArgs{...}
type CompensationEntryInput interface {
	pulumi.Input

	ToCompensationEntryOutput() CompensationEntryOutput
	ToCompensationEntryOutputWithContext(context.Context) CompensationEntryOutput
}

// A compensation entry that represents one component of compensation, such as base pay, bonus, or other compensation type. Annualization: One compensation entry can be annualized if - it contains valid amount or range. - and its expected_units_per_year is set or can be derived. Its annualized range is determined as (amount or range) times expected_units_per_year.
type CompensationEntryArgs struct {
	// Optional. Compensation amount.
	Amount MoneyPtrInput `pulumi:"amount"`
	// Optional. Compensation description. For example, could indicate equity terms or provide additional context to an estimated bonus.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Optional. Expected number of units paid each year. If not specified, when Job.employment_types is FULLTIME, a default value is inferred based on unit. Default values: - HOURLY: 2080 - DAILY: 260 - WEEKLY: 52 - MONTHLY: 12 - ANNUAL: 1
	ExpectedUnitsPerYear pulumi.Float64PtrInput `pulumi:"expectedUnitsPerYear"`
	// Optional. Compensation range.
	Range CompensationRangePtrInput `pulumi:"range"`
	// Optional. Compensation type. Default is CompensationUnit.COMPENSATION_TYPE_UNSPECIFIED.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Optional. Frequency of the specified amount. Default is CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED.
	Unit pulumi.StringPtrInput `pulumi:"unit"`
}

func (CompensationEntryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationEntry)(nil)).Elem()
}

func (i CompensationEntryArgs) ToCompensationEntryOutput() CompensationEntryOutput {
	return i.ToCompensationEntryOutputWithContext(context.Background())
}

func (i CompensationEntryArgs) ToCompensationEntryOutputWithContext(ctx context.Context) CompensationEntryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationEntryOutput)
}

// CompensationEntryArrayInput is an input type that accepts CompensationEntryArray and CompensationEntryArrayOutput values.
// You can construct a concrete instance of `CompensationEntryArrayInput` via:
//
//          CompensationEntryArray{ CompensationEntryArgs{...} }
type CompensationEntryArrayInput interface {
	pulumi.Input

	ToCompensationEntryArrayOutput() CompensationEntryArrayOutput
	ToCompensationEntryArrayOutputWithContext(context.Context) CompensationEntryArrayOutput
}

type CompensationEntryArray []CompensationEntryInput

func (CompensationEntryArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CompensationEntry)(nil)).Elem()
}

func (i CompensationEntryArray) ToCompensationEntryArrayOutput() CompensationEntryArrayOutput {
	return i.ToCompensationEntryArrayOutputWithContext(context.Background())
}

func (i CompensationEntryArray) ToCompensationEntryArrayOutputWithContext(ctx context.Context) CompensationEntryArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationEntryArrayOutput)
}

// A compensation entry that represents one component of compensation, such as base pay, bonus, or other compensation type. Annualization: One compensation entry can be annualized if - it contains valid amount or range. - and its expected_units_per_year is set or can be derived. Its annualized range is determined as (amount or range) times expected_units_per_year.
type CompensationEntryOutput struct{ *pulumi.OutputState }

func (CompensationEntryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationEntry)(nil)).Elem()
}

func (o CompensationEntryOutput) ToCompensationEntryOutput() CompensationEntryOutput {
	return o
}

func (o CompensationEntryOutput) ToCompensationEntryOutputWithContext(ctx context.Context) CompensationEntryOutput {
	return o
}

// Optional. Compensation amount.
func (o CompensationEntryOutput) Amount() MoneyPtrOutput {
	return o.ApplyT(func(v CompensationEntry) *Money { return v.Amount }).(MoneyPtrOutput)
}

// Optional. Compensation description. For example, could indicate equity terms or provide additional context to an estimated bonus.
func (o CompensationEntryOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CompensationEntry) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Optional. Expected number of units paid each year. If not specified, when Job.employment_types is FULLTIME, a default value is inferred based on unit. Default values: - HOURLY: 2080 - DAILY: 260 - WEEKLY: 52 - MONTHLY: 12 - ANNUAL: 1
func (o CompensationEntryOutput) ExpectedUnitsPerYear() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v CompensationEntry) *float64 { return v.ExpectedUnitsPerYear }).(pulumi.Float64PtrOutput)
}

// Optional. Compensation range.
func (o CompensationEntryOutput) Range() CompensationRangePtrOutput {
	return o.ApplyT(func(v CompensationEntry) *CompensationRange { return v.Range }).(CompensationRangePtrOutput)
}

// Optional. Compensation type. Default is CompensationUnit.COMPENSATION_TYPE_UNSPECIFIED.
func (o CompensationEntryOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CompensationEntry) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Optional. Frequency of the specified amount. Default is CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED.
func (o CompensationEntryOutput) Unit() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CompensationEntry) *string { return v.Unit }).(pulumi.StringPtrOutput)
}

type CompensationEntryArrayOutput struct{ *pulumi.OutputState }

func (CompensationEntryArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CompensationEntry)(nil)).Elem()
}

func (o CompensationEntryArrayOutput) ToCompensationEntryArrayOutput() CompensationEntryArrayOutput {
	return o
}

func (o CompensationEntryArrayOutput) ToCompensationEntryArrayOutputWithContext(ctx context.Context) CompensationEntryArrayOutput {
	return o
}

func (o CompensationEntryArrayOutput) Index(i pulumi.IntInput) CompensationEntryOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CompensationEntry {
		return vs[0].([]CompensationEntry)[vs[1].(int)]
	}).(CompensationEntryOutput)
}

// A compensation entry that represents one component of compensation, such as base pay, bonus, or other compensation type. Annualization: One compensation entry can be annualized if - it contains valid amount or range. - and its expected_units_per_year is set or can be derived. Its annualized range is determined as (amount or range) times expected_units_per_year.
type CompensationEntryResponse struct {
	// Optional. Compensation amount.
	Amount MoneyResponse `pulumi:"amount"`
	// Optional. Compensation description. For example, could indicate equity terms or provide additional context to an estimated bonus.
	Description string `pulumi:"description"`
	// Optional. Expected number of units paid each year. If not specified, when Job.employment_types is FULLTIME, a default value is inferred based on unit. Default values: - HOURLY: 2080 - DAILY: 260 - WEEKLY: 52 - MONTHLY: 12 - ANNUAL: 1
	ExpectedUnitsPerYear float64 `pulumi:"expectedUnitsPerYear"`
	// Optional. Compensation range.
	Range CompensationRangeResponse `pulumi:"range"`
	// Optional. Compensation type. Default is CompensationUnit.COMPENSATION_TYPE_UNSPECIFIED.
	Type string `pulumi:"type"`
	// Optional. Frequency of the specified amount. Default is CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED.
	Unit string `pulumi:"unit"`
}

// CompensationEntryResponseInput is an input type that accepts CompensationEntryResponseArgs and CompensationEntryResponseOutput values.
// You can construct a concrete instance of `CompensationEntryResponseInput` via:
//
//          CompensationEntryResponseArgs{...}
type CompensationEntryResponseInput interface {
	pulumi.Input

	ToCompensationEntryResponseOutput() CompensationEntryResponseOutput
	ToCompensationEntryResponseOutputWithContext(context.Context) CompensationEntryResponseOutput
}

// A compensation entry that represents one component of compensation, such as base pay, bonus, or other compensation type. Annualization: One compensation entry can be annualized if - it contains valid amount or range. - and its expected_units_per_year is set or can be derived. Its annualized range is determined as (amount or range) times expected_units_per_year.
type CompensationEntryResponseArgs struct {
	// Optional. Compensation amount.
	Amount MoneyResponseInput `pulumi:"amount"`
	// Optional. Compensation description. For example, could indicate equity terms or provide additional context to an estimated bonus.
	Description pulumi.StringInput `pulumi:"description"`
	// Optional. Expected number of units paid each year. If not specified, when Job.employment_types is FULLTIME, a default value is inferred based on unit. Default values: - HOURLY: 2080 - DAILY: 260 - WEEKLY: 52 - MONTHLY: 12 - ANNUAL: 1
	ExpectedUnitsPerYear pulumi.Float64Input `pulumi:"expectedUnitsPerYear"`
	// Optional. Compensation range.
	Range CompensationRangeResponseInput `pulumi:"range"`
	// Optional. Compensation type. Default is CompensationUnit.COMPENSATION_TYPE_UNSPECIFIED.
	Type pulumi.StringInput `pulumi:"type"`
	// Optional. Frequency of the specified amount. Default is CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED.
	Unit pulumi.StringInput `pulumi:"unit"`
}

func (CompensationEntryResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationEntryResponse)(nil)).Elem()
}

func (i CompensationEntryResponseArgs) ToCompensationEntryResponseOutput() CompensationEntryResponseOutput {
	return i.ToCompensationEntryResponseOutputWithContext(context.Background())
}

func (i CompensationEntryResponseArgs) ToCompensationEntryResponseOutputWithContext(ctx context.Context) CompensationEntryResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationEntryResponseOutput)
}

// CompensationEntryResponseArrayInput is an input type that accepts CompensationEntryResponseArray and CompensationEntryResponseArrayOutput values.
// You can construct a concrete instance of `CompensationEntryResponseArrayInput` via:
//
//          CompensationEntryResponseArray{ CompensationEntryResponseArgs{...} }
type CompensationEntryResponseArrayInput interface {
	pulumi.Input

	ToCompensationEntryResponseArrayOutput() CompensationEntryResponseArrayOutput
	ToCompensationEntryResponseArrayOutputWithContext(context.Context) CompensationEntryResponseArrayOutput
}

type CompensationEntryResponseArray []CompensationEntryResponseInput

func (CompensationEntryResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CompensationEntryResponse)(nil)).Elem()
}

func (i CompensationEntryResponseArray) ToCompensationEntryResponseArrayOutput() CompensationEntryResponseArrayOutput {
	return i.ToCompensationEntryResponseArrayOutputWithContext(context.Background())
}

func (i CompensationEntryResponseArray) ToCompensationEntryResponseArrayOutputWithContext(ctx context.Context) CompensationEntryResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationEntryResponseArrayOutput)
}

// A compensation entry that represents one component of compensation, such as base pay, bonus, or other compensation type. Annualization: One compensation entry can be annualized if - it contains valid amount or range. - and its expected_units_per_year is set or can be derived. Its annualized range is determined as (amount or range) times expected_units_per_year.
type CompensationEntryResponseOutput struct{ *pulumi.OutputState }

func (CompensationEntryResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationEntryResponse)(nil)).Elem()
}

func (o CompensationEntryResponseOutput) ToCompensationEntryResponseOutput() CompensationEntryResponseOutput {
	return o
}

func (o CompensationEntryResponseOutput) ToCompensationEntryResponseOutputWithContext(ctx context.Context) CompensationEntryResponseOutput {
	return o
}

// Optional. Compensation amount.
func (o CompensationEntryResponseOutput) Amount() MoneyResponseOutput {
	return o.ApplyT(func(v CompensationEntryResponse) MoneyResponse { return v.Amount }).(MoneyResponseOutput)
}

// Optional. Compensation description. For example, could indicate equity terms or provide additional context to an estimated bonus.
func (o CompensationEntryResponseOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v CompensationEntryResponse) string { return v.Description }).(pulumi.StringOutput)
}

// Optional. Expected number of units paid each year. If not specified, when Job.employment_types is FULLTIME, a default value is inferred based on unit. Default values: - HOURLY: 2080 - DAILY: 260 - WEEKLY: 52 - MONTHLY: 12 - ANNUAL: 1
func (o CompensationEntryResponseOutput) ExpectedUnitsPerYear() pulumi.Float64Output {
	return o.ApplyT(func(v CompensationEntryResponse) float64 { return v.ExpectedUnitsPerYear }).(pulumi.Float64Output)
}

// Optional. Compensation range.
func (o CompensationEntryResponseOutput) Range() CompensationRangeResponseOutput {
	return o.ApplyT(func(v CompensationEntryResponse) CompensationRangeResponse { return v.Range }).(CompensationRangeResponseOutput)
}

// Optional. Compensation type. Default is CompensationUnit.COMPENSATION_TYPE_UNSPECIFIED.
func (o CompensationEntryResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v CompensationEntryResponse) string { return v.Type }).(pulumi.StringOutput)
}

// Optional. Frequency of the specified amount. Default is CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED.
func (o CompensationEntryResponseOutput) Unit() pulumi.StringOutput {
	return o.ApplyT(func(v CompensationEntryResponse) string { return v.Unit }).(pulumi.StringOutput)
}

type CompensationEntryResponseArrayOutput struct{ *pulumi.OutputState }

func (CompensationEntryResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CompensationEntryResponse)(nil)).Elem()
}

func (o CompensationEntryResponseArrayOutput) ToCompensationEntryResponseArrayOutput() CompensationEntryResponseArrayOutput {
	return o
}

func (o CompensationEntryResponseArrayOutput) ToCompensationEntryResponseArrayOutputWithContext(ctx context.Context) CompensationEntryResponseArrayOutput {
	return o
}

func (o CompensationEntryResponseArrayOutput) Index(i pulumi.IntInput) CompensationEntryResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CompensationEntryResponse {
		return vs[0].([]CompensationEntryResponse)[vs[1].(int)]
	}).(CompensationEntryResponseOutput)
}

// Job compensation details.
type CompensationInfo struct {
	// Annualized base compensation range. Computed as base compensation entry's CompensationEntry.compensation times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
	AnnualizedBaseCompensationRange *CompensationRange `pulumi:"annualizedBaseCompensationRange"`
	// Annualized total compensation range. Computed as all compensation entries' CompensationEntry.compensation times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
	AnnualizedTotalCompensationRange *CompensationRange `pulumi:"annualizedTotalCompensationRange"`
	// Optional. Job compensation information. At most one entry can be of type CompensationInfo.CompensationType.BASE, which is referred as ** base compensation entry ** for the job.
	Entries []CompensationEntry `pulumi:"entries"`
}

// CompensationInfoInput is an input type that accepts CompensationInfoArgs and CompensationInfoOutput values.
// You can construct a concrete instance of `CompensationInfoInput` via:
//
//          CompensationInfoArgs{...}
type CompensationInfoInput interface {
	pulumi.Input

	ToCompensationInfoOutput() CompensationInfoOutput
	ToCompensationInfoOutputWithContext(context.Context) CompensationInfoOutput
}

// Job compensation details.
type CompensationInfoArgs struct {
	// Annualized base compensation range. Computed as base compensation entry's CompensationEntry.compensation times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
	AnnualizedBaseCompensationRange CompensationRangePtrInput `pulumi:"annualizedBaseCompensationRange"`
	// Annualized total compensation range. Computed as all compensation entries' CompensationEntry.compensation times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
	AnnualizedTotalCompensationRange CompensationRangePtrInput `pulumi:"annualizedTotalCompensationRange"`
	// Optional. Job compensation information. At most one entry can be of type CompensationInfo.CompensationType.BASE, which is referred as ** base compensation entry ** for the job.
	Entries CompensationEntryArrayInput `pulumi:"entries"`
}

func (CompensationInfoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationInfo)(nil)).Elem()
}

func (i CompensationInfoArgs) ToCompensationInfoOutput() CompensationInfoOutput {
	return i.ToCompensationInfoOutputWithContext(context.Background())
}

func (i CompensationInfoArgs) ToCompensationInfoOutputWithContext(ctx context.Context) CompensationInfoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationInfoOutput)
}

func (i CompensationInfoArgs) ToCompensationInfoPtrOutput() CompensationInfoPtrOutput {
	return i.ToCompensationInfoPtrOutputWithContext(context.Background())
}

func (i CompensationInfoArgs) ToCompensationInfoPtrOutputWithContext(ctx context.Context) CompensationInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationInfoOutput).ToCompensationInfoPtrOutputWithContext(ctx)
}

// CompensationInfoPtrInput is an input type that accepts CompensationInfoArgs, CompensationInfoPtr and CompensationInfoPtrOutput values.
// You can construct a concrete instance of `CompensationInfoPtrInput` via:
//
//          CompensationInfoArgs{...}
//
//  or:
//
//          nil
type CompensationInfoPtrInput interface {
	pulumi.Input

	ToCompensationInfoPtrOutput() CompensationInfoPtrOutput
	ToCompensationInfoPtrOutputWithContext(context.Context) CompensationInfoPtrOutput
}

type compensationInfoPtrType CompensationInfoArgs

func CompensationInfoPtr(v *CompensationInfoArgs) CompensationInfoPtrInput {
	return (*compensationInfoPtrType)(v)
}

func (*compensationInfoPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CompensationInfo)(nil)).Elem()
}

func (i *compensationInfoPtrType) ToCompensationInfoPtrOutput() CompensationInfoPtrOutput {
	return i.ToCompensationInfoPtrOutputWithContext(context.Background())
}

func (i *compensationInfoPtrType) ToCompensationInfoPtrOutputWithContext(ctx context.Context) CompensationInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationInfoPtrOutput)
}

// Job compensation details.
type CompensationInfoOutput struct{ *pulumi.OutputState }

func (CompensationInfoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationInfo)(nil)).Elem()
}

func (o CompensationInfoOutput) ToCompensationInfoOutput() CompensationInfoOutput {
	return o
}

func (o CompensationInfoOutput) ToCompensationInfoOutputWithContext(ctx context.Context) CompensationInfoOutput {
	return o
}

func (o CompensationInfoOutput) ToCompensationInfoPtrOutput() CompensationInfoPtrOutput {
	return o.ToCompensationInfoPtrOutputWithContext(context.Background())
}

func (o CompensationInfoOutput) ToCompensationInfoPtrOutputWithContext(ctx context.Context) CompensationInfoPtrOutput {
	return o.ApplyT(func(v CompensationInfo) *CompensationInfo {
		return &v
	}).(CompensationInfoPtrOutput)
}

// Annualized base compensation range. Computed as base compensation entry's CompensationEntry.compensation times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
func (o CompensationInfoOutput) AnnualizedBaseCompensationRange() CompensationRangePtrOutput {
	return o.ApplyT(func(v CompensationInfo) *CompensationRange { return v.AnnualizedBaseCompensationRange }).(CompensationRangePtrOutput)
}

// Annualized total compensation range. Computed as all compensation entries' CompensationEntry.compensation times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
func (o CompensationInfoOutput) AnnualizedTotalCompensationRange() CompensationRangePtrOutput {
	return o.ApplyT(func(v CompensationInfo) *CompensationRange { return v.AnnualizedTotalCompensationRange }).(CompensationRangePtrOutput)
}

// Optional. Job compensation information. At most one entry can be of type CompensationInfo.CompensationType.BASE, which is referred as ** base compensation entry ** for the job.
func (o CompensationInfoOutput) Entries() CompensationEntryArrayOutput {
	return o.ApplyT(func(v CompensationInfo) []CompensationEntry { return v.Entries }).(CompensationEntryArrayOutput)
}

type CompensationInfoPtrOutput struct{ *pulumi.OutputState }

func (CompensationInfoPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CompensationInfo)(nil)).Elem()
}

func (o CompensationInfoPtrOutput) ToCompensationInfoPtrOutput() CompensationInfoPtrOutput {
	return o
}

func (o CompensationInfoPtrOutput) ToCompensationInfoPtrOutputWithContext(ctx context.Context) CompensationInfoPtrOutput {
	return o
}

func (o CompensationInfoPtrOutput) Elem() CompensationInfoOutput {
	return o.ApplyT(func(v *CompensationInfo) CompensationInfo { return *v }).(CompensationInfoOutput)
}

// Annualized base compensation range. Computed as base compensation entry's CompensationEntry.compensation times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
func (o CompensationInfoPtrOutput) AnnualizedBaseCompensationRange() CompensationRangePtrOutput {
	return o.ApplyT(func(v *CompensationInfo) *CompensationRange {
		if v == nil {
			return nil
		}
		return v.AnnualizedBaseCompensationRange
	}).(CompensationRangePtrOutput)
}

// Annualized total compensation range. Computed as all compensation entries' CompensationEntry.compensation times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
func (o CompensationInfoPtrOutput) AnnualizedTotalCompensationRange() CompensationRangePtrOutput {
	return o.ApplyT(func(v *CompensationInfo) *CompensationRange {
		if v == nil {
			return nil
		}
		return v.AnnualizedTotalCompensationRange
	}).(CompensationRangePtrOutput)
}

// Optional. Job compensation information. At most one entry can be of type CompensationInfo.CompensationType.BASE, which is referred as ** base compensation entry ** for the job.
func (o CompensationInfoPtrOutput) Entries() CompensationEntryArrayOutput {
	return o.ApplyT(func(v *CompensationInfo) []CompensationEntry {
		if v == nil {
			return nil
		}
		return v.Entries
	}).(CompensationEntryArrayOutput)
}

// Job compensation details.
type CompensationInfoResponse struct {
	// Annualized base compensation range. Computed as base compensation entry's CompensationEntry.compensation times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
	AnnualizedBaseCompensationRange CompensationRangeResponse `pulumi:"annualizedBaseCompensationRange"`
	// Annualized total compensation range. Computed as all compensation entries' CompensationEntry.compensation times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
	AnnualizedTotalCompensationRange CompensationRangeResponse `pulumi:"annualizedTotalCompensationRange"`
	// Optional. Job compensation information. At most one entry can be of type CompensationInfo.CompensationType.BASE, which is referred as ** base compensation entry ** for the job.
	Entries []CompensationEntryResponse `pulumi:"entries"`
}

// CompensationInfoResponseInput is an input type that accepts CompensationInfoResponseArgs and CompensationInfoResponseOutput values.
// You can construct a concrete instance of `CompensationInfoResponseInput` via:
//
//          CompensationInfoResponseArgs{...}
type CompensationInfoResponseInput interface {
	pulumi.Input

	ToCompensationInfoResponseOutput() CompensationInfoResponseOutput
	ToCompensationInfoResponseOutputWithContext(context.Context) CompensationInfoResponseOutput
}

// Job compensation details.
type CompensationInfoResponseArgs struct {
	// Annualized base compensation range. Computed as base compensation entry's CompensationEntry.compensation times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
	AnnualizedBaseCompensationRange CompensationRangeResponseInput `pulumi:"annualizedBaseCompensationRange"`
	// Annualized total compensation range. Computed as all compensation entries' CompensationEntry.compensation times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
	AnnualizedTotalCompensationRange CompensationRangeResponseInput `pulumi:"annualizedTotalCompensationRange"`
	// Optional. Job compensation information. At most one entry can be of type CompensationInfo.CompensationType.BASE, which is referred as ** base compensation entry ** for the job.
	Entries CompensationEntryResponseArrayInput `pulumi:"entries"`
}

func (CompensationInfoResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationInfoResponse)(nil)).Elem()
}

func (i CompensationInfoResponseArgs) ToCompensationInfoResponseOutput() CompensationInfoResponseOutput {
	return i.ToCompensationInfoResponseOutputWithContext(context.Background())
}

func (i CompensationInfoResponseArgs) ToCompensationInfoResponseOutputWithContext(ctx context.Context) CompensationInfoResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationInfoResponseOutput)
}

func (i CompensationInfoResponseArgs) ToCompensationInfoResponsePtrOutput() CompensationInfoResponsePtrOutput {
	return i.ToCompensationInfoResponsePtrOutputWithContext(context.Background())
}

func (i CompensationInfoResponseArgs) ToCompensationInfoResponsePtrOutputWithContext(ctx context.Context) CompensationInfoResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationInfoResponseOutput).ToCompensationInfoResponsePtrOutputWithContext(ctx)
}

// CompensationInfoResponsePtrInput is an input type that accepts CompensationInfoResponseArgs, CompensationInfoResponsePtr and CompensationInfoResponsePtrOutput values.
// You can construct a concrete instance of `CompensationInfoResponsePtrInput` via:
//
//          CompensationInfoResponseArgs{...}
//
//  or:
//
//          nil
type CompensationInfoResponsePtrInput interface {
	pulumi.Input

	ToCompensationInfoResponsePtrOutput() CompensationInfoResponsePtrOutput
	ToCompensationInfoResponsePtrOutputWithContext(context.Context) CompensationInfoResponsePtrOutput
}

type compensationInfoResponsePtrType CompensationInfoResponseArgs

func CompensationInfoResponsePtr(v *CompensationInfoResponseArgs) CompensationInfoResponsePtrInput {
	return (*compensationInfoResponsePtrType)(v)
}

func (*compensationInfoResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CompensationInfoResponse)(nil)).Elem()
}

func (i *compensationInfoResponsePtrType) ToCompensationInfoResponsePtrOutput() CompensationInfoResponsePtrOutput {
	return i.ToCompensationInfoResponsePtrOutputWithContext(context.Background())
}

func (i *compensationInfoResponsePtrType) ToCompensationInfoResponsePtrOutputWithContext(ctx context.Context) CompensationInfoResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationInfoResponsePtrOutput)
}

// Job compensation details.
type CompensationInfoResponseOutput struct{ *pulumi.OutputState }

func (CompensationInfoResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationInfoResponse)(nil)).Elem()
}

func (o CompensationInfoResponseOutput) ToCompensationInfoResponseOutput() CompensationInfoResponseOutput {
	return o
}

func (o CompensationInfoResponseOutput) ToCompensationInfoResponseOutputWithContext(ctx context.Context) CompensationInfoResponseOutput {
	return o
}

func (o CompensationInfoResponseOutput) ToCompensationInfoResponsePtrOutput() CompensationInfoResponsePtrOutput {
	return o.ToCompensationInfoResponsePtrOutputWithContext(context.Background())
}

func (o CompensationInfoResponseOutput) ToCompensationInfoResponsePtrOutputWithContext(ctx context.Context) CompensationInfoResponsePtrOutput {
	return o.ApplyT(func(v CompensationInfoResponse) *CompensationInfoResponse {
		return &v
	}).(CompensationInfoResponsePtrOutput)
}

// Annualized base compensation range. Computed as base compensation entry's CompensationEntry.compensation times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
func (o CompensationInfoResponseOutput) AnnualizedBaseCompensationRange() CompensationRangeResponseOutput {
	return o.ApplyT(func(v CompensationInfoResponse) CompensationRangeResponse { return v.AnnualizedBaseCompensationRange }).(CompensationRangeResponseOutput)
}

// Annualized total compensation range. Computed as all compensation entries' CompensationEntry.compensation times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
func (o CompensationInfoResponseOutput) AnnualizedTotalCompensationRange() CompensationRangeResponseOutput {
	return o.ApplyT(func(v CompensationInfoResponse) CompensationRangeResponse { return v.AnnualizedTotalCompensationRange }).(CompensationRangeResponseOutput)
}

// Optional. Job compensation information. At most one entry can be of type CompensationInfo.CompensationType.BASE, which is referred as ** base compensation entry ** for the job.
func (o CompensationInfoResponseOutput) Entries() CompensationEntryResponseArrayOutput {
	return o.ApplyT(func(v CompensationInfoResponse) []CompensationEntryResponse { return v.Entries }).(CompensationEntryResponseArrayOutput)
}

type CompensationInfoResponsePtrOutput struct{ *pulumi.OutputState }

func (CompensationInfoResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CompensationInfoResponse)(nil)).Elem()
}

func (o CompensationInfoResponsePtrOutput) ToCompensationInfoResponsePtrOutput() CompensationInfoResponsePtrOutput {
	return o
}

func (o CompensationInfoResponsePtrOutput) ToCompensationInfoResponsePtrOutputWithContext(ctx context.Context) CompensationInfoResponsePtrOutput {
	return o
}

func (o CompensationInfoResponsePtrOutput) Elem() CompensationInfoResponseOutput {
	return o.ApplyT(func(v *CompensationInfoResponse) CompensationInfoResponse { return *v }).(CompensationInfoResponseOutput)
}

// Annualized base compensation range. Computed as base compensation entry's CompensationEntry.compensation times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
func (o CompensationInfoResponsePtrOutput) AnnualizedBaseCompensationRange() CompensationRangeResponsePtrOutput {
	return o.ApplyT(func(v *CompensationInfoResponse) *CompensationRangeResponse {
		if v == nil {
			return nil
		}
		return &v.AnnualizedBaseCompensationRange
	}).(CompensationRangeResponsePtrOutput)
}

// Annualized total compensation range. Computed as all compensation entries' CompensationEntry.compensation times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
func (o CompensationInfoResponsePtrOutput) AnnualizedTotalCompensationRange() CompensationRangeResponsePtrOutput {
	return o.ApplyT(func(v *CompensationInfoResponse) *CompensationRangeResponse {
		if v == nil {
			return nil
		}
		return &v.AnnualizedTotalCompensationRange
	}).(CompensationRangeResponsePtrOutput)
}

// Optional. Job compensation information. At most one entry can be of type CompensationInfo.CompensationType.BASE, which is referred as ** base compensation entry ** for the job.
func (o CompensationInfoResponsePtrOutput) Entries() CompensationEntryResponseArrayOutput {
	return o.ApplyT(func(v *CompensationInfoResponse) []CompensationEntryResponse {
		if v == nil {
			return nil
		}
		return v.Entries
	}).(CompensationEntryResponseArrayOutput)
}

// Compensation range.
type CompensationRange struct {
	// Optional. The maximum amount of compensation. If left empty, the value is set to a maximal compensation value and the currency code is set to match the currency code of min_compensation.
	MaxCompensation *Money `pulumi:"maxCompensation"`
	// Optional. The minimum amount of compensation. If left empty, the value is set to zero and the currency code is set to match the currency code of max_compensation.
	MinCompensation *Money `pulumi:"minCompensation"`
}

// CompensationRangeInput is an input type that accepts CompensationRangeArgs and CompensationRangeOutput values.
// You can construct a concrete instance of `CompensationRangeInput` via:
//
//          CompensationRangeArgs{...}
type CompensationRangeInput interface {
	pulumi.Input

	ToCompensationRangeOutput() CompensationRangeOutput
	ToCompensationRangeOutputWithContext(context.Context) CompensationRangeOutput
}

// Compensation range.
type CompensationRangeArgs struct {
	// Optional. The maximum amount of compensation. If left empty, the value is set to a maximal compensation value and the currency code is set to match the currency code of min_compensation.
	MaxCompensation MoneyPtrInput `pulumi:"maxCompensation"`
	// Optional. The minimum amount of compensation. If left empty, the value is set to zero and the currency code is set to match the currency code of max_compensation.
	MinCompensation MoneyPtrInput `pulumi:"minCompensation"`
}

func (CompensationRangeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationRange)(nil)).Elem()
}

func (i CompensationRangeArgs) ToCompensationRangeOutput() CompensationRangeOutput {
	return i.ToCompensationRangeOutputWithContext(context.Background())
}

func (i CompensationRangeArgs) ToCompensationRangeOutputWithContext(ctx context.Context) CompensationRangeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationRangeOutput)
}

func (i CompensationRangeArgs) ToCompensationRangePtrOutput() CompensationRangePtrOutput {
	return i.ToCompensationRangePtrOutputWithContext(context.Background())
}

func (i CompensationRangeArgs) ToCompensationRangePtrOutputWithContext(ctx context.Context) CompensationRangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationRangeOutput).ToCompensationRangePtrOutputWithContext(ctx)
}

// CompensationRangePtrInput is an input type that accepts CompensationRangeArgs, CompensationRangePtr and CompensationRangePtrOutput values.
// You can construct a concrete instance of `CompensationRangePtrInput` via:
//
//          CompensationRangeArgs{...}
//
//  or:
//
//          nil
type CompensationRangePtrInput interface {
	pulumi.Input

	ToCompensationRangePtrOutput() CompensationRangePtrOutput
	ToCompensationRangePtrOutputWithContext(context.Context) CompensationRangePtrOutput
}

type compensationRangePtrType CompensationRangeArgs

func CompensationRangePtr(v *CompensationRangeArgs) CompensationRangePtrInput {
	return (*compensationRangePtrType)(v)
}

func (*compensationRangePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CompensationRange)(nil)).Elem()
}

func (i *compensationRangePtrType) ToCompensationRangePtrOutput() CompensationRangePtrOutput {
	return i.ToCompensationRangePtrOutputWithContext(context.Background())
}

func (i *compensationRangePtrType) ToCompensationRangePtrOutputWithContext(ctx context.Context) CompensationRangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationRangePtrOutput)
}

// Compensation range.
type CompensationRangeOutput struct{ *pulumi.OutputState }

func (CompensationRangeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationRange)(nil)).Elem()
}

func (o CompensationRangeOutput) ToCompensationRangeOutput() CompensationRangeOutput {
	return o
}

func (o CompensationRangeOutput) ToCompensationRangeOutputWithContext(ctx context.Context) CompensationRangeOutput {
	return o
}

func (o CompensationRangeOutput) ToCompensationRangePtrOutput() CompensationRangePtrOutput {
	return o.ToCompensationRangePtrOutputWithContext(context.Background())
}

func (o CompensationRangeOutput) ToCompensationRangePtrOutputWithContext(ctx context.Context) CompensationRangePtrOutput {
	return o.ApplyT(func(v CompensationRange) *CompensationRange {
		return &v
	}).(CompensationRangePtrOutput)
}

// Optional. The maximum amount of compensation. If left empty, the value is set to a maximal compensation value and the currency code is set to match the currency code of min_compensation.
func (o CompensationRangeOutput) MaxCompensation() MoneyPtrOutput {
	return o.ApplyT(func(v CompensationRange) *Money { return v.MaxCompensation }).(MoneyPtrOutput)
}

// Optional. The minimum amount of compensation. If left empty, the value is set to zero and the currency code is set to match the currency code of max_compensation.
func (o CompensationRangeOutput) MinCompensation() MoneyPtrOutput {
	return o.ApplyT(func(v CompensationRange) *Money { return v.MinCompensation }).(MoneyPtrOutput)
}

type CompensationRangePtrOutput struct{ *pulumi.OutputState }

func (CompensationRangePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CompensationRange)(nil)).Elem()
}

func (o CompensationRangePtrOutput) ToCompensationRangePtrOutput() CompensationRangePtrOutput {
	return o
}

func (o CompensationRangePtrOutput) ToCompensationRangePtrOutputWithContext(ctx context.Context) CompensationRangePtrOutput {
	return o
}

func (o CompensationRangePtrOutput) Elem() CompensationRangeOutput {
	return o.ApplyT(func(v *CompensationRange) CompensationRange { return *v }).(CompensationRangeOutput)
}

// Optional. The maximum amount of compensation. If left empty, the value is set to a maximal compensation value and the currency code is set to match the currency code of min_compensation.
func (o CompensationRangePtrOutput) MaxCompensation() MoneyPtrOutput {
	return o.ApplyT(func(v *CompensationRange) *Money {
		if v == nil {
			return nil
		}
		return v.MaxCompensation
	}).(MoneyPtrOutput)
}

// Optional. The minimum amount of compensation. If left empty, the value is set to zero and the currency code is set to match the currency code of max_compensation.
func (o CompensationRangePtrOutput) MinCompensation() MoneyPtrOutput {
	return o.ApplyT(func(v *CompensationRange) *Money {
		if v == nil {
			return nil
		}
		return v.MinCompensation
	}).(MoneyPtrOutput)
}

// Compensation range.
type CompensationRangeResponse struct {
	// Optional. The maximum amount of compensation. If left empty, the value is set to a maximal compensation value and the currency code is set to match the currency code of min_compensation.
	MaxCompensation MoneyResponse `pulumi:"maxCompensation"`
	// Optional. The minimum amount of compensation. If left empty, the value is set to zero and the currency code is set to match the currency code of max_compensation.
	MinCompensation MoneyResponse `pulumi:"minCompensation"`
}

// CompensationRangeResponseInput is an input type that accepts CompensationRangeResponseArgs and CompensationRangeResponseOutput values.
// You can construct a concrete instance of `CompensationRangeResponseInput` via:
//
//          CompensationRangeResponseArgs{...}
type CompensationRangeResponseInput interface {
	pulumi.Input

	ToCompensationRangeResponseOutput() CompensationRangeResponseOutput
	ToCompensationRangeResponseOutputWithContext(context.Context) CompensationRangeResponseOutput
}

// Compensation range.
type CompensationRangeResponseArgs struct {
	// Optional. The maximum amount of compensation. If left empty, the value is set to a maximal compensation value and the currency code is set to match the currency code of min_compensation.
	MaxCompensation MoneyResponseInput `pulumi:"maxCompensation"`
	// Optional. The minimum amount of compensation. If left empty, the value is set to zero and the currency code is set to match the currency code of max_compensation.
	MinCompensation MoneyResponseInput `pulumi:"minCompensation"`
}

func (CompensationRangeResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationRangeResponse)(nil)).Elem()
}

func (i CompensationRangeResponseArgs) ToCompensationRangeResponseOutput() CompensationRangeResponseOutput {
	return i.ToCompensationRangeResponseOutputWithContext(context.Background())
}

func (i CompensationRangeResponseArgs) ToCompensationRangeResponseOutputWithContext(ctx context.Context) CompensationRangeResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationRangeResponseOutput)
}

func (i CompensationRangeResponseArgs) ToCompensationRangeResponsePtrOutput() CompensationRangeResponsePtrOutput {
	return i.ToCompensationRangeResponsePtrOutputWithContext(context.Background())
}

func (i CompensationRangeResponseArgs) ToCompensationRangeResponsePtrOutputWithContext(ctx context.Context) CompensationRangeResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationRangeResponseOutput).ToCompensationRangeResponsePtrOutputWithContext(ctx)
}

// CompensationRangeResponsePtrInput is an input type that accepts CompensationRangeResponseArgs, CompensationRangeResponsePtr and CompensationRangeResponsePtrOutput values.
// You can construct a concrete instance of `CompensationRangeResponsePtrInput` via:
//
//          CompensationRangeResponseArgs{...}
//
//  or:
//
//          nil
type CompensationRangeResponsePtrInput interface {
	pulumi.Input

	ToCompensationRangeResponsePtrOutput() CompensationRangeResponsePtrOutput
	ToCompensationRangeResponsePtrOutputWithContext(context.Context) CompensationRangeResponsePtrOutput
}

type compensationRangeResponsePtrType CompensationRangeResponseArgs

func CompensationRangeResponsePtr(v *CompensationRangeResponseArgs) CompensationRangeResponsePtrInput {
	return (*compensationRangeResponsePtrType)(v)
}

func (*compensationRangeResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CompensationRangeResponse)(nil)).Elem()
}

func (i *compensationRangeResponsePtrType) ToCompensationRangeResponsePtrOutput() CompensationRangeResponsePtrOutput {
	return i.ToCompensationRangeResponsePtrOutputWithContext(context.Background())
}

func (i *compensationRangeResponsePtrType) ToCompensationRangeResponsePtrOutputWithContext(ctx context.Context) CompensationRangeResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationRangeResponsePtrOutput)
}

// Compensation range.
type CompensationRangeResponseOutput struct{ *pulumi.OutputState }

func (CompensationRangeResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationRangeResponse)(nil)).Elem()
}

func (o CompensationRangeResponseOutput) ToCompensationRangeResponseOutput() CompensationRangeResponseOutput {
	return o
}

func (o CompensationRangeResponseOutput) ToCompensationRangeResponseOutputWithContext(ctx context.Context) CompensationRangeResponseOutput {
	return o
}

func (o CompensationRangeResponseOutput) ToCompensationRangeResponsePtrOutput() CompensationRangeResponsePtrOutput {
	return o.ToCompensationRangeResponsePtrOutputWithContext(context.Background())
}

func (o CompensationRangeResponseOutput) ToCompensationRangeResponsePtrOutputWithContext(ctx context.Context) CompensationRangeResponsePtrOutput {
	return o.ApplyT(func(v CompensationRangeResponse) *CompensationRangeResponse {
		return &v
	}).(CompensationRangeResponsePtrOutput)
}

// Optional. The maximum amount of compensation. If left empty, the value is set to a maximal compensation value and the currency code is set to match the currency code of min_compensation.
func (o CompensationRangeResponseOutput) MaxCompensation() MoneyResponseOutput {
	return o.ApplyT(func(v CompensationRangeResponse) MoneyResponse { return v.MaxCompensation }).(MoneyResponseOutput)
}

// Optional. The minimum amount of compensation. If left empty, the value is set to zero and the currency code is set to match the currency code of max_compensation.
func (o CompensationRangeResponseOutput) MinCompensation() MoneyResponseOutput {
	return o.ApplyT(func(v CompensationRangeResponse) MoneyResponse { return v.MinCompensation }).(MoneyResponseOutput)
}

type CompensationRangeResponsePtrOutput struct{ *pulumi.OutputState }

func (CompensationRangeResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CompensationRangeResponse)(nil)).Elem()
}

func (o CompensationRangeResponsePtrOutput) ToCompensationRangeResponsePtrOutput() CompensationRangeResponsePtrOutput {
	return o
}

func (o CompensationRangeResponsePtrOutput) ToCompensationRangeResponsePtrOutputWithContext(ctx context.Context) CompensationRangeResponsePtrOutput {
	return o
}

func (o CompensationRangeResponsePtrOutput) Elem() CompensationRangeResponseOutput {
	return o.ApplyT(func(v *CompensationRangeResponse) CompensationRangeResponse { return *v }).(CompensationRangeResponseOutput)
}

// Optional. The maximum amount of compensation. If left empty, the value is set to a maximal compensation value and the currency code is set to match the currency code of min_compensation.
func (o CompensationRangeResponsePtrOutput) MaxCompensation() MoneyResponsePtrOutput {
	return o.ApplyT(func(v *CompensationRangeResponse) *MoneyResponse {
		if v == nil {
			return nil
		}
		return &v.MaxCompensation
	}).(MoneyResponsePtrOutput)
}

// Optional. The minimum amount of compensation. If left empty, the value is set to zero and the currency code is set to match the currency code of max_compensation.
func (o CompensationRangeResponsePtrOutput) MinCompensation() MoneyResponsePtrOutput {
	return o.ApplyT(func(v *CompensationRangeResponse) *MoneyResponse {
		if v == nil {
			return nil
		}
		return &v.MinCompensation
	}).(MoneyResponsePtrOutput)
}

// A Job resource represents a job posting (also referred to as a "job listing" or "job requisition"). A job belongs to a Company, which is the hiring entity responsible for the job.
type JobType struct {
	// Optional but strongly recommended for the best service experience. Location(s) where the employer is looking to hire for this job posting. Specifying the full street address(es) of the hiring location enables better API results, especially job searches by commute time. At most 50 locations are allowed for best search performance. If a job has more locations, it is suggested to split it into multiple jobs with unique requisition_ids (e.g. 'ReqA' becomes 'ReqA-1', 'ReqA-2', etc.) as multiple jobs with the same company_name, language_code and requisition_id are not allowed. If the original requisition_id must be preserved, a custom field should be used for storage. It is also suggested to group the locations that close to each other in the same job for better search experience. The maximum number of allowed characters is 500.
	Addresses []string `pulumi:"addresses"`
	// Required. At least one field within ApplicationInfo must be specified. Job application information.
	ApplicationInfo *ApplicationInfo `pulumi:"applicationInfo"`
	// Display name of the company listing the job.
	CompanyDisplayName *string `pulumi:"companyDisplayName"`
	// Required. The resource name of the company listing the job, such as "projects/api-test-project/companies/foo".
	CompanyName *string `pulumi:"companyName"`
	// Optional. Job compensation information.
	CompensationInfo *CompensationInfo `pulumi:"compensationInfo"`
	// Optional. A map of fields to hold both filterable and non-filterable custom job attributes that are not covered by the provided structured fields. The keys of the map are strings up to 64 bytes and must match the pattern: a-zA-Z*. For example, key0LikeThis or KEY_1_LIKE_THIS. At most 100 filterable and at most 100 unfilterable keys are supported. For filterable `string_values`, across all keys at most 200 values are allowed, with each string no more than 255 characters. For unfilterable `string_values`, the maximum total size of `string_values` across all keys is 50KB.
	CustomAttributes map[string]string `pulumi:"customAttributes"`
	// Optional. The desired education degrees for the job, such as Bachelors, Masters.
	DegreeTypes []string `pulumi:"degreeTypes"`
	// Optional. The department or functional area within the company with the open position. The maximum number of allowed characters is 255.
	Department *string `pulumi:"department"`
	// Derived details about the job posting.
	DerivedInfo *JobDerivedInfo `pulumi:"derivedInfo"`
	// Required. The description of the job, which typically includes a multi-paragraph description of the company and related information. Separate fields are provided on the job object for responsibilities, qualifications, and other job characteristics. Use of these separate job fields is recommended. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 100,000.
	Description *string `pulumi:"description"`
	// Optional. The employment type(s) of a job, for example, full time or part time.
	EmploymentTypes []string `pulumi:"employmentTypes"`
	// Optional. A description of bonus, commission, and other compensation incentives associated with the job not including salary or pay. The maximum number of allowed characters is 10,000.
	Incentives *string `pulumi:"incentives"`
	// Optional. The benefits included with the job.
	JobBenefits []string `pulumi:"jobBenefits"`
	// Optional. The end timestamp of the job. Typically this field is used for contracting engagements. Invalid timestamps are ignored.
	JobEndTime *string `pulumi:"jobEndTime"`
	// Optional. The experience level associated with the job, such as "Entry Level".
	JobLevel *string `pulumi:"jobLevel"`
	// Optional. The start timestamp of the job in UTC time zone. Typically this field is used for contracting engagements. Invalid timestamps are ignored.
	JobStartTime *string `pulumi:"jobStartTime"`
	// Optional. The language of the posting. This field is distinct from any requirements for fluency that are associated with the job. Language codes must be in BCP-47 format, such as "en-US" or "sr-Latn". For more information, see [Tags for Identifying Languages](https://tools.ietf.org/html/bcp47){: class="external" target="_blank" }. If this field is unspecified and Job.description is present, detected language code based on Job.description is assigned, otherwise defaults to 'en_US'.
	LanguageCode *string `pulumi:"languageCode"`
	// Required during job update. The resource name for the job. This is generated by the service when a job is created. The format is "projects/{project_id}/jobs/{job_id}", for example, "projects/api-test-project/jobs/1234". Use of this field in job queries and API calls is preferred over the use of requisition_id since this value is unique.
	Name *string `pulumi:"name"`
	// The timestamp when this job posting was created.
	PostingCreateTime *string `pulumi:"postingCreateTime"`
	// Optional but strongly recommended for the best service experience. The expiration timestamp of the job. After this timestamp, the job is marked as expired, and it no longer appears in search results. The expired job can't be deleted or listed by the DeleteJob and ListJobs APIs, but it can be retrieved with the GetJob API or updated with the UpdateJob API. An expired job can be updated and opened again by using a future expiration timestamp. Updating an expired job fails if there is another existing open job with same company_name, language_code and requisition_id. The expired jobs are retained in our system for 90 days. However, the overall expired job count cannot exceed 3 times the maximum of open jobs count over the past week, otherwise jobs with earlier expire time are cleaned first. Expired jobs are no longer accessible after they are cleaned out. Invalid timestamps are ignored, and treated as expire time not provided. Timestamp before the instant request is made is considered valid, the job will be treated as expired immediately. If this value is not provided at the time of job creation or is invalid, the job posting expires after 30 days from the job's creation time. For example, if the job was created on 2017/01/01 13:00AM UTC with an unspecified expiration date, the job expires after 2017/01/31 13:00AM UTC. If this value is not provided on job update, it depends on the field masks set by UpdateJobRequest.update_mask. If the field masks include expiry_time, or the masks are empty meaning that every field is updated, the job posting expires after 30 days from the job's last update time. Otherwise the expiration date isn't updated.
	PostingExpireTime *string `pulumi:"postingExpireTime"`
	// Optional. The timestamp this job posting was most recently published. The default value is the time the request arrives at the server. Invalid timestamps are ignored.
	PostingPublishTime *string `pulumi:"postingPublishTime"`
	// Optional. The job PostingRegion (for example, state, country) throughout which the job is available. If this field is set, a LocationFilter in a search query within the job region finds this job posting if an exact location match isn't specified. If this field is set to PostingRegion.NATION or PostingRegion.ADMINISTRATIVE_AREA, setting job Job.addresses to the same location level as this field is strongly recommended.
	PostingRegion *string `pulumi:"postingRegion"`
	// The timestamp when this job posting was last updated.
	PostingUpdateTime *string `pulumi:"postingUpdateTime"`
	// Optional. Options for job processing.
	ProcessingOptions *ProcessingOptions `pulumi:"processingOptions"`
	// Optional. A promotion value of the job, as determined by the client. The value determines the sort order of the jobs returned when searching for jobs using the featured jobs search call, with higher promotional values being returned first and ties being resolved by relevance sort. Only the jobs with a promotionValue >0 are returned in a FEATURED_JOB_SEARCH. Default value is 0, and negative values are treated as 0.
	PromotionValue *int `pulumi:"promotionValue"`
	// Optional. A description of the qualifications required to perform the job. The use of this field is recommended as an alternative to using the more general description field. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 10,000.
	Qualifications *string `pulumi:"qualifications"`
	// Required. The requisition ID, also referred to as the posting ID, assigned by the client to identify a job. This field is intended to be used by clients for client identification and tracking of postings. A job is not allowed to be created if there is another job with the same [company_name], language_code and requisition_id. The maximum number of allowed characters is 255.
	RequisitionId *string `pulumi:"requisitionId"`
	// Optional. A description of job responsibilities. The use of this field is recommended as an alternative to using the more general description field. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 10,000.
	Responsibilities *string `pulumi:"responsibilities"`
	// Required. The title of the job, such as "Software Engineer" The maximum number of allowed characters is 500.
	Title *string `pulumi:"title"`
}

// JobTypeInput is an input type that accepts JobTypeArgs and JobTypeOutput values.
// You can construct a concrete instance of `JobTypeInput` via:
//
//          JobTypeArgs{...}
type JobTypeInput interface {
	pulumi.Input

	ToJobTypeOutput() JobTypeOutput
	ToJobTypeOutputWithContext(context.Context) JobTypeOutput
}

// A Job resource represents a job posting (also referred to as a "job listing" or "job requisition"). A job belongs to a Company, which is the hiring entity responsible for the job.
type JobTypeArgs struct {
	// Optional but strongly recommended for the best service experience. Location(s) where the employer is looking to hire for this job posting. Specifying the full street address(es) of the hiring location enables better API results, especially job searches by commute time. At most 50 locations are allowed for best search performance. If a job has more locations, it is suggested to split it into multiple jobs with unique requisition_ids (e.g. 'ReqA' becomes 'ReqA-1', 'ReqA-2', etc.) as multiple jobs with the same company_name, language_code and requisition_id are not allowed. If the original requisition_id must be preserved, a custom field should be used for storage. It is also suggested to group the locations that close to each other in the same job for better search experience. The maximum number of allowed characters is 500.
	Addresses pulumi.StringArrayInput `pulumi:"addresses"`
	// Required. At least one field within ApplicationInfo must be specified. Job application information.
	ApplicationInfo ApplicationInfoPtrInput `pulumi:"applicationInfo"`
	// Display name of the company listing the job.
	CompanyDisplayName pulumi.StringPtrInput `pulumi:"companyDisplayName"`
	// Required. The resource name of the company listing the job, such as "projects/api-test-project/companies/foo".
	CompanyName pulumi.StringPtrInput `pulumi:"companyName"`
	// Optional. Job compensation information.
	CompensationInfo CompensationInfoPtrInput `pulumi:"compensationInfo"`
	// Optional. A map of fields to hold both filterable and non-filterable custom job attributes that are not covered by the provided structured fields. The keys of the map are strings up to 64 bytes and must match the pattern: a-zA-Z*. For example, key0LikeThis or KEY_1_LIKE_THIS. At most 100 filterable and at most 100 unfilterable keys are supported. For filterable `string_values`, across all keys at most 200 values are allowed, with each string no more than 255 characters. For unfilterable `string_values`, the maximum total size of `string_values` across all keys is 50KB.
	CustomAttributes pulumi.StringMapInput `pulumi:"customAttributes"`
	// Optional. The desired education degrees for the job, such as Bachelors, Masters.
	DegreeTypes pulumi.StringArrayInput `pulumi:"degreeTypes"`
	// Optional. The department or functional area within the company with the open position. The maximum number of allowed characters is 255.
	Department pulumi.StringPtrInput `pulumi:"department"`
	// Derived details about the job posting.
	DerivedInfo JobDerivedInfoPtrInput `pulumi:"derivedInfo"`
	// Required. The description of the job, which typically includes a multi-paragraph description of the company and related information. Separate fields are provided on the job object for responsibilities, qualifications, and other job characteristics. Use of these separate job fields is recommended. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 100,000.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Optional. The employment type(s) of a job, for example, full time or part time.
	EmploymentTypes pulumi.StringArrayInput `pulumi:"employmentTypes"`
	// Optional. A description of bonus, commission, and other compensation incentives associated with the job not including salary or pay. The maximum number of allowed characters is 10,000.
	Incentives pulumi.StringPtrInput `pulumi:"incentives"`
	// Optional. The benefits included with the job.
	JobBenefits pulumi.StringArrayInput `pulumi:"jobBenefits"`
	// Optional. The end timestamp of the job. Typically this field is used for contracting engagements. Invalid timestamps are ignored.
	JobEndTime pulumi.StringPtrInput `pulumi:"jobEndTime"`
	// Optional. The experience level associated with the job, such as "Entry Level".
	JobLevel pulumi.StringPtrInput `pulumi:"jobLevel"`
	// Optional. The start timestamp of the job in UTC time zone. Typically this field is used for contracting engagements. Invalid timestamps are ignored.
	JobStartTime pulumi.StringPtrInput `pulumi:"jobStartTime"`
	// Optional. The language of the posting. This field is distinct from any requirements for fluency that are associated with the job. Language codes must be in BCP-47 format, such as "en-US" or "sr-Latn". For more information, see [Tags for Identifying Languages](https://tools.ietf.org/html/bcp47){: class="external" target="_blank" }. If this field is unspecified and Job.description is present, detected language code based on Job.description is assigned, otherwise defaults to 'en_US'.
	LanguageCode pulumi.StringPtrInput `pulumi:"languageCode"`
	// Required during job update. The resource name for the job. This is generated by the service when a job is created. The format is "projects/{project_id}/jobs/{job_id}", for example, "projects/api-test-project/jobs/1234". Use of this field in job queries and API calls is preferred over the use of requisition_id since this value is unique.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// The timestamp when this job posting was created.
	PostingCreateTime pulumi.StringPtrInput `pulumi:"postingCreateTime"`
	// Optional but strongly recommended for the best service experience. The expiration timestamp of the job. After this timestamp, the job is marked as expired, and it no longer appears in search results. The expired job can't be deleted or listed by the DeleteJob and ListJobs APIs, but it can be retrieved with the GetJob API or updated with the UpdateJob API. An expired job can be updated and opened again by using a future expiration timestamp. Updating an expired job fails if there is another existing open job with same company_name, language_code and requisition_id. The expired jobs are retained in our system for 90 days. However, the overall expired job count cannot exceed 3 times the maximum of open jobs count over the past week, otherwise jobs with earlier expire time are cleaned first. Expired jobs are no longer accessible after they are cleaned out. Invalid timestamps are ignored, and treated as expire time not provided. Timestamp before the instant request is made is considered valid, the job will be treated as expired immediately. If this value is not provided at the time of job creation or is invalid, the job posting expires after 30 days from the job's creation time. For example, if the job was created on 2017/01/01 13:00AM UTC with an unspecified expiration date, the job expires after 2017/01/31 13:00AM UTC. If this value is not provided on job update, it depends on the field masks set by UpdateJobRequest.update_mask. If the field masks include expiry_time, or the masks are empty meaning that every field is updated, the job posting expires after 30 days from the job's last update time. Otherwise the expiration date isn't updated.
	PostingExpireTime pulumi.StringPtrInput `pulumi:"postingExpireTime"`
	// Optional. The timestamp this job posting was most recently published. The default value is the time the request arrives at the server. Invalid timestamps are ignored.
	PostingPublishTime pulumi.StringPtrInput `pulumi:"postingPublishTime"`
	// Optional. The job PostingRegion (for example, state, country) throughout which the job is available. If this field is set, a LocationFilter in a search query within the job region finds this job posting if an exact location match isn't specified. If this field is set to PostingRegion.NATION or PostingRegion.ADMINISTRATIVE_AREA, setting job Job.addresses to the same location level as this field is strongly recommended.
	PostingRegion pulumi.StringPtrInput `pulumi:"postingRegion"`
	// The timestamp when this job posting was last updated.
	PostingUpdateTime pulumi.StringPtrInput `pulumi:"postingUpdateTime"`
	// Optional. Options for job processing.
	ProcessingOptions ProcessingOptionsPtrInput `pulumi:"processingOptions"`
	// Optional. A promotion value of the job, as determined by the client. The value determines the sort order of the jobs returned when searching for jobs using the featured jobs search call, with higher promotional values being returned first and ties being resolved by relevance sort. Only the jobs with a promotionValue >0 are returned in a FEATURED_JOB_SEARCH. Default value is 0, and negative values are treated as 0.
	PromotionValue pulumi.IntPtrInput `pulumi:"promotionValue"`
	// Optional. A description of the qualifications required to perform the job. The use of this field is recommended as an alternative to using the more general description field. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 10,000.
	Qualifications pulumi.StringPtrInput `pulumi:"qualifications"`
	// Required. The requisition ID, also referred to as the posting ID, assigned by the client to identify a job. This field is intended to be used by clients for client identification and tracking of postings. A job is not allowed to be created if there is another job with the same [company_name], language_code and requisition_id. The maximum number of allowed characters is 255.
	RequisitionId pulumi.StringPtrInput `pulumi:"requisitionId"`
	// Optional. A description of job responsibilities. The use of this field is recommended as an alternative to using the more general description field. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 10,000.
	Responsibilities pulumi.StringPtrInput `pulumi:"responsibilities"`
	// Required. The title of the job, such as "Software Engineer" The maximum number of allowed characters is 500.
	Title pulumi.StringPtrInput `pulumi:"title"`
}

func (JobTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*JobType)(nil)).Elem()
}

func (i JobTypeArgs) ToJobTypeOutput() JobTypeOutput {
	return i.ToJobTypeOutputWithContext(context.Background())
}

func (i JobTypeArgs) ToJobTypeOutputWithContext(ctx context.Context) JobTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobTypeOutput)
}

func (i JobTypeArgs) ToJobTypePtrOutput() JobTypePtrOutput {
	return i.ToJobTypePtrOutputWithContext(context.Background())
}

func (i JobTypeArgs) ToJobTypePtrOutputWithContext(ctx context.Context) JobTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobTypeOutput).ToJobTypePtrOutputWithContext(ctx)
}

// JobTypePtrInput is an input type that accepts JobTypeArgs, JobTypePtr and JobTypePtrOutput values.
// You can construct a concrete instance of `JobTypePtrInput` via:
//
//          JobTypeArgs{...}
//
//  or:
//
//          nil
type JobTypePtrInput interface {
	pulumi.Input

	ToJobTypePtrOutput() JobTypePtrOutput
	ToJobTypePtrOutputWithContext(context.Context) JobTypePtrOutput
}

type jobTypePtrType JobTypeArgs

func JobTypePtr(v *JobTypeArgs) JobTypePtrInput {
	return (*jobTypePtrType)(v)
}

func (*jobTypePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**JobType)(nil)).Elem()
}

func (i *jobTypePtrType) ToJobTypePtrOutput() JobTypePtrOutput {
	return i.ToJobTypePtrOutputWithContext(context.Background())
}

func (i *jobTypePtrType) ToJobTypePtrOutputWithContext(ctx context.Context) JobTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobTypePtrOutput)
}

// A Job resource represents a job posting (also referred to as a "job listing" or "job requisition"). A job belongs to a Company, which is the hiring entity responsible for the job.
type JobTypeOutput struct{ *pulumi.OutputState }

func (JobTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobType)(nil)).Elem()
}

func (o JobTypeOutput) ToJobTypeOutput() JobTypeOutput {
	return o
}

func (o JobTypeOutput) ToJobTypeOutputWithContext(ctx context.Context) JobTypeOutput {
	return o
}

func (o JobTypeOutput) ToJobTypePtrOutput() JobTypePtrOutput {
	return o.ToJobTypePtrOutputWithContext(context.Background())
}

func (o JobTypeOutput) ToJobTypePtrOutputWithContext(ctx context.Context) JobTypePtrOutput {
	return o.ApplyT(func(v JobType) *JobType {
		return &v
	}).(JobTypePtrOutput)
}

// Optional but strongly recommended for the best service experience. Location(s) where the employer is looking to hire for this job posting. Specifying the full street address(es) of the hiring location enables better API results, especially job searches by commute time. At most 50 locations are allowed for best search performance. If a job has more locations, it is suggested to split it into multiple jobs with unique requisition_ids (e.g. 'ReqA' becomes 'ReqA-1', 'ReqA-2', etc.) as multiple jobs with the same company_name, language_code and requisition_id are not allowed. If the original requisition_id must be preserved, a custom field should be used for storage. It is also suggested to group the locations that close to each other in the same job for better search experience. The maximum number of allowed characters is 500.
func (o JobTypeOutput) Addresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v JobType) []string { return v.Addresses }).(pulumi.StringArrayOutput)
}

// Required. At least one field within ApplicationInfo must be specified. Job application information.
func (o JobTypeOutput) ApplicationInfo() ApplicationInfoPtrOutput {
	return o.ApplyT(func(v JobType) *ApplicationInfo { return v.ApplicationInfo }).(ApplicationInfoPtrOutput)
}

// Display name of the company listing the job.
func (o JobTypeOutput) CompanyDisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobType) *string { return v.CompanyDisplayName }).(pulumi.StringPtrOutput)
}

// Required. The resource name of the company listing the job, such as "projects/api-test-project/companies/foo".
func (o JobTypeOutput) CompanyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobType) *string { return v.CompanyName }).(pulumi.StringPtrOutput)
}

// Optional. Job compensation information.
func (o JobTypeOutput) CompensationInfo() CompensationInfoPtrOutput {
	return o.ApplyT(func(v JobType) *CompensationInfo { return v.CompensationInfo }).(CompensationInfoPtrOutput)
}

// Optional. A map of fields to hold both filterable and non-filterable custom job attributes that are not covered by the provided structured fields. The keys of the map are strings up to 64 bytes and must match the pattern: a-zA-Z*. For example, key0LikeThis or KEY_1_LIKE_THIS. At most 100 filterable and at most 100 unfilterable keys are supported. For filterable `string_values`, across all keys at most 200 values are allowed, with each string no more than 255 characters. For unfilterable `string_values`, the maximum total size of `string_values` across all keys is 50KB.
func (o JobTypeOutput) CustomAttributes() pulumi.StringMapOutput {
	return o.ApplyT(func(v JobType) map[string]string { return v.CustomAttributes }).(pulumi.StringMapOutput)
}

// Optional. The desired education degrees for the job, such as Bachelors, Masters.
func (o JobTypeOutput) DegreeTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v JobType) []string { return v.DegreeTypes }).(pulumi.StringArrayOutput)
}

// Optional. The department or functional area within the company with the open position. The maximum number of allowed characters is 255.
func (o JobTypeOutput) Department() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobType) *string { return v.Department }).(pulumi.StringPtrOutput)
}

// Derived details about the job posting.
func (o JobTypeOutput) DerivedInfo() JobDerivedInfoPtrOutput {
	return o.ApplyT(func(v JobType) *JobDerivedInfo { return v.DerivedInfo }).(JobDerivedInfoPtrOutput)
}

// Required. The description of the job, which typically includes a multi-paragraph description of the company and related information. Separate fields are provided on the job object for responsibilities, qualifications, and other job characteristics. Use of these separate job fields is recommended. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 100,000.
func (o JobTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobType) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Optional. The employment type(s) of a job, for example, full time or part time.
func (o JobTypeOutput) EmploymentTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v JobType) []string { return v.EmploymentTypes }).(pulumi.StringArrayOutput)
}

// Optional. A description of bonus, commission, and other compensation incentives associated with the job not including salary or pay. The maximum number of allowed characters is 10,000.
func (o JobTypeOutput) Incentives() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobType) *string { return v.Incentives }).(pulumi.StringPtrOutput)
}

// Optional. The benefits included with the job.
func (o JobTypeOutput) JobBenefits() pulumi.StringArrayOutput {
	return o.ApplyT(func(v JobType) []string { return v.JobBenefits }).(pulumi.StringArrayOutput)
}

// Optional. The end timestamp of the job. Typically this field is used for contracting engagements. Invalid timestamps are ignored.
func (o JobTypeOutput) JobEndTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobType) *string { return v.JobEndTime }).(pulumi.StringPtrOutput)
}

// Optional. The experience level associated with the job, such as "Entry Level".
func (o JobTypeOutput) JobLevel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobType) *string { return v.JobLevel }).(pulumi.StringPtrOutput)
}

// Optional. The start timestamp of the job in UTC time zone. Typically this field is used for contracting engagements. Invalid timestamps are ignored.
func (o JobTypeOutput) JobStartTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobType) *string { return v.JobStartTime }).(pulumi.StringPtrOutput)
}

// Optional. The language of the posting. This field is distinct from any requirements for fluency that are associated with the job. Language codes must be in BCP-47 format, such as "en-US" or "sr-Latn". For more information, see [Tags for Identifying Languages](https://tools.ietf.org/html/bcp47){: class="external" target="_blank" }. If this field is unspecified and Job.description is present, detected language code based on Job.description is assigned, otherwise defaults to 'en_US'.
func (o JobTypeOutput) LanguageCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobType) *string { return v.LanguageCode }).(pulumi.StringPtrOutput)
}

// Required during job update. The resource name for the job. This is generated by the service when a job is created. The format is "projects/{project_id}/jobs/{job_id}", for example, "projects/api-test-project/jobs/1234". Use of this field in job queries and API calls is preferred over the use of requisition_id since this value is unique.
func (o JobTypeOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobType) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The timestamp when this job posting was created.
func (o JobTypeOutput) PostingCreateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobType) *string { return v.PostingCreateTime }).(pulumi.StringPtrOutput)
}

// Optional but strongly recommended for the best service experience. The expiration timestamp of the job. After this timestamp, the job is marked as expired, and it no longer appears in search results. The expired job can't be deleted or listed by the DeleteJob and ListJobs APIs, but it can be retrieved with the GetJob API or updated with the UpdateJob API. An expired job can be updated and opened again by using a future expiration timestamp. Updating an expired job fails if there is another existing open job with same company_name, language_code and requisition_id. The expired jobs are retained in our system for 90 days. However, the overall expired job count cannot exceed 3 times the maximum of open jobs count over the past week, otherwise jobs with earlier expire time are cleaned first. Expired jobs are no longer accessible after they are cleaned out. Invalid timestamps are ignored, and treated as expire time not provided. Timestamp before the instant request is made is considered valid, the job will be treated as expired immediately. If this value is not provided at the time of job creation or is invalid, the job posting expires after 30 days from the job's creation time. For example, if the job was created on 2017/01/01 13:00AM UTC with an unspecified expiration date, the job expires after 2017/01/31 13:00AM UTC. If this value is not provided on job update, it depends on the field masks set by UpdateJobRequest.update_mask. If the field masks include expiry_time, or the masks are empty meaning that every field is updated, the job posting expires after 30 days from the job's last update time. Otherwise the expiration date isn't updated.
func (o JobTypeOutput) PostingExpireTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobType) *string { return v.PostingExpireTime }).(pulumi.StringPtrOutput)
}

// Optional. The timestamp this job posting was most recently published. The default value is the time the request arrives at the server. Invalid timestamps are ignored.
func (o JobTypeOutput) PostingPublishTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobType) *string { return v.PostingPublishTime }).(pulumi.StringPtrOutput)
}

// Optional. The job PostingRegion (for example, state, country) throughout which the job is available. If this field is set, a LocationFilter in a search query within the job region finds this job posting if an exact location match isn't specified. If this field is set to PostingRegion.NATION or PostingRegion.ADMINISTRATIVE_AREA, setting job Job.addresses to the same location level as this field is strongly recommended.
func (o JobTypeOutput) PostingRegion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobType) *string { return v.PostingRegion }).(pulumi.StringPtrOutput)
}

// The timestamp when this job posting was last updated.
func (o JobTypeOutput) PostingUpdateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobType) *string { return v.PostingUpdateTime }).(pulumi.StringPtrOutput)
}

// Optional. Options for job processing.
func (o JobTypeOutput) ProcessingOptions() ProcessingOptionsPtrOutput {
	return o.ApplyT(func(v JobType) *ProcessingOptions { return v.ProcessingOptions }).(ProcessingOptionsPtrOutput)
}

// Optional. A promotion value of the job, as determined by the client. The value determines the sort order of the jobs returned when searching for jobs using the featured jobs search call, with higher promotional values being returned first and ties being resolved by relevance sort. Only the jobs with a promotionValue >0 are returned in a FEATURED_JOB_SEARCH. Default value is 0, and negative values are treated as 0.
func (o JobTypeOutput) PromotionValue() pulumi.IntPtrOutput {
	return o.ApplyT(func(v JobType) *int { return v.PromotionValue }).(pulumi.IntPtrOutput)
}

// Optional. A description of the qualifications required to perform the job. The use of this field is recommended as an alternative to using the more general description field. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 10,000.
func (o JobTypeOutput) Qualifications() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobType) *string { return v.Qualifications }).(pulumi.StringPtrOutput)
}

// Required. The requisition ID, also referred to as the posting ID, assigned by the client to identify a job. This field is intended to be used by clients for client identification and tracking of postings. A job is not allowed to be created if there is another job with the same [company_name], language_code and requisition_id. The maximum number of allowed characters is 255.
func (o JobTypeOutput) RequisitionId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobType) *string { return v.RequisitionId }).(pulumi.StringPtrOutput)
}

// Optional. A description of job responsibilities. The use of this field is recommended as an alternative to using the more general description field. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 10,000.
func (o JobTypeOutput) Responsibilities() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobType) *string { return v.Responsibilities }).(pulumi.StringPtrOutput)
}

// Required. The title of the job, such as "Software Engineer" The maximum number of allowed characters is 500.
func (o JobTypeOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobType) *string { return v.Title }).(pulumi.StringPtrOutput)
}

type JobTypePtrOutput struct{ *pulumi.OutputState }

func (JobTypePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**JobType)(nil)).Elem()
}

func (o JobTypePtrOutput) ToJobTypePtrOutput() JobTypePtrOutput {
	return o
}

func (o JobTypePtrOutput) ToJobTypePtrOutputWithContext(ctx context.Context) JobTypePtrOutput {
	return o
}

func (o JobTypePtrOutput) Elem() JobTypeOutput {
	return o.ApplyT(func(v *JobType) JobType { return *v }).(JobTypeOutput)
}

// Optional but strongly recommended for the best service experience. Location(s) where the employer is looking to hire for this job posting. Specifying the full street address(es) of the hiring location enables better API results, especially job searches by commute time. At most 50 locations are allowed for best search performance. If a job has more locations, it is suggested to split it into multiple jobs with unique requisition_ids (e.g. 'ReqA' becomes 'ReqA-1', 'ReqA-2', etc.) as multiple jobs with the same company_name, language_code and requisition_id are not allowed. If the original requisition_id must be preserved, a custom field should be used for storage. It is also suggested to group the locations that close to each other in the same job for better search experience. The maximum number of allowed characters is 500.
func (o JobTypePtrOutput) Addresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *JobType) []string {
		if v == nil {
			return nil
		}
		return v.Addresses
	}).(pulumi.StringArrayOutput)
}

// Required. At least one field within ApplicationInfo must be specified. Job application information.
func (o JobTypePtrOutput) ApplicationInfo() ApplicationInfoPtrOutput {
	return o.ApplyT(func(v *JobType) *ApplicationInfo {
		if v == nil {
			return nil
		}
		return v.ApplicationInfo
	}).(ApplicationInfoPtrOutput)
}

// Display name of the company listing the job.
func (o JobTypePtrOutput) CompanyDisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JobType) *string {
		if v == nil {
			return nil
		}
		return v.CompanyDisplayName
	}).(pulumi.StringPtrOutput)
}

// Required. The resource name of the company listing the job, such as "projects/api-test-project/companies/foo".
func (o JobTypePtrOutput) CompanyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JobType) *string {
		if v == nil {
			return nil
		}
		return v.CompanyName
	}).(pulumi.StringPtrOutput)
}

// Optional. Job compensation information.
func (o JobTypePtrOutput) CompensationInfo() CompensationInfoPtrOutput {
	return o.ApplyT(func(v *JobType) *CompensationInfo {
		if v == nil {
			return nil
		}
		return v.CompensationInfo
	}).(CompensationInfoPtrOutput)
}

// Optional. A map of fields to hold both filterable and non-filterable custom job attributes that are not covered by the provided structured fields. The keys of the map are strings up to 64 bytes and must match the pattern: a-zA-Z*. For example, key0LikeThis or KEY_1_LIKE_THIS. At most 100 filterable and at most 100 unfilterable keys are supported. For filterable `string_values`, across all keys at most 200 values are allowed, with each string no more than 255 characters. For unfilterable `string_values`, the maximum total size of `string_values` across all keys is 50KB.
func (o JobTypePtrOutput) CustomAttributes() pulumi.StringMapOutput {
	return o.ApplyT(func(v *JobType) map[string]string {
		if v == nil {
			return nil
		}
		return v.CustomAttributes
	}).(pulumi.StringMapOutput)
}

// Optional. The desired education degrees for the job, such as Bachelors, Masters.
func (o JobTypePtrOutput) DegreeTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *JobType) []string {
		if v == nil {
			return nil
		}
		return v.DegreeTypes
	}).(pulumi.StringArrayOutput)
}

// Optional. The department or functional area within the company with the open position. The maximum number of allowed characters is 255.
func (o JobTypePtrOutput) Department() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JobType) *string {
		if v == nil {
			return nil
		}
		return v.Department
	}).(pulumi.StringPtrOutput)
}

// Derived details about the job posting.
func (o JobTypePtrOutput) DerivedInfo() JobDerivedInfoPtrOutput {
	return o.ApplyT(func(v *JobType) *JobDerivedInfo {
		if v == nil {
			return nil
		}
		return v.DerivedInfo
	}).(JobDerivedInfoPtrOutput)
}

// Required. The description of the job, which typically includes a multi-paragraph description of the company and related information. Separate fields are provided on the job object for responsibilities, qualifications, and other job characteristics. Use of these separate job fields is recommended. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 100,000.
func (o JobTypePtrOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JobType) *string {
		if v == nil {
			return nil
		}
		return v.Description
	}).(pulumi.StringPtrOutput)
}

// Optional. The employment type(s) of a job, for example, full time or part time.
func (o JobTypePtrOutput) EmploymentTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *JobType) []string {
		if v == nil {
			return nil
		}
		return v.EmploymentTypes
	}).(pulumi.StringArrayOutput)
}

// Optional. A description of bonus, commission, and other compensation incentives associated with the job not including salary or pay. The maximum number of allowed characters is 10,000.
func (o JobTypePtrOutput) Incentives() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JobType) *string {
		if v == nil {
			return nil
		}
		return v.Incentives
	}).(pulumi.StringPtrOutput)
}

// Optional. The benefits included with the job.
func (o JobTypePtrOutput) JobBenefits() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *JobType) []string {
		if v == nil {
			return nil
		}
		return v.JobBenefits
	}).(pulumi.StringArrayOutput)
}

// Optional. The end timestamp of the job. Typically this field is used for contracting engagements. Invalid timestamps are ignored.
func (o JobTypePtrOutput) JobEndTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JobType) *string {
		if v == nil {
			return nil
		}
		return v.JobEndTime
	}).(pulumi.StringPtrOutput)
}

// Optional. The experience level associated with the job, such as "Entry Level".
func (o JobTypePtrOutput) JobLevel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JobType) *string {
		if v == nil {
			return nil
		}
		return v.JobLevel
	}).(pulumi.StringPtrOutput)
}

// Optional. The start timestamp of the job in UTC time zone. Typically this field is used for contracting engagements. Invalid timestamps are ignored.
func (o JobTypePtrOutput) JobStartTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JobType) *string {
		if v == nil {
			return nil
		}
		return v.JobStartTime
	}).(pulumi.StringPtrOutput)
}

// Optional. The language of the posting. This field is distinct from any requirements for fluency that are associated with the job. Language codes must be in BCP-47 format, such as "en-US" or "sr-Latn". For more information, see [Tags for Identifying Languages](https://tools.ietf.org/html/bcp47){: class="external" target="_blank" }. If this field is unspecified and Job.description is present, detected language code based on Job.description is assigned, otherwise defaults to 'en_US'.
func (o JobTypePtrOutput) LanguageCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JobType) *string {
		if v == nil {
			return nil
		}
		return v.LanguageCode
	}).(pulumi.StringPtrOutput)
}

// Required during job update. The resource name for the job. This is generated by the service when a job is created. The format is "projects/{project_id}/jobs/{job_id}", for example, "projects/api-test-project/jobs/1234". Use of this field in job queries and API calls is preferred over the use of requisition_id since this value is unique.
func (o JobTypePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JobType) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// The timestamp when this job posting was created.
func (o JobTypePtrOutput) PostingCreateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JobType) *string {
		if v == nil {
			return nil
		}
		return v.PostingCreateTime
	}).(pulumi.StringPtrOutput)
}

// Optional but strongly recommended for the best service experience. The expiration timestamp of the job. After this timestamp, the job is marked as expired, and it no longer appears in search results. The expired job can't be deleted or listed by the DeleteJob and ListJobs APIs, but it can be retrieved with the GetJob API or updated with the UpdateJob API. An expired job can be updated and opened again by using a future expiration timestamp. Updating an expired job fails if there is another existing open job with same company_name, language_code and requisition_id. The expired jobs are retained in our system for 90 days. However, the overall expired job count cannot exceed 3 times the maximum of open jobs count over the past week, otherwise jobs with earlier expire time are cleaned first. Expired jobs are no longer accessible after they are cleaned out. Invalid timestamps are ignored, and treated as expire time not provided. Timestamp before the instant request is made is considered valid, the job will be treated as expired immediately. If this value is not provided at the time of job creation or is invalid, the job posting expires after 30 days from the job's creation time. For example, if the job was created on 2017/01/01 13:00AM UTC with an unspecified expiration date, the job expires after 2017/01/31 13:00AM UTC. If this value is not provided on job update, it depends on the field masks set by UpdateJobRequest.update_mask. If the field masks include expiry_time, or the masks are empty meaning that every field is updated, the job posting expires after 30 days from the job's last update time. Otherwise the expiration date isn't updated.
func (o JobTypePtrOutput) PostingExpireTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JobType) *string {
		if v == nil {
			return nil
		}
		return v.PostingExpireTime
	}).(pulumi.StringPtrOutput)
}

// Optional. The timestamp this job posting was most recently published. The default value is the time the request arrives at the server. Invalid timestamps are ignored.
func (o JobTypePtrOutput) PostingPublishTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JobType) *string {
		if v == nil {
			return nil
		}
		return v.PostingPublishTime
	}).(pulumi.StringPtrOutput)
}

// Optional. The job PostingRegion (for example, state, country) throughout which the job is available. If this field is set, a LocationFilter in a search query within the job region finds this job posting if an exact location match isn't specified. If this field is set to PostingRegion.NATION or PostingRegion.ADMINISTRATIVE_AREA, setting job Job.addresses to the same location level as this field is strongly recommended.
func (o JobTypePtrOutput) PostingRegion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JobType) *string {
		if v == nil {
			return nil
		}
		return v.PostingRegion
	}).(pulumi.StringPtrOutput)
}

// The timestamp when this job posting was last updated.
func (o JobTypePtrOutput) PostingUpdateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JobType) *string {
		if v == nil {
			return nil
		}
		return v.PostingUpdateTime
	}).(pulumi.StringPtrOutput)
}

// Optional. Options for job processing.
func (o JobTypePtrOutput) ProcessingOptions() ProcessingOptionsPtrOutput {
	return o.ApplyT(func(v *JobType) *ProcessingOptions {
		if v == nil {
			return nil
		}
		return v.ProcessingOptions
	}).(ProcessingOptionsPtrOutput)
}

// Optional. A promotion value of the job, as determined by the client. The value determines the sort order of the jobs returned when searching for jobs using the featured jobs search call, with higher promotional values being returned first and ties being resolved by relevance sort. Only the jobs with a promotionValue >0 are returned in a FEATURED_JOB_SEARCH. Default value is 0, and negative values are treated as 0.
func (o JobTypePtrOutput) PromotionValue() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *JobType) *int {
		if v == nil {
			return nil
		}
		return v.PromotionValue
	}).(pulumi.IntPtrOutput)
}

// Optional. A description of the qualifications required to perform the job. The use of this field is recommended as an alternative to using the more general description field. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 10,000.
func (o JobTypePtrOutput) Qualifications() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JobType) *string {
		if v == nil {
			return nil
		}
		return v.Qualifications
	}).(pulumi.StringPtrOutput)
}

// Required. The requisition ID, also referred to as the posting ID, assigned by the client to identify a job. This field is intended to be used by clients for client identification and tracking of postings. A job is not allowed to be created if there is another job with the same [company_name], language_code and requisition_id. The maximum number of allowed characters is 255.
func (o JobTypePtrOutput) RequisitionId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JobType) *string {
		if v == nil {
			return nil
		}
		return v.RequisitionId
	}).(pulumi.StringPtrOutput)
}

// Optional. A description of job responsibilities. The use of this field is recommended as an alternative to using the more general description field. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 10,000.
func (o JobTypePtrOutput) Responsibilities() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JobType) *string {
		if v == nil {
			return nil
		}
		return v.Responsibilities
	}).(pulumi.StringPtrOutput)
}

// Required. The title of the job, such as "Software Engineer" The maximum number of allowed characters is 500.
func (o JobTypePtrOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JobType) *string {
		if v == nil {
			return nil
		}
		return v.Title
	}).(pulumi.StringPtrOutput)
}

// Output only. Derived details about the job posting.
type JobDerivedInfo struct {
	// Job categories derived from Job.title and Job.description.
	JobCategories []string `pulumi:"jobCategories"`
	// Structured locations of the job, resolved from Job.addresses. locations are exactly matched to Job.addresses in the same order.
	Locations []Location `pulumi:"locations"`
}

// JobDerivedInfoInput is an input type that accepts JobDerivedInfoArgs and JobDerivedInfoOutput values.
// You can construct a concrete instance of `JobDerivedInfoInput` via:
//
//          JobDerivedInfoArgs{...}
type JobDerivedInfoInput interface {
	pulumi.Input

	ToJobDerivedInfoOutput() JobDerivedInfoOutput
	ToJobDerivedInfoOutputWithContext(context.Context) JobDerivedInfoOutput
}

// Output only. Derived details about the job posting.
type JobDerivedInfoArgs struct {
	// Job categories derived from Job.title and Job.description.
	JobCategories pulumi.StringArrayInput `pulumi:"jobCategories"`
	// Structured locations of the job, resolved from Job.addresses. locations are exactly matched to Job.addresses in the same order.
	Locations LocationArrayInput `pulumi:"locations"`
}

func (JobDerivedInfoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*JobDerivedInfo)(nil)).Elem()
}

func (i JobDerivedInfoArgs) ToJobDerivedInfoOutput() JobDerivedInfoOutput {
	return i.ToJobDerivedInfoOutputWithContext(context.Background())
}

func (i JobDerivedInfoArgs) ToJobDerivedInfoOutputWithContext(ctx context.Context) JobDerivedInfoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobDerivedInfoOutput)
}

func (i JobDerivedInfoArgs) ToJobDerivedInfoPtrOutput() JobDerivedInfoPtrOutput {
	return i.ToJobDerivedInfoPtrOutputWithContext(context.Background())
}

func (i JobDerivedInfoArgs) ToJobDerivedInfoPtrOutputWithContext(ctx context.Context) JobDerivedInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobDerivedInfoOutput).ToJobDerivedInfoPtrOutputWithContext(ctx)
}

// JobDerivedInfoPtrInput is an input type that accepts JobDerivedInfoArgs, JobDerivedInfoPtr and JobDerivedInfoPtrOutput values.
// You can construct a concrete instance of `JobDerivedInfoPtrInput` via:
//
//          JobDerivedInfoArgs{...}
//
//  or:
//
//          nil
type JobDerivedInfoPtrInput interface {
	pulumi.Input

	ToJobDerivedInfoPtrOutput() JobDerivedInfoPtrOutput
	ToJobDerivedInfoPtrOutputWithContext(context.Context) JobDerivedInfoPtrOutput
}

type jobDerivedInfoPtrType JobDerivedInfoArgs

func JobDerivedInfoPtr(v *JobDerivedInfoArgs) JobDerivedInfoPtrInput {
	return (*jobDerivedInfoPtrType)(v)
}

func (*jobDerivedInfoPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**JobDerivedInfo)(nil)).Elem()
}

func (i *jobDerivedInfoPtrType) ToJobDerivedInfoPtrOutput() JobDerivedInfoPtrOutput {
	return i.ToJobDerivedInfoPtrOutputWithContext(context.Background())
}

func (i *jobDerivedInfoPtrType) ToJobDerivedInfoPtrOutputWithContext(ctx context.Context) JobDerivedInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobDerivedInfoPtrOutput)
}

// Output only. Derived details about the job posting.
type JobDerivedInfoOutput struct{ *pulumi.OutputState }

func (JobDerivedInfoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobDerivedInfo)(nil)).Elem()
}

func (o JobDerivedInfoOutput) ToJobDerivedInfoOutput() JobDerivedInfoOutput {
	return o
}

func (o JobDerivedInfoOutput) ToJobDerivedInfoOutputWithContext(ctx context.Context) JobDerivedInfoOutput {
	return o
}

func (o JobDerivedInfoOutput) ToJobDerivedInfoPtrOutput() JobDerivedInfoPtrOutput {
	return o.ToJobDerivedInfoPtrOutputWithContext(context.Background())
}

func (o JobDerivedInfoOutput) ToJobDerivedInfoPtrOutputWithContext(ctx context.Context) JobDerivedInfoPtrOutput {
	return o.ApplyT(func(v JobDerivedInfo) *JobDerivedInfo {
		return &v
	}).(JobDerivedInfoPtrOutput)
}

// Job categories derived from Job.title and Job.description.
func (o JobDerivedInfoOutput) JobCategories() pulumi.StringArrayOutput {
	return o.ApplyT(func(v JobDerivedInfo) []string { return v.JobCategories }).(pulumi.StringArrayOutput)
}

// Structured locations of the job, resolved from Job.addresses. locations are exactly matched to Job.addresses in the same order.
func (o JobDerivedInfoOutput) Locations() LocationArrayOutput {
	return o.ApplyT(func(v JobDerivedInfo) []Location { return v.Locations }).(LocationArrayOutput)
}

type JobDerivedInfoPtrOutput struct{ *pulumi.OutputState }

func (JobDerivedInfoPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**JobDerivedInfo)(nil)).Elem()
}

func (o JobDerivedInfoPtrOutput) ToJobDerivedInfoPtrOutput() JobDerivedInfoPtrOutput {
	return o
}

func (o JobDerivedInfoPtrOutput) ToJobDerivedInfoPtrOutputWithContext(ctx context.Context) JobDerivedInfoPtrOutput {
	return o
}

func (o JobDerivedInfoPtrOutput) Elem() JobDerivedInfoOutput {
	return o.ApplyT(func(v *JobDerivedInfo) JobDerivedInfo { return *v }).(JobDerivedInfoOutput)
}

// Job categories derived from Job.title and Job.description.
func (o JobDerivedInfoPtrOutput) JobCategories() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *JobDerivedInfo) []string {
		if v == nil {
			return nil
		}
		return v.JobCategories
	}).(pulumi.StringArrayOutput)
}

// Structured locations of the job, resolved from Job.addresses. locations are exactly matched to Job.addresses in the same order.
func (o JobDerivedInfoPtrOutput) Locations() LocationArrayOutput {
	return o.ApplyT(func(v *JobDerivedInfo) []Location {
		if v == nil {
			return nil
		}
		return v.Locations
	}).(LocationArrayOutput)
}

// Output only. Derived details about the job posting.
type JobDerivedInfoResponse struct {
	// Job categories derived from Job.title and Job.description.
	JobCategories []string `pulumi:"jobCategories"`
	// Structured locations of the job, resolved from Job.addresses. locations are exactly matched to Job.addresses in the same order.
	Locations []LocationResponse `pulumi:"locations"`
}

// JobDerivedInfoResponseInput is an input type that accepts JobDerivedInfoResponseArgs and JobDerivedInfoResponseOutput values.
// You can construct a concrete instance of `JobDerivedInfoResponseInput` via:
//
//          JobDerivedInfoResponseArgs{...}
type JobDerivedInfoResponseInput interface {
	pulumi.Input

	ToJobDerivedInfoResponseOutput() JobDerivedInfoResponseOutput
	ToJobDerivedInfoResponseOutputWithContext(context.Context) JobDerivedInfoResponseOutput
}

// Output only. Derived details about the job posting.
type JobDerivedInfoResponseArgs struct {
	// Job categories derived from Job.title and Job.description.
	JobCategories pulumi.StringArrayInput `pulumi:"jobCategories"`
	// Structured locations of the job, resolved from Job.addresses. locations are exactly matched to Job.addresses in the same order.
	Locations LocationResponseArrayInput `pulumi:"locations"`
}

func (JobDerivedInfoResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*JobDerivedInfoResponse)(nil)).Elem()
}

func (i JobDerivedInfoResponseArgs) ToJobDerivedInfoResponseOutput() JobDerivedInfoResponseOutput {
	return i.ToJobDerivedInfoResponseOutputWithContext(context.Background())
}

func (i JobDerivedInfoResponseArgs) ToJobDerivedInfoResponseOutputWithContext(ctx context.Context) JobDerivedInfoResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobDerivedInfoResponseOutput)
}

func (i JobDerivedInfoResponseArgs) ToJobDerivedInfoResponsePtrOutput() JobDerivedInfoResponsePtrOutput {
	return i.ToJobDerivedInfoResponsePtrOutputWithContext(context.Background())
}

func (i JobDerivedInfoResponseArgs) ToJobDerivedInfoResponsePtrOutputWithContext(ctx context.Context) JobDerivedInfoResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobDerivedInfoResponseOutput).ToJobDerivedInfoResponsePtrOutputWithContext(ctx)
}

// JobDerivedInfoResponsePtrInput is an input type that accepts JobDerivedInfoResponseArgs, JobDerivedInfoResponsePtr and JobDerivedInfoResponsePtrOutput values.
// You can construct a concrete instance of `JobDerivedInfoResponsePtrInput` via:
//
//          JobDerivedInfoResponseArgs{...}
//
//  or:
//
//          nil
type JobDerivedInfoResponsePtrInput interface {
	pulumi.Input

	ToJobDerivedInfoResponsePtrOutput() JobDerivedInfoResponsePtrOutput
	ToJobDerivedInfoResponsePtrOutputWithContext(context.Context) JobDerivedInfoResponsePtrOutput
}

type jobDerivedInfoResponsePtrType JobDerivedInfoResponseArgs

func JobDerivedInfoResponsePtr(v *JobDerivedInfoResponseArgs) JobDerivedInfoResponsePtrInput {
	return (*jobDerivedInfoResponsePtrType)(v)
}

func (*jobDerivedInfoResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**JobDerivedInfoResponse)(nil)).Elem()
}

func (i *jobDerivedInfoResponsePtrType) ToJobDerivedInfoResponsePtrOutput() JobDerivedInfoResponsePtrOutput {
	return i.ToJobDerivedInfoResponsePtrOutputWithContext(context.Background())
}

func (i *jobDerivedInfoResponsePtrType) ToJobDerivedInfoResponsePtrOutputWithContext(ctx context.Context) JobDerivedInfoResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobDerivedInfoResponsePtrOutput)
}

// Output only. Derived details about the job posting.
type JobDerivedInfoResponseOutput struct{ *pulumi.OutputState }

func (JobDerivedInfoResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobDerivedInfoResponse)(nil)).Elem()
}

func (o JobDerivedInfoResponseOutput) ToJobDerivedInfoResponseOutput() JobDerivedInfoResponseOutput {
	return o
}

func (o JobDerivedInfoResponseOutput) ToJobDerivedInfoResponseOutputWithContext(ctx context.Context) JobDerivedInfoResponseOutput {
	return o
}

func (o JobDerivedInfoResponseOutput) ToJobDerivedInfoResponsePtrOutput() JobDerivedInfoResponsePtrOutput {
	return o.ToJobDerivedInfoResponsePtrOutputWithContext(context.Background())
}

func (o JobDerivedInfoResponseOutput) ToJobDerivedInfoResponsePtrOutputWithContext(ctx context.Context) JobDerivedInfoResponsePtrOutput {
	return o.ApplyT(func(v JobDerivedInfoResponse) *JobDerivedInfoResponse {
		return &v
	}).(JobDerivedInfoResponsePtrOutput)
}

// Job categories derived from Job.title and Job.description.
func (o JobDerivedInfoResponseOutput) JobCategories() pulumi.StringArrayOutput {
	return o.ApplyT(func(v JobDerivedInfoResponse) []string { return v.JobCategories }).(pulumi.StringArrayOutput)
}

// Structured locations of the job, resolved from Job.addresses. locations are exactly matched to Job.addresses in the same order.
func (o JobDerivedInfoResponseOutput) Locations() LocationResponseArrayOutput {
	return o.ApplyT(func(v JobDerivedInfoResponse) []LocationResponse { return v.Locations }).(LocationResponseArrayOutput)
}

type JobDerivedInfoResponsePtrOutput struct{ *pulumi.OutputState }

func (JobDerivedInfoResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**JobDerivedInfoResponse)(nil)).Elem()
}

func (o JobDerivedInfoResponsePtrOutput) ToJobDerivedInfoResponsePtrOutput() JobDerivedInfoResponsePtrOutput {
	return o
}

func (o JobDerivedInfoResponsePtrOutput) ToJobDerivedInfoResponsePtrOutputWithContext(ctx context.Context) JobDerivedInfoResponsePtrOutput {
	return o
}

func (o JobDerivedInfoResponsePtrOutput) Elem() JobDerivedInfoResponseOutput {
	return o.ApplyT(func(v *JobDerivedInfoResponse) JobDerivedInfoResponse { return *v }).(JobDerivedInfoResponseOutput)
}

// Job categories derived from Job.title and Job.description.
func (o JobDerivedInfoResponsePtrOutput) JobCategories() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *JobDerivedInfoResponse) []string {
		if v == nil {
			return nil
		}
		return v.JobCategories
	}).(pulumi.StringArrayOutput)
}

// Structured locations of the job, resolved from Job.addresses. locations are exactly matched to Job.addresses in the same order.
func (o JobDerivedInfoResponsePtrOutput) Locations() LocationResponseArrayOutput {
	return o.ApplyT(func(v *JobDerivedInfoResponse) []LocationResponse {
		if v == nil {
			return nil
		}
		return v.Locations
	}).(LocationResponseArrayOutput)
}

// An event issued when a job seeker interacts with the application that implements Cloud Talent Solution.
type JobEvent struct {
	// Required. The job name(s) associated with this event. For example, if this is an impression event, this field contains the identifiers of all jobs shown to the job seeker. If this was a view event, this field contains the identifier of the viewed job.
	Jobs []string `pulumi:"jobs"`
	// Required. The type of the event (see JobEventType).
	Type *string `pulumi:"type"`
}

// JobEventInput is an input type that accepts JobEventArgs and JobEventOutput values.
// You can construct a concrete instance of `JobEventInput` via:
//
//          JobEventArgs{...}
type JobEventInput interface {
	pulumi.Input

	ToJobEventOutput() JobEventOutput
	ToJobEventOutputWithContext(context.Context) JobEventOutput
}

// An event issued when a job seeker interacts with the application that implements Cloud Talent Solution.
type JobEventArgs struct {
	// Required. The job name(s) associated with this event. For example, if this is an impression event, this field contains the identifiers of all jobs shown to the job seeker. If this was a view event, this field contains the identifier of the viewed job.
	Jobs pulumi.StringArrayInput `pulumi:"jobs"`
	// Required. The type of the event (see JobEventType).
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (JobEventArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*JobEvent)(nil)).Elem()
}

func (i JobEventArgs) ToJobEventOutput() JobEventOutput {
	return i.ToJobEventOutputWithContext(context.Background())
}

func (i JobEventArgs) ToJobEventOutputWithContext(ctx context.Context) JobEventOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobEventOutput)
}

func (i JobEventArgs) ToJobEventPtrOutput() JobEventPtrOutput {
	return i.ToJobEventPtrOutputWithContext(context.Background())
}

func (i JobEventArgs) ToJobEventPtrOutputWithContext(ctx context.Context) JobEventPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobEventOutput).ToJobEventPtrOutputWithContext(ctx)
}

// JobEventPtrInput is an input type that accepts JobEventArgs, JobEventPtr and JobEventPtrOutput values.
// You can construct a concrete instance of `JobEventPtrInput` via:
//
//          JobEventArgs{...}
//
//  or:
//
//          nil
type JobEventPtrInput interface {
	pulumi.Input

	ToJobEventPtrOutput() JobEventPtrOutput
	ToJobEventPtrOutputWithContext(context.Context) JobEventPtrOutput
}

type jobEventPtrType JobEventArgs

func JobEventPtr(v *JobEventArgs) JobEventPtrInput {
	return (*jobEventPtrType)(v)
}

func (*jobEventPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**JobEvent)(nil)).Elem()
}

func (i *jobEventPtrType) ToJobEventPtrOutput() JobEventPtrOutput {
	return i.ToJobEventPtrOutputWithContext(context.Background())
}

func (i *jobEventPtrType) ToJobEventPtrOutputWithContext(ctx context.Context) JobEventPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobEventPtrOutput)
}

// An event issued when a job seeker interacts with the application that implements Cloud Talent Solution.
type JobEventOutput struct{ *pulumi.OutputState }

func (JobEventOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobEvent)(nil)).Elem()
}

func (o JobEventOutput) ToJobEventOutput() JobEventOutput {
	return o
}

func (o JobEventOutput) ToJobEventOutputWithContext(ctx context.Context) JobEventOutput {
	return o
}

func (o JobEventOutput) ToJobEventPtrOutput() JobEventPtrOutput {
	return o.ToJobEventPtrOutputWithContext(context.Background())
}

func (o JobEventOutput) ToJobEventPtrOutputWithContext(ctx context.Context) JobEventPtrOutput {
	return o.ApplyT(func(v JobEvent) *JobEvent {
		return &v
	}).(JobEventPtrOutput)
}

// Required. The job name(s) associated with this event. For example, if this is an impression event, this field contains the identifiers of all jobs shown to the job seeker. If this was a view event, this field contains the identifier of the viewed job.
func (o JobEventOutput) Jobs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v JobEvent) []string { return v.Jobs }).(pulumi.StringArrayOutput)
}

// Required. The type of the event (see JobEventType).
func (o JobEventOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobEvent) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type JobEventPtrOutput struct{ *pulumi.OutputState }

func (JobEventPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**JobEvent)(nil)).Elem()
}

func (o JobEventPtrOutput) ToJobEventPtrOutput() JobEventPtrOutput {
	return o
}

func (o JobEventPtrOutput) ToJobEventPtrOutputWithContext(ctx context.Context) JobEventPtrOutput {
	return o
}

func (o JobEventPtrOutput) Elem() JobEventOutput {
	return o.ApplyT(func(v *JobEvent) JobEvent { return *v }).(JobEventOutput)
}

// Required. The job name(s) associated with this event. For example, if this is an impression event, this field contains the identifiers of all jobs shown to the job seeker. If this was a view event, this field contains the identifier of the viewed job.
func (o JobEventPtrOutput) Jobs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *JobEvent) []string {
		if v == nil {
			return nil
		}
		return v.Jobs
	}).(pulumi.StringArrayOutput)
}

// Required. The type of the event (see JobEventType).
func (o JobEventPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JobEvent) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// An object that represents a latitude/longitude pair. This is expressed as a pair of doubles to represent degrees latitude and degrees longitude. Unless specified otherwise, this must conform to the WGS84 standard. Values must be within normalized ranges.
type LatLng struct {
	// The latitude in degrees. It must be in the range [-90.0, +90.0].
	Latitude *float64 `pulumi:"latitude"`
	// The longitude in degrees. It must be in the range [-180.0, +180.0].
	Longitude *float64 `pulumi:"longitude"`
}

// LatLngInput is an input type that accepts LatLngArgs and LatLngOutput values.
// You can construct a concrete instance of `LatLngInput` via:
//
//          LatLngArgs{...}
type LatLngInput interface {
	pulumi.Input

	ToLatLngOutput() LatLngOutput
	ToLatLngOutputWithContext(context.Context) LatLngOutput
}

// An object that represents a latitude/longitude pair. This is expressed as a pair of doubles to represent degrees latitude and degrees longitude. Unless specified otherwise, this must conform to the WGS84 standard. Values must be within normalized ranges.
type LatLngArgs struct {
	// The latitude in degrees. It must be in the range [-90.0, +90.0].
	Latitude pulumi.Float64PtrInput `pulumi:"latitude"`
	// The longitude in degrees. It must be in the range [-180.0, +180.0].
	Longitude pulumi.Float64PtrInput `pulumi:"longitude"`
}

func (LatLngArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LatLng)(nil)).Elem()
}

func (i LatLngArgs) ToLatLngOutput() LatLngOutput {
	return i.ToLatLngOutputWithContext(context.Background())
}

func (i LatLngArgs) ToLatLngOutputWithContext(ctx context.Context) LatLngOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LatLngOutput)
}

func (i LatLngArgs) ToLatLngPtrOutput() LatLngPtrOutput {
	return i.ToLatLngPtrOutputWithContext(context.Background())
}

func (i LatLngArgs) ToLatLngPtrOutputWithContext(ctx context.Context) LatLngPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LatLngOutput).ToLatLngPtrOutputWithContext(ctx)
}

// LatLngPtrInput is an input type that accepts LatLngArgs, LatLngPtr and LatLngPtrOutput values.
// You can construct a concrete instance of `LatLngPtrInput` via:
//
//          LatLngArgs{...}
//
//  or:
//
//          nil
type LatLngPtrInput interface {
	pulumi.Input

	ToLatLngPtrOutput() LatLngPtrOutput
	ToLatLngPtrOutputWithContext(context.Context) LatLngPtrOutput
}

type latLngPtrType LatLngArgs

func LatLngPtr(v *LatLngArgs) LatLngPtrInput {
	return (*latLngPtrType)(v)
}

func (*latLngPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LatLng)(nil)).Elem()
}

func (i *latLngPtrType) ToLatLngPtrOutput() LatLngPtrOutput {
	return i.ToLatLngPtrOutputWithContext(context.Background())
}

func (i *latLngPtrType) ToLatLngPtrOutputWithContext(ctx context.Context) LatLngPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LatLngPtrOutput)
}

// An object that represents a latitude/longitude pair. This is expressed as a pair of doubles to represent degrees latitude and degrees longitude. Unless specified otherwise, this must conform to the WGS84 standard. Values must be within normalized ranges.
type LatLngOutput struct{ *pulumi.OutputState }

func (LatLngOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LatLng)(nil)).Elem()
}

func (o LatLngOutput) ToLatLngOutput() LatLngOutput {
	return o
}

func (o LatLngOutput) ToLatLngOutputWithContext(ctx context.Context) LatLngOutput {
	return o
}

func (o LatLngOutput) ToLatLngPtrOutput() LatLngPtrOutput {
	return o.ToLatLngPtrOutputWithContext(context.Background())
}

func (o LatLngOutput) ToLatLngPtrOutputWithContext(ctx context.Context) LatLngPtrOutput {
	return o.ApplyT(func(v LatLng) *LatLng {
		return &v
	}).(LatLngPtrOutput)
}

// The latitude in degrees. It must be in the range [-90.0, +90.0].
func (o LatLngOutput) Latitude() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v LatLng) *float64 { return v.Latitude }).(pulumi.Float64PtrOutput)
}

// The longitude in degrees. It must be in the range [-180.0, +180.0].
func (o LatLngOutput) Longitude() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v LatLng) *float64 { return v.Longitude }).(pulumi.Float64PtrOutput)
}

type LatLngPtrOutput struct{ *pulumi.OutputState }

func (LatLngPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LatLng)(nil)).Elem()
}

func (o LatLngPtrOutput) ToLatLngPtrOutput() LatLngPtrOutput {
	return o
}

func (o LatLngPtrOutput) ToLatLngPtrOutputWithContext(ctx context.Context) LatLngPtrOutput {
	return o
}

func (o LatLngPtrOutput) Elem() LatLngOutput {
	return o.ApplyT(func(v *LatLng) LatLng { return *v }).(LatLngOutput)
}

// The latitude in degrees. It must be in the range [-90.0, +90.0].
func (o LatLngPtrOutput) Latitude() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *LatLng) *float64 {
		if v == nil {
			return nil
		}
		return v.Latitude
	}).(pulumi.Float64PtrOutput)
}

// The longitude in degrees. It must be in the range [-180.0, +180.0].
func (o LatLngPtrOutput) Longitude() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *LatLng) *float64 {
		if v == nil {
			return nil
		}
		return v.Longitude
	}).(pulumi.Float64PtrOutput)
}

// An object that represents a latitude/longitude pair. This is expressed as a pair of doubles to represent degrees latitude and degrees longitude. Unless specified otherwise, this must conform to the WGS84 standard. Values must be within normalized ranges.
type LatLngResponse struct {
	// The latitude in degrees. It must be in the range [-90.0, +90.0].
	Latitude float64 `pulumi:"latitude"`
	// The longitude in degrees. It must be in the range [-180.0, +180.0].
	Longitude float64 `pulumi:"longitude"`
}

// LatLngResponseInput is an input type that accepts LatLngResponseArgs and LatLngResponseOutput values.
// You can construct a concrete instance of `LatLngResponseInput` via:
//
//          LatLngResponseArgs{...}
type LatLngResponseInput interface {
	pulumi.Input

	ToLatLngResponseOutput() LatLngResponseOutput
	ToLatLngResponseOutputWithContext(context.Context) LatLngResponseOutput
}

// An object that represents a latitude/longitude pair. This is expressed as a pair of doubles to represent degrees latitude and degrees longitude. Unless specified otherwise, this must conform to the WGS84 standard. Values must be within normalized ranges.
type LatLngResponseArgs struct {
	// The latitude in degrees. It must be in the range [-90.0, +90.0].
	Latitude pulumi.Float64Input `pulumi:"latitude"`
	// The longitude in degrees. It must be in the range [-180.0, +180.0].
	Longitude pulumi.Float64Input `pulumi:"longitude"`
}

func (LatLngResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LatLngResponse)(nil)).Elem()
}

func (i LatLngResponseArgs) ToLatLngResponseOutput() LatLngResponseOutput {
	return i.ToLatLngResponseOutputWithContext(context.Background())
}

func (i LatLngResponseArgs) ToLatLngResponseOutputWithContext(ctx context.Context) LatLngResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LatLngResponseOutput)
}

func (i LatLngResponseArgs) ToLatLngResponsePtrOutput() LatLngResponsePtrOutput {
	return i.ToLatLngResponsePtrOutputWithContext(context.Background())
}

func (i LatLngResponseArgs) ToLatLngResponsePtrOutputWithContext(ctx context.Context) LatLngResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LatLngResponseOutput).ToLatLngResponsePtrOutputWithContext(ctx)
}

// LatLngResponsePtrInput is an input type that accepts LatLngResponseArgs, LatLngResponsePtr and LatLngResponsePtrOutput values.
// You can construct a concrete instance of `LatLngResponsePtrInput` via:
//
//          LatLngResponseArgs{...}
//
//  or:
//
//          nil
type LatLngResponsePtrInput interface {
	pulumi.Input

	ToLatLngResponsePtrOutput() LatLngResponsePtrOutput
	ToLatLngResponsePtrOutputWithContext(context.Context) LatLngResponsePtrOutput
}

type latLngResponsePtrType LatLngResponseArgs

func LatLngResponsePtr(v *LatLngResponseArgs) LatLngResponsePtrInput {
	return (*latLngResponsePtrType)(v)
}

func (*latLngResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LatLngResponse)(nil)).Elem()
}

func (i *latLngResponsePtrType) ToLatLngResponsePtrOutput() LatLngResponsePtrOutput {
	return i.ToLatLngResponsePtrOutputWithContext(context.Background())
}

func (i *latLngResponsePtrType) ToLatLngResponsePtrOutputWithContext(ctx context.Context) LatLngResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LatLngResponsePtrOutput)
}

// An object that represents a latitude/longitude pair. This is expressed as a pair of doubles to represent degrees latitude and degrees longitude. Unless specified otherwise, this must conform to the WGS84 standard. Values must be within normalized ranges.
type LatLngResponseOutput struct{ *pulumi.OutputState }

func (LatLngResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LatLngResponse)(nil)).Elem()
}

func (o LatLngResponseOutput) ToLatLngResponseOutput() LatLngResponseOutput {
	return o
}

func (o LatLngResponseOutput) ToLatLngResponseOutputWithContext(ctx context.Context) LatLngResponseOutput {
	return o
}

func (o LatLngResponseOutput) ToLatLngResponsePtrOutput() LatLngResponsePtrOutput {
	return o.ToLatLngResponsePtrOutputWithContext(context.Background())
}

func (o LatLngResponseOutput) ToLatLngResponsePtrOutputWithContext(ctx context.Context) LatLngResponsePtrOutput {
	return o.ApplyT(func(v LatLngResponse) *LatLngResponse {
		return &v
	}).(LatLngResponsePtrOutput)
}

// The latitude in degrees. It must be in the range [-90.0, +90.0].
func (o LatLngResponseOutput) Latitude() pulumi.Float64Output {
	return o.ApplyT(func(v LatLngResponse) float64 { return v.Latitude }).(pulumi.Float64Output)
}

// The longitude in degrees. It must be in the range [-180.0, +180.0].
func (o LatLngResponseOutput) Longitude() pulumi.Float64Output {
	return o.ApplyT(func(v LatLngResponse) float64 { return v.Longitude }).(pulumi.Float64Output)
}

type LatLngResponsePtrOutput struct{ *pulumi.OutputState }

func (LatLngResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LatLngResponse)(nil)).Elem()
}

func (o LatLngResponsePtrOutput) ToLatLngResponsePtrOutput() LatLngResponsePtrOutput {
	return o
}

func (o LatLngResponsePtrOutput) ToLatLngResponsePtrOutputWithContext(ctx context.Context) LatLngResponsePtrOutput {
	return o
}

func (o LatLngResponsePtrOutput) Elem() LatLngResponseOutput {
	return o.ApplyT(func(v *LatLngResponse) LatLngResponse { return *v }).(LatLngResponseOutput)
}

// The latitude in degrees. It must be in the range [-90.0, +90.0].
func (o LatLngResponsePtrOutput) Latitude() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *LatLngResponse) *float64 {
		if v == nil {
			return nil
		}
		return &v.Latitude
	}).(pulumi.Float64PtrOutput)
}

// The longitude in degrees. It must be in the range [-180.0, +180.0].
func (o LatLngResponsePtrOutput) Longitude() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *LatLngResponse) *float64 {
		if v == nil {
			return nil
		}
		return &v.Longitude
	}).(pulumi.Float64PtrOutput)
}

// Output only. A resource that represents a location with full geographic information.
type Location struct {
	// An object representing a latitude/longitude pair.
	LatLng *LatLng `pulumi:"latLng"`
	// The type of a location, which corresponds to the address lines field of PostalAddress. For example, "Downtown, Atlanta, GA, USA" has a type of LocationType#NEIGHBORHOOD, and "Kansas City, KS, USA" has a type of LocationType#LOCALITY.
	LocationType *string `pulumi:"locationType"`
	// Postal address of the location that includes human readable information, such as postal delivery and payments addresses. Given a postal address, a postal service can deliver items to a premises, P.O. Box, or other delivery location.
	PostalAddress *PostalAddress `pulumi:"postalAddress"`
	// Radius in miles of the job location. This value is derived from the location bounding box in which a circle with the specified radius centered from LatLng covers the area associated with the job location. For example, currently, "Mountain View, CA, USA" has a radius of 6.17 miles.
	RadiusInMiles *float64 `pulumi:"radiusInMiles"`
}

// LocationInput is an input type that accepts LocationArgs and LocationOutput values.
// You can construct a concrete instance of `LocationInput` via:
//
//          LocationArgs{...}
type LocationInput interface {
	pulumi.Input

	ToLocationOutput() LocationOutput
	ToLocationOutputWithContext(context.Context) LocationOutput
}

// Output only. A resource that represents a location with full geographic information.
type LocationArgs struct {
	// An object representing a latitude/longitude pair.
	LatLng LatLngPtrInput `pulumi:"latLng"`
	// The type of a location, which corresponds to the address lines field of PostalAddress. For example, "Downtown, Atlanta, GA, USA" has a type of LocationType#NEIGHBORHOOD, and "Kansas City, KS, USA" has a type of LocationType#LOCALITY.
	LocationType pulumi.StringPtrInput `pulumi:"locationType"`
	// Postal address of the location that includes human readable information, such as postal delivery and payments addresses. Given a postal address, a postal service can deliver items to a premises, P.O. Box, or other delivery location.
	PostalAddress PostalAddressPtrInput `pulumi:"postalAddress"`
	// Radius in miles of the job location. This value is derived from the location bounding box in which a circle with the specified radius centered from LatLng covers the area associated with the job location. For example, currently, "Mountain View, CA, USA" has a radius of 6.17 miles.
	RadiusInMiles pulumi.Float64PtrInput `pulumi:"radiusInMiles"`
}

func (LocationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Location)(nil)).Elem()
}

func (i LocationArgs) ToLocationOutput() LocationOutput {
	return i.ToLocationOutputWithContext(context.Background())
}

func (i LocationArgs) ToLocationOutputWithContext(ctx context.Context) LocationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocationOutput)
}

func (i LocationArgs) ToLocationPtrOutput() LocationPtrOutput {
	return i.ToLocationPtrOutputWithContext(context.Background())
}

func (i LocationArgs) ToLocationPtrOutputWithContext(ctx context.Context) LocationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocationOutput).ToLocationPtrOutputWithContext(ctx)
}

// LocationPtrInput is an input type that accepts LocationArgs, LocationPtr and LocationPtrOutput values.
// You can construct a concrete instance of `LocationPtrInput` via:
//
//          LocationArgs{...}
//
//  or:
//
//          nil
type LocationPtrInput interface {
	pulumi.Input

	ToLocationPtrOutput() LocationPtrOutput
	ToLocationPtrOutputWithContext(context.Context) LocationPtrOutput
}

type locationPtrType LocationArgs

func LocationPtr(v *LocationArgs) LocationPtrInput {
	return (*locationPtrType)(v)
}

func (*locationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Location)(nil)).Elem()
}

func (i *locationPtrType) ToLocationPtrOutput() LocationPtrOutput {
	return i.ToLocationPtrOutputWithContext(context.Background())
}

func (i *locationPtrType) ToLocationPtrOutputWithContext(ctx context.Context) LocationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocationPtrOutput)
}

// LocationArrayInput is an input type that accepts LocationArray and LocationArrayOutput values.
// You can construct a concrete instance of `LocationArrayInput` via:
//
//          LocationArray{ LocationArgs{...} }
type LocationArrayInput interface {
	pulumi.Input

	ToLocationArrayOutput() LocationArrayOutput
	ToLocationArrayOutputWithContext(context.Context) LocationArrayOutput
}

type LocationArray []LocationInput

func (LocationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Location)(nil)).Elem()
}

func (i LocationArray) ToLocationArrayOutput() LocationArrayOutput {
	return i.ToLocationArrayOutputWithContext(context.Background())
}

func (i LocationArray) ToLocationArrayOutputWithContext(ctx context.Context) LocationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocationArrayOutput)
}

// Output only. A resource that represents a location with full geographic information.
type LocationOutput struct{ *pulumi.OutputState }

func (LocationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Location)(nil)).Elem()
}

func (o LocationOutput) ToLocationOutput() LocationOutput {
	return o
}

func (o LocationOutput) ToLocationOutputWithContext(ctx context.Context) LocationOutput {
	return o
}

func (o LocationOutput) ToLocationPtrOutput() LocationPtrOutput {
	return o.ToLocationPtrOutputWithContext(context.Background())
}

func (o LocationOutput) ToLocationPtrOutputWithContext(ctx context.Context) LocationPtrOutput {
	return o.ApplyT(func(v Location) *Location {
		return &v
	}).(LocationPtrOutput)
}

// An object representing a latitude/longitude pair.
func (o LocationOutput) LatLng() LatLngPtrOutput {
	return o.ApplyT(func(v Location) *LatLng { return v.LatLng }).(LatLngPtrOutput)
}

// The type of a location, which corresponds to the address lines field of PostalAddress. For example, "Downtown, Atlanta, GA, USA" has a type of LocationType#NEIGHBORHOOD, and "Kansas City, KS, USA" has a type of LocationType#LOCALITY.
func (o LocationOutput) LocationType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Location) *string { return v.LocationType }).(pulumi.StringPtrOutput)
}

// Postal address of the location that includes human readable information, such as postal delivery and payments addresses. Given a postal address, a postal service can deliver items to a premises, P.O. Box, or other delivery location.
func (o LocationOutput) PostalAddress() PostalAddressPtrOutput {
	return o.ApplyT(func(v Location) *PostalAddress { return v.PostalAddress }).(PostalAddressPtrOutput)
}

// Radius in miles of the job location. This value is derived from the location bounding box in which a circle with the specified radius centered from LatLng covers the area associated with the job location. For example, currently, "Mountain View, CA, USA" has a radius of 6.17 miles.
func (o LocationOutput) RadiusInMiles() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Location) *float64 { return v.RadiusInMiles }).(pulumi.Float64PtrOutput)
}

type LocationPtrOutput struct{ *pulumi.OutputState }

func (LocationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Location)(nil)).Elem()
}

func (o LocationPtrOutput) ToLocationPtrOutput() LocationPtrOutput {
	return o
}

func (o LocationPtrOutput) ToLocationPtrOutputWithContext(ctx context.Context) LocationPtrOutput {
	return o
}

func (o LocationPtrOutput) Elem() LocationOutput {
	return o.ApplyT(func(v *Location) Location { return *v }).(LocationOutput)
}

// An object representing a latitude/longitude pair.
func (o LocationPtrOutput) LatLng() LatLngPtrOutput {
	return o.ApplyT(func(v *Location) *LatLng {
		if v == nil {
			return nil
		}
		return v.LatLng
	}).(LatLngPtrOutput)
}

// The type of a location, which corresponds to the address lines field of PostalAddress. For example, "Downtown, Atlanta, GA, USA" has a type of LocationType#NEIGHBORHOOD, and "Kansas City, KS, USA" has a type of LocationType#LOCALITY.
func (o LocationPtrOutput) LocationType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Location) *string {
		if v == nil {
			return nil
		}
		return v.LocationType
	}).(pulumi.StringPtrOutput)
}

// Postal address of the location that includes human readable information, such as postal delivery and payments addresses. Given a postal address, a postal service can deliver items to a premises, P.O. Box, or other delivery location.
func (o LocationPtrOutput) PostalAddress() PostalAddressPtrOutput {
	return o.ApplyT(func(v *Location) *PostalAddress {
		if v == nil {
			return nil
		}
		return v.PostalAddress
	}).(PostalAddressPtrOutput)
}

// Radius in miles of the job location. This value is derived from the location bounding box in which a circle with the specified radius centered from LatLng covers the area associated with the job location. For example, currently, "Mountain View, CA, USA" has a radius of 6.17 miles.
func (o LocationPtrOutput) RadiusInMiles() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *Location) *float64 {
		if v == nil {
			return nil
		}
		return v.RadiusInMiles
	}).(pulumi.Float64PtrOutput)
}

type LocationArrayOutput struct{ *pulumi.OutputState }

func (LocationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Location)(nil)).Elem()
}

func (o LocationArrayOutput) ToLocationArrayOutput() LocationArrayOutput {
	return o
}

func (o LocationArrayOutput) ToLocationArrayOutputWithContext(ctx context.Context) LocationArrayOutput {
	return o
}

func (o LocationArrayOutput) Index(i pulumi.IntInput) LocationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Location {
		return vs[0].([]Location)[vs[1].(int)]
	}).(LocationOutput)
}

// Output only. A resource that represents a location with full geographic information.
type LocationResponse struct {
	// An object representing a latitude/longitude pair.
	LatLng LatLngResponse `pulumi:"latLng"`
	// The type of a location, which corresponds to the address lines field of PostalAddress. For example, "Downtown, Atlanta, GA, USA" has a type of LocationType#NEIGHBORHOOD, and "Kansas City, KS, USA" has a type of LocationType#LOCALITY.
	LocationType string `pulumi:"locationType"`
	// Postal address of the location that includes human readable information, such as postal delivery and payments addresses. Given a postal address, a postal service can deliver items to a premises, P.O. Box, or other delivery location.
	PostalAddress PostalAddressResponse `pulumi:"postalAddress"`
	// Radius in miles of the job location. This value is derived from the location bounding box in which a circle with the specified radius centered from LatLng covers the area associated with the job location. For example, currently, "Mountain View, CA, USA" has a radius of 6.17 miles.
	RadiusInMiles float64 `pulumi:"radiusInMiles"`
}

// LocationResponseInput is an input type that accepts LocationResponseArgs and LocationResponseOutput values.
// You can construct a concrete instance of `LocationResponseInput` via:
//
//          LocationResponseArgs{...}
type LocationResponseInput interface {
	pulumi.Input

	ToLocationResponseOutput() LocationResponseOutput
	ToLocationResponseOutputWithContext(context.Context) LocationResponseOutput
}

// Output only. A resource that represents a location with full geographic information.
type LocationResponseArgs struct {
	// An object representing a latitude/longitude pair.
	LatLng LatLngResponseInput `pulumi:"latLng"`
	// The type of a location, which corresponds to the address lines field of PostalAddress. For example, "Downtown, Atlanta, GA, USA" has a type of LocationType#NEIGHBORHOOD, and "Kansas City, KS, USA" has a type of LocationType#LOCALITY.
	LocationType pulumi.StringInput `pulumi:"locationType"`
	// Postal address of the location that includes human readable information, such as postal delivery and payments addresses. Given a postal address, a postal service can deliver items to a premises, P.O. Box, or other delivery location.
	PostalAddress PostalAddressResponseInput `pulumi:"postalAddress"`
	// Radius in miles of the job location. This value is derived from the location bounding box in which a circle with the specified radius centered from LatLng covers the area associated with the job location. For example, currently, "Mountain View, CA, USA" has a radius of 6.17 miles.
	RadiusInMiles pulumi.Float64Input `pulumi:"radiusInMiles"`
}

func (LocationResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LocationResponse)(nil)).Elem()
}

func (i LocationResponseArgs) ToLocationResponseOutput() LocationResponseOutput {
	return i.ToLocationResponseOutputWithContext(context.Background())
}

func (i LocationResponseArgs) ToLocationResponseOutputWithContext(ctx context.Context) LocationResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocationResponseOutput)
}

func (i LocationResponseArgs) ToLocationResponsePtrOutput() LocationResponsePtrOutput {
	return i.ToLocationResponsePtrOutputWithContext(context.Background())
}

func (i LocationResponseArgs) ToLocationResponsePtrOutputWithContext(ctx context.Context) LocationResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocationResponseOutput).ToLocationResponsePtrOutputWithContext(ctx)
}

// LocationResponsePtrInput is an input type that accepts LocationResponseArgs, LocationResponsePtr and LocationResponsePtrOutput values.
// You can construct a concrete instance of `LocationResponsePtrInput` via:
//
//          LocationResponseArgs{...}
//
//  or:
//
//          nil
type LocationResponsePtrInput interface {
	pulumi.Input

	ToLocationResponsePtrOutput() LocationResponsePtrOutput
	ToLocationResponsePtrOutputWithContext(context.Context) LocationResponsePtrOutput
}

type locationResponsePtrType LocationResponseArgs

func LocationResponsePtr(v *LocationResponseArgs) LocationResponsePtrInput {
	return (*locationResponsePtrType)(v)
}

func (*locationResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LocationResponse)(nil)).Elem()
}

func (i *locationResponsePtrType) ToLocationResponsePtrOutput() LocationResponsePtrOutput {
	return i.ToLocationResponsePtrOutputWithContext(context.Background())
}

func (i *locationResponsePtrType) ToLocationResponsePtrOutputWithContext(ctx context.Context) LocationResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocationResponsePtrOutput)
}

// LocationResponseArrayInput is an input type that accepts LocationResponseArray and LocationResponseArrayOutput values.
// You can construct a concrete instance of `LocationResponseArrayInput` via:
//
//          LocationResponseArray{ LocationResponseArgs{...} }
type LocationResponseArrayInput interface {
	pulumi.Input

	ToLocationResponseArrayOutput() LocationResponseArrayOutput
	ToLocationResponseArrayOutputWithContext(context.Context) LocationResponseArrayOutput
}

type LocationResponseArray []LocationResponseInput

func (LocationResponseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LocationResponse)(nil)).Elem()
}

func (i LocationResponseArray) ToLocationResponseArrayOutput() LocationResponseArrayOutput {
	return i.ToLocationResponseArrayOutputWithContext(context.Background())
}

func (i LocationResponseArray) ToLocationResponseArrayOutputWithContext(ctx context.Context) LocationResponseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocationResponseArrayOutput)
}

// Output only. A resource that represents a location with full geographic information.
type LocationResponseOutput struct{ *pulumi.OutputState }

func (LocationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LocationResponse)(nil)).Elem()
}

func (o LocationResponseOutput) ToLocationResponseOutput() LocationResponseOutput {
	return o
}

func (o LocationResponseOutput) ToLocationResponseOutputWithContext(ctx context.Context) LocationResponseOutput {
	return o
}

func (o LocationResponseOutput) ToLocationResponsePtrOutput() LocationResponsePtrOutput {
	return o.ToLocationResponsePtrOutputWithContext(context.Background())
}

func (o LocationResponseOutput) ToLocationResponsePtrOutputWithContext(ctx context.Context) LocationResponsePtrOutput {
	return o.ApplyT(func(v LocationResponse) *LocationResponse {
		return &v
	}).(LocationResponsePtrOutput)
}

// An object representing a latitude/longitude pair.
func (o LocationResponseOutput) LatLng() LatLngResponseOutput {
	return o.ApplyT(func(v LocationResponse) LatLngResponse { return v.LatLng }).(LatLngResponseOutput)
}

// The type of a location, which corresponds to the address lines field of PostalAddress. For example, "Downtown, Atlanta, GA, USA" has a type of LocationType#NEIGHBORHOOD, and "Kansas City, KS, USA" has a type of LocationType#LOCALITY.
func (o LocationResponseOutput) LocationType() pulumi.StringOutput {
	return o.ApplyT(func(v LocationResponse) string { return v.LocationType }).(pulumi.StringOutput)
}

// Postal address of the location that includes human readable information, such as postal delivery and payments addresses. Given a postal address, a postal service can deliver items to a premises, P.O. Box, or other delivery location.
func (o LocationResponseOutput) PostalAddress() PostalAddressResponseOutput {
	return o.ApplyT(func(v LocationResponse) PostalAddressResponse { return v.PostalAddress }).(PostalAddressResponseOutput)
}

// Radius in miles of the job location. This value is derived from the location bounding box in which a circle with the specified radius centered from LatLng covers the area associated with the job location. For example, currently, "Mountain View, CA, USA" has a radius of 6.17 miles.
func (o LocationResponseOutput) RadiusInMiles() pulumi.Float64Output {
	return o.ApplyT(func(v LocationResponse) float64 { return v.RadiusInMiles }).(pulumi.Float64Output)
}

type LocationResponsePtrOutput struct{ *pulumi.OutputState }

func (LocationResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LocationResponse)(nil)).Elem()
}

func (o LocationResponsePtrOutput) ToLocationResponsePtrOutput() LocationResponsePtrOutput {
	return o
}

func (o LocationResponsePtrOutput) ToLocationResponsePtrOutputWithContext(ctx context.Context) LocationResponsePtrOutput {
	return o
}

func (o LocationResponsePtrOutput) Elem() LocationResponseOutput {
	return o.ApplyT(func(v *LocationResponse) LocationResponse { return *v }).(LocationResponseOutput)
}

// An object representing a latitude/longitude pair.
func (o LocationResponsePtrOutput) LatLng() LatLngResponsePtrOutput {
	return o.ApplyT(func(v *LocationResponse) *LatLngResponse {
		if v == nil {
			return nil
		}
		return &v.LatLng
	}).(LatLngResponsePtrOutput)
}

// The type of a location, which corresponds to the address lines field of PostalAddress. For example, "Downtown, Atlanta, GA, USA" has a type of LocationType#NEIGHBORHOOD, and "Kansas City, KS, USA" has a type of LocationType#LOCALITY.
func (o LocationResponsePtrOutput) LocationType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LocationResponse) *string {
		if v == nil {
			return nil
		}
		return &v.LocationType
	}).(pulumi.StringPtrOutput)
}

// Postal address of the location that includes human readable information, such as postal delivery and payments addresses. Given a postal address, a postal service can deliver items to a premises, P.O. Box, or other delivery location.
func (o LocationResponsePtrOutput) PostalAddress() PostalAddressResponsePtrOutput {
	return o.ApplyT(func(v *LocationResponse) *PostalAddressResponse {
		if v == nil {
			return nil
		}
		return &v.PostalAddress
	}).(PostalAddressResponsePtrOutput)
}

// Radius in miles of the job location. This value is derived from the location bounding box in which a circle with the specified radius centered from LatLng covers the area associated with the job location. For example, currently, "Mountain View, CA, USA" has a radius of 6.17 miles.
func (o LocationResponsePtrOutput) RadiusInMiles() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *LocationResponse) *float64 {
		if v == nil {
			return nil
		}
		return &v.RadiusInMiles
	}).(pulumi.Float64PtrOutput)
}

type LocationResponseArrayOutput struct{ *pulumi.OutputState }

func (LocationResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LocationResponse)(nil)).Elem()
}

func (o LocationResponseArrayOutput) ToLocationResponseArrayOutput() LocationResponseArrayOutput {
	return o
}

func (o LocationResponseArrayOutput) ToLocationResponseArrayOutputWithContext(ctx context.Context) LocationResponseArrayOutput {
	return o
}

func (o LocationResponseArrayOutput) Index(i pulumi.IntInput) LocationResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LocationResponse {
		return vs[0].([]LocationResponse)[vs[1].(int)]
	}).(LocationResponseOutput)
}

// Represents an amount of money with its currency type.
type Money struct {
	// The three-letter currency code defined in ISO 4217.
	CurrencyCode *string `pulumi:"currencyCode"`
	// Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
	Nanos *int `pulumi:"nanos"`
	// The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
	Units *string `pulumi:"units"`
}

// MoneyInput is an input type that accepts MoneyArgs and MoneyOutput values.
// You can construct a concrete instance of `MoneyInput` via:
//
//          MoneyArgs{...}
type MoneyInput interface {
	pulumi.Input

	ToMoneyOutput() MoneyOutput
	ToMoneyOutputWithContext(context.Context) MoneyOutput
}

// Represents an amount of money with its currency type.
type MoneyArgs struct {
	// The three-letter currency code defined in ISO 4217.
	CurrencyCode pulumi.StringPtrInput `pulumi:"currencyCode"`
	// Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
	Nanos pulumi.IntPtrInput `pulumi:"nanos"`
	// The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
	Units pulumi.StringPtrInput `pulumi:"units"`
}

func (MoneyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Money)(nil)).Elem()
}

func (i MoneyArgs) ToMoneyOutput() MoneyOutput {
	return i.ToMoneyOutputWithContext(context.Background())
}

func (i MoneyArgs) ToMoneyOutputWithContext(ctx context.Context) MoneyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MoneyOutput)
}

func (i MoneyArgs) ToMoneyPtrOutput() MoneyPtrOutput {
	return i.ToMoneyPtrOutputWithContext(context.Background())
}

func (i MoneyArgs) ToMoneyPtrOutputWithContext(ctx context.Context) MoneyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MoneyOutput).ToMoneyPtrOutputWithContext(ctx)
}

// MoneyPtrInput is an input type that accepts MoneyArgs, MoneyPtr and MoneyPtrOutput values.
// You can construct a concrete instance of `MoneyPtrInput` via:
//
//          MoneyArgs{...}
//
//  or:
//
//          nil
type MoneyPtrInput interface {
	pulumi.Input

	ToMoneyPtrOutput() MoneyPtrOutput
	ToMoneyPtrOutputWithContext(context.Context) MoneyPtrOutput
}

type moneyPtrType MoneyArgs

func MoneyPtr(v *MoneyArgs) MoneyPtrInput {
	return (*moneyPtrType)(v)
}

func (*moneyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Money)(nil)).Elem()
}

func (i *moneyPtrType) ToMoneyPtrOutput() MoneyPtrOutput {
	return i.ToMoneyPtrOutputWithContext(context.Background())
}

func (i *moneyPtrType) ToMoneyPtrOutputWithContext(ctx context.Context) MoneyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MoneyPtrOutput)
}

// Represents an amount of money with its currency type.
type MoneyOutput struct{ *pulumi.OutputState }

func (MoneyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Money)(nil)).Elem()
}

func (o MoneyOutput) ToMoneyOutput() MoneyOutput {
	return o
}

func (o MoneyOutput) ToMoneyOutputWithContext(ctx context.Context) MoneyOutput {
	return o
}

func (o MoneyOutput) ToMoneyPtrOutput() MoneyPtrOutput {
	return o.ToMoneyPtrOutputWithContext(context.Background())
}

func (o MoneyOutput) ToMoneyPtrOutputWithContext(ctx context.Context) MoneyPtrOutput {
	return o.ApplyT(func(v Money) *Money {
		return &v
	}).(MoneyPtrOutput)
}

// The three-letter currency code defined in ISO 4217.
func (o MoneyOutput) CurrencyCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Money) *string { return v.CurrencyCode }).(pulumi.StringPtrOutput)
}

// Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
func (o MoneyOutput) Nanos() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Money) *int { return v.Nanos }).(pulumi.IntPtrOutput)
}

// The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
func (o MoneyOutput) Units() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Money) *string { return v.Units }).(pulumi.StringPtrOutput)
}

type MoneyPtrOutput struct{ *pulumi.OutputState }

func (MoneyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Money)(nil)).Elem()
}

func (o MoneyPtrOutput) ToMoneyPtrOutput() MoneyPtrOutput {
	return o
}

func (o MoneyPtrOutput) ToMoneyPtrOutputWithContext(ctx context.Context) MoneyPtrOutput {
	return o
}

func (o MoneyPtrOutput) Elem() MoneyOutput {
	return o.ApplyT(func(v *Money) Money { return *v }).(MoneyOutput)
}

// The three-letter currency code defined in ISO 4217.
func (o MoneyPtrOutput) CurrencyCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Money) *string {
		if v == nil {
			return nil
		}
		return v.CurrencyCode
	}).(pulumi.StringPtrOutput)
}

// Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
func (o MoneyPtrOutput) Nanos() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Money) *int {
		if v == nil {
			return nil
		}
		return v.Nanos
	}).(pulumi.IntPtrOutput)
}

// The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
func (o MoneyPtrOutput) Units() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Money) *string {
		if v == nil {
			return nil
		}
		return v.Units
	}).(pulumi.StringPtrOutput)
}

// Represents an amount of money with its currency type.
type MoneyResponse struct {
	// The three-letter currency code defined in ISO 4217.
	CurrencyCode string `pulumi:"currencyCode"`
	// Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
	Nanos int `pulumi:"nanos"`
	// The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
	Units string `pulumi:"units"`
}

// MoneyResponseInput is an input type that accepts MoneyResponseArgs and MoneyResponseOutput values.
// You can construct a concrete instance of `MoneyResponseInput` via:
//
//          MoneyResponseArgs{...}
type MoneyResponseInput interface {
	pulumi.Input

	ToMoneyResponseOutput() MoneyResponseOutput
	ToMoneyResponseOutputWithContext(context.Context) MoneyResponseOutput
}

// Represents an amount of money with its currency type.
type MoneyResponseArgs struct {
	// The three-letter currency code defined in ISO 4217.
	CurrencyCode pulumi.StringInput `pulumi:"currencyCode"`
	// Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
	Nanos pulumi.IntInput `pulumi:"nanos"`
	// The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
	Units pulumi.StringInput `pulumi:"units"`
}

func (MoneyResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MoneyResponse)(nil)).Elem()
}

func (i MoneyResponseArgs) ToMoneyResponseOutput() MoneyResponseOutput {
	return i.ToMoneyResponseOutputWithContext(context.Background())
}

func (i MoneyResponseArgs) ToMoneyResponseOutputWithContext(ctx context.Context) MoneyResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MoneyResponseOutput)
}

func (i MoneyResponseArgs) ToMoneyResponsePtrOutput() MoneyResponsePtrOutput {
	return i.ToMoneyResponsePtrOutputWithContext(context.Background())
}

func (i MoneyResponseArgs) ToMoneyResponsePtrOutputWithContext(ctx context.Context) MoneyResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MoneyResponseOutput).ToMoneyResponsePtrOutputWithContext(ctx)
}

// MoneyResponsePtrInput is an input type that accepts MoneyResponseArgs, MoneyResponsePtr and MoneyResponsePtrOutput values.
// You can construct a concrete instance of `MoneyResponsePtrInput` via:
//
//          MoneyResponseArgs{...}
//
//  or:
//
//          nil
type MoneyResponsePtrInput interface {
	pulumi.Input

	ToMoneyResponsePtrOutput() MoneyResponsePtrOutput
	ToMoneyResponsePtrOutputWithContext(context.Context) MoneyResponsePtrOutput
}

type moneyResponsePtrType MoneyResponseArgs

func MoneyResponsePtr(v *MoneyResponseArgs) MoneyResponsePtrInput {
	return (*moneyResponsePtrType)(v)
}

func (*moneyResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MoneyResponse)(nil)).Elem()
}

func (i *moneyResponsePtrType) ToMoneyResponsePtrOutput() MoneyResponsePtrOutput {
	return i.ToMoneyResponsePtrOutputWithContext(context.Background())
}

func (i *moneyResponsePtrType) ToMoneyResponsePtrOutputWithContext(ctx context.Context) MoneyResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MoneyResponsePtrOutput)
}

// Represents an amount of money with its currency type.
type MoneyResponseOutput struct{ *pulumi.OutputState }

func (MoneyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MoneyResponse)(nil)).Elem()
}

func (o MoneyResponseOutput) ToMoneyResponseOutput() MoneyResponseOutput {
	return o
}

func (o MoneyResponseOutput) ToMoneyResponseOutputWithContext(ctx context.Context) MoneyResponseOutput {
	return o
}

func (o MoneyResponseOutput) ToMoneyResponsePtrOutput() MoneyResponsePtrOutput {
	return o.ToMoneyResponsePtrOutputWithContext(context.Background())
}

func (o MoneyResponseOutput) ToMoneyResponsePtrOutputWithContext(ctx context.Context) MoneyResponsePtrOutput {
	return o.ApplyT(func(v MoneyResponse) *MoneyResponse {
		return &v
	}).(MoneyResponsePtrOutput)
}

// The three-letter currency code defined in ISO 4217.
func (o MoneyResponseOutput) CurrencyCode() pulumi.StringOutput {
	return o.ApplyT(func(v MoneyResponse) string { return v.CurrencyCode }).(pulumi.StringOutput)
}

// Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
func (o MoneyResponseOutput) Nanos() pulumi.IntOutput {
	return o.ApplyT(func(v MoneyResponse) int { return v.Nanos }).(pulumi.IntOutput)
}

// The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
func (o MoneyResponseOutput) Units() pulumi.StringOutput {
	return o.ApplyT(func(v MoneyResponse) string { return v.Units }).(pulumi.StringOutput)
}

type MoneyResponsePtrOutput struct{ *pulumi.OutputState }

func (MoneyResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MoneyResponse)(nil)).Elem()
}

func (o MoneyResponsePtrOutput) ToMoneyResponsePtrOutput() MoneyResponsePtrOutput {
	return o
}

func (o MoneyResponsePtrOutput) ToMoneyResponsePtrOutputWithContext(ctx context.Context) MoneyResponsePtrOutput {
	return o
}

func (o MoneyResponsePtrOutput) Elem() MoneyResponseOutput {
	return o.ApplyT(func(v *MoneyResponse) MoneyResponse { return *v }).(MoneyResponseOutput)
}

// The three-letter currency code defined in ISO 4217.
func (o MoneyResponsePtrOutput) CurrencyCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MoneyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.CurrencyCode
	}).(pulumi.StringPtrOutput)
}

// Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
func (o MoneyResponsePtrOutput) Nanos() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *MoneyResponse) *int {
		if v == nil {
			return nil
		}
		return &v.Nanos
	}).(pulumi.IntPtrOutput)
}

// The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
func (o MoneyResponsePtrOutput) Units() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MoneyResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Units
	}).(pulumi.StringPtrOutput)
}

// Represents a postal address, e.g. for postal delivery or payments addresses. Given a postal address, a postal service can deliver items to a premise, P.O. Box or similar. It is not intended to model geographical locations (roads, towns, mountains). In typical usage an address would be created via user input or from importing existing data, depending on the type of process. Advice on address input / editing: - Use an i18n-ready address widget such as https://github.com/google/libaddressinput) - Users should not be presented with UI elements for input or editing of fields outside countries where that field is used. For more guidance on how to use this schema, please see: https://support.google.com/business/answer/6397478
type PostalAddress struct {
	// Unstructured address lines describing the lower levels of an address. Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way, the most specific line of an address can be selected based on the language. The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved. Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
	AddressLines []string `pulumi:"addressLines"`
	// Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
	AdministrativeArea *string `pulumi:"administrativeArea"`
	// Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations. If this value is not known, it should be omitted (rather than specifying a possibly incorrect default). Examples: "zh-Hant", "ja", "ja-Latn", "en".
	LanguageCode *string `pulumi:"languageCode"`
	// Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
	Locality *string `pulumi:"locality"`
	// Optional. The name of the organization at the address.
	Organization *string `pulumi:"organization"`
	// Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
	PostalCode *string `pulumi:"postalCode"`
	// Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain "care of" information.
	Recipients []string `pulumi:"recipients"`
	// Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See http://cldr.unicode.org/ and http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.
	RegionCode *string `pulumi:"regionCode"`
	// The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision. All new revisions **must** be backward compatible with old revisions.
	Revision *int `pulumi:"revision"`
	// Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number alone, representing the "sector code" (Jamaica), "delivery area indicator" (Malawi) or "post office indicator" (e.g. Cte d'Ivoire).
	SortingCode *string `pulumi:"sortingCode"`
	// Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
	Sublocality *string `pulumi:"sublocality"`
}

// PostalAddressInput is an input type that accepts PostalAddressArgs and PostalAddressOutput values.
// You can construct a concrete instance of `PostalAddressInput` via:
//
//          PostalAddressArgs{...}
type PostalAddressInput interface {
	pulumi.Input

	ToPostalAddressOutput() PostalAddressOutput
	ToPostalAddressOutputWithContext(context.Context) PostalAddressOutput
}

// Represents a postal address, e.g. for postal delivery or payments addresses. Given a postal address, a postal service can deliver items to a premise, P.O. Box or similar. It is not intended to model geographical locations (roads, towns, mountains). In typical usage an address would be created via user input or from importing existing data, depending on the type of process. Advice on address input / editing: - Use an i18n-ready address widget such as https://github.com/google/libaddressinput) - Users should not be presented with UI elements for input or editing of fields outside countries where that field is used. For more guidance on how to use this schema, please see: https://support.google.com/business/answer/6397478
type PostalAddressArgs struct {
	// Unstructured address lines describing the lower levels of an address. Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way, the most specific line of an address can be selected based on the language. The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved. Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
	AddressLines pulumi.StringArrayInput `pulumi:"addressLines"`
	// Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
	AdministrativeArea pulumi.StringPtrInput `pulumi:"administrativeArea"`
	// Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations. If this value is not known, it should be omitted (rather than specifying a possibly incorrect default). Examples: "zh-Hant", "ja", "ja-Latn", "en".
	LanguageCode pulumi.StringPtrInput `pulumi:"languageCode"`
	// Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
	Locality pulumi.StringPtrInput `pulumi:"locality"`
	// Optional. The name of the organization at the address.
	Organization pulumi.StringPtrInput `pulumi:"organization"`
	// Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
	PostalCode pulumi.StringPtrInput `pulumi:"postalCode"`
	// Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain "care of" information.
	Recipients pulumi.StringArrayInput `pulumi:"recipients"`
	// Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See http://cldr.unicode.org/ and http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.
	RegionCode pulumi.StringPtrInput `pulumi:"regionCode"`
	// The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision. All new revisions **must** be backward compatible with old revisions.
	Revision pulumi.IntPtrInput `pulumi:"revision"`
	// Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number alone, representing the "sector code" (Jamaica), "delivery area indicator" (Malawi) or "post office indicator" (e.g. Cte d'Ivoire).
	SortingCode pulumi.StringPtrInput `pulumi:"sortingCode"`
	// Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
	Sublocality pulumi.StringPtrInput `pulumi:"sublocality"`
}

func (PostalAddressArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PostalAddress)(nil)).Elem()
}

func (i PostalAddressArgs) ToPostalAddressOutput() PostalAddressOutput {
	return i.ToPostalAddressOutputWithContext(context.Background())
}

func (i PostalAddressArgs) ToPostalAddressOutputWithContext(ctx context.Context) PostalAddressOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PostalAddressOutput)
}

func (i PostalAddressArgs) ToPostalAddressPtrOutput() PostalAddressPtrOutput {
	return i.ToPostalAddressPtrOutputWithContext(context.Background())
}

func (i PostalAddressArgs) ToPostalAddressPtrOutputWithContext(ctx context.Context) PostalAddressPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PostalAddressOutput).ToPostalAddressPtrOutputWithContext(ctx)
}

// PostalAddressPtrInput is an input type that accepts PostalAddressArgs, PostalAddressPtr and PostalAddressPtrOutput values.
// You can construct a concrete instance of `PostalAddressPtrInput` via:
//
//          PostalAddressArgs{...}
//
//  or:
//
//          nil
type PostalAddressPtrInput interface {
	pulumi.Input

	ToPostalAddressPtrOutput() PostalAddressPtrOutput
	ToPostalAddressPtrOutputWithContext(context.Context) PostalAddressPtrOutput
}

type postalAddressPtrType PostalAddressArgs

func PostalAddressPtr(v *PostalAddressArgs) PostalAddressPtrInput {
	return (*postalAddressPtrType)(v)
}

func (*postalAddressPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PostalAddress)(nil)).Elem()
}

func (i *postalAddressPtrType) ToPostalAddressPtrOutput() PostalAddressPtrOutput {
	return i.ToPostalAddressPtrOutputWithContext(context.Background())
}

func (i *postalAddressPtrType) ToPostalAddressPtrOutputWithContext(ctx context.Context) PostalAddressPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PostalAddressPtrOutput)
}

// Represents a postal address, e.g. for postal delivery or payments addresses. Given a postal address, a postal service can deliver items to a premise, P.O. Box or similar. It is not intended to model geographical locations (roads, towns, mountains). In typical usage an address would be created via user input or from importing existing data, depending on the type of process. Advice on address input / editing: - Use an i18n-ready address widget such as https://github.com/google/libaddressinput) - Users should not be presented with UI elements for input or editing of fields outside countries where that field is used. For more guidance on how to use this schema, please see: https://support.google.com/business/answer/6397478
type PostalAddressOutput struct{ *pulumi.OutputState }

func (PostalAddressOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PostalAddress)(nil)).Elem()
}

func (o PostalAddressOutput) ToPostalAddressOutput() PostalAddressOutput {
	return o
}

func (o PostalAddressOutput) ToPostalAddressOutputWithContext(ctx context.Context) PostalAddressOutput {
	return o
}

func (o PostalAddressOutput) ToPostalAddressPtrOutput() PostalAddressPtrOutput {
	return o.ToPostalAddressPtrOutputWithContext(context.Background())
}

func (o PostalAddressOutput) ToPostalAddressPtrOutputWithContext(ctx context.Context) PostalAddressPtrOutput {
	return o.ApplyT(func(v PostalAddress) *PostalAddress {
		return &v
	}).(PostalAddressPtrOutput)
}

// Unstructured address lines describing the lower levels of an address. Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way, the most specific line of an address can be selected based on the language. The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved. Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
func (o PostalAddressOutput) AddressLines() pulumi.StringArrayOutput {
	return o.ApplyT(func(v PostalAddress) []string { return v.AddressLines }).(pulumi.StringArrayOutput)
}

// Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
func (o PostalAddressOutput) AdministrativeArea() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PostalAddress) *string { return v.AdministrativeArea }).(pulumi.StringPtrOutput)
}

// Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations. If this value is not known, it should be omitted (rather than specifying a possibly incorrect default). Examples: "zh-Hant", "ja", "ja-Latn", "en".
func (o PostalAddressOutput) LanguageCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PostalAddress) *string { return v.LanguageCode }).(pulumi.StringPtrOutput)
}

// Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
func (o PostalAddressOutput) Locality() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PostalAddress) *string { return v.Locality }).(pulumi.StringPtrOutput)
}

// Optional. The name of the organization at the address.
func (o PostalAddressOutput) Organization() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PostalAddress) *string { return v.Organization }).(pulumi.StringPtrOutput)
}

// Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
func (o PostalAddressOutput) PostalCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PostalAddress) *string { return v.PostalCode }).(pulumi.StringPtrOutput)
}

// Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain "care of" information.
func (o PostalAddressOutput) Recipients() pulumi.StringArrayOutput {
	return o.ApplyT(func(v PostalAddress) []string { return v.Recipients }).(pulumi.StringArrayOutput)
}

// Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See http://cldr.unicode.org/ and http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.
func (o PostalAddressOutput) RegionCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PostalAddress) *string { return v.RegionCode }).(pulumi.StringPtrOutput)
}

// The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision. All new revisions **must** be backward compatible with old revisions.
func (o PostalAddressOutput) Revision() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PostalAddress) *int { return v.Revision }).(pulumi.IntPtrOutput)
}

// Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number alone, representing the "sector code" (Jamaica), "delivery area indicator" (Malawi) or "post office indicator" (e.g. Cte d'Ivoire).
func (o PostalAddressOutput) SortingCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PostalAddress) *string { return v.SortingCode }).(pulumi.StringPtrOutput)
}

// Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
func (o PostalAddressOutput) Sublocality() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PostalAddress) *string { return v.Sublocality }).(pulumi.StringPtrOutput)
}

type PostalAddressPtrOutput struct{ *pulumi.OutputState }

func (PostalAddressPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PostalAddress)(nil)).Elem()
}

func (o PostalAddressPtrOutput) ToPostalAddressPtrOutput() PostalAddressPtrOutput {
	return o
}

func (o PostalAddressPtrOutput) ToPostalAddressPtrOutputWithContext(ctx context.Context) PostalAddressPtrOutput {
	return o
}

func (o PostalAddressPtrOutput) Elem() PostalAddressOutput {
	return o.ApplyT(func(v *PostalAddress) PostalAddress { return *v }).(PostalAddressOutput)
}

// Unstructured address lines describing the lower levels of an address. Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way, the most specific line of an address can be selected based on the language. The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved. Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
func (o PostalAddressPtrOutput) AddressLines() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *PostalAddress) []string {
		if v == nil {
			return nil
		}
		return v.AddressLines
	}).(pulumi.StringArrayOutput)
}

// Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
func (o PostalAddressPtrOutput) AdministrativeArea() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddress) *string {
		if v == nil {
			return nil
		}
		return v.AdministrativeArea
	}).(pulumi.StringPtrOutput)
}

// Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations. If this value is not known, it should be omitted (rather than specifying a possibly incorrect default). Examples: "zh-Hant", "ja", "ja-Latn", "en".
func (o PostalAddressPtrOutput) LanguageCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddress) *string {
		if v == nil {
			return nil
		}
		return v.LanguageCode
	}).(pulumi.StringPtrOutput)
}

// Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
func (o PostalAddressPtrOutput) Locality() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddress) *string {
		if v == nil {
			return nil
		}
		return v.Locality
	}).(pulumi.StringPtrOutput)
}

// Optional. The name of the organization at the address.
func (o PostalAddressPtrOutput) Organization() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddress) *string {
		if v == nil {
			return nil
		}
		return v.Organization
	}).(pulumi.StringPtrOutput)
}

// Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
func (o PostalAddressPtrOutput) PostalCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddress) *string {
		if v == nil {
			return nil
		}
		return v.PostalCode
	}).(pulumi.StringPtrOutput)
}

// Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain "care of" information.
func (o PostalAddressPtrOutput) Recipients() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *PostalAddress) []string {
		if v == nil {
			return nil
		}
		return v.Recipients
	}).(pulumi.StringArrayOutput)
}

// Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See http://cldr.unicode.org/ and http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.
func (o PostalAddressPtrOutput) RegionCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddress) *string {
		if v == nil {
			return nil
		}
		return v.RegionCode
	}).(pulumi.StringPtrOutput)
}

// The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision. All new revisions **must** be backward compatible with old revisions.
func (o PostalAddressPtrOutput) Revision() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PostalAddress) *int {
		if v == nil {
			return nil
		}
		return v.Revision
	}).(pulumi.IntPtrOutput)
}

// Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number alone, representing the "sector code" (Jamaica), "delivery area indicator" (Malawi) or "post office indicator" (e.g. Cte d'Ivoire).
func (o PostalAddressPtrOutput) SortingCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddress) *string {
		if v == nil {
			return nil
		}
		return v.SortingCode
	}).(pulumi.StringPtrOutput)
}

// Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
func (o PostalAddressPtrOutput) Sublocality() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddress) *string {
		if v == nil {
			return nil
		}
		return v.Sublocality
	}).(pulumi.StringPtrOutput)
}

// Represents a postal address, e.g. for postal delivery or payments addresses. Given a postal address, a postal service can deliver items to a premise, P.O. Box or similar. It is not intended to model geographical locations (roads, towns, mountains). In typical usage an address would be created via user input or from importing existing data, depending on the type of process. Advice on address input / editing: - Use an i18n-ready address widget such as https://github.com/google/libaddressinput) - Users should not be presented with UI elements for input or editing of fields outside countries where that field is used. For more guidance on how to use this schema, please see: https://support.google.com/business/answer/6397478
type PostalAddressResponse struct {
	// Unstructured address lines describing the lower levels of an address. Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way, the most specific line of an address can be selected based on the language. The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved. Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
	AddressLines []string `pulumi:"addressLines"`
	// Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
	AdministrativeArea string `pulumi:"administrativeArea"`
	// Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations. If this value is not known, it should be omitted (rather than specifying a possibly incorrect default). Examples: "zh-Hant", "ja", "ja-Latn", "en".
	LanguageCode string `pulumi:"languageCode"`
	// Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
	Locality string `pulumi:"locality"`
	// Optional. The name of the organization at the address.
	Organization string `pulumi:"organization"`
	// Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
	PostalCode string `pulumi:"postalCode"`
	// Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain "care of" information.
	Recipients []string `pulumi:"recipients"`
	// Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See http://cldr.unicode.org/ and http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.
	RegionCode string `pulumi:"regionCode"`
	// The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision. All new revisions **must** be backward compatible with old revisions.
	Revision int `pulumi:"revision"`
	// Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number alone, representing the "sector code" (Jamaica), "delivery area indicator" (Malawi) or "post office indicator" (e.g. Cte d'Ivoire).
	SortingCode string `pulumi:"sortingCode"`
	// Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
	Sublocality string `pulumi:"sublocality"`
}

// PostalAddressResponseInput is an input type that accepts PostalAddressResponseArgs and PostalAddressResponseOutput values.
// You can construct a concrete instance of `PostalAddressResponseInput` via:
//
//          PostalAddressResponseArgs{...}
type PostalAddressResponseInput interface {
	pulumi.Input

	ToPostalAddressResponseOutput() PostalAddressResponseOutput
	ToPostalAddressResponseOutputWithContext(context.Context) PostalAddressResponseOutput
}

// Represents a postal address, e.g. for postal delivery or payments addresses. Given a postal address, a postal service can deliver items to a premise, P.O. Box or similar. It is not intended to model geographical locations (roads, towns, mountains). In typical usage an address would be created via user input or from importing existing data, depending on the type of process. Advice on address input / editing: - Use an i18n-ready address widget such as https://github.com/google/libaddressinput) - Users should not be presented with UI elements for input or editing of fields outside countries where that field is used. For more guidance on how to use this schema, please see: https://support.google.com/business/answer/6397478
type PostalAddressResponseArgs struct {
	// Unstructured address lines describing the lower levels of an address. Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way, the most specific line of an address can be selected based on the language. The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved. Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
	AddressLines pulumi.StringArrayInput `pulumi:"addressLines"`
	// Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
	AdministrativeArea pulumi.StringInput `pulumi:"administrativeArea"`
	// Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations. If this value is not known, it should be omitted (rather than specifying a possibly incorrect default). Examples: "zh-Hant", "ja", "ja-Latn", "en".
	LanguageCode pulumi.StringInput `pulumi:"languageCode"`
	// Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
	Locality pulumi.StringInput `pulumi:"locality"`
	// Optional. The name of the organization at the address.
	Organization pulumi.StringInput `pulumi:"organization"`
	// Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
	PostalCode pulumi.StringInput `pulumi:"postalCode"`
	// Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain "care of" information.
	Recipients pulumi.StringArrayInput `pulumi:"recipients"`
	// Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See http://cldr.unicode.org/ and http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.
	RegionCode pulumi.StringInput `pulumi:"regionCode"`
	// The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision. All new revisions **must** be backward compatible with old revisions.
	Revision pulumi.IntInput `pulumi:"revision"`
	// Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number alone, representing the "sector code" (Jamaica), "delivery area indicator" (Malawi) or "post office indicator" (e.g. Cte d'Ivoire).
	SortingCode pulumi.StringInput `pulumi:"sortingCode"`
	// Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
	Sublocality pulumi.StringInput `pulumi:"sublocality"`
}

func (PostalAddressResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PostalAddressResponse)(nil)).Elem()
}

func (i PostalAddressResponseArgs) ToPostalAddressResponseOutput() PostalAddressResponseOutput {
	return i.ToPostalAddressResponseOutputWithContext(context.Background())
}

func (i PostalAddressResponseArgs) ToPostalAddressResponseOutputWithContext(ctx context.Context) PostalAddressResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PostalAddressResponseOutput)
}

func (i PostalAddressResponseArgs) ToPostalAddressResponsePtrOutput() PostalAddressResponsePtrOutput {
	return i.ToPostalAddressResponsePtrOutputWithContext(context.Background())
}

func (i PostalAddressResponseArgs) ToPostalAddressResponsePtrOutputWithContext(ctx context.Context) PostalAddressResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PostalAddressResponseOutput).ToPostalAddressResponsePtrOutputWithContext(ctx)
}

// PostalAddressResponsePtrInput is an input type that accepts PostalAddressResponseArgs, PostalAddressResponsePtr and PostalAddressResponsePtrOutput values.
// You can construct a concrete instance of `PostalAddressResponsePtrInput` via:
//
//          PostalAddressResponseArgs{...}
//
//  or:
//
//          nil
type PostalAddressResponsePtrInput interface {
	pulumi.Input

	ToPostalAddressResponsePtrOutput() PostalAddressResponsePtrOutput
	ToPostalAddressResponsePtrOutputWithContext(context.Context) PostalAddressResponsePtrOutput
}

type postalAddressResponsePtrType PostalAddressResponseArgs

func PostalAddressResponsePtr(v *PostalAddressResponseArgs) PostalAddressResponsePtrInput {
	return (*postalAddressResponsePtrType)(v)
}

func (*postalAddressResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PostalAddressResponse)(nil)).Elem()
}

func (i *postalAddressResponsePtrType) ToPostalAddressResponsePtrOutput() PostalAddressResponsePtrOutput {
	return i.ToPostalAddressResponsePtrOutputWithContext(context.Background())
}

func (i *postalAddressResponsePtrType) ToPostalAddressResponsePtrOutputWithContext(ctx context.Context) PostalAddressResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PostalAddressResponsePtrOutput)
}

// Represents a postal address, e.g. for postal delivery or payments addresses. Given a postal address, a postal service can deliver items to a premise, P.O. Box or similar. It is not intended to model geographical locations (roads, towns, mountains). In typical usage an address would be created via user input or from importing existing data, depending on the type of process. Advice on address input / editing: - Use an i18n-ready address widget such as https://github.com/google/libaddressinput) - Users should not be presented with UI elements for input or editing of fields outside countries where that field is used. For more guidance on how to use this schema, please see: https://support.google.com/business/answer/6397478
type PostalAddressResponseOutput struct{ *pulumi.OutputState }

func (PostalAddressResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PostalAddressResponse)(nil)).Elem()
}

func (o PostalAddressResponseOutput) ToPostalAddressResponseOutput() PostalAddressResponseOutput {
	return o
}

func (o PostalAddressResponseOutput) ToPostalAddressResponseOutputWithContext(ctx context.Context) PostalAddressResponseOutput {
	return o
}

func (o PostalAddressResponseOutput) ToPostalAddressResponsePtrOutput() PostalAddressResponsePtrOutput {
	return o.ToPostalAddressResponsePtrOutputWithContext(context.Background())
}

func (o PostalAddressResponseOutput) ToPostalAddressResponsePtrOutputWithContext(ctx context.Context) PostalAddressResponsePtrOutput {
	return o.ApplyT(func(v PostalAddressResponse) *PostalAddressResponse {
		return &v
	}).(PostalAddressResponsePtrOutput)
}

// Unstructured address lines describing the lower levels of an address. Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way, the most specific line of an address can be selected based on the language. The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved. Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
func (o PostalAddressResponseOutput) AddressLines() pulumi.StringArrayOutput {
	return o.ApplyT(func(v PostalAddressResponse) []string { return v.AddressLines }).(pulumi.StringArrayOutput)
}

// Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
func (o PostalAddressResponseOutput) AdministrativeArea() pulumi.StringOutput {
	return o.ApplyT(func(v PostalAddressResponse) string { return v.AdministrativeArea }).(pulumi.StringOutput)
}

// Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations. If this value is not known, it should be omitted (rather than specifying a possibly incorrect default). Examples: "zh-Hant", "ja", "ja-Latn", "en".
func (o PostalAddressResponseOutput) LanguageCode() pulumi.StringOutput {
	return o.ApplyT(func(v PostalAddressResponse) string { return v.LanguageCode }).(pulumi.StringOutput)
}

// Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
func (o PostalAddressResponseOutput) Locality() pulumi.StringOutput {
	return o.ApplyT(func(v PostalAddressResponse) string { return v.Locality }).(pulumi.StringOutput)
}

// Optional. The name of the organization at the address.
func (o PostalAddressResponseOutput) Organization() pulumi.StringOutput {
	return o.ApplyT(func(v PostalAddressResponse) string { return v.Organization }).(pulumi.StringOutput)
}

// Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
func (o PostalAddressResponseOutput) PostalCode() pulumi.StringOutput {
	return o.ApplyT(func(v PostalAddressResponse) string { return v.PostalCode }).(pulumi.StringOutput)
}

// Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain "care of" information.
func (o PostalAddressResponseOutput) Recipients() pulumi.StringArrayOutput {
	return o.ApplyT(func(v PostalAddressResponse) []string { return v.Recipients }).(pulumi.StringArrayOutput)
}

// Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See http://cldr.unicode.org/ and http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.
func (o PostalAddressResponseOutput) RegionCode() pulumi.StringOutput {
	return o.ApplyT(func(v PostalAddressResponse) string { return v.RegionCode }).(pulumi.StringOutput)
}

// The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision. All new revisions **must** be backward compatible with old revisions.
func (o PostalAddressResponseOutput) Revision() pulumi.IntOutput {
	return o.ApplyT(func(v PostalAddressResponse) int { return v.Revision }).(pulumi.IntOutput)
}

// Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number alone, representing the "sector code" (Jamaica), "delivery area indicator" (Malawi) or "post office indicator" (e.g. Cte d'Ivoire).
func (o PostalAddressResponseOutput) SortingCode() pulumi.StringOutput {
	return o.ApplyT(func(v PostalAddressResponse) string { return v.SortingCode }).(pulumi.StringOutput)
}

// Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
func (o PostalAddressResponseOutput) Sublocality() pulumi.StringOutput {
	return o.ApplyT(func(v PostalAddressResponse) string { return v.Sublocality }).(pulumi.StringOutput)
}

type PostalAddressResponsePtrOutput struct{ *pulumi.OutputState }

func (PostalAddressResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PostalAddressResponse)(nil)).Elem()
}

func (o PostalAddressResponsePtrOutput) ToPostalAddressResponsePtrOutput() PostalAddressResponsePtrOutput {
	return o
}

func (o PostalAddressResponsePtrOutput) ToPostalAddressResponsePtrOutputWithContext(ctx context.Context) PostalAddressResponsePtrOutput {
	return o
}

func (o PostalAddressResponsePtrOutput) Elem() PostalAddressResponseOutput {
	return o.ApplyT(func(v *PostalAddressResponse) PostalAddressResponse { return *v }).(PostalAddressResponseOutput)
}

// Unstructured address lines describing the lower levels of an address. Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way, the most specific line of an address can be selected based on the language. The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved. Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
func (o PostalAddressResponsePtrOutput) AddressLines() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *PostalAddressResponse) []string {
		if v == nil {
			return nil
		}
		return v.AddressLines
	}).(pulumi.StringArrayOutput)
}

// Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
func (o PostalAddressResponsePtrOutput) AdministrativeArea() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddressResponse) *string {
		if v == nil {
			return nil
		}
		return &v.AdministrativeArea
	}).(pulumi.StringPtrOutput)
}

// Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations. If this value is not known, it should be omitted (rather than specifying a possibly incorrect default). Examples: "zh-Hant", "ja", "ja-Latn", "en".
func (o PostalAddressResponsePtrOutput) LanguageCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddressResponse) *string {
		if v == nil {
			return nil
		}
		return &v.LanguageCode
	}).(pulumi.StringPtrOutput)
}

// Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
func (o PostalAddressResponsePtrOutput) Locality() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddressResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Locality
	}).(pulumi.StringPtrOutput)
}

// Optional. The name of the organization at the address.
func (o PostalAddressResponsePtrOutput) Organization() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddressResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Organization
	}).(pulumi.StringPtrOutput)
}

// Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
func (o PostalAddressResponsePtrOutput) PostalCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddressResponse) *string {
		if v == nil {
			return nil
		}
		return &v.PostalCode
	}).(pulumi.StringPtrOutput)
}

// Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain "care of" information.
func (o PostalAddressResponsePtrOutput) Recipients() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *PostalAddressResponse) []string {
		if v == nil {
			return nil
		}
		return v.Recipients
	}).(pulumi.StringArrayOutput)
}

// Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See http://cldr.unicode.org/ and http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.
func (o PostalAddressResponsePtrOutput) RegionCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddressResponse) *string {
		if v == nil {
			return nil
		}
		return &v.RegionCode
	}).(pulumi.StringPtrOutput)
}

// The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision. All new revisions **must** be backward compatible with old revisions.
func (o PostalAddressResponsePtrOutput) Revision() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PostalAddressResponse) *int {
		if v == nil {
			return nil
		}
		return &v.Revision
	}).(pulumi.IntPtrOutput)
}

// Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number alone, representing the "sector code" (Jamaica), "delivery area indicator" (Malawi) or "post office indicator" (e.g. Cte d'Ivoire).
func (o PostalAddressResponsePtrOutput) SortingCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddressResponse) *string {
		if v == nil {
			return nil
		}
		return &v.SortingCode
	}).(pulumi.StringPtrOutput)
}

// Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
func (o PostalAddressResponsePtrOutput) Sublocality() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddressResponse) *string {
		if v == nil {
			return nil
		}
		return &v.Sublocality
	}).(pulumi.StringPtrOutput)
}

// Input only. Options for job processing.
type ProcessingOptions struct {
	// Optional. If set to `true`, the service does not attempt to resolve a more precise address for the job.
	DisableStreetAddressResolution *bool `pulumi:"disableStreetAddressResolution"`
	// Optional. Option for job HTML content sanitization. Applied fields are: * description * applicationInfo.instruction * incentives * qualifications * responsibilities HTML tags in these fields may be stripped if sanitiazation is not disabled. Defaults to HtmlSanitization.SIMPLE_FORMATTING_ONLY.
	HtmlSanitization *string `pulumi:"htmlSanitization"`
}

// ProcessingOptionsInput is an input type that accepts ProcessingOptionsArgs and ProcessingOptionsOutput values.
// You can construct a concrete instance of `ProcessingOptionsInput` via:
//
//          ProcessingOptionsArgs{...}
type ProcessingOptionsInput interface {
	pulumi.Input

	ToProcessingOptionsOutput() ProcessingOptionsOutput
	ToProcessingOptionsOutputWithContext(context.Context) ProcessingOptionsOutput
}

// Input only. Options for job processing.
type ProcessingOptionsArgs struct {
	// Optional. If set to `true`, the service does not attempt to resolve a more precise address for the job.
	DisableStreetAddressResolution pulumi.BoolPtrInput `pulumi:"disableStreetAddressResolution"`
	// Optional. Option for job HTML content sanitization. Applied fields are: * description * applicationInfo.instruction * incentives * qualifications * responsibilities HTML tags in these fields may be stripped if sanitiazation is not disabled. Defaults to HtmlSanitization.SIMPLE_FORMATTING_ONLY.
	HtmlSanitization pulumi.StringPtrInput `pulumi:"htmlSanitization"`
}

func (ProcessingOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ProcessingOptions)(nil)).Elem()
}

func (i ProcessingOptionsArgs) ToProcessingOptionsOutput() ProcessingOptionsOutput {
	return i.ToProcessingOptionsOutputWithContext(context.Background())
}

func (i ProcessingOptionsArgs) ToProcessingOptionsOutputWithContext(ctx context.Context) ProcessingOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProcessingOptionsOutput)
}

func (i ProcessingOptionsArgs) ToProcessingOptionsPtrOutput() ProcessingOptionsPtrOutput {
	return i.ToProcessingOptionsPtrOutputWithContext(context.Background())
}

func (i ProcessingOptionsArgs) ToProcessingOptionsPtrOutputWithContext(ctx context.Context) ProcessingOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProcessingOptionsOutput).ToProcessingOptionsPtrOutputWithContext(ctx)
}

// ProcessingOptionsPtrInput is an input type that accepts ProcessingOptionsArgs, ProcessingOptionsPtr and ProcessingOptionsPtrOutput values.
// You can construct a concrete instance of `ProcessingOptionsPtrInput` via:
//
//          ProcessingOptionsArgs{...}
//
//  or:
//
//          nil
type ProcessingOptionsPtrInput interface {
	pulumi.Input

	ToProcessingOptionsPtrOutput() ProcessingOptionsPtrOutput
	ToProcessingOptionsPtrOutputWithContext(context.Context) ProcessingOptionsPtrOutput
}

type processingOptionsPtrType ProcessingOptionsArgs

func ProcessingOptionsPtr(v *ProcessingOptionsArgs) ProcessingOptionsPtrInput {
	return (*processingOptionsPtrType)(v)
}

func (*processingOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ProcessingOptions)(nil)).Elem()
}

func (i *processingOptionsPtrType) ToProcessingOptionsPtrOutput() ProcessingOptionsPtrOutput {
	return i.ToProcessingOptionsPtrOutputWithContext(context.Background())
}

func (i *processingOptionsPtrType) ToProcessingOptionsPtrOutputWithContext(ctx context.Context) ProcessingOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProcessingOptionsPtrOutput)
}

// Input only. Options for job processing.
type ProcessingOptionsOutput struct{ *pulumi.OutputState }

func (ProcessingOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ProcessingOptions)(nil)).Elem()
}

func (o ProcessingOptionsOutput) ToProcessingOptionsOutput() ProcessingOptionsOutput {
	return o
}

func (o ProcessingOptionsOutput) ToProcessingOptionsOutputWithContext(ctx context.Context) ProcessingOptionsOutput {
	return o
}

func (o ProcessingOptionsOutput) ToProcessingOptionsPtrOutput() ProcessingOptionsPtrOutput {
	return o.ToProcessingOptionsPtrOutputWithContext(context.Background())
}

func (o ProcessingOptionsOutput) ToProcessingOptionsPtrOutputWithContext(ctx context.Context) ProcessingOptionsPtrOutput {
	return o.ApplyT(func(v ProcessingOptions) *ProcessingOptions {
		return &v
	}).(ProcessingOptionsPtrOutput)
}

// Optional. If set to `true`, the service does not attempt to resolve a more precise address for the job.
func (o ProcessingOptionsOutput) DisableStreetAddressResolution() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ProcessingOptions) *bool { return v.DisableStreetAddressResolution }).(pulumi.BoolPtrOutput)
}

// Optional. Option for job HTML content sanitization. Applied fields are: * description * applicationInfo.instruction * incentives * qualifications * responsibilities HTML tags in these fields may be stripped if sanitiazation is not disabled. Defaults to HtmlSanitization.SIMPLE_FORMATTING_ONLY.
func (o ProcessingOptionsOutput) HtmlSanitization() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ProcessingOptions) *string { return v.HtmlSanitization }).(pulumi.StringPtrOutput)
}

type ProcessingOptionsPtrOutput struct{ *pulumi.OutputState }

func (ProcessingOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ProcessingOptions)(nil)).Elem()
}

func (o ProcessingOptionsPtrOutput) ToProcessingOptionsPtrOutput() ProcessingOptionsPtrOutput {
	return o
}

func (o ProcessingOptionsPtrOutput) ToProcessingOptionsPtrOutputWithContext(ctx context.Context) ProcessingOptionsPtrOutput {
	return o
}

func (o ProcessingOptionsPtrOutput) Elem() ProcessingOptionsOutput {
	return o.ApplyT(func(v *ProcessingOptions) ProcessingOptions { return *v }).(ProcessingOptionsOutput)
}

// Optional. If set to `true`, the service does not attempt to resolve a more precise address for the job.
func (o ProcessingOptionsPtrOutput) DisableStreetAddressResolution() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ProcessingOptions) *bool {
		if v == nil {
			return nil
		}
		return v.DisableStreetAddressResolution
	}).(pulumi.BoolPtrOutput)
}

// Optional. Option for job HTML content sanitization. Applied fields are: * description * applicationInfo.instruction * incentives * qualifications * responsibilities HTML tags in these fields may be stripped if sanitiazation is not disabled. Defaults to HtmlSanitization.SIMPLE_FORMATTING_ONLY.
func (o ProcessingOptionsPtrOutput) HtmlSanitization() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ProcessingOptions) *string {
		if v == nil {
			return nil
		}
		return v.HtmlSanitization
	}).(pulumi.StringPtrOutput)
}

// Input only. Options for job processing.
type ProcessingOptionsResponse struct {
	// Optional. If set to `true`, the service does not attempt to resolve a more precise address for the job.
	DisableStreetAddressResolution bool `pulumi:"disableStreetAddressResolution"`
	// Optional. Option for job HTML content sanitization. Applied fields are: * description * applicationInfo.instruction * incentives * qualifications * responsibilities HTML tags in these fields may be stripped if sanitiazation is not disabled. Defaults to HtmlSanitization.SIMPLE_FORMATTING_ONLY.
	HtmlSanitization string `pulumi:"htmlSanitization"`
}

// ProcessingOptionsResponseInput is an input type that accepts ProcessingOptionsResponseArgs and ProcessingOptionsResponseOutput values.
// You can construct a concrete instance of `ProcessingOptionsResponseInput` via:
//
//          ProcessingOptionsResponseArgs{...}
type ProcessingOptionsResponseInput interface {
	pulumi.Input

	ToProcessingOptionsResponseOutput() ProcessingOptionsResponseOutput
	ToProcessingOptionsResponseOutputWithContext(context.Context) ProcessingOptionsResponseOutput
}

// Input only. Options for job processing.
type ProcessingOptionsResponseArgs struct {
	// Optional. If set to `true`, the service does not attempt to resolve a more precise address for the job.
	DisableStreetAddressResolution pulumi.BoolInput `pulumi:"disableStreetAddressResolution"`
	// Optional. Option for job HTML content sanitization. Applied fields are: * description * applicationInfo.instruction * incentives * qualifications * responsibilities HTML tags in these fields may be stripped if sanitiazation is not disabled. Defaults to HtmlSanitization.SIMPLE_FORMATTING_ONLY.
	HtmlSanitization pulumi.StringInput `pulumi:"htmlSanitization"`
}

func (ProcessingOptionsResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ProcessingOptionsResponse)(nil)).Elem()
}

func (i ProcessingOptionsResponseArgs) ToProcessingOptionsResponseOutput() ProcessingOptionsResponseOutput {
	return i.ToProcessingOptionsResponseOutputWithContext(context.Background())
}

func (i ProcessingOptionsResponseArgs) ToProcessingOptionsResponseOutputWithContext(ctx context.Context) ProcessingOptionsResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProcessingOptionsResponseOutput)
}

func (i ProcessingOptionsResponseArgs) ToProcessingOptionsResponsePtrOutput() ProcessingOptionsResponsePtrOutput {
	return i.ToProcessingOptionsResponsePtrOutputWithContext(context.Background())
}

func (i ProcessingOptionsResponseArgs) ToProcessingOptionsResponsePtrOutputWithContext(ctx context.Context) ProcessingOptionsResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProcessingOptionsResponseOutput).ToProcessingOptionsResponsePtrOutputWithContext(ctx)
}

// ProcessingOptionsResponsePtrInput is an input type that accepts ProcessingOptionsResponseArgs, ProcessingOptionsResponsePtr and ProcessingOptionsResponsePtrOutput values.
// You can construct a concrete instance of `ProcessingOptionsResponsePtrInput` via:
//
//          ProcessingOptionsResponseArgs{...}
//
//  or:
//
//          nil
type ProcessingOptionsResponsePtrInput interface {
	pulumi.Input

	ToProcessingOptionsResponsePtrOutput() ProcessingOptionsResponsePtrOutput
	ToProcessingOptionsResponsePtrOutputWithContext(context.Context) ProcessingOptionsResponsePtrOutput
}

type processingOptionsResponsePtrType ProcessingOptionsResponseArgs

func ProcessingOptionsResponsePtr(v *ProcessingOptionsResponseArgs) ProcessingOptionsResponsePtrInput {
	return (*processingOptionsResponsePtrType)(v)
}

func (*processingOptionsResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ProcessingOptionsResponse)(nil)).Elem()
}

func (i *processingOptionsResponsePtrType) ToProcessingOptionsResponsePtrOutput() ProcessingOptionsResponsePtrOutput {
	return i.ToProcessingOptionsResponsePtrOutputWithContext(context.Background())
}

func (i *processingOptionsResponsePtrType) ToProcessingOptionsResponsePtrOutputWithContext(ctx context.Context) ProcessingOptionsResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProcessingOptionsResponsePtrOutput)
}

// Input only. Options for job processing.
type ProcessingOptionsResponseOutput struct{ *pulumi.OutputState }

func (ProcessingOptionsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ProcessingOptionsResponse)(nil)).Elem()
}

func (o ProcessingOptionsResponseOutput) ToProcessingOptionsResponseOutput() ProcessingOptionsResponseOutput {
	return o
}

func (o ProcessingOptionsResponseOutput) ToProcessingOptionsResponseOutputWithContext(ctx context.Context) ProcessingOptionsResponseOutput {
	return o
}

func (o ProcessingOptionsResponseOutput) ToProcessingOptionsResponsePtrOutput() ProcessingOptionsResponsePtrOutput {
	return o.ToProcessingOptionsResponsePtrOutputWithContext(context.Background())
}

func (o ProcessingOptionsResponseOutput) ToProcessingOptionsResponsePtrOutputWithContext(ctx context.Context) ProcessingOptionsResponsePtrOutput {
	return o.ApplyT(func(v ProcessingOptionsResponse) *ProcessingOptionsResponse {
		return &v
	}).(ProcessingOptionsResponsePtrOutput)
}

// Optional. If set to `true`, the service does not attempt to resolve a more precise address for the job.
func (o ProcessingOptionsResponseOutput) DisableStreetAddressResolution() pulumi.BoolOutput {
	return o.ApplyT(func(v ProcessingOptionsResponse) bool { return v.DisableStreetAddressResolution }).(pulumi.BoolOutput)
}

// Optional. Option for job HTML content sanitization. Applied fields are: * description * applicationInfo.instruction * incentives * qualifications * responsibilities HTML tags in these fields may be stripped if sanitiazation is not disabled. Defaults to HtmlSanitization.SIMPLE_FORMATTING_ONLY.
func (o ProcessingOptionsResponseOutput) HtmlSanitization() pulumi.StringOutput {
	return o.ApplyT(func(v ProcessingOptionsResponse) string { return v.HtmlSanitization }).(pulumi.StringOutput)
}

type ProcessingOptionsResponsePtrOutput struct{ *pulumi.OutputState }

func (ProcessingOptionsResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ProcessingOptionsResponse)(nil)).Elem()
}

func (o ProcessingOptionsResponsePtrOutput) ToProcessingOptionsResponsePtrOutput() ProcessingOptionsResponsePtrOutput {
	return o
}

func (o ProcessingOptionsResponsePtrOutput) ToProcessingOptionsResponsePtrOutputWithContext(ctx context.Context) ProcessingOptionsResponsePtrOutput {
	return o
}

func (o ProcessingOptionsResponsePtrOutput) Elem() ProcessingOptionsResponseOutput {
	return o.ApplyT(func(v *ProcessingOptionsResponse) ProcessingOptionsResponse { return *v }).(ProcessingOptionsResponseOutput)
}

// Optional. If set to `true`, the service does not attempt to resolve a more precise address for the job.
func (o ProcessingOptionsResponsePtrOutput) DisableStreetAddressResolution() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ProcessingOptionsResponse) *bool {
		if v == nil {
			return nil
		}
		return &v.DisableStreetAddressResolution
	}).(pulumi.BoolPtrOutput)
}

// Optional. Option for job HTML content sanitization. Applied fields are: * description * applicationInfo.instruction * incentives * qualifications * responsibilities HTML tags in these fields may be stripped if sanitiazation is not disabled. Defaults to HtmlSanitization.SIMPLE_FORMATTING_ONLY.
func (o ProcessingOptionsResponsePtrOutput) HtmlSanitization() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ProcessingOptionsResponse) *string {
		if v == nil {
			return nil
		}
		return &v.HtmlSanitization
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterOutputType(ApplicationInfoOutput{})
	pulumi.RegisterOutputType(ApplicationInfoPtrOutput{})
	pulumi.RegisterOutputType(ApplicationInfoResponseOutput{})
	pulumi.RegisterOutputType(ApplicationInfoResponsePtrOutput{})
	pulumi.RegisterOutputType(ClientEventTypeOutput{})
	pulumi.RegisterOutputType(ClientEventTypePtrOutput{})
	pulumi.RegisterOutputType(CompanyTypeOutput{})
	pulumi.RegisterOutputType(CompanyTypePtrOutput{})
	pulumi.RegisterOutputType(CompanyDerivedInfoOutput{})
	pulumi.RegisterOutputType(CompanyDerivedInfoPtrOutput{})
	pulumi.RegisterOutputType(CompanyDerivedInfoResponseOutput{})
	pulumi.RegisterOutputType(CompanyDerivedInfoResponsePtrOutput{})
	pulumi.RegisterOutputType(CompensationEntryOutput{})
	pulumi.RegisterOutputType(CompensationEntryArrayOutput{})
	pulumi.RegisterOutputType(CompensationEntryResponseOutput{})
	pulumi.RegisterOutputType(CompensationEntryResponseArrayOutput{})
	pulumi.RegisterOutputType(CompensationInfoOutput{})
	pulumi.RegisterOutputType(CompensationInfoPtrOutput{})
	pulumi.RegisterOutputType(CompensationInfoResponseOutput{})
	pulumi.RegisterOutputType(CompensationInfoResponsePtrOutput{})
	pulumi.RegisterOutputType(CompensationRangeOutput{})
	pulumi.RegisterOutputType(CompensationRangePtrOutput{})
	pulumi.RegisterOutputType(CompensationRangeResponseOutput{})
	pulumi.RegisterOutputType(CompensationRangeResponsePtrOutput{})
	pulumi.RegisterOutputType(JobTypeOutput{})
	pulumi.RegisterOutputType(JobTypePtrOutput{})
	pulumi.RegisterOutputType(JobDerivedInfoOutput{})
	pulumi.RegisterOutputType(JobDerivedInfoPtrOutput{})
	pulumi.RegisterOutputType(JobDerivedInfoResponseOutput{})
	pulumi.RegisterOutputType(JobDerivedInfoResponsePtrOutput{})
	pulumi.RegisterOutputType(JobEventOutput{})
	pulumi.RegisterOutputType(JobEventPtrOutput{})
	pulumi.RegisterOutputType(LatLngOutput{})
	pulumi.RegisterOutputType(LatLngPtrOutput{})
	pulumi.RegisterOutputType(LatLngResponseOutput{})
	pulumi.RegisterOutputType(LatLngResponsePtrOutput{})
	pulumi.RegisterOutputType(LocationOutput{})
	pulumi.RegisterOutputType(LocationPtrOutput{})
	pulumi.RegisterOutputType(LocationArrayOutput{})
	pulumi.RegisterOutputType(LocationResponseOutput{})
	pulumi.RegisterOutputType(LocationResponsePtrOutput{})
	pulumi.RegisterOutputType(LocationResponseArrayOutput{})
	pulumi.RegisterOutputType(MoneyOutput{})
	pulumi.RegisterOutputType(MoneyPtrOutput{})
	pulumi.RegisterOutputType(MoneyResponseOutput{})
	pulumi.RegisterOutputType(MoneyResponsePtrOutput{})
	pulumi.RegisterOutputType(PostalAddressOutput{})
	pulumi.RegisterOutputType(PostalAddressPtrOutput{})
	pulumi.RegisterOutputType(PostalAddressResponseOutput{})
	pulumi.RegisterOutputType(PostalAddressResponsePtrOutput{})
	pulumi.RegisterOutputType(ProcessingOptionsOutput{})
	pulumi.RegisterOutputType(ProcessingOptionsPtrOutput{})
	pulumi.RegisterOutputType(ProcessingOptionsResponseOutput{})
	pulumi.RegisterOutputType(ProcessingOptionsResponsePtrOutput{})
}
