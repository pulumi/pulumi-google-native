// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v4

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

// Application related details of a job posting.
type ApplicationInfo struct {
	// Use this field to specify email address(es) to which resumes or applications can be sent. The maximum number of allowed characters for each entry is 255.
	Emails []string `pulumi:"emails"`
	// Use this field to provide instructions, such as "Mail your application to ...", that a candidate can follow to apply for the job. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 3,000.
	Instruction *string `pulumi:"instruction"`
	// Use this URI field to direct an applicant to a website, for example to link to an online application form. The maximum number of allowed characters for each entry is 2,000.
	Uris []string `pulumi:"uris"`
}

// ApplicationInfoInput is an input type that accepts ApplicationInfoArgs and ApplicationInfoOutput values.
// You can construct a concrete instance of `ApplicationInfoInput` via:
//
//          ApplicationInfoArgs{...}
type ApplicationInfoInput interface {
	pulumi.Input

	ToApplicationInfoOutput() ApplicationInfoOutput
	ToApplicationInfoOutputWithContext(context.Context) ApplicationInfoOutput
}

// Application related details of a job posting.
type ApplicationInfoArgs struct {
	// Use this field to specify email address(es) to which resumes or applications can be sent. The maximum number of allowed characters for each entry is 255.
	Emails pulumi.StringArrayInput `pulumi:"emails"`
	// Use this field to provide instructions, such as "Mail your application to ...", that a candidate can follow to apply for the job. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 3,000.
	Instruction pulumi.StringPtrInput `pulumi:"instruction"`
	// Use this URI field to direct an applicant to a website, for example to link to an online application form. The maximum number of allowed characters for each entry is 2,000.
	Uris pulumi.StringArrayInput `pulumi:"uris"`
}

func (ApplicationInfoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationInfo)(nil)).Elem()
}

func (i ApplicationInfoArgs) ToApplicationInfoOutput() ApplicationInfoOutput {
	return i.ToApplicationInfoOutputWithContext(context.Background())
}

func (i ApplicationInfoArgs) ToApplicationInfoOutputWithContext(ctx context.Context) ApplicationInfoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationInfoOutput)
}

func (i ApplicationInfoArgs) ToApplicationInfoPtrOutput() ApplicationInfoPtrOutput {
	return i.ToApplicationInfoPtrOutputWithContext(context.Background())
}

func (i ApplicationInfoArgs) ToApplicationInfoPtrOutputWithContext(ctx context.Context) ApplicationInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationInfoOutput).ToApplicationInfoPtrOutputWithContext(ctx)
}

// ApplicationInfoPtrInput is an input type that accepts ApplicationInfoArgs, ApplicationInfoPtr and ApplicationInfoPtrOutput values.
// You can construct a concrete instance of `ApplicationInfoPtrInput` via:
//
//          ApplicationInfoArgs{...}
//
//  or:
//
//          nil
type ApplicationInfoPtrInput interface {
	pulumi.Input

	ToApplicationInfoPtrOutput() ApplicationInfoPtrOutput
	ToApplicationInfoPtrOutputWithContext(context.Context) ApplicationInfoPtrOutput
}

type applicationInfoPtrType ApplicationInfoArgs

func ApplicationInfoPtr(v *ApplicationInfoArgs) ApplicationInfoPtrInput {
	return (*applicationInfoPtrType)(v)
}

func (*applicationInfoPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationInfo)(nil)).Elem()
}

func (i *applicationInfoPtrType) ToApplicationInfoPtrOutput() ApplicationInfoPtrOutput {
	return i.ToApplicationInfoPtrOutputWithContext(context.Background())
}

func (i *applicationInfoPtrType) ToApplicationInfoPtrOutputWithContext(ctx context.Context) ApplicationInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplicationInfoPtrOutput)
}

// Application related details of a job posting.
type ApplicationInfoOutput struct{ *pulumi.OutputState }

func (ApplicationInfoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ApplicationInfo)(nil)).Elem()
}

func (o ApplicationInfoOutput) ToApplicationInfoOutput() ApplicationInfoOutput {
	return o
}

func (o ApplicationInfoOutput) ToApplicationInfoOutputWithContext(ctx context.Context) ApplicationInfoOutput {
	return o
}

func (o ApplicationInfoOutput) ToApplicationInfoPtrOutput() ApplicationInfoPtrOutput {
	return o.ToApplicationInfoPtrOutputWithContext(context.Background())
}

func (o ApplicationInfoOutput) ToApplicationInfoPtrOutputWithContext(ctx context.Context) ApplicationInfoPtrOutput {
	return o.ApplyT(func(v ApplicationInfo) *ApplicationInfo {
		return &v
	}).(ApplicationInfoPtrOutput)
}

// Use this field to specify email address(es) to which resumes or applications can be sent. The maximum number of allowed characters for each entry is 255.
func (o ApplicationInfoOutput) Emails() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ApplicationInfo) []string { return v.Emails }).(pulumi.StringArrayOutput)
}

// Use this field to provide instructions, such as "Mail your application to ...", that a candidate can follow to apply for the job. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 3,000.
func (o ApplicationInfoOutput) Instruction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ApplicationInfo) *string { return v.Instruction }).(pulumi.StringPtrOutput)
}

// Use this URI field to direct an applicant to a website, for example to link to an online application form. The maximum number of allowed characters for each entry is 2,000.
func (o ApplicationInfoOutput) Uris() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ApplicationInfo) []string { return v.Uris }).(pulumi.StringArrayOutput)
}

type ApplicationInfoPtrOutput struct{ *pulumi.OutputState }

func (ApplicationInfoPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplicationInfo)(nil)).Elem()
}

func (o ApplicationInfoPtrOutput) ToApplicationInfoPtrOutput() ApplicationInfoPtrOutput {
	return o
}

func (o ApplicationInfoPtrOutput) ToApplicationInfoPtrOutputWithContext(ctx context.Context) ApplicationInfoPtrOutput {
	return o
}

func (o ApplicationInfoPtrOutput) Elem() ApplicationInfoOutput {
	return o.ApplyT(func(v *ApplicationInfo) ApplicationInfo { return *v }).(ApplicationInfoOutput)
}

// Use this field to specify email address(es) to which resumes or applications can be sent. The maximum number of allowed characters for each entry is 255.
func (o ApplicationInfoPtrOutput) Emails() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ApplicationInfo) []string {
		if v == nil {
			return nil
		}
		return v.Emails
	}).(pulumi.StringArrayOutput)
}

// Use this field to provide instructions, such as "Mail your application to ...", that a candidate can follow to apply for the job. This field accepts and sanitizes HTML input, and also accepts bold, italic, ordered list, and unordered list markup tags. The maximum number of allowed characters is 3,000.
func (o ApplicationInfoPtrOutput) Instruction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ApplicationInfo) *string {
		if v == nil {
			return nil
		}
		return v.Instruction
	}).(pulumi.StringPtrOutput)
}

// Use this URI field to direct an applicant to a website, for example to link to an online application form. The maximum number of allowed characters for each entry is 2,000.
func (o ApplicationInfoPtrOutput) Uris() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ApplicationInfo) []string {
		if v == nil {
			return nil
		}
		return v.Uris
	}).(pulumi.StringArrayOutput)
}

// Derived details about the company.
type CompanyDerivedInfo struct {
	// A structured headquarters location of the company, resolved from Company.headquarters_address if provided.
	HeadquartersLocation *Location `pulumi:"headquartersLocation"`
}

// CompanyDerivedInfoInput is an input type that accepts CompanyDerivedInfoArgs and CompanyDerivedInfoOutput values.
// You can construct a concrete instance of `CompanyDerivedInfoInput` via:
//
//          CompanyDerivedInfoArgs{...}
type CompanyDerivedInfoInput interface {
	pulumi.Input

	ToCompanyDerivedInfoOutput() CompanyDerivedInfoOutput
	ToCompanyDerivedInfoOutputWithContext(context.Context) CompanyDerivedInfoOutput
}

// Derived details about the company.
type CompanyDerivedInfoArgs struct {
	// A structured headquarters location of the company, resolved from Company.headquarters_address if provided.
	HeadquartersLocation LocationPtrInput `pulumi:"headquartersLocation"`
}

func (CompanyDerivedInfoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CompanyDerivedInfo)(nil)).Elem()
}

func (i CompanyDerivedInfoArgs) ToCompanyDerivedInfoOutput() CompanyDerivedInfoOutput {
	return i.ToCompanyDerivedInfoOutputWithContext(context.Background())
}

func (i CompanyDerivedInfoArgs) ToCompanyDerivedInfoOutputWithContext(ctx context.Context) CompanyDerivedInfoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompanyDerivedInfoOutput)
}

func (i CompanyDerivedInfoArgs) ToCompanyDerivedInfoPtrOutput() CompanyDerivedInfoPtrOutput {
	return i.ToCompanyDerivedInfoPtrOutputWithContext(context.Background())
}

func (i CompanyDerivedInfoArgs) ToCompanyDerivedInfoPtrOutputWithContext(ctx context.Context) CompanyDerivedInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompanyDerivedInfoOutput).ToCompanyDerivedInfoPtrOutputWithContext(ctx)
}

// CompanyDerivedInfoPtrInput is an input type that accepts CompanyDerivedInfoArgs, CompanyDerivedInfoPtr and CompanyDerivedInfoPtrOutput values.
// You can construct a concrete instance of `CompanyDerivedInfoPtrInput` via:
//
//          CompanyDerivedInfoArgs{...}
//
//  or:
//
//          nil
type CompanyDerivedInfoPtrInput interface {
	pulumi.Input

	ToCompanyDerivedInfoPtrOutput() CompanyDerivedInfoPtrOutput
	ToCompanyDerivedInfoPtrOutputWithContext(context.Context) CompanyDerivedInfoPtrOutput
}

type companyDerivedInfoPtrType CompanyDerivedInfoArgs

func CompanyDerivedInfoPtr(v *CompanyDerivedInfoArgs) CompanyDerivedInfoPtrInput {
	return (*companyDerivedInfoPtrType)(v)
}

func (*companyDerivedInfoPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CompanyDerivedInfo)(nil)).Elem()
}

func (i *companyDerivedInfoPtrType) ToCompanyDerivedInfoPtrOutput() CompanyDerivedInfoPtrOutput {
	return i.ToCompanyDerivedInfoPtrOutputWithContext(context.Background())
}

func (i *companyDerivedInfoPtrType) ToCompanyDerivedInfoPtrOutputWithContext(ctx context.Context) CompanyDerivedInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompanyDerivedInfoPtrOutput)
}

// Derived details about the company.
type CompanyDerivedInfoOutput struct{ *pulumi.OutputState }

func (CompanyDerivedInfoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompanyDerivedInfo)(nil)).Elem()
}

func (o CompanyDerivedInfoOutput) ToCompanyDerivedInfoOutput() CompanyDerivedInfoOutput {
	return o
}

func (o CompanyDerivedInfoOutput) ToCompanyDerivedInfoOutputWithContext(ctx context.Context) CompanyDerivedInfoOutput {
	return o
}

func (o CompanyDerivedInfoOutput) ToCompanyDerivedInfoPtrOutput() CompanyDerivedInfoPtrOutput {
	return o.ToCompanyDerivedInfoPtrOutputWithContext(context.Background())
}

func (o CompanyDerivedInfoOutput) ToCompanyDerivedInfoPtrOutputWithContext(ctx context.Context) CompanyDerivedInfoPtrOutput {
	return o.ApplyT(func(v CompanyDerivedInfo) *CompanyDerivedInfo {
		return &v
	}).(CompanyDerivedInfoPtrOutput)
}

// A structured headquarters location of the company, resolved from Company.headquarters_address if provided.
func (o CompanyDerivedInfoOutput) HeadquartersLocation() LocationPtrOutput {
	return o.ApplyT(func(v CompanyDerivedInfo) *Location { return v.HeadquartersLocation }).(LocationPtrOutput)
}

type CompanyDerivedInfoPtrOutput struct{ *pulumi.OutputState }

func (CompanyDerivedInfoPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CompanyDerivedInfo)(nil)).Elem()
}

func (o CompanyDerivedInfoPtrOutput) ToCompanyDerivedInfoPtrOutput() CompanyDerivedInfoPtrOutput {
	return o
}

func (o CompanyDerivedInfoPtrOutput) ToCompanyDerivedInfoPtrOutputWithContext(ctx context.Context) CompanyDerivedInfoPtrOutput {
	return o
}

func (o CompanyDerivedInfoPtrOutput) Elem() CompanyDerivedInfoOutput {
	return o.ApplyT(func(v *CompanyDerivedInfo) CompanyDerivedInfo { return *v }).(CompanyDerivedInfoOutput)
}

// A structured headquarters location of the company, resolved from Company.headquarters_address if provided.
func (o CompanyDerivedInfoPtrOutput) HeadquartersLocation() LocationPtrOutput {
	return o.ApplyT(func(v *CompanyDerivedInfo) *Location {
		if v == nil {
			return nil
		}
		return v.HeadquartersLocation
	}).(LocationPtrOutput)
}

// A compensation entry that represents one component of compensation, such as base pay, bonus, or other compensation type. Annualization: One compensation entry can be annualized if - it contains valid amount or range. - and its expected_units_per_year is set or can be derived. Its annualized range is determined as (amount or range) times expected_units_per_year.
type CompensationEntry struct {
	// Compensation amount.
	Amount *Money `pulumi:"amount"`
	// Compensation description. For example, could indicate equity terms or provide additional context to an estimated bonus.
	Description *string `pulumi:"description"`
	// Expected number of units paid each year. If not specified, when Job.employment_types is FULLTIME, a default value is inferred based on unit. Default values: - HOURLY: 2080 - DAILY: 260 - WEEKLY: 52 - MONTHLY: 12 - ANNUAL: 1
	ExpectedUnitsPerYear *float64 `pulumi:"expectedUnitsPerYear"`
	// Compensation range.
	Range *CompensationRange `pulumi:"range"`
	// Compensation type. Default is CompensationType.COMPENSATION_TYPE_UNSPECIFIED.
	Type *string `pulumi:"type"`
	// Frequency of the specified amount. Default is CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED.
	Unit *string `pulumi:"unit"`
}

// CompensationEntryInput is an input type that accepts CompensationEntryArgs and CompensationEntryOutput values.
// You can construct a concrete instance of `CompensationEntryInput` via:
//
//          CompensationEntryArgs{...}
type CompensationEntryInput interface {
	pulumi.Input

	ToCompensationEntryOutput() CompensationEntryOutput
	ToCompensationEntryOutputWithContext(context.Context) CompensationEntryOutput
}

// A compensation entry that represents one component of compensation, such as base pay, bonus, or other compensation type. Annualization: One compensation entry can be annualized if - it contains valid amount or range. - and its expected_units_per_year is set or can be derived. Its annualized range is determined as (amount or range) times expected_units_per_year.
type CompensationEntryArgs struct {
	// Compensation amount.
	Amount MoneyPtrInput `pulumi:"amount"`
	// Compensation description. For example, could indicate equity terms or provide additional context to an estimated bonus.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Expected number of units paid each year. If not specified, when Job.employment_types is FULLTIME, a default value is inferred based on unit. Default values: - HOURLY: 2080 - DAILY: 260 - WEEKLY: 52 - MONTHLY: 12 - ANNUAL: 1
	ExpectedUnitsPerYear pulumi.Float64PtrInput `pulumi:"expectedUnitsPerYear"`
	// Compensation range.
	Range CompensationRangePtrInput `pulumi:"range"`
	// Compensation type. Default is CompensationType.COMPENSATION_TYPE_UNSPECIFIED.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Frequency of the specified amount. Default is CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED.
	Unit pulumi.StringPtrInput `pulumi:"unit"`
}

func (CompensationEntryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationEntry)(nil)).Elem()
}

func (i CompensationEntryArgs) ToCompensationEntryOutput() CompensationEntryOutput {
	return i.ToCompensationEntryOutputWithContext(context.Background())
}

func (i CompensationEntryArgs) ToCompensationEntryOutputWithContext(ctx context.Context) CompensationEntryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationEntryOutput)
}

// CompensationEntryArrayInput is an input type that accepts CompensationEntryArray and CompensationEntryArrayOutput values.
// You can construct a concrete instance of `CompensationEntryArrayInput` via:
//
//          CompensationEntryArray{ CompensationEntryArgs{...} }
type CompensationEntryArrayInput interface {
	pulumi.Input

	ToCompensationEntryArrayOutput() CompensationEntryArrayOutput
	ToCompensationEntryArrayOutputWithContext(context.Context) CompensationEntryArrayOutput
}

type CompensationEntryArray []CompensationEntryInput

func (CompensationEntryArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CompensationEntry)(nil)).Elem()
}

func (i CompensationEntryArray) ToCompensationEntryArrayOutput() CompensationEntryArrayOutput {
	return i.ToCompensationEntryArrayOutputWithContext(context.Background())
}

func (i CompensationEntryArray) ToCompensationEntryArrayOutputWithContext(ctx context.Context) CompensationEntryArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationEntryArrayOutput)
}

// A compensation entry that represents one component of compensation, such as base pay, bonus, or other compensation type. Annualization: One compensation entry can be annualized if - it contains valid amount or range. - and its expected_units_per_year is set or can be derived. Its annualized range is determined as (amount or range) times expected_units_per_year.
type CompensationEntryOutput struct{ *pulumi.OutputState }

func (CompensationEntryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationEntry)(nil)).Elem()
}

func (o CompensationEntryOutput) ToCompensationEntryOutput() CompensationEntryOutput {
	return o
}

func (o CompensationEntryOutput) ToCompensationEntryOutputWithContext(ctx context.Context) CompensationEntryOutput {
	return o
}

// Compensation amount.
func (o CompensationEntryOutput) Amount() MoneyPtrOutput {
	return o.ApplyT(func(v CompensationEntry) *Money { return v.Amount }).(MoneyPtrOutput)
}

// Compensation description. For example, could indicate equity terms or provide additional context to an estimated bonus.
func (o CompensationEntryOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CompensationEntry) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Expected number of units paid each year. If not specified, when Job.employment_types is FULLTIME, a default value is inferred based on unit. Default values: - HOURLY: 2080 - DAILY: 260 - WEEKLY: 52 - MONTHLY: 12 - ANNUAL: 1
func (o CompensationEntryOutput) ExpectedUnitsPerYear() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v CompensationEntry) *float64 { return v.ExpectedUnitsPerYear }).(pulumi.Float64PtrOutput)
}

// Compensation range.
func (o CompensationEntryOutput) Range() CompensationRangePtrOutput {
	return o.ApplyT(func(v CompensationEntry) *CompensationRange { return v.Range }).(CompensationRangePtrOutput)
}

// Compensation type. Default is CompensationType.COMPENSATION_TYPE_UNSPECIFIED.
func (o CompensationEntryOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CompensationEntry) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Frequency of the specified amount. Default is CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED.
func (o CompensationEntryOutput) Unit() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CompensationEntry) *string { return v.Unit }).(pulumi.StringPtrOutput)
}

type CompensationEntryArrayOutput struct{ *pulumi.OutputState }

func (CompensationEntryArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CompensationEntry)(nil)).Elem()
}

func (o CompensationEntryArrayOutput) ToCompensationEntryArrayOutput() CompensationEntryArrayOutput {
	return o
}

func (o CompensationEntryArrayOutput) ToCompensationEntryArrayOutputWithContext(ctx context.Context) CompensationEntryArrayOutput {
	return o
}

func (o CompensationEntryArrayOutput) Index(i pulumi.IntInput) CompensationEntryOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CompensationEntry {
		return vs[0].([]CompensationEntry)[vs[1].(int)]
	}).(CompensationEntryOutput)
}

// Job compensation details.
type CompensationInfo struct {
	// Output only. Annualized base compensation range. Computed as base compensation entry's CompensationEntry.amount times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
	AnnualizedBaseCompensationRange *CompensationRange `pulumi:"annualizedBaseCompensationRange"`
	// Output only. Annualized total compensation range. Computed as all compensation entries' CompensationEntry.amount times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
	AnnualizedTotalCompensationRange *CompensationRange `pulumi:"annualizedTotalCompensationRange"`
	// Job compensation information. At most one entry can be of type CompensationInfo.CompensationType.BASE, which is referred as **base compensation entry** for the job.
	Entries []CompensationEntry `pulumi:"entries"`
}

// CompensationInfoInput is an input type that accepts CompensationInfoArgs and CompensationInfoOutput values.
// You can construct a concrete instance of `CompensationInfoInput` via:
//
//          CompensationInfoArgs{...}
type CompensationInfoInput interface {
	pulumi.Input

	ToCompensationInfoOutput() CompensationInfoOutput
	ToCompensationInfoOutputWithContext(context.Context) CompensationInfoOutput
}

// Job compensation details.
type CompensationInfoArgs struct {
	// Output only. Annualized base compensation range. Computed as base compensation entry's CompensationEntry.amount times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
	AnnualizedBaseCompensationRange CompensationRangePtrInput `pulumi:"annualizedBaseCompensationRange"`
	// Output only. Annualized total compensation range. Computed as all compensation entries' CompensationEntry.amount times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
	AnnualizedTotalCompensationRange CompensationRangePtrInput `pulumi:"annualizedTotalCompensationRange"`
	// Job compensation information. At most one entry can be of type CompensationInfo.CompensationType.BASE, which is referred as **base compensation entry** for the job.
	Entries CompensationEntryArrayInput `pulumi:"entries"`
}

func (CompensationInfoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationInfo)(nil)).Elem()
}

func (i CompensationInfoArgs) ToCompensationInfoOutput() CompensationInfoOutput {
	return i.ToCompensationInfoOutputWithContext(context.Background())
}

func (i CompensationInfoArgs) ToCompensationInfoOutputWithContext(ctx context.Context) CompensationInfoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationInfoOutput)
}

func (i CompensationInfoArgs) ToCompensationInfoPtrOutput() CompensationInfoPtrOutput {
	return i.ToCompensationInfoPtrOutputWithContext(context.Background())
}

func (i CompensationInfoArgs) ToCompensationInfoPtrOutputWithContext(ctx context.Context) CompensationInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationInfoOutput).ToCompensationInfoPtrOutputWithContext(ctx)
}

// CompensationInfoPtrInput is an input type that accepts CompensationInfoArgs, CompensationInfoPtr and CompensationInfoPtrOutput values.
// You can construct a concrete instance of `CompensationInfoPtrInput` via:
//
//          CompensationInfoArgs{...}
//
//  or:
//
//          nil
type CompensationInfoPtrInput interface {
	pulumi.Input

	ToCompensationInfoPtrOutput() CompensationInfoPtrOutput
	ToCompensationInfoPtrOutputWithContext(context.Context) CompensationInfoPtrOutput
}

type compensationInfoPtrType CompensationInfoArgs

func CompensationInfoPtr(v *CompensationInfoArgs) CompensationInfoPtrInput {
	return (*compensationInfoPtrType)(v)
}

func (*compensationInfoPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CompensationInfo)(nil)).Elem()
}

func (i *compensationInfoPtrType) ToCompensationInfoPtrOutput() CompensationInfoPtrOutput {
	return i.ToCompensationInfoPtrOutputWithContext(context.Background())
}

func (i *compensationInfoPtrType) ToCompensationInfoPtrOutputWithContext(ctx context.Context) CompensationInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationInfoPtrOutput)
}

// Job compensation details.
type CompensationInfoOutput struct{ *pulumi.OutputState }

func (CompensationInfoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationInfo)(nil)).Elem()
}

func (o CompensationInfoOutput) ToCompensationInfoOutput() CompensationInfoOutput {
	return o
}

func (o CompensationInfoOutput) ToCompensationInfoOutputWithContext(ctx context.Context) CompensationInfoOutput {
	return o
}

func (o CompensationInfoOutput) ToCompensationInfoPtrOutput() CompensationInfoPtrOutput {
	return o.ToCompensationInfoPtrOutputWithContext(context.Background())
}

func (o CompensationInfoOutput) ToCompensationInfoPtrOutputWithContext(ctx context.Context) CompensationInfoPtrOutput {
	return o.ApplyT(func(v CompensationInfo) *CompensationInfo {
		return &v
	}).(CompensationInfoPtrOutput)
}

// Output only. Annualized base compensation range. Computed as base compensation entry's CompensationEntry.amount times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
func (o CompensationInfoOutput) AnnualizedBaseCompensationRange() CompensationRangePtrOutput {
	return o.ApplyT(func(v CompensationInfo) *CompensationRange { return v.AnnualizedBaseCompensationRange }).(CompensationRangePtrOutput)
}

// Output only. Annualized total compensation range. Computed as all compensation entries' CompensationEntry.amount times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
func (o CompensationInfoOutput) AnnualizedTotalCompensationRange() CompensationRangePtrOutput {
	return o.ApplyT(func(v CompensationInfo) *CompensationRange { return v.AnnualizedTotalCompensationRange }).(CompensationRangePtrOutput)
}

// Job compensation information. At most one entry can be of type CompensationInfo.CompensationType.BASE, which is referred as **base compensation entry** for the job.
func (o CompensationInfoOutput) Entries() CompensationEntryArrayOutput {
	return o.ApplyT(func(v CompensationInfo) []CompensationEntry { return v.Entries }).(CompensationEntryArrayOutput)
}

type CompensationInfoPtrOutput struct{ *pulumi.OutputState }

func (CompensationInfoPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CompensationInfo)(nil)).Elem()
}

func (o CompensationInfoPtrOutput) ToCompensationInfoPtrOutput() CompensationInfoPtrOutput {
	return o
}

func (o CompensationInfoPtrOutput) ToCompensationInfoPtrOutputWithContext(ctx context.Context) CompensationInfoPtrOutput {
	return o
}

func (o CompensationInfoPtrOutput) Elem() CompensationInfoOutput {
	return o.ApplyT(func(v *CompensationInfo) CompensationInfo { return *v }).(CompensationInfoOutput)
}

// Output only. Annualized base compensation range. Computed as base compensation entry's CompensationEntry.amount times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
func (o CompensationInfoPtrOutput) AnnualizedBaseCompensationRange() CompensationRangePtrOutput {
	return o.ApplyT(func(v *CompensationInfo) *CompensationRange {
		if v == nil {
			return nil
		}
		return v.AnnualizedBaseCompensationRange
	}).(CompensationRangePtrOutput)
}

// Output only. Annualized total compensation range. Computed as all compensation entries' CompensationEntry.amount times CompensationEntry.expected_units_per_year. See CompensationEntry for explanation on compensation annualization.
func (o CompensationInfoPtrOutput) AnnualizedTotalCompensationRange() CompensationRangePtrOutput {
	return o.ApplyT(func(v *CompensationInfo) *CompensationRange {
		if v == nil {
			return nil
		}
		return v.AnnualizedTotalCompensationRange
	}).(CompensationRangePtrOutput)
}

// Job compensation information. At most one entry can be of type CompensationInfo.CompensationType.BASE, which is referred as **base compensation entry** for the job.
func (o CompensationInfoPtrOutput) Entries() CompensationEntryArrayOutput {
	return o.ApplyT(func(v *CompensationInfo) []CompensationEntry {
		if v == nil {
			return nil
		}
		return v.Entries
	}).(CompensationEntryArrayOutput)
}

// Compensation range.
type CompensationRange struct {
	// The maximum amount of compensation. If left empty, the value is set to a maximal compensation value and the currency code is set to match the currency code of min_compensation.
	MaxCompensation *Money `pulumi:"maxCompensation"`
	// The minimum amount of compensation. If left empty, the value is set to zero and the currency code is set to match the currency code of max_compensation.
	MinCompensation *Money `pulumi:"minCompensation"`
}

// CompensationRangeInput is an input type that accepts CompensationRangeArgs and CompensationRangeOutput values.
// You can construct a concrete instance of `CompensationRangeInput` via:
//
//          CompensationRangeArgs{...}
type CompensationRangeInput interface {
	pulumi.Input

	ToCompensationRangeOutput() CompensationRangeOutput
	ToCompensationRangeOutputWithContext(context.Context) CompensationRangeOutput
}

// Compensation range.
type CompensationRangeArgs struct {
	// The maximum amount of compensation. If left empty, the value is set to a maximal compensation value and the currency code is set to match the currency code of min_compensation.
	MaxCompensation MoneyPtrInput `pulumi:"maxCompensation"`
	// The minimum amount of compensation. If left empty, the value is set to zero and the currency code is set to match the currency code of max_compensation.
	MinCompensation MoneyPtrInput `pulumi:"minCompensation"`
}

func (CompensationRangeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationRange)(nil)).Elem()
}

func (i CompensationRangeArgs) ToCompensationRangeOutput() CompensationRangeOutput {
	return i.ToCompensationRangeOutputWithContext(context.Background())
}

func (i CompensationRangeArgs) ToCompensationRangeOutputWithContext(ctx context.Context) CompensationRangeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationRangeOutput)
}

func (i CompensationRangeArgs) ToCompensationRangePtrOutput() CompensationRangePtrOutput {
	return i.ToCompensationRangePtrOutputWithContext(context.Background())
}

func (i CompensationRangeArgs) ToCompensationRangePtrOutputWithContext(ctx context.Context) CompensationRangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationRangeOutput).ToCompensationRangePtrOutputWithContext(ctx)
}

// CompensationRangePtrInput is an input type that accepts CompensationRangeArgs, CompensationRangePtr and CompensationRangePtrOutput values.
// You can construct a concrete instance of `CompensationRangePtrInput` via:
//
//          CompensationRangeArgs{...}
//
//  or:
//
//          nil
type CompensationRangePtrInput interface {
	pulumi.Input

	ToCompensationRangePtrOutput() CompensationRangePtrOutput
	ToCompensationRangePtrOutputWithContext(context.Context) CompensationRangePtrOutput
}

type compensationRangePtrType CompensationRangeArgs

func CompensationRangePtr(v *CompensationRangeArgs) CompensationRangePtrInput {
	return (*compensationRangePtrType)(v)
}

func (*compensationRangePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CompensationRange)(nil)).Elem()
}

func (i *compensationRangePtrType) ToCompensationRangePtrOutput() CompensationRangePtrOutput {
	return i.ToCompensationRangePtrOutputWithContext(context.Background())
}

func (i *compensationRangePtrType) ToCompensationRangePtrOutputWithContext(ctx context.Context) CompensationRangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CompensationRangePtrOutput)
}

// Compensation range.
type CompensationRangeOutput struct{ *pulumi.OutputState }

func (CompensationRangeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CompensationRange)(nil)).Elem()
}

func (o CompensationRangeOutput) ToCompensationRangeOutput() CompensationRangeOutput {
	return o
}

func (o CompensationRangeOutput) ToCompensationRangeOutputWithContext(ctx context.Context) CompensationRangeOutput {
	return o
}

func (o CompensationRangeOutput) ToCompensationRangePtrOutput() CompensationRangePtrOutput {
	return o.ToCompensationRangePtrOutputWithContext(context.Background())
}

func (o CompensationRangeOutput) ToCompensationRangePtrOutputWithContext(ctx context.Context) CompensationRangePtrOutput {
	return o.ApplyT(func(v CompensationRange) *CompensationRange {
		return &v
	}).(CompensationRangePtrOutput)
}

// The maximum amount of compensation. If left empty, the value is set to a maximal compensation value and the currency code is set to match the currency code of min_compensation.
func (o CompensationRangeOutput) MaxCompensation() MoneyPtrOutput {
	return o.ApplyT(func(v CompensationRange) *Money { return v.MaxCompensation }).(MoneyPtrOutput)
}

// The minimum amount of compensation. If left empty, the value is set to zero and the currency code is set to match the currency code of max_compensation.
func (o CompensationRangeOutput) MinCompensation() MoneyPtrOutput {
	return o.ApplyT(func(v CompensationRange) *Money { return v.MinCompensation }).(MoneyPtrOutput)
}

type CompensationRangePtrOutput struct{ *pulumi.OutputState }

func (CompensationRangePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CompensationRange)(nil)).Elem()
}

func (o CompensationRangePtrOutput) ToCompensationRangePtrOutput() CompensationRangePtrOutput {
	return o
}

func (o CompensationRangePtrOutput) ToCompensationRangePtrOutputWithContext(ctx context.Context) CompensationRangePtrOutput {
	return o
}

func (o CompensationRangePtrOutput) Elem() CompensationRangeOutput {
	return o.ApplyT(func(v *CompensationRange) CompensationRange { return *v }).(CompensationRangeOutput)
}

// The maximum amount of compensation. If left empty, the value is set to a maximal compensation value and the currency code is set to match the currency code of min_compensation.
func (o CompensationRangePtrOutput) MaxCompensation() MoneyPtrOutput {
	return o.ApplyT(func(v *CompensationRange) *Money {
		if v == nil {
			return nil
		}
		return v.MaxCompensation
	}).(MoneyPtrOutput)
}

// The minimum amount of compensation. If left empty, the value is set to zero and the currency code is set to match the currency code of max_compensation.
func (o CompensationRangePtrOutput) MinCompensation() MoneyPtrOutput {
	return o.ApplyT(func(v *CompensationRange) *Money {
		if v == nil {
			return nil
		}
		return v.MinCompensation
	}).(MoneyPtrOutput)
}

// Derived details about the job posting.
type JobDerivedInfo struct {
	// Job categories derived from Job.title and Job.description.
	JobCategories []string `pulumi:"jobCategories"`
	// Structured locations of the job, resolved from Job.addresses. locations are exactly matched to Job.addresses in the same order.
	Locations []Location `pulumi:"locations"`
}

// JobDerivedInfoInput is an input type that accepts JobDerivedInfoArgs and JobDerivedInfoOutput values.
// You can construct a concrete instance of `JobDerivedInfoInput` via:
//
//          JobDerivedInfoArgs{...}
type JobDerivedInfoInput interface {
	pulumi.Input

	ToJobDerivedInfoOutput() JobDerivedInfoOutput
	ToJobDerivedInfoOutputWithContext(context.Context) JobDerivedInfoOutput
}

// Derived details about the job posting.
type JobDerivedInfoArgs struct {
	// Job categories derived from Job.title and Job.description.
	JobCategories pulumi.StringArrayInput `pulumi:"jobCategories"`
	// Structured locations of the job, resolved from Job.addresses. locations are exactly matched to Job.addresses in the same order.
	Locations LocationArrayInput `pulumi:"locations"`
}

func (JobDerivedInfoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*JobDerivedInfo)(nil)).Elem()
}

func (i JobDerivedInfoArgs) ToJobDerivedInfoOutput() JobDerivedInfoOutput {
	return i.ToJobDerivedInfoOutputWithContext(context.Background())
}

func (i JobDerivedInfoArgs) ToJobDerivedInfoOutputWithContext(ctx context.Context) JobDerivedInfoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobDerivedInfoOutput)
}

func (i JobDerivedInfoArgs) ToJobDerivedInfoPtrOutput() JobDerivedInfoPtrOutput {
	return i.ToJobDerivedInfoPtrOutputWithContext(context.Background())
}

func (i JobDerivedInfoArgs) ToJobDerivedInfoPtrOutputWithContext(ctx context.Context) JobDerivedInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobDerivedInfoOutput).ToJobDerivedInfoPtrOutputWithContext(ctx)
}

// JobDerivedInfoPtrInput is an input type that accepts JobDerivedInfoArgs, JobDerivedInfoPtr and JobDerivedInfoPtrOutput values.
// You can construct a concrete instance of `JobDerivedInfoPtrInput` via:
//
//          JobDerivedInfoArgs{...}
//
//  or:
//
//          nil
type JobDerivedInfoPtrInput interface {
	pulumi.Input

	ToJobDerivedInfoPtrOutput() JobDerivedInfoPtrOutput
	ToJobDerivedInfoPtrOutputWithContext(context.Context) JobDerivedInfoPtrOutput
}

type jobDerivedInfoPtrType JobDerivedInfoArgs

func JobDerivedInfoPtr(v *JobDerivedInfoArgs) JobDerivedInfoPtrInput {
	return (*jobDerivedInfoPtrType)(v)
}

func (*jobDerivedInfoPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**JobDerivedInfo)(nil)).Elem()
}

func (i *jobDerivedInfoPtrType) ToJobDerivedInfoPtrOutput() JobDerivedInfoPtrOutput {
	return i.ToJobDerivedInfoPtrOutputWithContext(context.Background())
}

func (i *jobDerivedInfoPtrType) ToJobDerivedInfoPtrOutputWithContext(ctx context.Context) JobDerivedInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobDerivedInfoPtrOutput)
}

// Derived details about the job posting.
type JobDerivedInfoOutput struct{ *pulumi.OutputState }

func (JobDerivedInfoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobDerivedInfo)(nil)).Elem()
}

func (o JobDerivedInfoOutput) ToJobDerivedInfoOutput() JobDerivedInfoOutput {
	return o
}

func (o JobDerivedInfoOutput) ToJobDerivedInfoOutputWithContext(ctx context.Context) JobDerivedInfoOutput {
	return o
}

func (o JobDerivedInfoOutput) ToJobDerivedInfoPtrOutput() JobDerivedInfoPtrOutput {
	return o.ToJobDerivedInfoPtrOutputWithContext(context.Background())
}

func (o JobDerivedInfoOutput) ToJobDerivedInfoPtrOutputWithContext(ctx context.Context) JobDerivedInfoPtrOutput {
	return o.ApplyT(func(v JobDerivedInfo) *JobDerivedInfo {
		return &v
	}).(JobDerivedInfoPtrOutput)
}

// Job categories derived from Job.title and Job.description.
func (o JobDerivedInfoOutput) JobCategories() pulumi.StringArrayOutput {
	return o.ApplyT(func(v JobDerivedInfo) []string { return v.JobCategories }).(pulumi.StringArrayOutput)
}

// Structured locations of the job, resolved from Job.addresses. locations are exactly matched to Job.addresses in the same order.
func (o JobDerivedInfoOutput) Locations() LocationArrayOutput {
	return o.ApplyT(func(v JobDerivedInfo) []Location { return v.Locations }).(LocationArrayOutput)
}

type JobDerivedInfoPtrOutput struct{ *pulumi.OutputState }

func (JobDerivedInfoPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**JobDerivedInfo)(nil)).Elem()
}

func (o JobDerivedInfoPtrOutput) ToJobDerivedInfoPtrOutput() JobDerivedInfoPtrOutput {
	return o
}

func (o JobDerivedInfoPtrOutput) ToJobDerivedInfoPtrOutputWithContext(ctx context.Context) JobDerivedInfoPtrOutput {
	return o
}

func (o JobDerivedInfoPtrOutput) Elem() JobDerivedInfoOutput {
	return o.ApplyT(func(v *JobDerivedInfo) JobDerivedInfo { return *v }).(JobDerivedInfoOutput)
}

// Job categories derived from Job.title and Job.description.
func (o JobDerivedInfoPtrOutput) JobCategories() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *JobDerivedInfo) []string {
		if v == nil {
			return nil
		}
		return v.JobCategories
	}).(pulumi.StringArrayOutput)
}

// Structured locations of the job, resolved from Job.addresses. locations are exactly matched to Job.addresses in the same order.
func (o JobDerivedInfoPtrOutput) Locations() LocationArrayOutput {
	return o.ApplyT(func(v *JobDerivedInfo) []Location {
		if v == nil {
			return nil
		}
		return v.Locations
	}).(LocationArrayOutput)
}

// An event issued when a job seeker interacts with the application that implements Cloud Talent Solution.
type JobEvent struct {
	// Required. The job name(s) associated with this event. For example, if this is an impression event, this field contains the identifiers of all jobs shown to the job seeker. If this was a view event, this field contains the identifier of the viewed job. The format is "projects/{project_id}/tenants/{tenant_id}/jobs/{job_id}", for example, "projects/foo/tenants/bar/jobs/baz".
	Jobs []string `pulumi:"jobs"`
	// Required. The type of the event (see JobEventType).
	Type *string `pulumi:"type"`
}

// JobEventInput is an input type that accepts JobEventArgs and JobEventOutput values.
// You can construct a concrete instance of `JobEventInput` via:
//
//          JobEventArgs{...}
type JobEventInput interface {
	pulumi.Input

	ToJobEventOutput() JobEventOutput
	ToJobEventOutputWithContext(context.Context) JobEventOutput
}

// An event issued when a job seeker interacts with the application that implements Cloud Talent Solution.
type JobEventArgs struct {
	// Required. The job name(s) associated with this event. For example, if this is an impression event, this field contains the identifiers of all jobs shown to the job seeker. If this was a view event, this field contains the identifier of the viewed job. The format is "projects/{project_id}/tenants/{tenant_id}/jobs/{job_id}", for example, "projects/foo/tenants/bar/jobs/baz".
	Jobs pulumi.StringArrayInput `pulumi:"jobs"`
	// Required. The type of the event (see JobEventType).
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (JobEventArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*JobEvent)(nil)).Elem()
}

func (i JobEventArgs) ToJobEventOutput() JobEventOutput {
	return i.ToJobEventOutputWithContext(context.Background())
}

func (i JobEventArgs) ToJobEventOutputWithContext(ctx context.Context) JobEventOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobEventOutput)
}

func (i JobEventArgs) ToJobEventPtrOutput() JobEventPtrOutput {
	return i.ToJobEventPtrOutputWithContext(context.Background())
}

func (i JobEventArgs) ToJobEventPtrOutputWithContext(ctx context.Context) JobEventPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobEventOutput).ToJobEventPtrOutputWithContext(ctx)
}

// JobEventPtrInput is an input type that accepts JobEventArgs, JobEventPtr and JobEventPtrOutput values.
// You can construct a concrete instance of `JobEventPtrInput` via:
//
//          JobEventArgs{...}
//
//  or:
//
//          nil
type JobEventPtrInput interface {
	pulumi.Input

	ToJobEventPtrOutput() JobEventPtrOutput
	ToJobEventPtrOutputWithContext(context.Context) JobEventPtrOutput
}

type jobEventPtrType JobEventArgs

func JobEventPtr(v *JobEventArgs) JobEventPtrInput {
	return (*jobEventPtrType)(v)
}

func (*jobEventPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**JobEvent)(nil)).Elem()
}

func (i *jobEventPtrType) ToJobEventPtrOutput() JobEventPtrOutput {
	return i.ToJobEventPtrOutputWithContext(context.Background())
}

func (i *jobEventPtrType) ToJobEventPtrOutputWithContext(ctx context.Context) JobEventPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobEventPtrOutput)
}

// An event issued when a job seeker interacts with the application that implements Cloud Talent Solution.
type JobEventOutput struct{ *pulumi.OutputState }

func (JobEventOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*JobEvent)(nil)).Elem()
}

func (o JobEventOutput) ToJobEventOutput() JobEventOutput {
	return o
}

func (o JobEventOutput) ToJobEventOutputWithContext(ctx context.Context) JobEventOutput {
	return o
}

func (o JobEventOutput) ToJobEventPtrOutput() JobEventPtrOutput {
	return o.ToJobEventPtrOutputWithContext(context.Background())
}

func (o JobEventOutput) ToJobEventPtrOutputWithContext(ctx context.Context) JobEventPtrOutput {
	return o.ApplyT(func(v JobEvent) *JobEvent {
		return &v
	}).(JobEventPtrOutput)
}

// Required. The job name(s) associated with this event. For example, if this is an impression event, this field contains the identifiers of all jobs shown to the job seeker. If this was a view event, this field contains the identifier of the viewed job. The format is "projects/{project_id}/tenants/{tenant_id}/jobs/{job_id}", for example, "projects/foo/tenants/bar/jobs/baz".
func (o JobEventOutput) Jobs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v JobEvent) []string { return v.Jobs }).(pulumi.StringArrayOutput)
}

// Required. The type of the event (see JobEventType).
func (o JobEventOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v JobEvent) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type JobEventPtrOutput struct{ *pulumi.OutputState }

func (JobEventPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**JobEvent)(nil)).Elem()
}

func (o JobEventPtrOutput) ToJobEventPtrOutput() JobEventPtrOutput {
	return o
}

func (o JobEventPtrOutput) ToJobEventPtrOutputWithContext(ctx context.Context) JobEventPtrOutput {
	return o
}

func (o JobEventPtrOutput) Elem() JobEventOutput {
	return o.ApplyT(func(v *JobEvent) JobEvent { return *v }).(JobEventOutput)
}

// Required. The job name(s) associated with this event. For example, if this is an impression event, this field contains the identifiers of all jobs shown to the job seeker. If this was a view event, this field contains the identifier of the viewed job. The format is "projects/{project_id}/tenants/{tenant_id}/jobs/{job_id}", for example, "projects/foo/tenants/bar/jobs/baz".
func (o JobEventPtrOutput) Jobs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *JobEvent) []string {
		if v == nil {
			return nil
		}
		return v.Jobs
	}).(pulumi.StringArrayOutput)
}

// Required. The type of the event (see JobEventType).
func (o JobEventPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *JobEvent) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// An object that represents a latitude/longitude pair. This is expressed as a pair of doubles to represent degrees latitude and degrees longitude. Unless specified otherwise, this must conform to the WGS84 standard. Values must be within normalized ranges.
type LatLng struct {
	// The latitude in degrees. It must be in the range [-90.0, +90.0].
	Latitude *float64 `pulumi:"latitude"`
	// The longitude in degrees. It must be in the range [-180.0, +180.0].
	Longitude *float64 `pulumi:"longitude"`
}

// LatLngInput is an input type that accepts LatLngArgs and LatLngOutput values.
// You can construct a concrete instance of `LatLngInput` via:
//
//          LatLngArgs{...}
type LatLngInput interface {
	pulumi.Input

	ToLatLngOutput() LatLngOutput
	ToLatLngOutputWithContext(context.Context) LatLngOutput
}

// An object that represents a latitude/longitude pair. This is expressed as a pair of doubles to represent degrees latitude and degrees longitude. Unless specified otherwise, this must conform to the WGS84 standard. Values must be within normalized ranges.
type LatLngArgs struct {
	// The latitude in degrees. It must be in the range [-90.0, +90.0].
	Latitude pulumi.Float64PtrInput `pulumi:"latitude"`
	// The longitude in degrees. It must be in the range [-180.0, +180.0].
	Longitude pulumi.Float64PtrInput `pulumi:"longitude"`
}

func (LatLngArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LatLng)(nil)).Elem()
}

func (i LatLngArgs) ToLatLngOutput() LatLngOutput {
	return i.ToLatLngOutputWithContext(context.Background())
}

func (i LatLngArgs) ToLatLngOutputWithContext(ctx context.Context) LatLngOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LatLngOutput)
}

func (i LatLngArgs) ToLatLngPtrOutput() LatLngPtrOutput {
	return i.ToLatLngPtrOutputWithContext(context.Background())
}

func (i LatLngArgs) ToLatLngPtrOutputWithContext(ctx context.Context) LatLngPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LatLngOutput).ToLatLngPtrOutputWithContext(ctx)
}

// LatLngPtrInput is an input type that accepts LatLngArgs, LatLngPtr and LatLngPtrOutput values.
// You can construct a concrete instance of `LatLngPtrInput` via:
//
//          LatLngArgs{...}
//
//  or:
//
//          nil
type LatLngPtrInput interface {
	pulumi.Input

	ToLatLngPtrOutput() LatLngPtrOutput
	ToLatLngPtrOutputWithContext(context.Context) LatLngPtrOutput
}

type latLngPtrType LatLngArgs

func LatLngPtr(v *LatLngArgs) LatLngPtrInput {
	return (*latLngPtrType)(v)
}

func (*latLngPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LatLng)(nil)).Elem()
}

func (i *latLngPtrType) ToLatLngPtrOutput() LatLngPtrOutput {
	return i.ToLatLngPtrOutputWithContext(context.Background())
}

func (i *latLngPtrType) ToLatLngPtrOutputWithContext(ctx context.Context) LatLngPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LatLngPtrOutput)
}

// An object that represents a latitude/longitude pair. This is expressed as a pair of doubles to represent degrees latitude and degrees longitude. Unless specified otherwise, this must conform to the WGS84 standard. Values must be within normalized ranges.
type LatLngOutput struct{ *pulumi.OutputState }

func (LatLngOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LatLng)(nil)).Elem()
}

func (o LatLngOutput) ToLatLngOutput() LatLngOutput {
	return o
}

func (o LatLngOutput) ToLatLngOutputWithContext(ctx context.Context) LatLngOutput {
	return o
}

func (o LatLngOutput) ToLatLngPtrOutput() LatLngPtrOutput {
	return o.ToLatLngPtrOutputWithContext(context.Background())
}

func (o LatLngOutput) ToLatLngPtrOutputWithContext(ctx context.Context) LatLngPtrOutput {
	return o.ApplyT(func(v LatLng) *LatLng {
		return &v
	}).(LatLngPtrOutput)
}

// The latitude in degrees. It must be in the range [-90.0, +90.0].
func (o LatLngOutput) Latitude() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v LatLng) *float64 { return v.Latitude }).(pulumi.Float64PtrOutput)
}

// The longitude in degrees. It must be in the range [-180.0, +180.0].
func (o LatLngOutput) Longitude() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v LatLng) *float64 { return v.Longitude }).(pulumi.Float64PtrOutput)
}

type LatLngPtrOutput struct{ *pulumi.OutputState }

func (LatLngPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LatLng)(nil)).Elem()
}

func (o LatLngPtrOutput) ToLatLngPtrOutput() LatLngPtrOutput {
	return o
}

func (o LatLngPtrOutput) ToLatLngPtrOutputWithContext(ctx context.Context) LatLngPtrOutput {
	return o
}

func (o LatLngPtrOutput) Elem() LatLngOutput {
	return o.ApplyT(func(v *LatLng) LatLng { return *v }).(LatLngOutput)
}

// The latitude in degrees. It must be in the range [-90.0, +90.0].
func (o LatLngPtrOutput) Latitude() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *LatLng) *float64 {
		if v == nil {
			return nil
		}
		return v.Latitude
	}).(pulumi.Float64PtrOutput)
}

// The longitude in degrees. It must be in the range [-180.0, +180.0].
func (o LatLngPtrOutput) Longitude() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *LatLng) *float64 {
		if v == nil {
			return nil
		}
		return v.Longitude
	}).(pulumi.Float64PtrOutput)
}

// A resource that represents a location with full geographic information.
type Location struct {
	// An object representing a latitude/longitude pair.
	LatLng *LatLng `pulumi:"latLng"`
	// The type of a location, which corresponds to the address lines field of google.type.PostalAddress. For example, "Downtown, Atlanta, GA, USA" has a type of LocationType.NEIGHBORHOOD, and "Kansas City, KS, USA" has a type of LocationType.LOCALITY.
	LocationType *string `pulumi:"locationType"`
	// Postal address of the location that includes human readable information, such as postal delivery and payments addresses. Given a postal address, a postal service can deliver items to a premises, P.O. Box, or other delivery location.
	PostalAddress *PostalAddress `pulumi:"postalAddress"`
	// Radius in miles of the job location. This value is derived from the location bounding box in which a circle with the specified radius centered from google.type.LatLng covers the area associated with the job location. For example, currently, "Mountain View, CA, USA" has a radius of 6.17 miles.
	RadiusMiles *float64 `pulumi:"radiusMiles"`
}

// LocationInput is an input type that accepts LocationArgs and LocationOutput values.
// You can construct a concrete instance of `LocationInput` via:
//
//          LocationArgs{...}
type LocationInput interface {
	pulumi.Input

	ToLocationOutput() LocationOutput
	ToLocationOutputWithContext(context.Context) LocationOutput
}

// A resource that represents a location with full geographic information.
type LocationArgs struct {
	// An object representing a latitude/longitude pair.
	LatLng LatLngPtrInput `pulumi:"latLng"`
	// The type of a location, which corresponds to the address lines field of google.type.PostalAddress. For example, "Downtown, Atlanta, GA, USA" has a type of LocationType.NEIGHBORHOOD, and "Kansas City, KS, USA" has a type of LocationType.LOCALITY.
	LocationType pulumi.StringPtrInput `pulumi:"locationType"`
	// Postal address of the location that includes human readable information, such as postal delivery and payments addresses. Given a postal address, a postal service can deliver items to a premises, P.O. Box, or other delivery location.
	PostalAddress PostalAddressPtrInput `pulumi:"postalAddress"`
	// Radius in miles of the job location. This value is derived from the location bounding box in which a circle with the specified radius centered from google.type.LatLng covers the area associated with the job location. For example, currently, "Mountain View, CA, USA" has a radius of 6.17 miles.
	RadiusMiles pulumi.Float64PtrInput `pulumi:"radiusMiles"`
}

func (LocationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Location)(nil)).Elem()
}

func (i LocationArgs) ToLocationOutput() LocationOutput {
	return i.ToLocationOutputWithContext(context.Background())
}

func (i LocationArgs) ToLocationOutputWithContext(ctx context.Context) LocationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocationOutput)
}

func (i LocationArgs) ToLocationPtrOutput() LocationPtrOutput {
	return i.ToLocationPtrOutputWithContext(context.Background())
}

func (i LocationArgs) ToLocationPtrOutputWithContext(ctx context.Context) LocationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocationOutput).ToLocationPtrOutputWithContext(ctx)
}

// LocationPtrInput is an input type that accepts LocationArgs, LocationPtr and LocationPtrOutput values.
// You can construct a concrete instance of `LocationPtrInput` via:
//
//          LocationArgs{...}
//
//  or:
//
//          nil
type LocationPtrInput interface {
	pulumi.Input

	ToLocationPtrOutput() LocationPtrOutput
	ToLocationPtrOutputWithContext(context.Context) LocationPtrOutput
}

type locationPtrType LocationArgs

func LocationPtr(v *LocationArgs) LocationPtrInput {
	return (*locationPtrType)(v)
}

func (*locationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Location)(nil)).Elem()
}

func (i *locationPtrType) ToLocationPtrOutput() LocationPtrOutput {
	return i.ToLocationPtrOutputWithContext(context.Background())
}

func (i *locationPtrType) ToLocationPtrOutputWithContext(ctx context.Context) LocationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocationPtrOutput)
}

// LocationArrayInput is an input type that accepts LocationArray and LocationArrayOutput values.
// You can construct a concrete instance of `LocationArrayInput` via:
//
//          LocationArray{ LocationArgs{...} }
type LocationArrayInput interface {
	pulumi.Input

	ToLocationArrayOutput() LocationArrayOutput
	ToLocationArrayOutputWithContext(context.Context) LocationArrayOutput
}

type LocationArray []LocationInput

func (LocationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Location)(nil)).Elem()
}

func (i LocationArray) ToLocationArrayOutput() LocationArrayOutput {
	return i.ToLocationArrayOutputWithContext(context.Background())
}

func (i LocationArray) ToLocationArrayOutputWithContext(ctx context.Context) LocationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocationArrayOutput)
}

// A resource that represents a location with full geographic information.
type LocationOutput struct{ *pulumi.OutputState }

func (LocationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Location)(nil)).Elem()
}

func (o LocationOutput) ToLocationOutput() LocationOutput {
	return o
}

func (o LocationOutput) ToLocationOutputWithContext(ctx context.Context) LocationOutput {
	return o
}

func (o LocationOutput) ToLocationPtrOutput() LocationPtrOutput {
	return o.ToLocationPtrOutputWithContext(context.Background())
}

func (o LocationOutput) ToLocationPtrOutputWithContext(ctx context.Context) LocationPtrOutput {
	return o.ApplyT(func(v Location) *Location {
		return &v
	}).(LocationPtrOutput)
}

// An object representing a latitude/longitude pair.
func (o LocationOutput) LatLng() LatLngPtrOutput {
	return o.ApplyT(func(v Location) *LatLng { return v.LatLng }).(LatLngPtrOutput)
}

// The type of a location, which corresponds to the address lines field of google.type.PostalAddress. For example, "Downtown, Atlanta, GA, USA" has a type of LocationType.NEIGHBORHOOD, and "Kansas City, KS, USA" has a type of LocationType.LOCALITY.
func (o LocationOutput) LocationType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Location) *string { return v.LocationType }).(pulumi.StringPtrOutput)
}

// Postal address of the location that includes human readable information, such as postal delivery and payments addresses. Given a postal address, a postal service can deliver items to a premises, P.O. Box, or other delivery location.
func (o LocationOutput) PostalAddress() PostalAddressPtrOutput {
	return o.ApplyT(func(v Location) *PostalAddress { return v.PostalAddress }).(PostalAddressPtrOutput)
}

// Radius in miles of the job location. This value is derived from the location bounding box in which a circle with the specified radius centered from google.type.LatLng covers the area associated with the job location. For example, currently, "Mountain View, CA, USA" has a radius of 6.17 miles.
func (o LocationOutput) RadiusMiles() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Location) *float64 { return v.RadiusMiles }).(pulumi.Float64PtrOutput)
}

type LocationPtrOutput struct{ *pulumi.OutputState }

func (LocationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Location)(nil)).Elem()
}

func (o LocationPtrOutput) ToLocationPtrOutput() LocationPtrOutput {
	return o
}

func (o LocationPtrOutput) ToLocationPtrOutputWithContext(ctx context.Context) LocationPtrOutput {
	return o
}

func (o LocationPtrOutput) Elem() LocationOutput {
	return o.ApplyT(func(v *Location) Location { return *v }).(LocationOutput)
}

// An object representing a latitude/longitude pair.
func (o LocationPtrOutput) LatLng() LatLngPtrOutput {
	return o.ApplyT(func(v *Location) *LatLng {
		if v == nil {
			return nil
		}
		return v.LatLng
	}).(LatLngPtrOutput)
}

// The type of a location, which corresponds to the address lines field of google.type.PostalAddress. For example, "Downtown, Atlanta, GA, USA" has a type of LocationType.NEIGHBORHOOD, and "Kansas City, KS, USA" has a type of LocationType.LOCALITY.
func (o LocationPtrOutput) LocationType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Location) *string {
		if v == nil {
			return nil
		}
		return v.LocationType
	}).(pulumi.StringPtrOutput)
}

// Postal address of the location that includes human readable information, such as postal delivery and payments addresses. Given a postal address, a postal service can deliver items to a premises, P.O. Box, or other delivery location.
func (o LocationPtrOutput) PostalAddress() PostalAddressPtrOutput {
	return o.ApplyT(func(v *Location) *PostalAddress {
		if v == nil {
			return nil
		}
		return v.PostalAddress
	}).(PostalAddressPtrOutput)
}

// Radius in miles of the job location. This value is derived from the location bounding box in which a circle with the specified radius centered from google.type.LatLng covers the area associated with the job location. For example, currently, "Mountain View, CA, USA" has a radius of 6.17 miles.
func (o LocationPtrOutput) RadiusMiles() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *Location) *float64 {
		if v == nil {
			return nil
		}
		return v.RadiusMiles
	}).(pulumi.Float64PtrOutput)
}

type LocationArrayOutput struct{ *pulumi.OutputState }

func (LocationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Location)(nil)).Elem()
}

func (o LocationArrayOutput) ToLocationArrayOutput() LocationArrayOutput {
	return o
}

func (o LocationArrayOutput) ToLocationArrayOutputWithContext(ctx context.Context) LocationArrayOutput {
	return o
}

func (o LocationArrayOutput) Index(i pulumi.IntInput) LocationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Location {
		return vs[0].([]Location)[vs[1].(int)]
	}).(LocationOutput)
}

// Represents an amount of money with its currency type.
type Money struct {
	// The three-letter currency code defined in ISO 4217.
	CurrencyCode *string `pulumi:"currencyCode"`
	// Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
	Nanos *int `pulumi:"nanos"`
	// The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
	Units *string `pulumi:"units"`
}

// MoneyInput is an input type that accepts MoneyArgs and MoneyOutput values.
// You can construct a concrete instance of `MoneyInput` via:
//
//          MoneyArgs{...}
type MoneyInput interface {
	pulumi.Input

	ToMoneyOutput() MoneyOutput
	ToMoneyOutputWithContext(context.Context) MoneyOutput
}

// Represents an amount of money with its currency type.
type MoneyArgs struct {
	// The three-letter currency code defined in ISO 4217.
	CurrencyCode pulumi.StringPtrInput `pulumi:"currencyCode"`
	// Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
	Nanos pulumi.IntPtrInput `pulumi:"nanos"`
	// The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
	Units pulumi.StringPtrInput `pulumi:"units"`
}

func (MoneyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Money)(nil)).Elem()
}

func (i MoneyArgs) ToMoneyOutput() MoneyOutput {
	return i.ToMoneyOutputWithContext(context.Background())
}

func (i MoneyArgs) ToMoneyOutputWithContext(ctx context.Context) MoneyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MoneyOutput)
}

func (i MoneyArgs) ToMoneyPtrOutput() MoneyPtrOutput {
	return i.ToMoneyPtrOutputWithContext(context.Background())
}

func (i MoneyArgs) ToMoneyPtrOutputWithContext(ctx context.Context) MoneyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MoneyOutput).ToMoneyPtrOutputWithContext(ctx)
}

// MoneyPtrInput is an input type that accepts MoneyArgs, MoneyPtr and MoneyPtrOutput values.
// You can construct a concrete instance of `MoneyPtrInput` via:
//
//          MoneyArgs{...}
//
//  or:
//
//          nil
type MoneyPtrInput interface {
	pulumi.Input

	ToMoneyPtrOutput() MoneyPtrOutput
	ToMoneyPtrOutputWithContext(context.Context) MoneyPtrOutput
}

type moneyPtrType MoneyArgs

func MoneyPtr(v *MoneyArgs) MoneyPtrInput {
	return (*moneyPtrType)(v)
}

func (*moneyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Money)(nil)).Elem()
}

func (i *moneyPtrType) ToMoneyPtrOutput() MoneyPtrOutput {
	return i.ToMoneyPtrOutputWithContext(context.Background())
}

func (i *moneyPtrType) ToMoneyPtrOutputWithContext(ctx context.Context) MoneyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MoneyPtrOutput)
}

// Represents an amount of money with its currency type.
type MoneyOutput struct{ *pulumi.OutputState }

func (MoneyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Money)(nil)).Elem()
}

func (o MoneyOutput) ToMoneyOutput() MoneyOutput {
	return o
}

func (o MoneyOutput) ToMoneyOutputWithContext(ctx context.Context) MoneyOutput {
	return o
}

func (o MoneyOutput) ToMoneyPtrOutput() MoneyPtrOutput {
	return o.ToMoneyPtrOutputWithContext(context.Background())
}

func (o MoneyOutput) ToMoneyPtrOutputWithContext(ctx context.Context) MoneyPtrOutput {
	return o.ApplyT(func(v Money) *Money {
		return &v
	}).(MoneyPtrOutput)
}

// The three-letter currency code defined in ISO 4217.
func (o MoneyOutput) CurrencyCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Money) *string { return v.CurrencyCode }).(pulumi.StringPtrOutput)
}

// Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
func (o MoneyOutput) Nanos() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Money) *int { return v.Nanos }).(pulumi.IntPtrOutput)
}

// The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
func (o MoneyOutput) Units() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Money) *string { return v.Units }).(pulumi.StringPtrOutput)
}

type MoneyPtrOutput struct{ *pulumi.OutputState }

func (MoneyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Money)(nil)).Elem()
}

func (o MoneyPtrOutput) ToMoneyPtrOutput() MoneyPtrOutput {
	return o
}

func (o MoneyPtrOutput) ToMoneyPtrOutputWithContext(ctx context.Context) MoneyPtrOutput {
	return o
}

func (o MoneyPtrOutput) Elem() MoneyOutput {
	return o.ApplyT(func(v *Money) Money { return *v }).(MoneyOutput)
}

// The three-letter currency code defined in ISO 4217.
func (o MoneyPtrOutput) CurrencyCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Money) *string {
		if v == nil {
			return nil
		}
		return v.CurrencyCode
	}).(pulumi.StringPtrOutput)
}

// Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
func (o MoneyPtrOutput) Nanos() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Money) *int {
		if v == nil {
			return nil
		}
		return v.Nanos
	}).(pulumi.IntPtrOutput)
}

// The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
func (o MoneyPtrOutput) Units() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Money) *string {
		if v == nil {
			return nil
		}
		return v.Units
	}).(pulumi.StringPtrOutput)
}

// Represents a postal address, e.g. for postal delivery or payments addresses. Given a postal address, a postal service can deliver items to a premise, P.O. Box or similar. It is not intended to model geographical locations (roads, towns, mountains). In typical usage an address would be created via user input or from importing existing data, depending on the type of process. Advice on address input / editing: - Use an i18n-ready address widget such as https://github.com/google/libaddressinput) - Users should not be presented with UI elements for input or editing of fields outside countries where that field is used. For more guidance on how to use this schema, please see: https://support.google.com/business/answer/6397478
type PostalAddress struct {
	// Unstructured address lines describing the lower levels of an address. Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way, the most specific line of an address can be selected based on the language. The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved. Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
	AddressLines []string `pulumi:"addressLines"`
	// Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
	AdministrativeArea *string `pulumi:"administrativeArea"`
	// Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations. If this value is not known, it should be omitted (rather than specifying a possibly incorrect default). Examples: "zh-Hant", "ja", "ja-Latn", "en".
	LanguageCode *string `pulumi:"languageCode"`
	// Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
	Locality *string `pulumi:"locality"`
	// Optional. The name of the organization at the address.
	Organization *string `pulumi:"organization"`
	// Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
	PostalCode *string `pulumi:"postalCode"`
	// Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain "care of" information.
	Recipients []string `pulumi:"recipients"`
	// Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See http://cldr.unicode.org/ and http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.
	RegionCode *string `pulumi:"regionCode"`
	// The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision. All new revisions **must** be backward compatible with old revisions.
	Revision *int `pulumi:"revision"`
	// Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number alone, representing the "sector code" (Jamaica), "delivery area indicator" (Malawi) or "post office indicator" (e.g. Cte d'Ivoire).
	SortingCode *string `pulumi:"sortingCode"`
	// Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
	Sublocality *string `pulumi:"sublocality"`
}

// PostalAddressInput is an input type that accepts PostalAddressArgs and PostalAddressOutput values.
// You can construct a concrete instance of `PostalAddressInput` via:
//
//          PostalAddressArgs{...}
type PostalAddressInput interface {
	pulumi.Input

	ToPostalAddressOutput() PostalAddressOutput
	ToPostalAddressOutputWithContext(context.Context) PostalAddressOutput
}

// Represents a postal address, e.g. for postal delivery or payments addresses. Given a postal address, a postal service can deliver items to a premise, P.O. Box or similar. It is not intended to model geographical locations (roads, towns, mountains). In typical usage an address would be created via user input or from importing existing data, depending on the type of process. Advice on address input / editing: - Use an i18n-ready address widget such as https://github.com/google/libaddressinput) - Users should not be presented with UI elements for input or editing of fields outside countries where that field is used. For more guidance on how to use this schema, please see: https://support.google.com/business/answer/6397478
type PostalAddressArgs struct {
	// Unstructured address lines describing the lower levels of an address. Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way, the most specific line of an address can be selected based on the language. The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved. Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
	AddressLines pulumi.StringArrayInput `pulumi:"addressLines"`
	// Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
	AdministrativeArea pulumi.StringPtrInput `pulumi:"administrativeArea"`
	// Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations. If this value is not known, it should be omitted (rather than specifying a possibly incorrect default). Examples: "zh-Hant", "ja", "ja-Latn", "en".
	LanguageCode pulumi.StringPtrInput `pulumi:"languageCode"`
	// Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
	Locality pulumi.StringPtrInput `pulumi:"locality"`
	// Optional. The name of the organization at the address.
	Organization pulumi.StringPtrInput `pulumi:"organization"`
	// Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
	PostalCode pulumi.StringPtrInput `pulumi:"postalCode"`
	// Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain "care of" information.
	Recipients pulumi.StringArrayInput `pulumi:"recipients"`
	// Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See http://cldr.unicode.org/ and http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.
	RegionCode pulumi.StringPtrInput `pulumi:"regionCode"`
	// The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision. All new revisions **must** be backward compatible with old revisions.
	Revision pulumi.IntPtrInput `pulumi:"revision"`
	// Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number alone, representing the "sector code" (Jamaica), "delivery area indicator" (Malawi) or "post office indicator" (e.g. Cte d'Ivoire).
	SortingCode pulumi.StringPtrInput `pulumi:"sortingCode"`
	// Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
	Sublocality pulumi.StringPtrInput `pulumi:"sublocality"`
}

func (PostalAddressArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PostalAddress)(nil)).Elem()
}

func (i PostalAddressArgs) ToPostalAddressOutput() PostalAddressOutput {
	return i.ToPostalAddressOutputWithContext(context.Background())
}

func (i PostalAddressArgs) ToPostalAddressOutputWithContext(ctx context.Context) PostalAddressOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PostalAddressOutput)
}

func (i PostalAddressArgs) ToPostalAddressPtrOutput() PostalAddressPtrOutput {
	return i.ToPostalAddressPtrOutputWithContext(context.Background())
}

func (i PostalAddressArgs) ToPostalAddressPtrOutputWithContext(ctx context.Context) PostalAddressPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PostalAddressOutput).ToPostalAddressPtrOutputWithContext(ctx)
}

// PostalAddressPtrInput is an input type that accepts PostalAddressArgs, PostalAddressPtr and PostalAddressPtrOutput values.
// You can construct a concrete instance of `PostalAddressPtrInput` via:
//
//          PostalAddressArgs{...}
//
//  or:
//
//          nil
type PostalAddressPtrInput interface {
	pulumi.Input

	ToPostalAddressPtrOutput() PostalAddressPtrOutput
	ToPostalAddressPtrOutputWithContext(context.Context) PostalAddressPtrOutput
}

type postalAddressPtrType PostalAddressArgs

func PostalAddressPtr(v *PostalAddressArgs) PostalAddressPtrInput {
	return (*postalAddressPtrType)(v)
}

func (*postalAddressPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PostalAddress)(nil)).Elem()
}

func (i *postalAddressPtrType) ToPostalAddressPtrOutput() PostalAddressPtrOutput {
	return i.ToPostalAddressPtrOutputWithContext(context.Background())
}

func (i *postalAddressPtrType) ToPostalAddressPtrOutputWithContext(ctx context.Context) PostalAddressPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PostalAddressPtrOutput)
}

// Represents a postal address, e.g. for postal delivery or payments addresses. Given a postal address, a postal service can deliver items to a premise, P.O. Box or similar. It is not intended to model geographical locations (roads, towns, mountains). In typical usage an address would be created via user input or from importing existing data, depending on the type of process. Advice on address input / editing: - Use an i18n-ready address widget such as https://github.com/google/libaddressinput) - Users should not be presented with UI elements for input or editing of fields outside countries where that field is used. For more guidance on how to use this schema, please see: https://support.google.com/business/answer/6397478
type PostalAddressOutput struct{ *pulumi.OutputState }

func (PostalAddressOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PostalAddress)(nil)).Elem()
}

func (o PostalAddressOutput) ToPostalAddressOutput() PostalAddressOutput {
	return o
}

func (o PostalAddressOutput) ToPostalAddressOutputWithContext(ctx context.Context) PostalAddressOutput {
	return o
}

func (o PostalAddressOutput) ToPostalAddressPtrOutput() PostalAddressPtrOutput {
	return o.ToPostalAddressPtrOutputWithContext(context.Background())
}

func (o PostalAddressOutput) ToPostalAddressPtrOutputWithContext(ctx context.Context) PostalAddressPtrOutput {
	return o.ApplyT(func(v PostalAddress) *PostalAddress {
		return &v
	}).(PostalAddressPtrOutput)
}

// Unstructured address lines describing the lower levels of an address. Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way, the most specific line of an address can be selected based on the language. The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved. Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
func (o PostalAddressOutput) AddressLines() pulumi.StringArrayOutput {
	return o.ApplyT(func(v PostalAddress) []string { return v.AddressLines }).(pulumi.StringArrayOutput)
}

// Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
func (o PostalAddressOutput) AdministrativeArea() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PostalAddress) *string { return v.AdministrativeArea }).(pulumi.StringPtrOutput)
}

// Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations. If this value is not known, it should be omitted (rather than specifying a possibly incorrect default). Examples: "zh-Hant", "ja", "ja-Latn", "en".
func (o PostalAddressOutput) LanguageCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PostalAddress) *string { return v.LanguageCode }).(pulumi.StringPtrOutput)
}

// Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
func (o PostalAddressOutput) Locality() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PostalAddress) *string { return v.Locality }).(pulumi.StringPtrOutput)
}

// Optional. The name of the organization at the address.
func (o PostalAddressOutput) Organization() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PostalAddress) *string { return v.Organization }).(pulumi.StringPtrOutput)
}

// Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
func (o PostalAddressOutput) PostalCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PostalAddress) *string { return v.PostalCode }).(pulumi.StringPtrOutput)
}

// Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain "care of" information.
func (o PostalAddressOutput) Recipients() pulumi.StringArrayOutput {
	return o.ApplyT(func(v PostalAddress) []string { return v.Recipients }).(pulumi.StringArrayOutput)
}

// Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See http://cldr.unicode.org/ and http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.
func (o PostalAddressOutput) RegionCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PostalAddress) *string { return v.RegionCode }).(pulumi.StringPtrOutput)
}

// The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision. All new revisions **must** be backward compatible with old revisions.
func (o PostalAddressOutput) Revision() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PostalAddress) *int { return v.Revision }).(pulumi.IntPtrOutput)
}

// Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number alone, representing the "sector code" (Jamaica), "delivery area indicator" (Malawi) or "post office indicator" (e.g. Cte d'Ivoire).
func (o PostalAddressOutput) SortingCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PostalAddress) *string { return v.SortingCode }).(pulumi.StringPtrOutput)
}

// Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
func (o PostalAddressOutput) Sublocality() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PostalAddress) *string { return v.Sublocality }).(pulumi.StringPtrOutput)
}

type PostalAddressPtrOutput struct{ *pulumi.OutputState }

func (PostalAddressPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PostalAddress)(nil)).Elem()
}

func (o PostalAddressPtrOutput) ToPostalAddressPtrOutput() PostalAddressPtrOutput {
	return o
}

func (o PostalAddressPtrOutput) ToPostalAddressPtrOutputWithContext(ctx context.Context) PostalAddressPtrOutput {
	return o
}

func (o PostalAddressPtrOutput) Elem() PostalAddressOutput {
	return o.ApplyT(func(v *PostalAddress) PostalAddress { return *v }).(PostalAddressOutput)
}

// Unstructured address lines describing the lower levels of an address. Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way, the most specific line of an address can be selected based on the language. The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved. Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
func (o PostalAddressPtrOutput) AddressLines() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *PostalAddress) []string {
		if v == nil {
			return nil
		}
		return v.AddressLines
	}).(pulumi.StringArrayOutput)
}

// Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
func (o PostalAddressPtrOutput) AdministrativeArea() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddress) *string {
		if v == nil {
			return nil
		}
		return v.AdministrativeArea
	}).(pulumi.StringPtrOutput)
}

// Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations. If this value is not known, it should be omitted (rather than specifying a possibly incorrect default). Examples: "zh-Hant", "ja", "ja-Latn", "en".
func (o PostalAddressPtrOutput) LanguageCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddress) *string {
		if v == nil {
			return nil
		}
		return v.LanguageCode
	}).(pulumi.StringPtrOutput)
}

// Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
func (o PostalAddressPtrOutput) Locality() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddress) *string {
		if v == nil {
			return nil
		}
		return v.Locality
	}).(pulumi.StringPtrOutput)
}

// Optional. The name of the organization at the address.
func (o PostalAddressPtrOutput) Organization() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddress) *string {
		if v == nil {
			return nil
		}
		return v.Organization
	}).(pulumi.StringPtrOutput)
}

// Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
func (o PostalAddressPtrOutput) PostalCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddress) *string {
		if v == nil {
			return nil
		}
		return v.PostalCode
	}).(pulumi.StringPtrOutput)
}

// Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain "care of" information.
func (o PostalAddressPtrOutput) Recipients() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *PostalAddress) []string {
		if v == nil {
			return nil
		}
		return v.Recipients
	}).(pulumi.StringArrayOutput)
}

// Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See http://cldr.unicode.org/ and http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.
func (o PostalAddressPtrOutput) RegionCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddress) *string {
		if v == nil {
			return nil
		}
		return v.RegionCode
	}).(pulumi.StringPtrOutput)
}

// The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision. All new revisions **must** be backward compatible with old revisions.
func (o PostalAddressPtrOutput) Revision() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PostalAddress) *int {
		if v == nil {
			return nil
		}
		return v.Revision
	}).(pulumi.IntPtrOutput)
}

// Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number alone, representing the "sector code" (Jamaica), "delivery area indicator" (Malawi) or "post office indicator" (e.g. Cte d'Ivoire).
func (o PostalAddressPtrOutput) SortingCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddress) *string {
		if v == nil {
			return nil
		}
		return v.SortingCode
	}).(pulumi.StringPtrOutput)
}

// Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
func (o PostalAddressPtrOutput) Sublocality() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PostalAddress) *string {
		if v == nil {
			return nil
		}
		return v.Sublocality
	}).(pulumi.StringPtrOutput)
}

// Options for job processing.
type ProcessingOptions struct {
	// If set to `true`, the service does not attempt to resolve a more precise address for the job.
	DisableStreetAddressResolution *bool `pulumi:"disableStreetAddressResolution"`
	// Option for job HTML content sanitization. Applied fields are: * description * applicationInfo.instruction * incentives * qualifications * responsibilities HTML tags in these fields may be stripped if sanitiazation isn't disabled. Defaults to HtmlSanitization.SIMPLE_FORMATTING_ONLY.
	HtmlSanitization *string `pulumi:"htmlSanitization"`
}

// ProcessingOptionsInput is an input type that accepts ProcessingOptionsArgs and ProcessingOptionsOutput values.
// You can construct a concrete instance of `ProcessingOptionsInput` via:
//
//          ProcessingOptionsArgs{...}
type ProcessingOptionsInput interface {
	pulumi.Input

	ToProcessingOptionsOutput() ProcessingOptionsOutput
	ToProcessingOptionsOutputWithContext(context.Context) ProcessingOptionsOutput
}

// Options for job processing.
type ProcessingOptionsArgs struct {
	// If set to `true`, the service does not attempt to resolve a more precise address for the job.
	DisableStreetAddressResolution pulumi.BoolPtrInput `pulumi:"disableStreetAddressResolution"`
	// Option for job HTML content sanitization. Applied fields are: * description * applicationInfo.instruction * incentives * qualifications * responsibilities HTML tags in these fields may be stripped if sanitiazation isn't disabled. Defaults to HtmlSanitization.SIMPLE_FORMATTING_ONLY.
	HtmlSanitization pulumi.StringPtrInput `pulumi:"htmlSanitization"`
}

func (ProcessingOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ProcessingOptions)(nil)).Elem()
}

func (i ProcessingOptionsArgs) ToProcessingOptionsOutput() ProcessingOptionsOutput {
	return i.ToProcessingOptionsOutputWithContext(context.Background())
}

func (i ProcessingOptionsArgs) ToProcessingOptionsOutputWithContext(ctx context.Context) ProcessingOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProcessingOptionsOutput)
}

func (i ProcessingOptionsArgs) ToProcessingOptionsPtrOutput() ProcessingOptionsPtrOutput {
	return i.ToProcessingOptionsPtrOutputWithContext(context.Background())
}

func (i ProcessingOptionsArgs) ToProcessingOptionsPtrOutputWithContext(ctx context.Context) ProcessingOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProcessingOptionsOutput).ToProcessingOptionsPtrOutputWithContext(ctx)
}

// ProcessingOptionsPtrInput is an input type that accepts ProcessingOptionsArgs, ProcessingOptionsPtr and ProcessingOptionsPtrOutput values.
// You can construct a concrete instance of `ProcessingOptionsPtrInput` via:
//
//          ProcessingOptionsArgs{...}
//
//  or:
//
//          nil
type ProcessingOptionsPtrInput interface {
	pulumi.Input

	ToProcessingOptionsPtrOutput() ProcessingOptionsPtrOutput
	ToProcessingOptionsPtrOutputWithContext(context.Context) ProcessingOptionsPtrOutput
}

type processingOptionsPtrType ProcessingOptionsArgs

func ProcessingOptionsPtr(v *ProcessingOptionsArgs) ProcessingOptionsPtrInput {
	return (*processingOptionsPtrType)(v)
}

func (*processingOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ProcessingOptions)(nil)).Elem()
}

func (i *processingOptionsPtrType) ToProcessingOptionsPtrOutput() ProcessingOptionsPtrOutput {
	return i.ToProcessingOptionsPtrOutputWithContext(context.Background())
}

func (i *processingOptionsPtrType) ToProcessingOptionsPtrOutputWithContext(ctx context.Context) ProcessingOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProcessingOptionsPtrOutput)
}

// Options for job processing.
type ProcessingOptionsOutput struct{ *pulumi.OutputState }

func (ProcessingOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ProcessingOptions)(nil)).Elem()
}

func (o ProcessingOptionsOutput) ToProcessingOptionsOutput() ProcessingOptionsOutput {
	return o
}

func (o ProcessingOptionsOutput) ToProcessingOptionsOutputWithContext(ctx context.Context) ProcessingOptionsOutput {
	return o
}

func (o ProcessingOptionsOutput) ToProcessingOptionsPtrOutput() ProcessingOptionsPtrOutput {
	return o.ToProcessingOptionsPtrOutputWithContext(context.Background())
}

func (o ProcessingOptionsOutput) ToProcessingOptionsPtrOutputWithContext(ctx context.Context) ProcessingOptionsPtrOutput {
	return o.ApplyT(func(v ProcessingOptions) *ProcessingOptions {
		return &v
	}).(ProcessingOptionsPtrOutput)
}

// If set to `true`, the service does not attempt to resolve a more precise address for the job.
func (o ProcessingOptionsOutput) DisableStreetAddressResolution() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ProcessingOptions) *bool { return v.DisableStreetAddressResolution }).(pulumi.BoolPtrOutput)
}

// Option for job HTML content sanitization. Applied fields are: * description * applicationInfo.instruction * incentives * qualifications * responsibilities HTML tags in these fields may be stripped if sanitiazation isn't disabled. Defaults to HtmlSanitization.SIMPLE_FORMATTING_ONLY.
func (o ProcessingOptionsOutput) HtmlSanitization() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ProcessingOptions) *string { return v.HtmlSanitization }).(pulumi.StringPtrOutput)
}

type ProcessingOptionsPtrOutput struct{ *pulumi.OutputState }

func (ProcessingOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ProcessingOptions)(nil)).Elem()
}

func (o ProcessingOptionsPtrOutput) ToProcessingOptionsPtrOutput() ProcessingOptionsPtrOutput {
	return o
}

func (o ProcessingOptionsPtrOutput) ToProcessingOptionsPtrOutputWithContext(ctx context.Context) ProcessingOptionsPtrOutput {
	return o
}

func (o ProcessingOptionsPtrOutput) Elem() ProcessingOptionsOutput {
	return o.ApplyT(func(v *ProcessingOptions) ProcessingOptions { return *v }).(ProcessingOptionsOutput)
}

// If set to `true`, the service does not attempt to resolve a more precise address for the job.
func (o ProcessingOptionsPtrOutput) DisableStreetAddressResolution() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ProcessingOptions) *bool {
		if v == nil {
			return nil
		}
		return v.DisableStreetAddressResolution
	}).(pulumi.BoolPtrOutput)
}

// Option for job HTML content sanitization. Applied fields are: * description * applicationInfo.instruction * incentives * qualifications * responsibilities HTML tags in these fields may be stripped if sanitiazation isn't disabled. Defaults to HtmlSanitization.SIMPLE_FORMATTING_ONLY.
func (o ProcessingOptionsPtrOutput) HtmlSanitization() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ProcessingOptions) *string {
		if v == nil {
			return nil
		}
		return v.HtmlSanitization
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterOutputType(ApplicationInfoOutput{})
	pulumi.RegisterOutputType(ApplicationInfoPtrOutput{})
	pulumi.RegisterOutputType(CompanyDerivedInfoOutput{})
	pulumi.RegisterOutputType(CompanyDerivedInfoPtrOutput{})
	pulumi.RegisterOutputType(CompensationEntryOutput{})
	pulumi.RegisterOutputType(CompensationEntryArrayOutput{})
	pulumi.RegisterOutputType(CompensationInfoOutput{})
	pulumi.RegisterOutputType(CompensationInfoPtrOutput{})
	pulumi.RegisterOutputType(CompensationRangeOutput{})
	pulumi.RegisterOutputType(CompensationRangePtrOutput{})
	pulumi.RegisterOutputType(JobDerivedInfoOutput{})
	pulumi.RegisterOutputType(JobDerivedInfoPtrOutput{})
	pulumi.RegisterOutputType(JobEventOutput{})
	pulumi.RegisterOutputType(JobEventPtrOutput{})
	pulumi.RegisterOutputType(LatLngOutput{})
	pulumi.RegisterOutputType(LatLngPtrOutput{})
	pulumi.RegisterOutputType(LocationOutput{})
	pulumi.RegisterOutputType(LocationPtrOutput{})
	pulumi.RegisterOutputType(LocationArrayOutput{})
	pulumi.RegisterOutputType(MoneyOutput{})
	pulumi.RegisterOutputType(MoneyPtrOutput{})
	pulumi.RegisterOutputType(PostalAddressOutput{})
	pulumi.RegisterOutputType(PostalAddressPtrOutput{})
	pulumi.RegisterOutputType(ProcessingOptionsOutput{})
	pulumi.RegisterOutputType(ProcessingOptionsPtrOutput{})
}
