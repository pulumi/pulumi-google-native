// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-google-native/sdk/go/google/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = internal.GetEnvOrDefault

// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
type Aggregation struct {
	// The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
	AlignmentPeriod *string `pulumi:"alignmentPeriod"`
	// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
	CrossSeriesReducer *AggregationCrossSeriesReducer `pulumi:"crossSeriesReducer"`
	// The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
	GroupByFields []string `pulumi:"groupByFields"`
	// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
	PerSeriesAligner *AggregationPerSeriesAligner `pulumi:"perSeriesAligner"`
}

// AggregationInput is an input type that accepts AggregationArgs and AggregationOutput values.
// You can construct a concrete instance of `AggregationInput` via:
//
//	AggregationArgs{...}
type AggregationInput interface {
	pulumi.Input

	ToAggregationOutput() AggregationOutput
	ToAggregationOutputWithContext(context.Context) AggregationOutput
}

// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
type AggregationArgs struct {
	// The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
	AlignmentPeriod pulumi.StringPtrInput `pulumi:"alignmentPeriod"`
	// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
	CrossSeriesReducer AggregationCrossSeriesReducerPtrInput `pulumi:"crossSeriesReducer"`
	// The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
	GroupByFields pulumi.StringArrayInput `pulumi:"groupByFields"`
	// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
	PerSeriesAligner AggregationPerSeriesAlignerPtrInput `pulumi:"perSeriesAligner"`
}

func (AggregationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Aggregation)(nil)).Elem()
}

func (i AggregationArgs) ToAggregationOutput() AggregationOutput {
	return i.ToAggregationOutputWithContext(context.Background())
}

func (i AggregationArgs) ToAggregationOutputWithContext(ctx context.Context) AggregationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AggregationOutput)
}

func (i AggregationArgs) ToAggregationPtrOutput() AggregationPtrOutput {
	return i.ToAggregationPtrOutputWithContext(context.Background())
}

func (i AggregationArgs) ToAggregationPtrOutputWithContext(ctx context.Context) AggregationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AggregationOutput).ToAggregationPtrOutputWithContext(ctx)
}

// AggregationPtrInput is an input type that accepts AggregationArgs, AggregationPtr and AggregationPtrOutput values.
// You can construct a concrete instance of `AggregationPtrInput` via:
//
//	        AggregationArgs{...}
//
//	or:
//
//	        nil
type AggregationPtrInput interface {
	pulumi.Input

	ToAggregationPtrOutput() AggregationPtrOutput
	ToAggregationPtrOutputWithContext(context.Context) AggregationPtrOutput
}

type aggregationPtrType AggregationArgs

func AggregationPtr(v *AggregationArgs) AggregationPtrInput {
	return (*aggregationPtrType)(v)
}

func (*aggregationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Aggregation)(nil)).Elem()
}

func (i *aggregationPtrType) ToAggregationPtrOutput() AggregationPtrOutput {
	return i.ToAggregationPtrOutputWithContext(context.Background())
}

func (i *aggregationPtrType) ToAggregationPtrOutputWithContext(ctx context.Context) AggregationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AggregationPtrOutput)
}

// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
type AggregationOutput struct{ *pulumi.OutputState }

func (AggregationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Aggregation)(nil)).Elem()
}

func (o AggregationOutput) ToAggregationOutput() AggregationOutput {
	return o
}

func (o AggregationOutput) ToAggregationOutputWithContext(ctx context.Context) AggregationOutput {
	return o
}

func (o AggregationOutput) ToAggregationPtrOutput() AggregationPtrOutput {
	return o.ToAggregationPtrOutputWithContext(context.Background())
}

func (o AggregationOutput) ToAggregationPtrOutputWithContext(ctx context.Context) AggregationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Aggregation) *Aggregation {
		return &v
	}).(AggregationPtrOutput)
}

// The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
func (o AggregationOutput) AlignmentPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Aggregation) *string { return v.AlignmentPeriod }).(pulumi.StringPtrOutput)
}

// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
func (o AggregationOutput) CrossSeriesReducer() AggregationCrossSeriesReducerPtrOutput {
	return o.ApplyT(func(v Aggregation) *AggregationCrossSeriesReducer { return v.CrossSeriesReducer }).(AggregationCrossSeriesReducerPtrOutput)
}

// The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
func (o AggregationOutput) GroupByFields() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Aggregation) []string { return v.GroupByFields }).(pulumi.StringArrayOutput)
}

// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
func (o AggregationOutput) PerSeriesAligner() AggregationPerSeriesAlignerPtrOutput {
	return o.ApplyT(func(v Aggregation) *AggregationPerSeriesAligner { return v.PerSeriesAligner }).(AggregationPerSeriesAlignerPtrOutput)
}

type AggregationPtrOutput struct{ *pulumi.OutputState }

func (AggregationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Aggregation)(nil)).Elem()
}

func (o AggregationPtrOutput) ToAggregationPtrOutput() AggregationPtrOutput {
	return o
}

func (o AggregationPtrOutput) ToAggregationPtrOutputWithContext(ctx context.Context) AggregationPtrOutput {
	return o
}

func (o AggregationPtrOutput) Elem() AggregationOutput {
	return o.ApplyT(func(v *Aggregation) Aggregation {
		if v != nil {
			return *v
		}
		var ret Aggregation
		return ret
	}).(AggregationOutput)
}

// The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
func (o AggregationPtrOutput) AlignmentPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Aggregation) *string {
		if v == nil {
			return nil
		}
		return v.AlignmentPeriod
	}).(pulumi.StringPtrOutput)
}

// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
func (o AggregationPtrOutput) CrossSeriesReducer() AggregationCrossSeriesReducerPtrOutput {
	return o.ApplyT(func(v *Aggregation) *AggregationCrossSeriesReducer {
		if v == nil {
			return nil
		}
		return v.CrossSeriesReducer
	}).(AggregationCrossSeriesReducerPtrOutput)
}

// The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
func (o AggregationPtrOutput) GroupByFields() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Aggregation) []string {
		if v == nil {
			return nil
		}
		return v.GroupByFields
	}).(pulumi.StringArrayOutput)
}

// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
func (o AggregationPtrOutput) PerSeriesAligner() AggregationPerSeriesAlignerPtrOutput {
	return o.ApplyT(func(v *Aggregation) *AggregationPerSeriesAligner {
		if v == nil {
			return nil
		}
		return v.PerSeriesAligner
	}).(AggregationPerSeriesAlignerPtrOutput)
}

// Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release.
type AggregationFunction struct {
	// Optional. Parameters applied to the aggregation function. Only used for functions that require them.
	Parameters []Parameter `pulumi:"parameters"`
	// The type of aggregation function, must be one of the following: "none" - no function. "percentile" - APPROX_QUANTILES() - 1 parameter numeric value "average" - AVG() "count" - COUNT() "count-distinct" - COUNT(DISTINCT) "count-distinct-approx" - APPROX_COUNT_DISTINCT() "max" - MAX() "min" - MIN() "sum" - SUM()
	Type string `pulumi:"type"`
}

// AggregationFunctionInput is an input type that accepts AggregationFunctionArgs and AggregationFunctionOutput values.
// You can construct a concrete instance of `AggregationFunctionInput` via:
//
//	AggregationFunctionArgs{...}
type AggregationFunctionInput interface {
	pulumi.Input

	ToAggregationFunctionOutput() AggregationFunctionOutput
	ToAggregationFunctionOutputWithContext(context.Context) AggregationFunctionOutput
}

// Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release.
type AggregationFunctionArgs struct {
	// Optional. Parameters applied to the aggregation function. Only used for functions that require them.
	Parameters ParameterArrayInput `pulumi:"parameters"`
	// The type of aggregation function, must be one of the following: "none" - no function. "percentile" - APPROX_QUANTILES() - 1 parameter numeric value "average" - AVG() "count" - COUNT() "count-distinct" - COUNT(DISTINCT) "count-distinct-approx" - APPROX_COUNT_DISTINCT() "max" - MAX() "min" - MIN() "sum" - SUM()
	Type pulumi.StringInput `pulumi:"type"`
}

func (AggregationFunctionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AggregationFunction)(nil)).Elem()
}

func (i AggregationFunctionArgs) ToAggregationFunctionOutput() AggregationFunctionOutput {
	return i.ToAggregationFunctionOutputWithContext(context.Background())
}

func (i AggregationFunctionArgs) ToAggregationFunctionOutputWithContext(ctx context.Context) AggregationFunctionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AggregationFunctionOutput)
}

// Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release.
type AggregationFunctionOutput struct{ *pulumi.OutputState }

func (AggregationFunctionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AggregationFunction)(nil)).Elem()
}

func (o AggregationFunctionOutput) ToAggregationFunctionOutput() AggregationFunctionOutput {
	return o
}

func (o AggregationFunctionOutput) ToAggregationFunctionOutputWithContext(ctx context.Context) AggregationFunctionOutput {
	return o
}

// Optional. Parameters applied to the aggregation function. Only used for functions that require them.
func (o AggregationFunctionOutput) Parameters() ParameterArrayOutput {
	return o.ApplyT(func(v AggregationFunction) []Parameter { return v.Parameters }).(ParameterArrayOutput)
}

// The type of aggregation function, must be one of the following: "none" - no function. "percentile" - APPROX_QUANTILES() - 1 parameter numeric value "average" - AVG() "count" - COUNT() "count-distinct" - COUNT(DISTINCT) "count-distinct-approx" - APPROX_COUNT_DISTINCT() "max" - MAX() "min" - MIN() "sum" - SUM()
func (o AggregationFunctionOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v AggregationFunction) string { return v.Type }).(pulumi.StringOutput)
}

// Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release.
type AggregationFunctionResponse struct {
	// Optional. Parameters applied to the aggregation function. Only used for functions that require them.
	Parameters []ParameterResponse `pulumi:"parameters"`
	// The type of aggregation function, must be one of the following: "none" - no function. "percentile" - APPROX_QUANTILES() - 1 parameter numeric value "average" - AVG() "count" - COUNT() "count-distinct" - COUNT(DISTINCT) "count-distinct-approx" - APPROX_COUNT_DISTINCT() "max" - MAX() "min" - MIN() "sum" - SUM()
	Type string `pulumi:"type"`
}

// Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release.
type AggregationFunctionResponseOutput struct{ *pulumi.OutputState }

func (AggregationFunctionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AggregationFunctionResponse)(nil)).Elem()
}

func (o AggregationFunctionResponseOutput) ToAggregationFunctionResponseOutput() AggregationFunctionResponseOutput {
	return o
}

func (o AggregationFunctionResponseOutput) ToAggregationFunctionResponseOutputWithContext(ctx context.Context) AggregationFunctionResponseOutput {
	return o
}

// Optional. Parameters applied to the aggregation function. Only used for functions that require them.
func (o AggregationFunctionResponseOutput) Parameters() ParameterResponseArrayOutput {
	return o.ApplyT(func(v AggregationFunctionResponse) []ParameterResponse { return v.Parameters }).(ParameterResponseArrayOutput)
}

// The type of aggregation function, must be one of the following: "none" - no function. "percentile" - APPROX_QUANTILES() - 1 parameter numeric value "average" - AVG() "count" - COUNT() "count-distinct" - COUNT(DISTINCT) "count-distinct-approx" - APPROX_COUNT_DISTINCT() "max" - MAX() "min" - MIN() "sum" - SUM()
func (o AggregationFunctionResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v AggregationFunctionResponse) string { return v.Type }).(pulumi.StringOutput)
}

// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
type AggregationResponse struct {
	// The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
	AlignmentPeriod string `pulumi:"alignmentPeriod"`
	// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
	CrossSeriesReducer string `pulumi:"crossSeriesReducer"`
	// The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
	GroupByFields []string `pulumi:"groupByFields"`
	// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
	PerSeriesAligner string `pulumi:"perSeriesAligner"`
}

// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
type AggregationResponseOutput struct{ *pulumi.OutputState }

func (AggregationResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AggregationResponse)(nil)).Elem()
}

func (o AggregationResponseOutput) ToAggregationResponseOutput() AggregationResponseOutput {
	return o
}

func (o AggregationResponseOutput) ToAggregationResponseOutputWithContext(ctx context.Context) AggregationResponseOutput {
	return o
}

// The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
func (o AggregationResponseOutput) AlignmentPeriod() pulumi.StringOutput {
	return o.ApplyT(func(v AggregationResponse) string { return v.AlignmentPeriod }).(pulumi.StringOutput)
}

// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
func (o AggregationResponseOutput) CrossSeriesReducer() pulumi.StringOutput {
	return o.ApplyT(func(v AggregationResponse) string { return v.CrossSeriesReducer }).(pulumi.StringOutput)
}

// The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
func (o AggregationResponseOutput) GroupByFields() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AggregationResponse) []string { return v.GroupByFields }).(pulumi.StringArrayOutput)
}

// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
func (o AggregationResponseOutput) PerSeriesAligner() pulumi.StringOutput {
	return o.ApplyT(func(v AggregationResponse) string { return v.PerSeriesAligner }).(pulumi.StringOutput)
}

// A chart that displays alert policy data.
type AlertChart struct {
	// The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
	Name string `pulumi:"name"`
}

// AlertChartInput is an input type that accepts AlertChartArgs and AlertChartOutput values.
// You can construct a concrete instance of `AlertChartInput` via:
//
//	AlertChartArgs{...}
type AlertChartInput interface {
	pulumi.Input

	ToAlertChartOutput() AlertChartOutput
	ToAlertChartOutputWithContext(context.Context) AlertChartOutput
}

// A chart that displays alert policy data.
type AlertChartArgs struct {
	// The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
	Name pulumi.StringInput `pulumi:"name"`
}

func (AlertChartArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertChart)(nil)).Elem()
}

func (i AlertChartArgs) ToAlertChartOutput() AlertChartOutput {
	return i.ToAlertChartOutputWithContext(context.Background())
}

func (i AlertChartArgs) ToAlertChartOutputWithContext(ctx context.Context) AlertChartOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertChartOutput)
}

func (i AlertChartArgs) ToAlertChartPtrOutput() AlertChartPtrOutput {
	return i.ToAlertChartPtrOutputWithContext(context.Background())
}

func (i AlertChartArgs) ToAlertChartPtrOutputWithContext(ctx context.Context) AlertChartPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertChartOutput).ToAlertChartPtrOutputWithContext(ctx)
}

// AlertChartPtrInput is an input type that accepts AlertChartArgs, AlertChartPtr and AlertChartPtrOutput values.
// You can construct a concrete instance of `AlertChartPtrInput` via:
//
//	        AlertChartArgs{...}
//
//	or:
//
//	        nil
type AlertChartPtrInput interface {
	pulumi.Input

	ToAlertChartPtrOutput() AlertChartPtrOutput
	ToAlertChartPtrOutputWithContext(context.Context) AlertChartPtrOutput
}

type alertChartPtrType AlertChartArgs

func AlertChartPtr(v *AlertChartArgs) AlertChartPtrInput {
	return (*alertChartPtrType)(v)
}

func (*alertChartPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AlertChart)(nil)).Elem()
}

func (i *alertChartPtrType) ToAlertChartPtrOutput() AlertChartPtrOutput {
	return i.ToAlertChartPtrOutputWithContext(context.Background())
}

func (i *alertChartPtrType) ToAlertChartPtrOutputWithContext(ctx context.Context) AlertChartPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlertChartPtrOutput)
}

// A chart that displays alert policy data.
type AlertChartOutput struct{ *pulumi.OutputState }

func (AlertChartOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertChart)(nil)).Elem()
}

func (o AlertChartOutput) ToAlertChartOutput() AlertChartOutput {
	return o
}

func (o AlertChartOutput) ToAlertChartOutputWithContext(ctx context.Context) AlertChartOutput {
	return o
}

func (o AlertChartOutput) ToAlertChartPtrOutput() AlertChartPtrOutput {
	return o.ToAlertChartPtrOutputWithContext(context.Background())
}

func (o AlertChartOutput) ToAlertChartPtrOutputWithContext(ctx context.Context) AlertChartPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AlertChart) *AlertChart {
		return &v
	}).(AlertChartPtrOutput)
}

// The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
func (o AlertChartOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v AlertChart) string { return v.Name }).(pulumi.StringOutput)
}

type AlertChartPtrOutput struct{ *pulumi.OutputState }

func (AlertChartPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AlertChart)(nil)).Elem()
}

func (o AlertChartPtrOutput) ToAlertChartPtrOutput() AlertChartPtrOutput {
	return o
}

func (o AlertChartPtrOutput) ToAlertChartPtrOutputWithContext(ctx context.Context) AlertChartPtrOutput {
	return o
}

func (o AlertChartPtrOutput) Elem() AlertChartOutput {
	return o.ApplyT(func(v *AlertChart) AlertChart {
		if v != nil {
			return *v
		}
		var ret AlertChart
		return ret
	}).(AlertChartOutput)
}

// The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
func (o AlertChartPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AlertChart) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// A chart that displays alert policy data.
type AlertChartResponse struct {
	// The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
	Name string `pulumi:"name"`
}

// A chart that displays alert policy data.
type AlertChartResponseOutput struct{ *pulumi.OutputState }

func (AlertChartResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlertChartResponse)(nil)).Elem()
}

func (o AlertChartResponseOutput) ToAlertChartResponseOutput() AlertChartResponseOutput {
	return o
}

func (o AlertChartResponseOutput) ToAlertChartResponseOutputWithContext(ctx context.Context) AlertChartResponseOutput {
	return o
}

// The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
func (o AlertChartResponseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v AlertChartResponse) string { return v.Name }).(pulumi.StringOutput)
}

// A chart axis.
type Axis struct {
	// The label of the axis.
	Label *string `pulumi:"label"`
	// The axis scale. By default, a linear scale is used.
	Scale *AxisScale `pulumi:"scale"`
}

// AxisInput is an input type that accepts AxisArgs and AxisOutput values.
// You can construct a concrete instance of `AxisInput` via:
//
//	AxisArgs{...}
type AxisInput interface {
	pulumi.Input

	ToAxisOutput() AxisOutput
	ToAxisOutputWithContext(context.Context) AxisOutput
}

// A chart axis.
type AxisArgs struct {
	// The label of the axis.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// The axis scale. By default, a linear scale is used.
	Scale AxisScalePtrInput `pulumi:"scale"`
}

func (AxisArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Axis)(nil)).Elem()
}

func (i AxisArgs) ToAxisOutput() AxisOutput {
	return i.ToAxisOutputWithContext(context.Background())
}

func (i AxisArgs) ToAxisOutputWithContext(ctx context.Context) AxisOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AxisOutput)
}

func (i AxisArgs) ToAxisPtrOutput() AxisPtrOutput {
	return i.ToAxisPtrOutputWithContext(context.Background())
}

func (i AxisArgs) ToAxisPtrOutputWithContext(ctx context.Context) AxisPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AxisOutput).ToAxisPtrOutputWithContext(ctx)
}

// AxisPtrInput is an input type that accepts AxisArgs, AxisPtr and AxisPtrOutput values.
// You can construct a concrete instance of `AxisPtrInput` via:
//
//	        AxisArgs{...}
//
//	or:
//
//	        nil
type AxisPtrInput interface {
	pulumi.Input

	ToAxisPtrOutput() AxisPtrOutput
	ToAxisPtrOutputWithContext(context.Context) AxisPtrOutput
}

type axisPtrType AxisArgs

func AxisPtr(v *AxisArgs) AxisPtrInput {
	return (*axisPtrType)(v)
}

func (*axisPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Axis)(nil)).Elem()
}

func (i *axisPtrType) ToAxisPtrOutput() AxisPtrOutput {
	return i.ToAxisPtrOutputWithContext(context.Background())
}

func (i *axisPtrType) ToAxisPtrOutputWithContext(ctx context.Context) AxisPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AxisPtrOutput)
}

// A chart axis.
type AxisOutput struct{ *pulumi.OutputState }

func (AxisOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Axis)(nil)).Elem()
}

func (o AxisOutput) ToAxisOutput() AxisOutput {
	return o
}

func (o AxisOutput) ToAxisOutputWithContext(ctx context.Context) AxisOutput {
	return o
}

func (o AxisOutput) ToAxisPtrOutput() AxisPtrOutput {
	return o.ToAxisPtrOutputWithContext(context.Background())
}

func (o AxisOutput) ToAxisPtrOutputWithContext(ctx context.Context) AxisPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Axis) *Axis {
		return &v
	}).(AxisPtrOutput)
}

// The label of the axis.
func (o AxisOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Axis) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The axis scale. By default, a linear scale is used.
func (o AxisOutput) Scale() AxisScalePtrOutput {
	return o.ApplyT(func(v Axis) *AxisScale { return v.Scale }).(AxisScalePtrOutput)
}

type AxisPtrOutput struct{ *pulumi.OutputState }

func (AxisPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Axis)(nil)).Elem()
}

func (o AxisPtrOutput) ToAxisPtrOutput() AxisPtrOutput {
	return o
}

func (o AxisPtrOutput) ToAxisPtrOutputWithContext(ctx context.Context) AxisPtrOutput {
	return o
}

func (o AxisPtrOutput) Elem() AxisOutput {
	return o.ApplyT(func(v *Axis) Axis {
		if v != nil {
			return *v
		}
		var ret Axis
		return ret
	}).(AxisOutput)
}

// The label of the axis.
func (o AxisPtrOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Axis) *string {
		if v == nil {
			return nil
		}
		return v.Label
	}).(pulumi.StringPtrOutput)
}

// The axis scale. By default, a linear scale is used.
func (o AxisPtrOutput) Scale() AxisScalePtrOutput {
	return o.ApplyT(func(v *Axis) *AxisScale {
		if v == nil {
			return nil
		}
		return v.Scale
	}).(AxisScalePtrOutput)
}

// A chart axis.
type AxisResponse struct {
	// The label of the axis.
	Label string `pulumi:"label"`
	// The axis scale. By default, a linear scale is used.
	Scale string `pulumi:"scale"`
}

// A chart axis.
type AxisResponseOutput struct{ *pulumi.OutputState }

func (AxisResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AxisResponse)(nil)).Elem()
}

func (o AxisResponseOutput) ToAxisResponseOutput() AxisResponseOutput {
	return o
}

func (o AxisResponseOutput) ToAxisResponseOutputWithContext(ctx context.Context) AxisResponseOutput {
	return o
}

// The label of the axis.
func (o AxisResponseOutput) Label() pulumi.StringOutput {
	return o.ApplyT(func(v AxisResponse) string { return v.Label }).(pulumi.StringOutput)
}

// The axis scale. By default, a linear scale is used.
func (o AxisResponseOutput) Scale() pulumi.StringOutput {
	return o.ApplyT(func(v AxisResponse) string { return v.Scale }).(pulumi.StringOutput)
}

// Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
type Breakdown struct {
	// The Aggregation function is applied across all data in each breakdown created.
	AggregationFunction AggregationFunction `pulumi:"aggregationFunction"`
	// The name of the column in the dataset containing the breakdown values.
	Column string `pulumi:"column"`
	// A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
	Limit int `pulumi:"limit"`
	// The sort order is applied to the values of the breakdown column.
	SortOrder BreakdownSortOrder `pulumi:"sortOrder"`
}

// BreakdownInput is an input type that accepts BreakdownArgs and BreakdownOutput values.
// You can construct a concrete instance of `BreakdownInput` via:
//
//	BreakdownArgs{...}
type BreakdownInput interface {
	pulumi.Input

	ToBreakdownOutput() BreakdownOutput
	ToBreakdownOutputWithContext(context.Context) BreakdownOutput
}

// Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
type BreakdownArgs struct {
	// The Aggregation function is applied across all data in each breakdown created.
	AggregationFunction AggregationFunctionInput `pulumi:"aggregationFunction"`
	// The name of the column in the dataset containing the breakdown values.
	Column pulumi.StringInput `pulumi:"column"`
	// A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
	Limit pulumi.IntInput `pulumi:"limit"`
	// The sort order is applied to the values of the breakdown column.
	SortOrder BreakdownSortOrderInput `pulumi:"sortOrder"`
}

func (BreakdownArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Breakdown)(nil)).Elem()
}

func (i BreakdownArgs) ToBreakdownOutput() BreakdownOutput {
	return i.ToBreakdownOutputWithContext(context.Background())
}

func (i BreakdownArgs) ToBreakdownOutputWithContext(ctx context.Context) BreakdownOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BreakdownOutput)
}

// BreakdownArrayInput is an input type that accepts BreakdownArray and BreakdownArrayOutput values.
// You can construct a concrete instance of `BreakdownArrayInput` via:
//
//	BreakdownArray{ BreakdownArgs{...} }
type BreakdownArrayInput interface {
	pulumi.Input

	ToBreakdownArrayOutput() BreakdownArrayOutput
	ToBreakdownArrayOutputWithContext(context.Context) BreakdownArrayOutput
}

type BreakdownArray []BreakdownInput

func (BreakdownArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Breakdown)(nil)).Elem()
}

func (i BreakdownArray) ToBreakdownArrayOutput() BreakdownArrayOutput {
	return i.ToBreakdownArrayOutputWithContext(context.Background())
}

func (i BreakdownArray) ToBreakdownArrayOutputWithContext(ctx context.Context) BreakdownArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BreakdownArrayOutput)
}

// Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
type BreakdownOutput struct{ *pulumi.OutputState }

func (BreakdownOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Breakdown)(nil)).Elem()
}

func (o BreakdownOutput) ToBreakdownOutput() BreakdownOutput {
	return o
}

func (o BreakdownOutput) ToBreakdownOutputWithContext(ctx context.Context) BreakdownOutput {
	return o
}

// The Aggregation function is applied across all data in each breakdown created.
func (o BreakdownOutput) AggregationFunction() AggregationFunctionOutput {
	return o.ApplyT(func(v Breakdown) AggregationFunction { return v.AggregationFunction }).(AggregationFunctionOutput)
}

// The name of the column in the dataset containing the breakdown values.
func (o BreakdownOutput) Column() pulumi.StringOutput {
	return o.ApplyT(func(v Breakdown) string { return v.Column }).(pulumi.StringOutput)
}

// A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
func (o BreakdownOutput) Limit() pulumi.IntOutput {
	return o.ApplyT(func(v Breakdown) int { return v.Limit }).(pulumi.IntOutput)
}

// The sort order is applied to the values of the breakdown column.
func (o BreakdownOutput) SortOrder() BreakdownSortOrderOutput {
	return o.ApplyT(func(v Breakdown) BreakdownSortOrder { return v.SortOrder }).(BreakdownSortOrderOutput)
}

type BreakdownArrayOutput struct{ *pulumi.OutputState }

func (BreakdownArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Breakdown)(nil)).Elem()
}

func (o BreakdownArrayOutput) ToBreakdownArrayOutput() BreakdownArrayOutput {
	return o
}

func (o BreakdownArrayOutput) ToBreakdownArrayOutputWithContext(ctx context.Context) BreakdownArrayOutput {
	return o
}

func (o BreakdownArrayOutput) Index(i pulumi.IntInput) BreakdownOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Breakdown {
		return vs[0].([]Breakdown)[vs[1].(int)]
	}).(BreakdownOutput)
}

// Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
type BreakdownResponse struct {
	// The Aggregation function is applied across all data in each breakdown created.
	AggregationFunction AggregationFunctionResponse `pulumi:"aggregationFunction"`
	// The name of the column in the dataset containing the breakdown values.
	Column string `pulumi:"column"`
	// A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
	Limit int `pulumi:"limit"`
	// The sort order is applied to the values of the breakdown column.
	SortOrder string `pulumi:"sortOrder"`
}

// Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
type BreakdownResponseOutput struct{ *pulumi.OutputState }

func (BreakdownResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BreakdownResponse)(nil)).Elem()
}

func (o BreakdownResponseOutput) ToBreakdownResponseOutput() BreakdownResponseOutput {
	return o
}

func (o BreakdownResponseOutput) ToBreakdownResponseOutputWithContext(ctx context.Context) BreakdownResponseOutput {
	return o
}

// The Aggregation function is applied across all data in each breakdown created.
func (o BreakdownResponseOutput) AggregationFunction() AggregationFunctionResponseOutput {
	return o.ApplyT(func(v BreakdownResponse) AggregationFunctionResponse { return v.AggregationFunction }).(AggregationFunctionResponseOutput)
}

// The name of the column in the dataset containing the breakdown values.
func (o BreakdownResponseOutput) Column() pulumi.StringOutput {
	return o.ApplyT(func(v BreakdownResponse) string { return v.Column }).(pulumi.StringOutput)
}

// A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
func (o BreakdownResponseOutput) Limit() pulumi.IntOutput {
	return o.ApplyT(func(v BreakdownResponse) int { return v.Limit }).(pulumi.IntOutput)
}

// The sort order is applied to the values of the breakdown column.
func (o BreakdownResponseOutput) SortOrder() pulumi.StringOutput {
	return o.ApplyT(func(v BreakdownResponse) string { return v.SortOrder }).(pulumi.StringOutput)
}

type BreakdownResponseArrayOutput struct{ *pulumi.OutputState }

func (BreakdownResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BreakdownResponse)(nil)).Elem()
}

func (o BreakdownResponseArrayOutput) ToBreakdownResponseArrayOutput() BreakdownResponseArrayOutput {
	return o
}

func (o BreakdownResponseArrayOutput) ToBreakdownResponseArrayOutputWithContext(ctx context.Context) BreakdownResponseArrayOutput {
	return o
}

func (o BreakdownResponseArrayOutput) Index(i pulumi.IntInput) BreakdownResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) BreakdownResponse {
		return vs[0].([]BreakdownResponse)[vs[1].(int)]
	}).(BreakdownResponseOutput)
}

// Options to control visual rendering of a chart.
type ChartOptions struct {
	// Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
	DisplayHorizontal *bool `pulumi:"displayHorizontal"`
	// The chart mode.
	Mode *ChartOptionsMode `pulumi:"mode"`
}

// ChartOptionsInput is an input type that accepts ChartOptionsArgs and ChartOptionsOutput values.
// You can construct a concrete instance of `ChartOptionsInput` via:
//
//	ChartOptionsArgs{...}
type ChartOptionsInput interface {
	pulumi.Input

	ToChartOptionsOutput() ChartOptionsOutput
	ToChartOptionsOutputWithContext(context.Context) ChartOptionsOutput
}

// Options to control visual rendering of a chart.
type ChartOptionsArgs struct {
	// Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
	DisplayHorizontal pulumi.BoolPtrInput `pulumi:"displayHorizontal"`
	// The chart mode.
	Mode ChartOptionsModePtrInput `pulumi:"mode"`
}

func (ChartOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChartOptions)(nil)).Elem()
}

func (i ChartOptionsArgs) ToChartOptionsOutput() ChartOptionsOutput {
	return i.ToChartOptionsOutputWithContext(context.Background())
}

func (i ChartOptionsArgs) ToChartOptionsOutputWithContext(ctx context.Context) ChartOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChartOptionsOutput)
}

func (i ChartOptionsArgs) ToChartOptionsPtrOutput() ChartOptionsPtrOutput {
	return i.ToChartOptionsPtrOutputWithContext(context.Background())
}

func (i ChartOptionsArgs) ToChartOptionsPtrOutputWithContext(ctx context.Context) ChartOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChartOptionsOutput).ToChartOptionsPtrOutputWithContext(ctx)
}

// ChartOptionsPtrInput is an input type that accepts ChartOptionsArgs, ChartOptionsPtr and ChartOptionsPtrOutput values.
// You can construct a concrete instance of `ChartOptionsPtrInput` via:
//
//	        ChartOptionsArgs{...}
//
//	or:
//
//	        nil
type ChartOptionsPtrInput interface {
	pulumi.Input

	ToChartOptionsPtrOutput() ChartOptionsPtrOutput
	ToChartOptionsPtrOutputWithContext(context.Context) ChartOptionsPtrOutput
}

type chartOptionsPtrType ChartOptionsArgs

func ChartOptionsPtr(v *ChartOptionsArgs) ChartOptionsPtrInput {
	return (*chartOptionsPtrType)(v)
}

func (*chartOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChartOptions)(nil)).Elem()
}

func (i *chartOptionsPtrType) ToChartOptionsPtrOutput() ChartOptionsPtrOutput {
	return i.ToChartOptionsPtrOutputWithContext(context.Background())
}

func (i *chartOptionsPtrType) ToChartOptionsPtrOutputWithContext(ctx context.Context) ChartOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChartOptionsPtrOutput)
}

// Options to control visual rendering of a chart.
type ChartOptionsOutput struct{ *pulumi.OutputState }

func (ChartOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChartOptions)(nil)).Elem()
}

func (o ChartOptionsOutput) ToChartOptionsOutput() ChartOptionsOutput {
	return o
}

func (o ChartOptionsOutput) ToChartOptionsOutputWithContext(ctx context.Context) ChartOptionsOutput {
	return o
}

func (o ChartOptionsOutput) ToChartOptionsPtrOutput() ChartOptionsPtrOutput {
	return o.ToChartOptionsPtrOutputWithContext(context.Background())
}

func (o ChartOptionsOutput) ToChartOptionsPtrOutputWithContext(ctx context.Context) ChartOptionsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChartOptions) *ChartOptions {
		return &v
	}).(ChartOptionsPtrOutput)
}

// Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
func (o ChartOptionsOutput) DisplayHorizontal() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ChartOptions) *bool { return v.DisplayHorizontal }).(pulumi.BoolPtrOutput)
}

// The chart mode.
func (o ChartOptionsOutput) Mode() ChartOptionsModePtrOutput {
	return o.ApplyT(func(v ChartOptions) *ChartOptionsMode { return v.Mode }).(ChartOptionsModePtrOutput)
}

type ChartOptionsPtrOutput struct{ *pulumi.OutputState }

func (ChartOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChartOptions)(nil)).Elem()
}

func (o ChartOptionsPtrOutput) ToChartOptionsPtrOutput() ChartOptionsPtrOutput {
	return o
}

func (o ChartOptionsPtrOutput) ToChartOptionsPtrOutputWithContext(ctx context.Context) ChartOptionsPtrOutput {
	return o
}

func (o ChartOptionsPtrOutput) Elem() ChartOptionsOutput {
	return o.ApplyT(func(v *ChartOptions) ChartOptions {
		if v != nil {
			return *v
		}
		var ret ChartOptions
		return ret
	}).(ChartOptionsOutput)
}

// Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
func (o ChartOptionsPtrOutput) DisplayHorizontal() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ChartOptions) *bool {
		if v == nil {
			return nil
		}
		return v.DisplayHorizontal
	}).(pulumi.BoolPtrOutput)
}

// The chart mode.
func (o ChartOptionsPtrOutput) Mode() ChartOptionsModePtrOutput {
	return o.ApplyT(func(v *ChartOptions) *ChartOptionsMode {
		if v == nil {
			return nil
		}
		return v.Mode
	}).(ChartOptionsModePtrOutput)
}

// Options to control visual rendering of a chart.
type ChartOptionsResponse struct {
	// Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
	DisplayHorizontal bool `pulumi:"displayHorizontal"`
	// The chart mode.
	Mode string `pulumi:"mode"`
}

// Options to control visual rendering of a chart.
type ChartOptionsResponseOutput struct{ *pulumi.OutputState }

func (ChartOptionsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChartOptionsResponse)(nil)).Elem()
}

func (o ChartOptionsResponseOutput) ToChartOptionsResponseOutput() ChartOptionsResponseOutput {
	return o
}

func (o ChartOptionsResponseOutput) ToChartOptionsResponseOutputWithContext(ctx context.Context) ChartOptionsResponseOutput {
	return o
}

// Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
func (o ChartOptionsResponseOutput) DisplayHorizontal() pulumi.BoolOutput {
	return o.ApplyT(func(v ChartOptionsResponse) bool { return v.DisplayHorizontal }).(pulumi.BoolOutput)
}

// The chart mode.
func (o ChartOptionsResponseOutput) Mode() pulumi.StringOutput {
	return o.ApplyT(func(v ChartOptionsResponse) string { return v.Mode }).(pulumi.StringOutput)
}

// A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
type CollapsibleGroup struct {
	// The collapsed state of the widget on first page load.
	Collapsed *bool `pulumi:"collapsed"`
}

// CollapsibleGroupInput is an input type that accepts CollapsibleGroupArgs and CollapsibleGroupOutput values.
// You can construct a concrete instance of `CollapsibleGroupInput` via:
//
//	CollapsibleGroupArgs{...}
type CollapsibleGroupInput interface {
	pulumi.Input

	ToCollapsibleGroupOutput() CollapsibleGroupOutput
	ToCollapsibleGroupOutputWithContext(context.Context) CollapsibleGroupOutput
}

// A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
type CollapsibleGroupArgs struct {
	// The collapsed state of the widget on first page load.
	Collapsed pulumi.BoolPtrInput `pulumi:"collapsed"`
}

func (CollapsibleGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CollapsibleGroup)(nil)).Elem()
}

func (i CollapsibleGroupArgs) ToCollapsibleGroupOutput() CollapsibleGroupOutput {
	return i.ToCollapsibleGroupOutputWithContext(context.Background())
}

func (i CollapsibleGroupArgs) ToCollapsibleGroupOutputWithContext(ctx context.Context) CollapsibleGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CollapsibleGroupOutput)
}

func (i CollapsibleGroupArgs) ToCollapsibleGroupPtrOutput() CollapsibleGroupPtrOutput {
	return i.ToCollapsibleGroupPtrOutputWithContext(context.Background())
}

func (i CollapsibleGroupArgs) ToCollapsibleGroupPtrOutputWithContext(ctx context.Context) CollapsibleGroupPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CollapsibleGroupOutput).ToCollapsibleGroupPtrOutputWithContext(ctx)
}

// CollapsibleGroupPtrInput is an input type that accepts CollapsibleGroupArgs, CollapsibleGroupPtr and CollapsibleGroupPtrOutput values.
// You can construct a concrete instance of `CollapsibleGroupPtrInput` via:
//
//	        CollapsibleGroupArgs{...}
//
//	or:
//
//	        nil
type CollapsibleGroupPtrInput interface {
	pulumi.Input

	ToCollapsibleGroupPtrOutput() CollapsibleGroupPtrOutput
	ToCollapsibleGroupPtrOutputWithContext(context.Context) CollapsibleGroupPtrOutput
}

type collapsibleGroupPtrType CollapsibleGroupArgs

func CollapsibleGroupPtr(v *CollapsibleGroupArgs) CollapsibleGroupPtrInput {
	return (*collapsibleGroupPtrType)(v)
}

func (*collapsibleGroupPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CollapsibleGroup)(nil)).Elem()
}

func (i *collapsibleGroupPtrType) ToCollapsibleGroupPtrOutput() CollapsibleGroupPtrOutput {
	return i.ToCollapsibleGroupPtrOutputWithContext(context.Background())
}

func (i *collapsibleGroupPtrType) ToCollapsibleGroupPtrOutputWithContext(ctx context.Context) CollapsibleGroupPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CollapsibleGroupPtrOutput)
}

// A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
type CollapsibleGroupOutput struct{ *pulumi.OutputState }

func (CollapsibleGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CollapsibleGroup)(nil)).Elem()
}

func (o CollapsibleGroupOutput) ToCollapsibleGroupOutput() CollapsibleGroupOutput {
	return o
}

func (o CollapsibleGroupOutput) ToCollapsibleGroupOutputWithContext(ctx context.Context) CollapsibleGroupOutput {
	return o
}

func (o CollapsibleGroupOutput) ToCollapsibleGroupPtrOutput() CollapsibleGroupPtrOutput {
	return o.ToCollapsibleGroupPtrOutputWithContext(context.Background())
}

func (o CollapsibleGroupOutput) ToCollapsibleGroupPtrOutputWithContext(ctx context.Context) CollapsibleGroupPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CollapsibleGroup) *CollapsibleGroup {
		return &v
	}).(CollapsibleGroupPtrOutput)
}

// The collapsed state of the widget on first page load.
func (o CollapsibleGroupOutput) Collapsed() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CollapsibleGroup) *bool { return v.Collapsed }).(pulumi.BoolPtrOutput)
}

type CollapsibleGroupPtrOutput struct{ *pulumi.OutputState }

func (CollapsibleGroupPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CollapsibleGroup)(nil)).Elem()
}

func (o CollapsibleGroupPtrOutput) ToCollapsibleGroupPtrOutput() CollapsibleGroupPtrOutput {
	return o
}

func (o CollapsibleGroupPtrOutput) ToCollapsibleGroupPtrOutputWithContext(ctx context.Context) CollapsibleGroupPtrOutput {
	return o
}

func (o CollapsibleGroupPtrOutput) Elem() CollapsibleGroupOutput {
	return o.ApplyT(func(v *CollapsibleGroup) CollapsibleGroup {
		if v != nil {
			return *v
		}
		var ret CollapsibleGroup
		return ret
	}).(CollapsibleGroupOutput)
}

// The collapsed state of the widget on first page load.
func (o CollapsibleGroupPtrOutput) Collapsed() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CollapsibleGroup) *bool {
		if v == nil {
			return nil
		}
		return v.Collapsed
	}).(pulumi.BoolPtrOutput)
}

// A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
type CollapsibleGroupResponse struct {
	// The collapsed state of the widget on first page load.
	Collapsed bool `pulumi:"collapsed"`
}

// A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
type CollapsibleGroupResponseOutput struct{ *pulumi.OutputState }

func (CollapsibleGroupResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CollapsibleGroupResponse)(nil)).Elem()
}

func (o CollapsibleGroupResponseOutput) ToCollapsibleGroupResponseOutput() CollapsibleGroupResponseOutput {
	return o
}

func (o CollapsibleGroupResponseOutput) ToCollapsibleGroupResponseOutputWithContext(ctx context.Context) CollapsibleGroupResponseOutput {
	return o
}

// The collapsed state of the widget on first page load.
func (o CollapsibleGroupResponseOutput) Collapsed() pulumi.BoolOutput {
	return o.ApplyT(func(v CollapsibleGroupResponse) bool { return v.Collapsed }).(pulumi.BoolOutput)
}

// Defines the layout properties and content for a column.
type Column struct {
	// The relative weight of this column. The column weight is used to adjust the width of columns on the screen (relative to peers). Greater the weight, greater the width of the column on the screen. If omitted, a value of 1 is used while rendering.
	Weight *string `pulumi:"weight"`
	// The display widgets arranged vertically in this column.
	Widgets []Widget `pulumi:"widgets"`
}

// ColumnInput is an input type that accepts ColumnArgs and ColumnOutput values.
// You can construct a concrete instance of `ColumnInput` via:
//
//	ColumnArgs{...}
type ColumnInput interface {
	pulumi.Input

	ToColumnOutput() ColumnOutput
	ToColumnOutputWithContext(context.Context) ColumnOutput
}

// Defines the layout properties and content for a column.
type ColumnArgs struct {
	// The relative weight of this column. The column weight is used to adjust the width of columns on the screen (relative to peers). Greater the weight, greater the width of the column on the screen. If omitted, a value of 1 is used while rendering.
	Weight pulumi.StringPtrInput `pulumi:"weight"`
	// The display widgets arranged vertically in this column.
	Widgets WidgetArrayInput `pulumi:"widgets"`
}

func (ColumnArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Column)(nil)).Elem()
}

func (i ColumnArgs) ToColumnOutput() ColumnOutput {
	return i.ToColumnOutputWithContext(context.Background())
}

func (i ColumnArgs) ToColumnOutputWithContext(ctx context.Context) ColumnOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ColumnOutput)
}

// ColumnArrayInput is an input type that accepts ColumnArray and ColumnArrayOutput values.
// You can construct a concrete instance of `ColumnArrayInput` via:
//
//	ColumnArray{ ColumnArgs{...} }
type ColumnArrayInput interface {
	pulumi.Input

	ToColumnArrayOutput() ColumnArrayOutput
	ToColumnArrayOutputWithContext(context.Context) ColumnArrayOutput
}

type ColumnArray []ColumnInput

func (ColumnArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Column)(nil)).Elem()
}

func (i ColumnArray) ToColumnArrayOutput() ColumnArrayOutput {
	return i.ToColumnArrayOutputWithContext(context.Background())
}

func (i ColumnArray) ToColumnArrayOutputWithContext(ctx context.Context) ColumnArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ColumnArrayOutput)
}

// Defines the layout properties and content for a column.
type ColumnOutput struct{ *pulumi.OutputState }

func (ColumnOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Column)(nil)).Elem()
}

func (o ColumnOutput) ToColumnOutput() ColumnOutput {
	return o
}

func (o ColumnOutput) ToColumnOutputWithContext(ctx context.Context) ColumnOutput {
	return o
}

// The relative weight of this column. The column weight is used to adjust the width of columns on the screen (relative to peers). Greater the weight, greater the width of the column on the screen. If omitted, a value of 1 is used while rendering.
func (o ColumnOutput) Weight() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Column) *string { return v.Weight }).(pulumi.StringPtrOutput)
}

// The display widgets arranged vertically in this column.
func (o ColumnOutput) Widgets() WidgetArrayOutput {
	return o.ApplyT(func(v Column) []Widget { return v.Widgets }).(WidgetArrayOutput)
}

type ColumnArrayOutput struct{ *pulumi.OutputState }

func (ColumnArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Column)(nil)).Elem()
}

func (o ColumnArrayOutput) ToColumnArrayOutput() ColumnArrayOutput {
	return o
}

func (o ColumnArrayOutput) ToColumnArrayOutputWithContext(ctx context.Context) ColumnArrayOutput {
	return o
}

func (o ColumnArrayOutput) Index(i pulumi.IntInput) ColumnOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Column {
		return vs[0].([]Column)[vs[1].(int)]
	}).(ColumnOutput)
}

// A simplified layout that divides the available space into vertical columns and arranges a set of widgets vertically in each column.
type ColumnLayout struct {
	// The columns of content to display.
	Columns []Column `pulumi:"columns"`
}

// ColumnLayoutInput is an input type that accepts ColumnLayoutArgs and ColumnLayoutOutput values.
// You can construct a concrete instance of `ColumnLayoutInput` via:
//
//	ColumnLayoutArgs{...}
type ColumnLayoutInput interface {
	pulumi.Input

	ToColumnLayoutOutput() ColumnLayoutOutput
	ToColumnLayoutOutputWithContext(context.Context) ColumnLayoutOutput
}

// A simplified layout that divides the available space into vertical columns and arranges a set of widgets vertically in each column.
type ColumnLayoutArgs struct {
	// The columns of content to display.
	Columns ColumnArrayInput `pulumi:"columns"`
}

func (ColumnLayoutArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ColumnLayout)(nil)).Elem()
}

func (i ColumnLayoutArgs) ToColumnLayoutOutput() ColumnLayoutOutput {
	return i.ToColumnLayoutOutputWithContext(context.Background())
}

func (i ColumnLayoutArgs) ToColumnLayoutOutputWithContext(ctx context.Context) ColumnLayoutOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ColumnLayoutOutput)
}

func (i ColumnLayoutArgs) ToColumnLayoutPtrOutput() ColumnLayoutPtrOutput {
	return i.ToColumnLayoutPtrOutputWithContext(context.Background())
}

func (i ColumnLayoutArgs) ToColumnLayoutPtrOutputWithContext(ctx context.Context) ColumnLayoutPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ColumnLayoutOutput).ToColumnLayoutPtrOutputWithContext(ctx)
}

// ColumnLayoutPtrInput is an input type that accepts ColumnLayoutArgs, ColumnLayoutPtr and ColumnLayoutPtrOutput values.
// You can construct a concrete instance of `ColumnLayoutPtrInput` via:
//
//	        ColumnLayoutArgs{...}
//
//	or:
//
//	        nil
type ColumnLayoutPtrInput interface {
	pulumi.Input

	ToColumnLayoutPtrOutput() ColumnLayoutPtrOutput
	ToColumnLayoutPtrOutputWithContext(context.Context) ColumnLayoutPtrOutput
}

type columnLayoutPtrType ColumnLayoutArgs

func ColumnLayoutPtr(v *ColumnLayoutArgs) ColumnLayoutPtrInput {
	return (*columnLayoutPtrType)(v)
}

func (*columnLayoutPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ColumnLayout)(nil)).Elem()
}

func (i *columnLayoutPtrType) ToColumnLayoutPtrOutput() ColumnLayoutPtrOutput {
	return i.ToColumnLayoutPtrOutputWithContext(context.Background())
}

func (i *columnLayoutPtrType) ToColumnLayoutPtrOutputWithContext(ctx context.Context) ColumnLayoutPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ColumnLayoutPtrOutput)
}

// A simplified layout that divides the available space into vertical columns and arranges a set of widgets vertically in each column.
type ColumnLayoutOutput struct{ *pulumi.OutputState }

func (ColumnLayoutOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ColumnLayout)(nil)).Elem()
}

func (o ColumnLayoutOutput) ToColumnLayoutOutput() ColumnLayoutOutput {
	return o
}

func (o ColumnLayoutOutput) ToColumnLayoutOutputWithContext(ctx context.Context) ColumnLayoutOutput {
	return o
}

func (o ColumnLayoutOutput) ToColumnLayoutPtrOutput() ColumnLayoutPtrOutput {
	return o.ToColumnLayoutPtrOutputWithContext(context.Background())
}

func (o ColumnLayoutOutput) ToColumnLayoutPtrOutputWithContext(ctx context.Context) ColumnLayoutPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ColumnLayout) *ColumnLayout {
		return &v
	}).(ColumnLayoutPtrOutput)
}

// The columns of content to display.
func (o ColumnLayoutOutput) Columns() ColumnArrayOutput {
	return o.ApplyT(func(v ColumnLayout) []Column { return v.Columns }).(ColumnArrayOutput)
}

type ColumnLayoutPtrOutput struct{ *pulumi.OutputState }

func (ColumnLayoutPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ColumnLayout)(nil)).Elem()
}

func (o ColumnLayoutPtrOutput) ToColumnLayoutPtrOutput() ColumnLayoutPtrOutput {
	return o
}

func (o ColumnLayoutPtrOutput) ToColumnLayoutPtrOutputWithContext(ctx context.Context) ColumnLayoutPtrOutput {
	return o
}

func (o ColumnLayoutPtrOutput) Elem() ColumnLayoutOutput {
	return o.ApplyT(func(v *ColumnLayout) ColumnLayout {
		if v != nil {
			return *v
		}
		var ret ColumnLayout
		return ret
	}).(ColumnLayoutOutput)
}

// The columns of content to display.
func (o ColumnLayoutPtrOutput) Columns() ColumnArrayOutput {
	return o.ApplyT(func(v *ColumnLayout) []Column {
		if v == nil {
			return nil
		}
		return v.Columns
	}).(ColumnArrayOutput)
}

// A simplified layout that divides the available space into vertical columns and arranges a set of widgets vertically in each column.
type ColumnLayoutResponse struct {
	// The columns of content to display.
	Columns []ColumnResponse `pulumi:"columns"`
}

// A simplified layout that divides the available space into vertical columns and arranges a set of widgets vertically in each column.
type ColumnLayoutResponseOutput struct{ *pulumi.OutputState }

func (ColumnLayoutResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ColumnLayoutResponse)(nil)).Elem()
}

func (o ColumnLayoutResponseOutput) ToColumnLayoutResponseOutput() ColumnLayoutResponseOutput {
	return o
}

func (o ColumnLayoutResponseOutput) ToColumnLayoutResponseOutputWithContext(ctx context.Context) ColumnLayoutResponseOutput {
	return o
}

// The columns of content to display.
func (o ColumnLayoutResponseOutput) Columns() ColumnResponseArrayOutput {
	return o.ApplyT(func(v ColumnLayoutResponse) []ColumnResponse { return v.Columns }).(ColumnResponseArrayOutput)
}

// Defines the layout properties and content for a column.
type ColumnResponse struct {
	// The relative weight of this column. The column weight is used to adjust the width of columns on the screen (relative to peers). Greater the weight, greater the width of the column on the screen. If omitted, a value of 1 is used while rendering.
	Weight string `pulumi:"weight"`
	// The display widgets arranged vertically in this column.
	Widgets []WidgetResponse `pulumi:"widgets"`
}

// Defines the layout properties and content for a column.
type ColumnResponseOutput struct{ *pulumi.OutputState }

func (ColumnResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ColumnResponse)(nil)).Elem()
}

func (o ColumnResponseOutput) ToColumnResponseOutput() ColumnResponseOutput {
	return o
}

func (o ColumnResponseOutput) ToColumnResponseOutputWithContext(ctx context.Context) ColumnResponseOutput {
	return o
}

// The relative weight of this column. The column weight is used to adjust the width of columns on the screen (relative to peers). Greater the weight, greater the width of the column on the screen. If omitted, a value of 1 is used while rendering.
func (o ColumnResponseOutput) Weight() pulumi.StringOutput {
	return o.ApplyT(func(v ColumnResponse) string { return v.Weight }).(pulumi.StringOutput)
}

// The display widgets arranged vertically in this column.
func (o ColumnResponseOutput) Widgets() WidgetResponseArrayOutput {
	return o.ApplyT(func(v ColumnResponse) []WidgetResponse { return v.Widgets }).(WidgetResponseArrayOutput)
}

type ColumnResponseArrayOutput struct{ *pulumi.OutputState }

func (ColumnResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ColumnResponse)(nil)).Elem()
}

func (o ColumnResponseArrayOutput) ToColumnResponseArrayOutput() ColumnResponseArrayOutput {
	return o
}

func (o ColumnResponseArrayOutput) ToColumnResponseArrayOutputWithContext(ctx context.Context) ColumnResponseArrayOutput {
	return o
}

func (o ColumnResponseArrayOutput) Index(i pulumi.IntInput) ColumnResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ColumnResponse {
		return vs[0].([]ColumnResponse)[vs[1].(int)]
	}).(ColumnResponseOutput)
}

// The persistent settings for a table's columns.
type ColumnSettings struct {
	// The id of the column.
	Column string `pulumi:"column"`
	// Whether the column should be visible on page load.
	Visible bool `pulumi:"visible"`
}

// ColumnSettingsInput is an input type that accepts ColumnSettingsArgs and ColumnSettingsOutput values.
// You can construct a concrete instance of `ColumnSettingsInput` via:
//
//	ColumnSettingsArgs{...}
type ColumnSettingsInput interface {
	pulumi.Input

	ToColumnSettingsOutput() ColumnSettingsOutput
	ToColumnSettingsOutputWithContext(context.Context) ColumnSettingsOutput
}

// The persistent settings for a table's columns.
type ColumnSettingsArgs struct {
	// The id of the column.
	Column pulumi.StringInput `pulumi:"column"`
	// Whether the column should be visible on page load.
	Visible pulumi.BoolInput `pulumi:"visible"`
}

func (ColumnSettingsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ColumnSettings)(nil)).Elem()
}

func (i ColumnSettingsArgs) ToColumnSettingsOutput() ColumnSettingsOutput {
	return i.ToColumnSettingsOutputWithContext(context.Background())
}

func (i ColumnSettingsArgs) ToColumnSettingsOutputWithContext(ctx context.Context) ColumnSettingsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ColumnSettingsOutput)
}

// ColumnSettingsArrayInput is an input type that accepts ColumnSettingsArray and ColumnSettingsArrayOutput values.
// You can construct a concrete instance of `ColumnSettingsArrayInput` via:
//
//	ColumnSettingsArray{ ColumnSettingsArgs{...} }
type ColumnSettingsArrayInput interface {
	pulumi.Input

	ToColumnSettingsArrayOutput() ColumnSettingsArrayOutput
	ToColumnSettingsArrayOutputWithContext(context.Context) ColumnSettingsArrayOutput
}

type ColumnSettingsArray []ColumnSettingsInput

func (ColumnSettingsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ColumnSettings)(nil)).Elem()
}

func (i ColumnSettingsArray) ToColumnSettingsArrayOutput() ColumnSettingsArrayOutput {
	return i.ToColumnSettingsArrayOutputWithContext(context.Background())
}

func (i ColumnSettingsArray) ToColumnSettingsArrayOutputWithContext(ctx context.Context) ColumnSettingsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ColumnSettingsArrayOutput)
}

// The persistent settings for a table's columns.
type ColumnSettingsOutput struct{ *pulumi.OutputState }

func (ColumnSettingsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ColumnSettings)(nil)).Elem()
}

func (o ColumnSettingsOutput) ToColumnSettingsOutput() ColumnSettingsOutput {
	return o
}

func (o ColumnSettingsOutput) ToColumnSettingsOutputWithContext(ctx context.Context) ColumnSettingsOutput {
	return o
}

// The id of the column.
func (o ColumnSettingsOutput) Column() pulumi.StringOutput {
	return o.ApplyT(func(v ColumnSettings) string { return v.Column }).(pulumi.StringOutput)
}

// Whether the column should be visible on page load.
func (o ColumnSettingsOutput) Visible() pulumi.BoolOutput {
	return o.ApplyT(func(v ColumnSettings) bool { return v.Visible }).(pulumi.BoolOutput)
}

type ColumnSettingsArrayOutput struct{ *pulumi.OutputState }

func (ColumnSettingsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ColumnSettings)(nil)).Elem()
}

func (o ColumnSettingsArrayOutput) ToColumnSettingsArrayOutput() ColumnSettingsArrayOutput {
	return o
}

func (o ColumnSettingsArrayOutput) ToColumnSettingsArrayOutputWithContext(ctx context.Context) ColumnSettingsArrayOutput {
	return o
}

func (o ColumnSettingsArrayOutput) Index(i pulumi.IntInput) ColumnSettingsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ColumnSettings {
		return vs[0].([]ColumnSettings)[vs[1].(int)]
	}).(ColumnSettingsOutput)
}

// The persistent settings for a table's columns.
type ColumnSettingsResponse struct {
	// The id of the column.
	Column string `pulumi:"column"`
	// Whether the column should be visible on page load.
	Visible bool `pulumi:"visible"`
}

// The persistent settings for a table's columns.
type ColumnSettingsResponseOutput struct{ *pulumi.OutputState }

func (ColumnSettingsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ColumnSettingsResponse)(nil)).Elem()
}

func (o ColumnSettingsResponseOutput) ToColumnSettingsResponseOutput() ColumnSettingsResponseOutput {
	return o
}

func (o ColumnSettingsResponseOutput) ToColumnSettingsResponseOutputWithContext(ctx context.Context) ColumnSettingsResponseOutput {
	return o
}

// The id of the column.
func (o ColumnSettingsResponseOutput) Column() pulumi.StringOutput {
	return o.ApplyT(func(v ColumnSettingsResponse) string { return v.Column }).(pulumi.StringOutput)
}

// Whether the column should be visible on page load.
func (o ColumnSettingsResponseOutput) Visible() pulumi.BoolOutput {
	return o.ApplyT(func(v ColumnSettingsResponse) bool { return v.Visible }).(pulumi.BoolOutput)
}

type ColumnSettingsResponseArrayOutput struct{ *pulumi.OutputState }

func (ColumnSettingsResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ColumnSettingsResponse)(nil)).Elem()
}

func (o ColumnSettingsResponseArrayOutput) ToColumnSettingsResponseArrayOutput() ColumnSettingsResponseArrayOutput {
	return o
}

func (o ColumnSettingsResponseArrayOutput) ToColumnSettingsResponseArrayOutputWithContext(ctx context.Context) ColumnSettingsResponseArrayOutput {
	return o
}

func (o ColumnSettingsResponseArrayOutput) Index(i pulumi.IntInput) ColumnSettingsResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ColumnSettingsResponse {
		return vs[0].([]ColumnSettingsResponse)[vs[1].(int)]
	}).(ColumnSettingsResponseOutput)
}

// A filter to reduce the amount of data charted in relevant widgets.
type DashboardFilter struct {
	// The specified filter type
	FilterType *DashboardFilterFilterType `pulumi:"filterType"`
	// The key for the label
	LabelKey string `pulumi:"labelKey"`
	// A variable-length string value.
	StringValue *string `pulumi:"stringValue"`
	// The placeholder text that can be referenced in a filter string or MQL query. If omitted, the dashboard filter will be applied to all relevant widgets in the dashboard.
	TemplateVariable *string `pulumi:"templateVariable"`
}

// DashboardFilterInput is an input type that accepts DashboardFilterArgs and DashboardFilterOutput values.
// You can construct a concrete instance of `DashboardFilterInput` via:
//
//	DashboardFilterArgs{...}
type DashboardFilterInput interface {
	pulumi.Input

	ToDashboardFilterOutput() DashboardFilterOutput
	ToDashboardFilterOutputWithContext(context.Context) DashboardFilterOutput
}

// A filter to reduce the amount of data charted in relevant widgets.
type DashboardFilterArgs struct {
	// The specified filter type
	FilterType DashboardFilterFilterTypePtrInput `pulumi:"filterType"`
	// The key for the label
	LabelKey pulumi.StringInput `pulumi:"labelKey"`
	// A variable-length string value.
	StringValue pulumi.StringPtrInput `pulumi:"stringValue"`
	// The placeholder text that can be referenced in a filter string or MQL query. If omitted, the dashboard filter will be applied to all relevant widgets in the dashboard.
	TemplateVariable pulumi.StringPtrInput `pulumi:"templateVariable"`
}

func (DashboardFilterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DashboardFilter)(nil)).Elem()
}

func (i DashboardFilterArgs) ToDashboardFilterOutput() DashboardFilterOutput {
	return i.ToDashboardFilterOutputWithContext(context.Background())
}

func (i DashboardFilterArgs) ToDashboardFilterOutputWithContext(ctx context.Context) DashboardFilterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DashboardFilterOutput)
}

// DashboardFilterArrayInput is an input type that accepts DashboardFilterArray and DashboardFilterArrayOutput values.
// You can construct a concrete instance of `DashboardFilterArrayInput` via:
//
//	DashboardFilterArray{ DashboardFilterArgs{...} }
type DashboardFilterArrayInput interface {
	pulumi.Input

	ToDashboardFilterArrayOutput() DashboardFilterArrayOutput
	ToDashboardFilterArrayOutputWithContext(context.Context) DashboardFilterArrayOutput
}

type DashboardFilterArray []DashboardFilterInput

func (DashboardFilterArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DashboardFilter)(nil)).Elem()
}

func (i DashboardFilterArray) ToDashboardFilterArrayOutput() DashboardFilterArrayOutput {
	return i.ToDashboardFilterArrayOutputWithContext(context.Background())
}

func (i DashboardFilterArray) ToDashboardFilterArrayOutputWithContext(ctx context.Context) DashboardFilterArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DashboardFilterArrayOutput)
}

// A filter to reduce the amount of data charted in relevant widgets.
type DashboardFilterOutput struct{ *pulumi.OutputState }

func (DashboardFilterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DashboardFilter)(nil)).Elem()
}

func (o DashboardFilterOutput) ToDashboardFilterOutput() DashboardFilterOutput {
	return o
}

func (o DashboardFilterOutput) ToDashboardFilterOutputWithContext(ctx context.Context) DashboardFilterOutput {
	return o
}

// The specified filter type
func (o DashboardFilterOutput) FilterType() DashboardFilterFilterTypePtrOutput {
	return o.ApplyT(func(v DashboardFilter) *DashboardFilterFilterType { return v.FilterType }).(DashboardFilterFilterTypePtrOutput)
}

// The key for the label
func (o DashboardFilterOutput) LabelKey() pulumi.StringOutput {
	return o.ApplyT(func(v DashboardFilter) string { return v.LabelKey }).(pulumi.StringOutput)
}

// A variable-length string value.
func (o DashboardFilterOutput) StringValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DashboardFilter) *string { return v.StringValue }).(pulumi.StringPtrOutput)
}

// The placeholder text that can be referenced in a filter string or MQL query. If omitted, the dashboard filter will be applied to all relevant widgets in the dashboard.
func (o DashboardFilterOutput) TemplateVariable() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DashboardFilter) *string { return v.TemplateVariable }).(pulumi.StringPtrOutput)
}

type DashboardFilterArrayOutput struct{ *pulumi.OutputState }

func (DashboardFilterArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DashboardFilter)(nil)).Elem()
}

func (o DashboardFilterArrayOutput) ToDashboardFilterArrayOutput() DashboardFilterArrayOutput {
	return o
}

func (o DashboardFilterArrayOutput) ToDashboardFilterArrayOutputWithContext(ctx context.Context) DashboardFilterArrayOutput {
	return o
}

func (o DashboardFilterArrayOutput) Index(i pulumi.IntInput) DashboardFilterOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DashboardFilter {
		return vs[0].([]DashboardFilter)[vs[1].(int)]
	}).(DashboardFilterOutput)
}

// A filter to reduce the amount of data charted in relevant widgets.
type DashboardFilterResponse struct {
	// The specified filter type
	FilterType string `pulumi:"filterType"`
	// The key for the label
	LabelKey string `pulumi:"labelKey"`
	// A variable-length string value.
	StringValue string `pulumi:"stringValue"`
	// The placeholder text that can be referenced in a filter string or MQL query. If omitted, the dashboard filter will be applied to all relevant widgets in the dashboard.
	TemplateVariable string `pulumi:"templateVariable"`
}

// A filter to reduce the amount of data charted in relevant widgets.
type DashboardFilterResponseOutput struct{ *pulumi.OutputState }

func (DashboardFilterResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DashboardFilterResponse)(nil)).Elem()
}

func (o DashboardFilterResponseOutput) ToDashboardFilterResponseOutput() DashboardFilterResponseOutput {
	return o
}

func (o DashboardFilterResponseOutput) ToDashboardFilterResponseOutputWithContext(ctx context.Context) DashboardFilterResponseOutput {
	return o
}

// The specified filter type
func (o DashboardFilterResponseOutput) FilterType() pulumi.StringOutput {
	return o.ApplyT(func(v DashboardFilterResponse) string { return v.FilterType }).(pulumi.StringOutput)
}

// The key for the label
func (o DashboardFilterResponseOutput) LabelKey() pulumi.StringOutput {
	return o.ApplyT(func(v DashboardFilterResponse) string { return v.LabelKey }).(pulumi.StringOutput)
}

// A variable-length string value.
func (o DashboardFilterResponseOutput) StringValue() pulumi.StringOutput {
	return o.ApplyT(func(v DashboardFilterResponse) string { return v.StringValue }).(pulumi.StringOutput)
}

// The placeholder text that can be referenced in a filter string or MQL query. If omitted, the dashboard filter will be applied to all relevant widgets in the dashboard.
func (o DashboardFilterResponseOutput) TemplateVariable() pulumi.StringOutput {
	return o.ApplyT(func(v DashboardFilterResponse) string { return v.TemplateVariable }).(pulumi.StringOutput)
}

type DashboardFilterResponseArrayOutput struct{ *pulumi.OutputState }

func (DashboardFilterResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DashboardFilterResponse)(nil)).Elem()
}

func (o DashboardFilterResponseArrayOutput) ToDashboardFilterResponseArrayOutput() DashboardFilterResponseArrayOutput {
	return o
}

func (o DashboardFilterResponseArrayOutput) ToDashboardFilterResponseArrayOutputWithContext(ctx context.Context) DashboardFilterResponseArrayOutput {
	return o
}

func (o DashboardFilterResponseArrayOutput) Index(i pulumi.IntInput) DashboardFilterResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DashboardFilterResponse {
		return vs[0].([]DashboardFilterResponse)[vs[1].(int)]
	}).(DashboardFilterResponseOutput)
}

// Groups a time series query definition with charting options.
type DataSet struct {
	// Optional. The collection of breakdowns to be applied to the dataset.
	Breakdowns []Breakdown `pulumi:"breakdowns"`
	// Optional. A collection of dimension columns.
	Dimensions []Dimension `pulumi:"dimensions"`
	// A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value.
	LegendTemplate *string `pulumi:"legendTemplate"`
	// Optional. A collection of measures.
	Measures []Measure `pulumi:"measures"`
	// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
	MinAlignmentPeriod *string `pulumi:"minAlignmentPeriod"`
	// How this data should be plotted on the chart.
	PlotType *DataSetPlotType `pulumi:"plotType"`
	// Optional. The target axis to use for plotting the metric.
	TargetAxis *DataSetTargetAxis `pulumi:"targetAxis"`
	// Fields for querying time series data from the Stackdriver metrics API.
	TimeSeriesQuery TimeSeriesQuery `pulumi:"timeSeriesQuery"`
}

// DataSetInput is an input type that accepts DataSetArgs and DataSetOutput values.
// You can construct a concrete instance of `DataSetInput` via:
//
//	DataSetArgs{...}
type DataSetInput interface {
	pulumi.Input

	ToDataSetOutput() DataSetOutput
	ToDataSetOutputWithContext(context.Context) DataSetOutput
}

// Groups a time series query definition with charting options.
type DataSetArgs struct {
	// Optional. The collection of breakdowns to be applied to the dataset.
	Breakdowns BreakdownArrayInput `pulumi:"breakdowns"`
	// Optional. A collection of dimension columns.
	Dimensions DimensionArrayInput `pulumi:"dimensions"`
	// A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value.
	LegendTemplate pulumi.StringPtrInput `pulumi:"legendTemplate"`
	// Optional. A collection of measures.
	Measures MeasureArrayInput `pulumi:"measures"`
	// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
	MinAlignmentPeriod pulumi.StringPtrInput `pulumi:"minAlignmentPeriod"`
	// How this data should be plotted on the chart.
	PlotType DataSetPlotTypePtrInput `pulumi:"plotType"`
	// Optional. The target axis to use for plotting the metric.
	TargetAxis DataSetTargetAxisPtrInput `pulumi:"targetAxis"`
	// Fields for querying time series data from the Stackdriver metrics API.
	TimeSeriesQuery TimeSeriesQueryInput `pulumi:"timeSeriesQuery"`
}

func (DataSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DataSet)(nil)).Elem()
}

func (i DataSetArgs) ToDataSetOutput() DataSetOutput {
	return i.ToDataSetOutputWithContext(context.Background())
}

func (i DataSetArgs) ToDataSetOutputWithContext(ctx context.Context) DataSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DataSetOutput)
}

// DataSetArrayInput is an input type that accepts DataSetArray and DataSetArrayOutput values.
// You can construct a concrete instance of `DataSetArrayInput` via:
//
//	DataSetArray{ DataSetArgs{...} }
type DataSetArrayInput interface {
	pulumi.Input

	ToDataSetArrayOutput() DataSetArrayOutput
	ToDataSetArrayOutputWithContext(context.Context) DataSetArrayOutput
}

type DataSetArray []DataSetInput

func (DataSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DataSet)(nil)).Elem()
}

func (i DataSetArray) ToDataSetArrayOutput() DataSetArrayOutput {
	return i.ToDataSetArrayOutputWithContext(context.Background())
}

func (i DataSetArray) ToDataSetArrayOutputWithContext(ctx context.Context) DataSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DataSetArrayOutput)
}

// Groups a time series query definition with charting options.
type DataSetOutput struct{ *pulumi.OutputState }

func (DataSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DataSet)(nil)).Elem()
}

func (o DataSetOutput) ToDataSetOutput() DataSetOutput {
	return o
}

func (o DataSetOutput) ToDataSetOutputWithContext(ctx context.Context) DataSetOutput {
	return o
}

// Optional. The collection of breakdowns to be applied to the dataset.
func (o DataSetOutput) Breakdowns() BreakdownArrayOutput {
	return o.ApplyT(func(v DataSet) []Breakdown { return v.Breakdowns }).(BreakdownArrayOutput)
}

// Optional. A collection of dimension columns.
func (o DataSetOutput) Dimensions() DimensionArrayOutput {
	return o.ApplyT(func(v DataSet) []Dimension { return v.Dimensions }).(DimensionArrayOutput)
}

// A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value.
func (o DataSetOutput) LegendTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DataSet) *string { return v.LegendTemplate }).(pulumi.StringPtrOutput)
}

// Optional. A collection of measures.
func (o DataSetOutput) Measures() MeasureArrayOutput {
	return o.ApplyT(func(v DataSet) []Measure { return v.Measures }).(MeasureArrayOutput)
}

// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
func (o DataSetOutput) MinAlignmentPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DataSet) *string { return v.MinAlignmentPeriod }).(pulumi.StringPtrOutput)
}

// How this data should be plotted on the chart.
func (o DataSetOutput) PlotType() DataSetPlotTypePtrOutput {
	return o.ApplyT(func(v DataSet) *DataSetPlotType { return v.PlotType }).(DataSetPlotTypePtrOutput)
}

// Optional. The target axis to use for plotting the metric.
func (o DataSetOutput) TargetAxis() DataSetTargetAxisPtrOutput {
	return o.ApplyT(func(v DataSet) *DataSetTargetAxis { return v.TargetAxis }).(DataSetTargetAxisPtrOutput)
}

// Fields for querying time series data from the Stackdriver metrics API.
func (o DataSetOutput) TimeSeriesQuery() TimeSeriesQueryOutput {
	return o.ApplyT(func(v DataSet) TimeSeriesQuery { return v.TimeSeriesQuery }).(TimeSeriesQueryOutput)
}

type DataSetArrayOutput struct{ *pulumi.OutputState }

func (DataSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DataSet)(nil)).Elem()
}

func (o DataSetArrayOutput) ToDataSetArrayOutput() DataSetArrayOutput {
	return o
}

func (o DataSetArrayOutput) ToDataSetArrayOutputWithContext(ctx context.Context) DataSetArrayOutput {
	return o
}

func (o DataSetArrayOutput) Index(i pulumi.IntInput) DataSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DataSet {
		return vs[0].([]DataSet)[vs[1].(int)]
	}).(DataSetOutput)
}

// Groups a time series query definition with charting options.
type DataSetResponse struct {
	// Optional. The collection of breakdowns to be applied to the dataset.
	Breakdowns []BreakdownResponse `pulumi:"breakdowns"`
	// Optional. A collection of dimension columns.
	Dimensions []DimensionResponse `pulumi:"dimensions"`
	// A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value.
	LegendTemplate string `pulumi:"legendTemplate"`
	// Optional. A collection of measures.
	Measures []MeasureResponse `pulumi:"measures"`
	// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
	MinAlignmentPeriod string `pulumi:"minAlignmentPeriod"`
	// How this data should be plotted on the chart.
	PlotType string `pulumi:"plotType"`
	// Optional. The target axis to use for plotting the metric.
	TargetAxis string `pulumi:"targetAxis"`
	// Fields for querying time series data from the Stackdriver metrics API.
	TimeSeriesQuery TimeSeriesQueryResponse `pulumi:"timeSeriesQuery"`
}

// Groups a time series query definition with charting options.
type DataSetResponseOutput struct{ *pulumi.OutputState }

func (DataSetResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DataSetResponse)(nil)).Elem()
}

func (o DataSetResponseOutput) ToDataSetResponseOutput() DataSetResponseOutput {
	return o
}

func (o DataSetResponseOutput) ToDataSetResponseOutputWithContext(ctx context.Context) DataSetResponseOutput {
	return o
}

// Optional. The collection of breakdowns to be applied to the dataset.
func (o DataSetResponseOutput) Breakdowns() BreakdownResponseArrayOutput {
	return o.ApplyT(func(v DataSetResponse) []BreakdownResponse { return v.Breakdowns }).(BreakdownResponseArrayOutput)
}

// Optional. A collection of dimension columns.
func (o DataSetResponseOutput) Dimensions() DimensionResponseArrayOutput {
	return o.ApplyT(func(v DataSetResponse) []DimensionResponse { return v.Dimensions }).(DimensionResponseArrayOutput)
}

// A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value.
func (o DataSetResponseOutput) LegendTemplate() pulumi.StringOutput {
	return o.ApplyT(func(v DataSetResponse) string { return v.LegendTemplate }).(pulumi.StringOutput)
}

// Optional. A collection of measures.
func (o DataSetResponseOutput) Measures() MeasureResponseArrayOutput {
	return o.ApplyT(func(v DataSetResponse) []MeasureResponse { return v.Measures }).(MeasureResponseArrayOutput)
}

// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
func (o DataSetResponseOutput) MinAlignmentPeriod() pulumi.StringOutput {
	return o.ApplyT(func(v DataSetResponse) string { return v.MinAlignmentPeriod }).(pulumi.StringOutput)
}

// How this data should be plotted on the chart.
func (o DataSetResponseOutput) PlotType() pulumi.StringOutput {
	return o.ApplyT(func(v DataSetResponse) string { return v.PlotType }).(pulumi.StringOutput)
}

// Optional. The target axis to use for plotting the metric.
func (o DataSetResponseOutput) TargetAxis() pulumi.StringOutput {
	return o.ApplyT(func(v DataSetResponse) string { return v.TargetAxis }).(pulumi.StringOutput)
}

// Fields for querying time series data from the Stackdriver metrics API.
func (o DataSetResponseOutput) TimeSeriesQuery() TimeSeriesQueryResponseOutput {
	return o.ApplyT(func(v DataSetResponse) TimeSeriesQueryResponse { return v.TimeSeriesQuery }).(TimeSeriesQueryResponseOutput)
}

type DataSetResponseArrayOutput struct{ *pulumi.OutputState }

func (DataSetResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DataSetResponse)(nil)).Elem()
}

func (o DataSetResponseArrayOutput) ToDataSetResponseArrayOutput() DataSetResponseArrayOutput {
	return o
}

func (o DataSetResponseArrayOutput) ToDataSetResponseArrayOutputWithContext(ctx context.Context) DataSetResponseArrayOutput {
	return o
}

func (o DataSetResponseArrayOutput) Index(i pulumi.IntInput) DataSetResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DataSetResponse {
		return vs[0].([]DataSetResponse)[vs[1].(int)]
	}).(DataSetResponseOutput)
}

// A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
type Dimension struct {
	// The name of the column in the source SQL query that is used to chart the dimension.
	Column string `pulumi:"column"`
	// Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
	ColumnType *string `pulumi:"columnType"`
	// Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
	FloatBinSize *float64 `pulumi:"floatBinSize"`
	// A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
	MaxBinCount *int `pulumi:"maxBinCount"`
	// numeric_bin_size is used when the column type used for a dimension is numeric or string.
	NumericBinSize *int `pulumi:"numericBinSize"`
	// The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
	SortColumn *string `pulumi:"sortColumn"`
	// The sort order applied to the sort column.
	SortOrder *DimensionSortOrder `pulumi:"sortOrder"`
	// time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
	TimeBinSize *string `pulumi:"timeBinSize"`
}

// DimensionInput is an input type that accepts DimensionArgs and DimensionOutput values.
// You can construct a concrete instance of `DimensionInput` via:
//
//	DimensionArgs{...}
type DimensionInput interface {
	pulumi.Input

	ToDimensionOutput() DimensionOutput
	ToDimensionOutputWithContext(context.Context) DimensionOutput
}

// A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
type DimensionArgs struct {
	// The name of the column in the source SQL query that is used to chart the dimension.
	Column pulumi.StringInput `pulumi:"column"`
	// Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
	ColumnType pulumi.StringPtrInput `pulumi:"columnType"`
	// Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
	FloatBinSize pulumi.Float64PtrInput `pulumi:"floatBinSize"`
	// A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
	MaxBinCount pulumi.IntPtrInput `pulumi:"maxBinCount"`
	// numeric_bin_size is used when the column type used for a dimension is numeric or string.
	NumericBinSize pulumi.IntPtrInput `pulumi:"numericBinSize"`
	// The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
	SortColumn pulumi.StringPtrInput `pulumi:"sortColumn"`
	// The sort order applied to the sort column.
	SortOrder DimensionSortOrderPtrInput `pulumi:"sortOrder"`
	// time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
	TimeBinSize pulumi.StringPtrInput `pulumi:"timeBinSize"`
}

func (DimensionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Dimension)(nil)).Elem()
}

func (i DimensionArgs) ToDimensionOutput() DimensionOutput {
	return i.ToDimensionOutputWithContext(context.Background())
}

func (i DimensionArgs) ToDimensionOutputWithContext(ctx context.Context) DimensionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DimensionOutput)
}

// DimensionArrayInput is an input type that accepts DimensionArray and DimensionArrayOutput values.
// You can construct a concrete instance of `DimensionArrayInput` via:
//
//	DimensionArray{ DimensionArgs{...} }
type DimensionArrayInput interface {
	pulumi.Input

	ToDimensionArrayOutput() DimensionArrayOutput
	ToDimensionArrayOutputWithContext(context.Context) DimensionArrayOutput
}

type DimensionArray []DimensionInput

func (DimensionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Dimension)(nil)).Elem()
}

func (i DimensionArray) ToDimensionArrayOutput() DimensionArrayOutput {
	return i.ToDimensionArrayOutputWithContext(context.Background())
}

func (i DimensionArray) ToDimensionArrayOutputWithContext(ctx context.Context) DimensionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DimensionArrayOutput)
}

// A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
type DimensionOutput struct{ *pulumi.OutputState }

func (DimensionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Dimension)(nil)).Elem()
}

func (o DimensionOutput) ToDimensionOutput() DimensionOutput {
	return o
}

func (o DimensionOutput) ToDimensionOutputWithContext(ctx context.Context) DimensionOutput {
	return o
}

// The name of the column in the source SQL query that is used to chart the dimension.
func (o DimensionOutput) Column() pulumi.StringOutput {
	return o.ApplyT(func(v Dimension) string { return v.Column }).(pulumi.StringOutput)
}

// Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
func (o DimensionOutput) ColumnType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Dimension) *string { return v.ColumnType }).(pulumi.StringPtrOutput)
}

// Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
func (o DimensionOutput) FloatBinSize() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Dimension) *float64 { return v.FloatBinSize }).(pulumi.Float64PtrOutput)
}

// A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
func (o DimensionOutput) MaxBinCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Dimension) *int { return v.MaxBinCount }).(pulumi.IntPtrOutput)
}

// numeric_bin_size is used when the column type used for a dimension is numeric or string.
func (o DimensionOutput) NumericBinSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Dimension) *int { return v.NumericBinSize }).(pulumi.IntPtrOutput)
}

// The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
func (o DimensionOutput) SortColumn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Dimension) *string { return v.SortColumn }).(pulumi.StringPtrOutput)
}

// The sort order applied to the sort column.
func (o DimensionOutput) SortOrder() DimensionSortOrderPtrOutput {
	return o.ApplyT(func(v Dimension) *DimensionSortOrder { return v.SortOrder }).(DimensionSortOrderPtrOutput)
}

// time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
func (o DimensionOutput) TimeBinSize() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Dimension) *string { return v.TimeBinSize }).(pulumi.StringPtrOutput)
}

type DimensionArrayOutput struct{ *pulumi.OutputState }

func (DimensionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Dimension)(nil)).Elem()
}

func (o DimensionArrayOutput) ToDimensionArrayOutput() DimensionArrayOutput {
	return o
}

func (o DimensionArrayOutput) ToDimensionArrayOutputWithContext(ctx context.Context) DimensionArrayOutput {
	return o
}

func (o DimensionArrayOutput) Index(i pulumi.IntInput) DimensionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Dimension {
		return vs[0].([]Dimension)[vs[1].(int)]
	}).(DimensionOutput)
}

// A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
type DimensionResponse struct {
	// The name of the column in the source SQL query that is used to chart the dimension.
	Column string `pulumi:"column"`
	// Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
	ColumnType string `pulumi:"columnType"`
	// Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
	FloatBinSize float64 `pulumi:"floatBinSize"`
	// A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
	MaxBinCount int `pulumi:"maxBinCount"`
	// numeric_bin_size is used when the column type used for a dimension is numeric or string.
	NumericBinSize int `pulumi:"numericBinSize"`
	// The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
	SortColumn string `pulumi:"sortColumn"`
	// The sort order applied to the sort column.
	SortOrder string `pulumi:"sortOrder"`
	// time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
	TimeBinSize string `pulumi:"timeBinSize"`
}

// A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
type DimensionResponseOutput struct{ *pulumi.OutputState }

func (DimensionResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DimensionResponse)(nil)).Elem()
}

func (o DimensionResponseOutput) ToDimensionResponseOutput() DimensionResponseOutput {
	return o
}

func (o DimensionResponseOutput) ToDimensionResponseOutputWithContext(ctx context.Context) DimensionResponseOutput {
	return o
}

// The name of the column in the source SQL query that is used to chart the dimension.
func (o DimensionResponseOutput) Column() pulumi.StringOutput {
	return o.ApplyT(func(v DimensionResponse) string { return v.Column }).(pulumi.StringOutput)
}

// Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
func (o DimensionResponseOutput) ColumnType() pulumi.StringOutput {
	return o.ApplyT(func(v DimensionResponse) string { return v.ColumnType }).(pulumi.StringOutput)
}

// Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
func (o DimensionResponseOutput) FloatBinSize() pulumi.Float64Output {
	return o.ApplyT(func(v DimensionResponse) float64 { return v.FloatBinSize }).(pulumi.Float64Output)
}

// A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
func (o DimensionResponseOutput) MaxBinCount() pulumi.IntOutput {
	return o.ApplyT(func(v DimensionResponse) int { return v.MaxBinCount }).(pulumi.IntOutput)
}

// numeric_bin_size is used when the column type used for a dimension is numeric or string.
func (o DimensionResponseOutput) NumericBinSize() pulumi.IntOutput {
	return o.ApplyT(func(v DimensionResponse) int { return v.NumericBinSize }).(pulumi.IntOutput)
}

// The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
func (o DimensionResponseOutput) SortColumn() pulumi.StringOutput {
	return o.ApplyT(func(v DimensionResponse) string { return v.SortColumn }).(pulumi.StringOutput)
}

// The sort order applied to the sort column.
func (o DimensionResponseOutput) SortOrder() pulumi.StringOutput {
	return o.ApplyT(func(v DimensionResponse) string { return v.SortOrder }).(pulumi.StringOutput)
}

// time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
func (o DimensionResponseOutput) TimeBinSize() pulumi.StringOutput {
	return o.ApplyT(func(v DimensionResponse) string { return v.TimeBinSize }).(pulumi.StringOutput)
}

type DimensionResponseArrayOutput struct{ *pulumi.OutputState }

func (DimensionResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DimensionResponse)(nil)).Elem()
}

func (o DimensionResponseArrayOutput) ToDimensionResponseArrayOutput() DimensionResponseArrayOutput {
	return o
}

func (o DimensionResponseArrayOutput) ToDimensionResponseArrayOutputWithContext(ctx context.Context) DimensionResponseArrayOutput {
	return o
}

func (o DimensionResponseArrayOutput) Index(i pulumi.IntInput) DimensionResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DimensionResponse {
		return vs[0].([]DimensionResponse)[vs[1].(int)]
	}).(DimensionResponseOutput)
}

// A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
type Empty struct {
}

// EmptyInput is an input type that accepts EmptyArgs and EmptyOutput values.
// You can construct a concrete instance of `EmptyInput` via:
//
//	EmptyArgs{...}
type EmptyInput interface {
	pulumi.Input

	ToEmptyOutput() EmptyOutput
	ToEmptyOutputWithContext(context.Context) EmptyOutput
}

// A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
type EmptyArgs struct {
}

func (EmptyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Empty)(nil)).Elem()
}

func (i EmptyArgs) ToEmptyOutput() EmptyOutput {
	return i.ToEmptyOutputWithContext(context.Background())
}

func (i EmptyArgs) ToEmptyOutputWithContext(ctx context.Context) EmptyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EmptyOutput)
}

func (i EmptyArgs) ToEmptyPtrOutput() EmptyPtrOutput {
	return i.ToEmptyPtrOutputWithContext(context.Background())
}

func (i EmptyArgs) ToEmptyPtrOutputWithContext(ctx context.Context) EmptyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EmptyOutput).ToEmptyPtrOutputWithContext(ctx)
}

// EmptyPtrInput is an input type that accepts EmptyArgs, EmptyPtr and EmptyPtrOutput values.
// You can construct a concrete instance of `EmptyPtrInput` via:
//
//	        EmptyArgs{...}
//
//	or:
//
//	        nil
type EmptyPtrInput interface {
	pulumi.Input

	ToEmptyPtrOutput() EmptyPtrOutput
	ToEmptyPtrOutputWithContext(context.Context) EmptyPtrOutput
}

type emptyPtrType EmptyArgs

func EmptyPtr(v *EmptyArgs) EmptyPtrInput {
	return (*emptyPtrType)(v)
}

func (*emptyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Empty)(nil)).Elem()
}

func (i *emptyPtrType) ToEmptyPtrOutput() EmptyPtrOutput {
	return i.ToEmptyPtrOutputWithContext(context.Background())
}

func (i *emptyPtrType) ToEmptyPtrOutputWithContext(ctx context.Context) EmptyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EmptyPtrOutput)
}

// A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
type EmptyOutput struct{ *pulumi.OutputState }

func (EmptyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Empty)(nil)).Elem()
}

func (o EmptyOutput) ToEmptyOutput() EmptyOutput {
	return o
}

func (o EmptyOutput) ToEmptyOutputWithContext(ctx context.Context) EmptyOutput {
	return o
}

func (o EmptyOutput) ToEmptyPtrOutput() EmptyPtrOutput {
	return o.ToEmptyPtrOutputWithContext(context.Background())
}

func (o EmptyOutput) ToEmptyPtrOutputWithContext(ctx context.Context) EmptyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Empty) *Empty {
		return &v
	}).(EmptyPtrOutput)
}

type EmptyPtrOutput struct{ *pulumi.OutputState }

func (EmptyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Empty)(nil)).Elem()
}

func (o EmptyPtrOutput) ToEmptyPtrOutput() EmptyPtrOutput {
	return o
}

func (o EmptyPtrOutput) ToEmptyPtrOutputWithContext(ctx context.Context) EmptyPtrOutput {
	return o
}

func (o EmptyPtrOutput) Elem() EmptyOutput {
	return o.ApplyT(func(v *Empty) Empty {
		if v != nil {
			return *v
		}
		var ret Empty
		return ret
	}).(EmptyOutput)
}

// A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
type EmptyResponse struct {
}

// A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
type EmptyResponseOutput struct{ *pulumi.OutputState }

func (EmptyResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EmptyResponse)(nil)).Elem()
}

func (o EmptyResponseOutput) ToEmptyResponseOutput() EmptyResponseOutput {
	return o
}

func (o EmptyResponseOutput) ToEmptyResponseOutputWithContext(ctx context.Context) EmptyResponseOutput {
	return o
}

// A widget that displays a list of error groups.
type ErrorReportingPanel struct {
	// The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
	ProjectNames []string `pulumi:"projectNames"`
	// An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
	Services []string `pulumi:"services"`
	// Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
	Versions []string `pulumi:"versions"`
}

// ErrorReportingPanelInput is an input type that accepts ErrorReportingPanelArgs and ErrorReportingPanelOutput values.
// You can construct a concrete instance of `ErrorReportingPanelInput` via:
//
//	ErrorReportingPanelArgs{...}
type ErrorReportingPanelInput interface {
	pulumi.Input

	ToErrorReportingPanelOutput() ErrorReportingPanelOutput
	ToErrorReportingPanelOutputWithContext(context.Context) ErrorReportingPanelOutput
}

// A widget that displays a list of error groups.
type ErrorReportingPanelArgs struct {
	// The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
	ProjectNames pulumi.StringArrayInput `pulumi:"projectNames"`
	// An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
	Services pulumi.StringArrayInput `pulumi:"services"`
	// Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
	Versions pulumi.StringArrayInput `pulumi:"versions"`
}

func (ErrorReportingPanelArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ErrorReportingPanel)(nil)).Elem()
}

func (i ErrorReportingPanelArgs) ToErrorReportingPanelOutput() ErrorReportingPanelOutput {
	return i.ToErrorReportingPanelOutputWithContext(context.Background())
}

func (i ErrorReportingPanelArgs) ToErrorReportingPanelOutputWithContext(ctx context.Context) ErrorReportingPanelOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ErrorReportingPanelOutput)
}

func (i ErrorReportingPanelArgs) ToErrorReportingPanelPtrOutput() ErrorReportingPanelPtrOutput {
	return i.ToErrorReportingPanelPtrOutputWithContext(context.Background())
}

func (i ErrorReportingPanelArgs) ToErrorReportingPanelPtrOutputWithContext(ctx context.Context) ErrorReportingPanelPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ErrorReportingPanelOutput).ToErrorReportingPanelPtrOutputWithContext(ctx)
}

// ErrorReportingPanelPtrInput is an input type that accepts ErrorReportingPanelArgs, ErrorReportingPanelPtr and ErrorReportingPanelPtrOutput values.
// You can construct a concrete instance of `ErrorReportingPanelPtrInput` via:
//
//	        ErrorReportingPanelArgs{...}
//
//	or:
//
//	        nil
type ErrorReportingPanelPtrInput interface {
	pulumi.Input

	ToErrorReportingPanelPtrOutput() ErrorReportingPanelPtrOutput
	ToErrorReportingPanelPtrOutputWithContext(context.Context) ErrorReportingPanelPtrOutput
}

type errorReportingPanelPtrType ErrorReportingPanelArgs

func ErrorReportingPanelPtr(v *ErrorReportingPanelArgs) ErrorReportingPanelPtrInput {
	return (*errorReportingPanelPtrType)(v)
}

func (*errorReportingPanelPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ErrorReportingPanel)(nil)).Elem()
}

func (i *errorReportingPanelPtrType) ToErrorReportingPanelPtrOutput() ErrorReportingPanelPtrOutput {
	return i.ToErrorReportingPanelPtrOutputWithContext(context.Background())
}

func (i *errorReportingPanelPtrType) ToErrorReportingPanelPtrOutputWithContext(ctx context.Context) ErrorReportingPanelPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ErrorReportingPanelPtrOutput)
}

// A widget that displays a list of error groups.
type ErrorReportingPanelOutput struct{ *pulumi.OutputState }

func (ErrorReportingPanelOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ErrorReportingPanel)(nil)).Elem()
}

func (o ErrorReportingPanelOutput) ToErrorReportingPanelOutput() ErrorReportingPanelOutput {
	return o
}

func (o ErrorReportingPanelOutput) ToErrorReportingPanelOutputWithContext(ctx context.Context) ErrorReportingPanelOutput {
	return o
}

func (o ErrorReportingPanelOutput) ToErrorReportingPanelPtrOutput() ErrorReportingPanelPtrOutput {
	return o.ToErrorReportingPanelPtrOutputWithContext(context.Background())
}

func (o ErrorReportingPanelOutput) ToErrorReportingPanelPtrOutputWithContext(ctx context.Context) ErrorReportingPanelPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ErrorReportingPanel) *ErrorReportingPanel {
		return &v
	}).(ErrorReportingPanelPtrOutput)
}

// The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
func (o ErrorReportingPanelOutput) ProjectNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ErrorReportingPanel) []string { return v.ProjectNames }).(pulumi.StringArrayOutput)
}

// An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
func (o ErrorReportingPanelOutput) Services() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ErrorReportingPanel) []string { return v.Services }).(pulumi.StringArrayOutput)
}

// Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
func (o ErrorReportingPanelOutput) Versions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ErrorReportingPanel) []string { return v.Versions }).(pulumi.StringArrayOutput)
}

type ErrorReportingPanelPtrOutput struct{ *pulumi.OutputState }

func (ErrorReportingPanelPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ErrorReportingPanel)(nil)).Elem()
}

func (o ErrorReportingPanelPtrOutput) ToErrorReportingPanelPtrOutput() ErrorReportingPanelPtrOutput {
	return o
}

func (o ErrorReportingPanelPtrOutput) ToErrorReportingPanelPtrOutputWithContext(ctx context.Context) ErrorReportingPanelPtrOutput {
	return o
}

func (o ErrorReportingPanelPtrOutput) Elem() ErrorReportingPanelOutput {
	return o.ApplyT(func(v *ErrorReportingPanel) ErrorReportingPanel {
		if v != nil {
			return *v
		}
		var ret ErrorReportingPanel
		return ret
	}).(ErrorReportingPanelOutput)
}

// The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
func (o ErrorReportingPanelPtrOutput) ProjectNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ErrorReportingPanel) []string {
		if v == nil {
			return nil
		}
		return v.ProjectNames
	}).(pulumi.StringArrayOutput)
}

// An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
func (o ErrorReportingPanelPtrOutput) Services() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ErrorReportingPanel) []string {
		if v == nil {
			return nil
		}
		return v.Services
	}).(pulumi.StringArrayOutput)
}

// Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
func (o ErrorReportingPanelPtrOutput) Versions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ErrorReportingPanel) []string {
		if v == nil {
			return nil
		}
		return v.Versions
	}).(pulumi.StringArrayOutput)
}

// A widget that displays a list of error groups.
type ErrorReportingPanelResponse struct {
	// The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
	ProjectNames []string `pulumi:"projectNames"`
	// An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
	Services []string `pulumi:"services"`
	// Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
	Versions []string `pulumi:"versions"`
}

// A widget that displays a list of error groups.
type ErrorReportingPanelResponseOutput struct{ *pulumi.OutputState }

func (ErrorReportingPanelResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ErrorReportingPanelResponse)(nil)).Elem()
}

func (o ErrorReportingPanelResponseOutput) ToErrorReportingPanelResponseOutput() ErrorReportingPanelResponseOutput {
	return o
}

func (o ErrorReportingPanelResponseOutput) ToErrorReportingPanelResponseOutputWithContext(ctx context.Context) ErrorReportingPanelResponseOutput {
	return o
}

// The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
func (o ErrorReportingPanelResponseOutput) ProjectNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ErrorReportingPanelResponse) []string { return v.ProjectNames }).(pulumi.StringArrayOutput)
}

// An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
func (o ErrorReportingPanelResponseOutput) Services() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ErrorReportingPanelResponse) []string { return v.Services }).(pulumi.StringArrayOutput)
}

// Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
func (o ErrorReportingPanelResponseOutput) Versions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ErrorReportingPanelResponse) []string { return v.Versions }).(pulumi.StringArrayOutput)
}

// A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard's query (inclusive).
type GaugeView struct {
	// The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
	LowerBound *float64 `pulumi:"lowerBound"`
	// The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
	UpperBound *float64 `pulumi:"upperBound"`
}

// GaugeViewInput is an input type that accepts GaugeViewArgs and GaugeViewOutput values.
// You can construct a concrete instance of `GaugeViewInput` via:
//
//	GaugeViewArgs{...}
type GaugeViewInput interface {
	pulumi.Input

	ToGaugeViewOutput() GaugeViewOutput
	ToGaugeViewOutputWithContext(context.Context) GaugeViewOutput
}

// A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard's query (inclusive).
type GaugeViewArgs struct {
	// The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
	LowerBound pulumi.Float64PtrInput `pulumi:"lowerBound"`
	// The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
	UpperBound pulumi.Float64PtrInput `pulumi:"upperBound"`
}

func (GaugeViewArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GaugeView)(nil)).Elem()
}

func (i GaugeViewArgs) ToGaugeViewOutput() GaugeViewOutput {
	return i.ToGaugeViewOutputWithContext(context.Background())
}

func (i GaugeViewArgs) ToGaugeViewOutputWithContext(ctx context.Context) GaugeViewOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GaugeViewOutput)
}

func (i GaugeViewArgs) ToGaugeViewPtrOutput() GaugeViewPtrOutput {
	return i.ToGaugeViewPtrOutputWithContext(context.Background())
}

func (i GaugeViewArgs) ToGaugeViewPtrOutputWithContext(ctx context.Context) GaugeViewPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GaugeViewOutput).ToGaugeViewPtrOutputWithContext(ctx)
}

// GaugeViewPtrInput is an input type that accepts GaugeViewArgs, GaugeViewPtr and GaugeViewPtrOutput values.
// You can construct a concrete instance of `GaugeViewPtrInput` via:
//
//	        GaugeViewArgs{...}
//
//	or:
//
//	        nil
type GaugeViewPtrInput interface {
	pulumi.Input

	ToGaugeViewPtrOutput() GaugeViewPtrOutput
	ToGaugeViewPtrOutputWithContext(context.Context) GaugeViewPtrOutput
}

type gaugeViewPtrType GaugeViewArgs

func GaugeViewPtr(v *GaugeViewArgs) GaugeViewPtrInput {
	return (*gaugeViewPtrType)(v)
}

func (*gaugeViewPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GaugeView)(nil)).Elem()
}

func (i *gaugeViewPtrType) ToGaugeViewPtrOutput() GaugeViewPtrOutput {
	return i.ToGaugeViewPtrOutputWithContext(context.Background())
}

func (i *gaugeViewPtrType) ToGaugeViewPtrOutputWithContext(ctx context.Context) GaugeViewPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GaugeViewPtrOutput)
}

// A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard's query (inclusive).
type GaugeViewOutput struct{ *pulumi.OutputState }

func (GaugeViewOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GaugeView)(nil)).Elem()
}

func (o GaugeViewOutput) ToGaugeViewOutput() GaugeViewOutput {
	return o
}

func (o GaugeViewOutput) ToGaugeViewOutputWithContext(ctx context.Context) GaugeViewOutput {
	return o
}

func (o GaugeViewOutput) ToGaugeViewPtrOutput() GaugeViewPtrOutput {
	return o.ToGaugeViewPtrOutputWithContext(context.Background())
}

func (o GaugeViewOutput) ToGaugeViewPtrOutputWithContext(ctx context.Context) GaugeViewPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GaugeView) *GaugeView {
		return &v
	}).(GaugeViewPtrOutput)
}

// The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
func (o GaugeViewOutput) LowerBound() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v GaugeView) *float64 { return v.LowerBound }).(pulumi.Float64PtrOutput)
}

// The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
func (o GaugeViewOutput) UpperBound() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v GaugeView) *float64 { return v.UpperBound }).(pulumi.Float64PtrOutput)
}

type GaugeViewPtrOutput struct{ *pulumi.OutputState }

func (GaugeViewPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GaugeView)(nil)).Elem()
}

func (o GaugeViewPtrOutput) ToGaugeViewPtrOutput() GaugeViewPtrOutput {
	return o
}

func (o GaugeViewPtrOutput) ToGaugeViewPtrOutputWithContext(ctx context.Context) GaugeViewPtrOutput {
	return o
}

func (o GaugeViewPtrOutput) Elem() GaugeViewOutput {
	return o.ApplyT(func(v *GaugeView) GaugeView {
		if v != nil {
			return *v
		}
		var ret GaugeView
		return ret
	}).(GaugeViewOutput)
}

// The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
func (o GaugeViewPtrOutput) LowerBound() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *GaugeView) *float64 {
		if v == nil {
			return nil
		}
		return v.LowerBound
	}).(pulumi.Float64PtrOutput)
}

// The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
func (o GaugeViewPtrOutput) UpperBound() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *GaugeView) *float64 {
		if v == nil {
			return nil
		}
		return v.UpperBound
	}).(pulumi.Float64PtrOutput)
}

// A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard's query (inclusive).
type GaugeViewResponse struct {
	// The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
	LowerBound float64 `pulumi:"lowerBound"`
	// The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
	UpperBound float64 `pulumi:"upperBound"`
}

// A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard's query (inclusive).
type GaugeViewResponseOutput struct{ *pulumi.OutputState }

func (GaugeViewResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GaugeViewResponse)(nil)).Elem()
}

func (o GaugeViewResponseOutput) ToGaugeViewResponseOutput() GaugeViewResponseOutput {
	return o
}

func (o GaugeViewResponseOutput) ToGaugeViewResponseOutputWithContext(ctx context.Context) GaugeViewResponseOutput {
	return o
}

// The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
func (o GaugeViewResponseOutput) LowerBound() pulumi.Float64Output {
	return o.ApplyT(func(v GaugeViewResponse) float64 { return v.LowerBound }).(pulumi.Float64Output)
}

// The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
func (o GaugeViewResponseOutput) UpperBound() pulumi.Float64Output {
	return o.ApplyT(func(v GaugeViewResponse) float64 { return v.UpperBound }).(pulumi.Float64Output)
}

// A basic layout divides the available space into vertical columns of equal width and arranges a list of widgets using a row-first strategy.
type GridLayout struct {
	// The number of columns into which the view's width is divided. If omitted or set to zero, a system default will be used while rendering.
	Columns *string `pulumi:"columns"`
	// The informational elements that are arranged into the columns row-first.
	Widgets []Widget `pulumi:"widgets"`
}

// GridLayoutInput is an input type that accepts GridLayoutArgs and GridLayoutOutput values.
// You can construct a concrete instance of `GridLayoutInput` via:
//
//	GridLayoutArgs{...}
type GridLayoutInput interface {
	pulumi.Input

	ToGridLayoutOutput() GridLayoutOutput
	ToGridLayoutOutputWithContext(context.Context) GridLayoutOutput
}

// A basic layout divides the available space into vertical columns of equal width and arranges a list of widgets using a row-first strategy.
type GridLayoutArgs struct {
	// The number of columns into which the view's width is divided. If omitted or set to zero, a system default will be used while rendering.
	Columns pulumi.StringPtrInput `pulumi:"columns"`
	// The informational elements that are arranged into the columns row-first.
	Widgets WidgetArrayInput `pulumi:"widgets"`
}

func (GridLayoutArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GridLayout)(nil)).Elem()
}

func (i GridLayoutArgs) ToGridLayoutOutput() GridLayoutOutput {
	return i.ToGridLayoutOutputWithContext(context.Background())
}

func (i GridLayoutArgs) ToGridLayoutOutputWithContext(ctx context.Context) GridLayoutOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GridLayoutOutput)
}

func (i GridLayoutArgs) ToGridLayoutPtrOutput() GridLayoutPtrOutput {
	return i.ToGridLayoutPtrOutputWithContext(context.Background())
}

func (i GridLayoutArgs) ToGridLayoutPtrOutputWithContext(ctx context.Context) GridLayoutPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GridLayoutOutput).ToGridLayoutPtrOutputWithContext(ctx)
}

// GridLayoutPtrInput is an input type that accepts GridLayoutArgs, GridLayoutPtr and GridLayoutPtrOutput values.
// You can construct a concrete instance of `GridLayoutPtrInput` via:
//
//	        GridLayoutArgs{...}
//
//	or:
//
//	        nil
type GridLayoutPtrInput interface {
	pulumi.Input

	ToGridLayoutPtrOutput() GridLayoutPtrOutput
	ToGridLayoutPtrOutputWithContext(context.Context) GridLayoutPtrOutput
}

type gridLayoutPtrType GridLayoutArgs

func GridLayoutPtr(v *GridLayoutArgs) GridLayoutPtrInput {
	return (*gridLayoutPtrType)(v)
}

func (*gridLayoutPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GridLayout)(nil)).Elem()
}

func (i *gridLayoutPtrType) ToGridLayoutPtrOutput() GridLayoutPtrOutput {
	return i.ToGridLayoutPtrOutputWithContext(context.Background())
}

func (i *gridLayoutPtrType) ToGridLayoutPtrOutputWithContext(ctx context.Context) GridLayoutPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GridLayoutPtrOutput)
}

// A basic layout divides the available space into vertical columns of equal width and arranges a list of widgets using a row-first strategy.
type GridLayoutOutput struct{ *pulumi.OutputState }

func (GridLayoutOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GridLayout)(nil)).Elem()
}

func (o GridLayoutOutput) ToGridLayoutOutput() GridLayoutOutput {
	return o
}

func (o GridLayoutOutput) ToGridLayoutOutputWithContext(ctx context.Context) GridLayoutOutput {
	return o
}

func (o GridLayoutOutput) ToGridLayoutPtrOutput() GridLayoutPtrOutput {
	return o.ToGridLayoutPtrOutputWithContext(context.Background())
}

func (o GridLayoutOutput) ToGridLayoutPtrOutputWithContext(ctx context.Context) GridLayoutPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GridLayout) *GridLayout {
		return &v
	}).(GridLayoutPtrOutput)
}

// The number of columns into which the view's width is divided. If omitted or set to zero, a system default will be used while rendering.
func (o GridLayoutOutput) Columns() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GridLayout) *string { return v.Columns }).(pulumi.StringPtrOutput)
}

// The informational elements that are arranged into the columns row-first.
func (o GridLayoutOutput) Widgets() WidgetArrayOutput {
	return o.ApplyT(func(v GridLayout) []Widget { return v.Widgets }).(WidgetArrayOutput)
}

type GridLayoutPtrOutput struct{ *pulumi.OutputState }

func (GridLayoutPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GridLayout)(nil)).Elem()
}

func (o GridLayoutPtrOutput) ToGridLayoutPtrOutput() GridLayoutPtrOutput {
	return o
}

func (o GridLayoutPtrOutput) ToGridLayoutPtrOutputWithContext(ctx context.Context) GridLayoutPtrOutput {
	return o
}

func (o GridLayoutPtrOutput) Elem() GridLayoutOutput {
	return o.ApplyT(func(v *GridLayout) GridLayout {
		if v != nil {
			return *v
		}
		var ret GridLayout
		return ret
	}).(GridLayoutOutput)
}

// The number of columns into which the view's width is divided. If omitted or set to zero, a system default will be used while rendering.
func (o GridLayoutPtrOutput) Columns() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GridLayout) *string {
		if v == nil {
			return nil
		}
		return v.Columns
	}).(pulumi.StringPtrOutput)
}

// The informational elements that are arranged into the columns row-first.
func (o GridLayoutPtrOutput) Widgets() WidgetArrayOutput {
	return o.ApplyT(func(v *GridLayout) []Widget {
		if v == nil {
			return nil
		}
		return v.Widgets
	}).(WidgetArrayOutput)
}

// A basic layout divides the available space into vertical columns of equal width and arranges a list of widgets using a row-first strategy.
type GridLayoutResponse struct {
	// The number of columns into which the view's width is divided. If omitted or set to zero, a system default will be used while rendering.
	Columns string `pulumi:"columns"`
	// The informational elements that are arranged into the columns row-first.
	Widgets []WidgetResponse `pulumi:"widgets"`
}

// A basic layout divides the available space into vertical columns of equal width and arranges a list of widgets using a row-first strategy.
type GridLayoutResponseOutput struct{ *pulumi.OutputState }

func (GridLayoutResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GridLayoutResponse)(nil)).Elem()
}

func (o GridLayoutResponseOutput) ToGridLayoutResponseOutput() GridLayoutResponseOutput {
	return o
}

func (o GridLayoutResponseOutput) ToGridLayoutResponseOutputWithContext(ctx context.Context) GridLayoutResponseOutput {
	return o
}

// The number of columns into which the view's width is divided. If omitted or set to zero, a system default will be used while rendering.
func (o GridLayoutResponseOutput) Columns() pulumi.StringOutput {
	return o.ApplyT(func(v GridLayoutResponse) string { return v.Columns }).(pulumi.StringOutput)
}

// The informational elements that are arranged into the columns row-first.
func (o GridLayoutResponseOutput) Widgets() WidgetResponseArrayOutput {
	return o.ApplyT(func(v GridLayoutResponse) []WidgetResponse { return v.Widgets }).(WidgetResponseArrayOutput)
}

// A widget that displays a list of incidents
type IncidentList struct {
	// Optional. The monitored resource for which incidents are listed. The resource doesn't need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
	MonitoredResources []MonitoredResource `pulumi:"monitoredResources"`
	// Optional. A list of alert policy names to filter the incident list by. Don't include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
	PolicyNames []string `pulumi:"policyNames"`
}

// IncidentListInput is an input type that accepts IncidentListArgs and IncidentListOutput values.
// You can construct a concrete instance of `IncidentListInput` via:
//
//	IncidentListArgs{...}
type IncidentListInput interface {
	pulumi.Input

	ToIncidentListOutput() IncidentListOutput
	ToIncidentListOutputWithContext(context.Context) IncidentListOutput
}

// A widget that displays a list of incidents
type IncidentListArgs struct {
	// Optional. The monitored resource for which incidents are listed. The resource doesn't need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
	MonitoredResources MonitoredResourceArrayInput `pulumi:"monitoredResources"`
	// Optional. A list of alert policy names to filter the incident list by. Don't include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
	PolicyNames pulumi.StringArrayInput `pulumi:"policyNames"`
}

func (IncidentListArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IncidentList)(nil)).Elem()
}

func (i IncidentListArgs) ToIncidentListOutput() IncidentListOutput {
	return i.ToIncidentListOutputWithContext(context.Background())
}

func (i IncidentListArgs) ToIncidentListOutputWithContext(ctx context.Context) IncidentListOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IncidentListOutput)
}

func (i IncidentListArgs) ToIncidentListPtrOutput() IncidentListPtrOutput {
	return i.ToIncidentListPtrOutputWithContext(context.Background())
}

func (i IncidentListArgs) ToIncidentListPtrOutputWithContext(ctx context.Context) IncidentListPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IncidentListOutput).ToIncidentListPtrOutputWithContext(ctx)
}

// IncidentListPtrInput is an input type that accepts IncidentListArgs, IncidentListPtr and IncidentListPtrOutput values.
// You can construct a concrete instance of `IncidentListPtrInput` via:
//
//	        IncidentListArgs{...}
//
//	or:
//
//	        nil
type IncidentListPtrInput interface {
	pulumi.Input

	ToIncidentListPtrOutput() IncidentListPtrOutput
	ToIncidentListPtrOutputWithContext(context.Context) IncidentListPtrOutput
}

type incidentListPtrType IncidentListArgs

func IncidentListPtr(v *IncidentListArgs) IncidentListPtrInput {
	return (*incidentListPtrType)(v)
}

func (*incidentListPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IncidentList)(nil)).Elem()
}

func (i *incidentListPtrType) ToIncidentListPtrOutput() IncidentListPtrOutput {
	return i.ToIncidentListPtrOutputWithContext(context.Background())
}

func (i *incidentListPtrType) ToIncidentListPtrOutputWithContext(ctx context.Context) IncidentListPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IncidentListPtrOutput)
}

// A widget that displays a list of incidents
type IncidentListOutput struct{ *pulumi.OutputState }

func (IncidentListOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IncidentList)(nil)).Elem()
}

func (o IncidentListOutput) ToIncidentListOutput() IncidentListOutput {
	return o
}

func (o IncidentListOutput) ToIncidentListOutputWithContext(ctx context.Context) IncidentListOutput {
	return o
}

func (o IncidentListOutput) ToIncidentListPtrOutput() IncidentListPtrOutput {
	return o.ToIncidentListPtrOutputWithContext(context.Background())
}

func (o IncidentListOutput) ToIncidentListPtrOutputWithContext(ctx context.Context) IncidentListPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v IncidentList) *IncidentList {
		return &v
	}).(IncidentListPtrOutput)
}

// Optional. The monitored resource for which incidents are listed. The resource doesn't need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
func (o IncidentListOutput) MonitoredResources() MonitoredResourceArrayOutput {
	return o.ApplyT(func(v IncidentList) []MonitoredResource { return v.MonitoredResources }).(MonitoredResourceArrayOutput)
}

// Optional. A list of alert policy names to filter the incident list by. Don't include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
func (o IncidentListOutput) PolicyNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v IncidentList) []string { return v.PolicyNames }).(pulumi.StringArrayOutput)
}

type IncidentListPtrOutput struct{ *pulumi.OutputState }

func (IncidentListPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IncidentList)(nil)).Elem()
}

func (o IncidentListPtrOutput) ToIncidentListPtrOutput() IncidentListPtrOutput {
	return o
}

func (o IncidentListPtrOutput) ToIncidentListPtrOutputWithContext(ctx context.Context) IncidentListPtrOutput {
	return o
}

func (o IncidentListPtrOutput) Elem() IncidentListOutput {
	return o.ApplyT(func(v *IncidentList) IncidentList {
		if v != nil {
			return *v
		}
		var ret IncidentList
		return ret
	}).(IncidentListOutput)
}

// Optional. The monitored resource for which incidents are listed. The resource doesn't need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
func (o IncidentListPtrOutput) MonitoredResources() MonitoredResourceArrayOutput {
	return o.ApplyT(func(v *IncidentList) []MonitoredResource {
		if v == nil {
			return nil
		}
		return v.MonitoredResources
	}).(MonitoredResourceArrayOutput)
}

// Optional. A list of alert policy names to filter the incident list by. Don't include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
func (o IncidentListPtrOutput) PolicyNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *IncidentList) []string {
		if v == nil {
			return nil
		}
		return v.PolicyNames
	}).(pulumi.StringArrayOutput)
}

// A widget that displays a list of incidents
type IncidentListResponse struct {
	// Optional. The monitored resource for which incidents are listed. The resource doesn't need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
	MonitoredResources []MonitoredResourceResponse `pulumi:"monitoredResources"`
	// Optional. A list of alert policy names to filter the incident list by. Don't include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
	PolicyNames []string `pulumi:"policyNames"`
}

// A widget that displays a list of incidents
type IncidentListResponseOutput struct{ *pulumi.OutputState }

func (IncidentListResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IncidentListResponse)(nil)).Elem()
}

func (o IncidentListResponseOutput) ToIncidentListResponseOutput() IncidentListResponseOutput {
	return o
}

func (o IncidentListResponseOutput) ToIncidentListResponseOutputWithContext(ctx context.Context) IncidentListResponseOutput {
	return o
}

// Optional. The monitored resource for which incidents are listed. The resource doesn't need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
func (o IncidentListResponseOutput) MonitoredResources() MonitoredResourceResponseArrayOutput {
	return o.ApplyT(func(v IncidentListResponse) []MonitoredResourceResponse { return v.MonitoredResources }).(MonitoredResourceResponseArrayOutput)
}

// Optional. A list of alert policy names to filter the incident list by. Don't include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
func (o IncidentListResponseOutput) PolicyNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v IncidentListResponse) []string { return v.PolicyNames }).(pulumi.StringArrayOutput)
}

// Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time.
type Interval struct {
	// Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
	EndTime *string `pulumi:"endTime"`
	// Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
	StartTime *string `pulumi:"startTime"`
}

// IntervalInput is an input type that accepts IntervalArgs and IntervalOutput values.
// You can construct a concrete instance of `IntervalInput` via:
//
//	IntervalArgs{...}
type IntervalInput interface {
	pulumi.Input

	ToIntervalOutput() IntervalOutput
	ToIntervalOutputWithContext(context.Context) IntervalOutput
}

// Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time.
type IntervalArgs struct {
	// Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
	EndTime pulumi.StringPtrInput `pulumi:"endTime"`
	// Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
	StartTime pulumi.StringPtrInput `pulumi:"startTime"`
}

func (IntervalArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Interval)(nil)).Elem()
}

func (i IntervalArgs) ToIntervalOutput() IntervalOutput {
	return i.ToIntervalOutputWithContext(context.Background())
}

func (i IntervalArgs) ToIntervalOutputWithContext(ctx context.Context) IntervalOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IntervalOutput)
}

func (i IntervalArgs) ToIntervalPtrOutput() IntervalPtrOutput {
	return i.ToIntervalPtrOutputWithContext(context.Background())
}

func (i IntervalArgs) ToIntervalPtrOutputWithContext(ctx context.Context) IntervalPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IntervalOutput).ToIntervalPtrOutputWithContext(ctx)
}

// IntervalPtrInput is an input type that accepts IntervalArgs, IntervalPtr and IntervalPtrOutput values.
// You can construct a concrete instance of `IntervalPtrInput` via:
//
//	        IntervalArgs{...}
//
//	or:
//
//	        nil
type IntervalPtrInput interface {
	pulumi.Input

	ToIntervalPtrOutput() IntervalPtrOutput
	ToIntervalPtrOutputWithContext(context.Context) IntervalPtrOutput
}

type intervalPtrType IntervalArgs

func IntervalPtr(v *IntervalArgs) IntervalPtrInput {
	return (*intervalPtrType)(v)
}

func (*intervalPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Interval)(nil)).Elem()
}

func (i *intervalPtrType) ToIntervalPtrOutput() IntervalPtrOutput {
	return i.ToIntervalPtrOutputWithContext(context.Background())
}

func (i *intervalPtrType) ToIntervalPtrOutputWithContext(ctx context.Context) IntervalPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IntervalPtrOutput)
}

// Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time.
type IntervalOutput struct{ *pulumi.OutputState }

func (IntervalOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Interval)(nil)).Elem()
}

func (o IntervalOutput) ToIntervalOutput() IntervalOutput {
	return o
}

func (o IntervalOutput) ToIntervalOutputWithContext(ctx context.Context) IntervalOutput {
	return o
}

func (o IntervalOutput) ToIntervalPtrOutput() IntervalPtrOutput {
	return o.ToIntervalPtrOutputWithContext(context.Background())
}

func (o IntervalOutput) ToIntervalPtrOutputWithContext(ctx context.Context) IntervalPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Interval) *Interval {
		return &v
	}).(IntervalPtrOutput)
}

// Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
func (o IntervalOutput) EndTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Interval) *string { return v.EndTime }).(pulumi.StringPtrOutput)
}

// Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
func (o IntervalOutput) StartTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Interval) *string { return v.StartTime }).(pulumi.StringPtrOutput)
}

type IntervalPtrOutput struct{ *pulumi.OutputState }

func (IntervalPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Interval)(nil)).Elem()
}

func (o IntervalPtrOutput) ToIntervalPtrOutput() IntervalPtrOutput {
	return o
}

func (o IntervalPtrOutput) ToIntervalPtrOutputWithContext(ctx context.Context) IntervalPtrOutput {
	return o
}

func (o IntervalPtrOutput) Elem() IntervalOutput {
	return o.ApplyT(func(v *Interval) Interval {
		if v != nil {
			return *v
		}
		var ret Interval
		return ret
	}).(IntervalOutput)
}

// Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
func (o IntervalPtrOutput) EndTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Interval) *string {
		if v == nil {
			return nil
		}
		return v.EndTime
	}).(pulumi.StringPtrOutput)
}

// Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
func (o IntervalPtrOutput) StartTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Interval) *string {
		if v == nil {
			return nil
		}
		return v.StartTime
	}).(pulumi.StringPtrOutput)
}

// Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time.
type IntervalResponse struct {
	// Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
	EndTime string `pulumi:"endTime"`
	// Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
	StartTime string `pulumi:"startTime"`
}

// Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time.
type IntervalResponseOutput struct{ *pulumi.OutputState }

func (IntervalResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IntervalResponse)(nil)).Elem()
}

func (o IntervalResponseOutput) ToIntervalResponseOutput() IntervalResponseOutput {
	return o
}

func (o IntervalResponseOutput) ToIntervalResponseOutputWithContext(ctx context.Context) IntervalResponseOutput {
	return o
}

// Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
func (o IntervalResponseOutput) EndTime() pulumi.StringOutput {
	return o.ApplyT(func(v IntervalResponse) string { return v.EndTime }).(pulumi.StringOutput)
}

// Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
func (o IntervalResponseOutput) StartTime() pulumi.StringOutput {
	return o.ApplyT(func(v IntervalResponse) string { return v.StartTime }).(pulumi.StringOutput)
}

// A widget that displays a stream of log.
type LogsPanel struct {
	// A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
	Filter *string `pulumi:"filter"`
	// The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
	ResourceNames []string `pulumi:"resourceNames"`
}

// LogsPanelInput is an input type that accepts LogsPanelArgs and LogsPanelOutput values.
// You can construct a concrete instance of `LogsPanelInput` via:
//
//	LogsPanelArgs{...}
type LogsPanelInput interface {
	pulumi.Input

	ToLogsPanelOutput() LogsPanelOutput
	ToLogsPanelOutputWithContext(context.Context) LogsPanelOutput
}

// A widget that displays a stream of log.
type LogsPanelArgs struct {
	// A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
	Filter pulumi.StringPtrInput `pulumi:"filter"`
	// The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
	ResourceNames pulumi.StringArrayInput `pulumi:"resourceNames"`
}

func (LogsPanelArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LogsPanel)(nil)).Elem()
}

func (i LogsPanelArgs) ToLogsPanelOutput() LogsPanelOutput {
	return i.ToLogsPanelOutputWithContext(context.Background())
}

func (i LogsPanelArgs) ToLogsPanelOutputWithContext(ctx context.Context) LogsPanelOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogsPanelOutput)
}

func (i LogsPanelArgs) ToLogsPanelPtrOutput() LogsPanelPtrOutput {
	return i.ToLogsPanelPtrOutputWithContext(context.Background())
}

func (i LogsPanelArgs) ToLogsPanelPtrOutputWithContext(ctx context.Context) LogsPanelPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogsPanelOutput).ToLogsPanelPtrOutputWithContext(ctx)
}

// LogsPanelPtrInput is an input type that accepts LogsPanelArgs, LogsPanelPtr and LogsPanelPtrOutput values.
// You can construct a concrete instance of `LogsPanelPtrInput` via:
//
//	        LogsPanelArgs{...}
//
//	or:
//
//	        nil
type LogsPanelPtrInput interface {
	pulumi.Input

	ToLogsPanelPtrOutput() LogsPanelPtrOutput
	ToLogsPanelPtrOutputWithContext(context.Context) LogsPanelPtrOutput
}

type logsPanelPtrType LogsPanelArgs

func LogsPanelPtr(v *LogsPanelArgs) LogsPanelPtrInput {
	return (*logsPanelPtrType)(v)
}

func (*logsPanelPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogsPanel)(nil)).Elem()
}

func (i *logsPanelPtrType) ToLogsPanelPtrOutput() LogsPanelPtrOutput {
	return i.ToLogsPanelPtrOutputWithContext(context.Background())
}

func (i *logsPanelPtrType) ToLogsPanelPtrOutputWithContext(ctx context.Context) LogsPanelPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogsPanelPtrOutput)
}

// A widget that displays a stream of log.
type LogsPanelOutput struct{ *pulumi.OutputState }

func (LogsPanelOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogsPanel)(nil)).Elem()
}

func (o LogsPanelOutput) ToLogsPanelOutput() LogsPanelOutput {
	return o
}

func (o LogsPanelOutput) ToLogsPanelOutputWithContext(ctx context.Context) LogsPanelOutput {
	return o
}

func (o LogsPanelOutput) ToLogsPanelPtrOutput() LogsPanelPtrOutput {
	return o.ToLogsPanelPtrOutputWithContext(context.Background())
}

func (o LogsPanelOutput) ToLogsPanelPtrOutputWithContext(ctx context.Context) LogsPanelPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LogsPanel) *LogsPanel {
		return &v
	}).(LogsPanelPtrOutput)
}

// A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
func (o LogsPanelOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LogsPanel) *string { return v.Filter }).(pulumi.StringPtrOutput)
}

// The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
func (o LogsPanelOutput) ResourceNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogsPanel) []string { return v.ResourceNames }).(pulumi.StringArrayOutput)
}

type LogsPanelPtrOutput struct{ *pulumi.OutputState }

func (LogsPanelPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogsPanel)(nil)).Elem()
}

func (o LogsPanelPtrOutput) ToLogsPanelPtrOutput() LogsPanelPtrOutput {
	return o
}

func (o LogsPanelPtrOutput) ToLogsPanelPtrOutputWithContext(ctx context.Context) LogsPanelPtrOutput {
	return o
}

func (o LogsPanelPtrOutput) Elem() LogsPanelOutput {
	return o.ApplyT(func(v *LogsPanel) LogsPanel {
		if v != nil {
			return *v
		}
		var ret LogsPanel
		return ret
	}).(LogsPanelOutput)
}

// A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
func (o LogsPanelPtrOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogsPanel) *string {
		if v == nil {
			return nil
		}
		return v.Filter
	}).(pulumi.StringPtrOutput)
}

// The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
func (o LogsPanelPtrOutput) ResourceNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogsPanel) []string {
		if v == nil {
			return nil
		}
		return v.ResourceNames
	}).(pulumi.StringArrayOutput)
}

// A widget that displays a stream of log.
type LogsPanelResponse struct {
	// A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
	Filter string `pulumi:"filter"`
	// The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
	ResourceNames []string `pulumi:"resourceNames"`
}

// A widget that displays a stream of log.
type LogsPanelResponseOutput struct{ *pulumi.OutputState }

func (LogsPanelResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogsPanelResponse)(nil)).Elem()
}

func (o LogsPanelResponseOutput) ToLogsPanelResponseOutput() LogsPanelResponseOutput {
	return o
}

func (o LogsPanelResponseOutput) ToLogsPanelResponseOutputWithContext(ctx context.Context) LogsPanelResponseOutput {
	return o
}

// A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
func (o LogsPanelResponseOutput) Filter() pulumi.StringOutput {
	return o.ApplyT(func(v LogsPanelResponse) string { return v.Filter }).(pulumi.StringOutput)
}

// The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
func (o LogsPanelResponseOutput) ResourceNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LogsPanelResponse) []string { return v.ResourceNames }).(pulumi.StringArrayOutput)
}

// A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
type Measure struct {
	// The aggregation function applied to the input column. This must not be set to "none" unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
	AggregationFunction AggregationFunction `pulumi:"aggregationFunction"`
	// The column name within in the dataset used for the measure.
	Column string `pulumi:"column"`
}

// MeasureInput is an input type that accepts MeasureArgs and MeasureOutput values.
// You can construct a concrete instance of `MeasureInput` via:
//
//	MeasureArgs{...}
type MeasureInput interface {
	pulumi.Input

	ToMeasureOutput() MeasureOutput
	ToMeasureOutputWithContext(context.Context) MeasureOutput
}

// A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
type MeasureArgs struct {
	// The aggregation function applied to the input column. This must not be set to "none" unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
	AggregationFunction AggregationFunctionInput `pulumi:"aggregationFunction"`
	// The column name within in the dataset used for the measure.
	Column pulumi.StringInput `pulumi:"column"`
}

func (MeasureArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Measure)(nil)).Elem()
}

func (i MeasureArgs) ToMeasureOutput() MeasureOutput {
	return i.ToMeasureOutputWithContext(context.Background())
}

func (i MeasureArgs) ToMeasureOutputWithContext(ctx context.Context) MeasureOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeasureOutput)
}

// MeasureArrayInput is an input type that accepts MeasureArray and MeasureArrayOutput values.
// You can construct a concrete instance of `MeasureArrayInput` via:
//
//	MeasureArray{ MeasureArgs{...} }
type MeasureArrayInput interface {
	pulumi.Input

	ToMeasureArrayOutput() MeasureArrayOutput
	ToMeasureArrayOutputWithContext(context.Context) MeasureArrayOutput
}

type MeasureArray []MeasureInput

func (MeasureArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Measure)(nil)).Elem()
}

func (i MeasureArray) ToMeasureArrayOutput() MeasureArrayOutput {
	return i.ToMeasureArrayOutputWithContext(context.Background())
}

func (i MeasureArray) ToMeasureArrayOutputWithContext(ctx context.Context) MeasureArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeasureArrayOutput)
}

// A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
type MeasureOutput struct{ *pulumi.OutputState }

func (MeasureOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Measure)(nil)).Elem()
}

func (o MeasureOutput) ToMeasureOutput() MeasureOutput {
	return o
}

func (o MeasureOutput) ToMeasureOutputWithContext(ctx context.Context) MeasureOutput {
	return o
}

// The aggregation function applied to the input column. This must not be set to "none" unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
func (o MeasureOutput) AggregationFunction() AggregationFunctionOutput {
	return o.ApplyT(func(v Measure) AggregationFunction { return v.AggregationFunction }).(AggregationFunctionOutput)
}

// The column name within in the dataset used for the measure.
func (o MeasureOutput) Column() pulumi.StringOutput {
	return o.ApplyT(func(v Measure) string { return v.Column }).(pulumi.StringOutput)
}

type MeasureArrayOutput struct{ *pulumi.OutputState }

func (MeasureArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Measure)(nil)).Elem()
}

func (o MeasureArrayOutput) ToMeasureArrayOutput() MeasureArrayOutput {
	return o
}

func (o MeasureArrayOutput) ToMeasureArrayOutputWithContext(ctx context.Context) MeasureArrayOutput {
	return o
}

func (o MeasureArrayOutput) Index(i pulumi.IntInput) MeasureOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Measure {
		return vs[0].([]Measure)[vs[1].(int)]
	}).(MeasureOutput)
}

// A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
type MeasureResponse struct {
	// The aggregation function applied to the input column. This must not be set to "none" unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
	AggregationFunction AggregationFunctionResponse `pulumi:"aggregationFunction"`
	// The column name within in the dataset used for the measure.
	Column string `pulumi:"column"`
}

// A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
type MeasureResponseOutput struct{ *pulumi.OutputState }

func (MeasureResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MeasureResponse)(nil)).Elem()
}

func (o MeasureResponseOutput) ToMeasureResponseOutput() MeasureResponseOutput {
	return o
}

func (o MeasureResponseOutput) ToMeasureResponseOutputWithContext(ctx context.Context) MeasureResponseOutput {
	return o
}

// The aggregation function applied to the input column. This must not be set to "none" unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
func (o MeasureResponseOutput) AggregationFunction() AggregationFunctionResponseOutput {
	return o.ApplyT(func(v MeasureResponse) AggregationFunctionResponse { return v.AggregationFunction }).(AggregationFunctionResponseOutput)
}

// The column name within in the dataset used for the measure.
func (o MeasureResponseOutput) Column() pulumi.StringOutput {
	return o.ApplyT(func(v MeasureResponse) string { return v.Column }).(pulumi.StringOutput)
}

type MeasureResponseArrayOutput struct{ *pulumi.OutputState }

func (MeasureResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MeasureResponse)(nil)).Elem()
}

func (o MeasureResponseArrayOutput) ToMeasureResponseArrayOutput() MeasureResponseArrayOutput {
	return o
}

func (o MeasureResponseArrayOutput) ToMeasureResponseArrayOutputWithContext(ctx context.Context) MeasureResponseArrayOutput {
	return o
}

func (o MeasureResponseArrayOutput) Index(i pulumi.IntInput) MeasureResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) MeasureResponse {
		return vs[0].([]MeasureResponse)[vs[1].(int)]
	}).(MeasureResponseOutput)
}

// An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource's schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for "gce_instance" has labels "project_id", "instance_id" and "zone": { "type": "gce_instance", "labels": { "project_id": "my-project", "instance_id": "12345678901234", "zone": "us-central1-a" }}
type MonitoredResource struct {
	// Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
	Labels map[string]string `pulumi:"labels"`
	// The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
	Type string `pulumi:"type"`
}

// MonitoredResourceInput is an input type that accepts MonitoredResourceArgs and MonitoredResourceOutput values.
// You can construct a concrete instance of `MonitoredResourceInput` via:
//
//	MonitoredResourceArgs{...}
type MonitoredResourceInput interface {
	pulumi.Input

	ToMonitoredResourceOutput() MonitoredResourceOutput
	ToMonitoredResourceOutputWithContext(context.Context) MonitoredResourceOutput
}

// An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource's schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for "gce_instance" has labels "project_id", "instance_id" and "zone": { "type": "gce_instance", "labels": { "project_id": "my-project", "instance_id": "12345678901234", "zone": "us-central1-a" }}
type MonitoredResourceArgs struct {
	// Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
	Labels pulumi.StringMapInput `pulumi:"labels"`
	// The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
	Type pulumi.StringInput `pulumi:"type"`
}

func (MonitoredResourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoredResource)(nil)).Elem()
}

func (i MonitoredResourceArgs) ToMonitoredResourceOutput() MonitoredResourceOutput {
	return i.ToMonitoredResourceOutputWithContext(context.Background())
}

func (i MonitoredResourceArgs) ToMonitoredResourceOutputWithContext(ctx context.Context) MonitoredResourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoredResourceOutput)
}

// MonitoredResourceArrayInput is an input type that accepts MonitoredResourceArray and MonitoredResourceArrayOutput values.
// You can construct a concrete instance of `MonitoredResourceArrayInput` via:
//
//	MonitoredResourceArray{ MonitoredResourceArgs{...} }
type MonitoredResourceArrayInput interface {
	pulumi.Input

	ToMonitoredResourceArrayOutput() MonitoredResourceArrayOutput
	ToMonitoredResourceArrayOutputWithContext(context.Context) MonitoredResourceArrayOutput
}

type MonitoredResourceArray []MonitoredResourceInput

func (MonitoredResourceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MonitoredResource)(nil)).Elem()
}

func (i MonitoredResourceArray) ToMonitoredResourceArrayOutput() MonitoredResourceArrayOutput {
	return i.ToMonitoredResourceArrayOutputWithContext(context.Background())
}

func (i MonitoredResourceArray) ToMonitoredResourceArrayOutputWithContext(ctx context.Context) MonitoredResourceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoredResourceArrayOutput)
}

// An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource's schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for "gce_instance" has labels "project_id", "instance_id" and "zone": { "type": "gce_instance", "labels": { "project_id": "my-project", "instance_id": "12345678901234", "zone": "us-central1-a" }}
type MonitoredResourceOutput struct{ *pulumi.OutputState }

func (MonitoredResourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoredResource)(nil)).Elem()
}

func (o MonitoredResourceOutput) ToMonitoredResourceOutput() MonitoredResourceOutput {
	return o
}

func (o MonitoredResourceOutput) ToMonitoredResourceOutputWithContext(ctx context.Context) MonitoredResourceOutput {
	return o
}

// Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
func (o MonitoredResourceOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v MonitoredResource) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
func (o MonitoredResourceOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v MonitoredResource) string { return v.Type }).(pulumi.StringOutput)
}

type MonitoredResourceArrayOutput struct{ *pulumi.OutputState }

func (MonitoredResourceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MonitoredResource)(nil)).Elem()
}

func (o MonitoredResourceArrayOutput) ToMonitoredResourceArrayOutput() MonitoredResourceArrayOutput {
	return o
}

func (o MonitoredResourceArrayOutput) ToMonitoredResourceArrayOutputWithContext(ctx context.Context) MonitoredResourceArrayOutput {
	return o
}

func (o MonitoredResourceArrayOutput) Index(i pulumi.IntInput) MonitoredResourceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) MonitoredResource {
		return vs[0].([]MonitoredResource)[vs[1].(int)]
	}).(MonitoredResourceOutput)
}

// An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource's schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for "gce_instance" has labels "project_id", "instance_id" and "zone": { "type": "gce_instance", "labels": { "project_id": "my-project", "instance_id": "12345678901234", "zone": "us-central1-a" }}
type MonitoredResourceResponse struct {
	// Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
	Labels map[string]string `pulumi:"labels"`
	// The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
	Type string `pulumi:"type"`
}

// An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource's schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for "gce_instance" has labels "project_id", "instance_id" and "zone": { "type": "gce_instance", "labels": { "project_id": "my-project", "instance_id": "12345678901234", "zone": "us-central1-a" }}
type MonitoredResourceResponseOutput struct{ *pulumi.OutputState }

func (MonitoredResourceResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoredResourceResponse)(nil)).Elem()
}

func (o MonitoredResourceResponseOutput) ToMonitoredResourceResponseOutput() MonitoredResourceResponseOutput {
	return o
}

func (o MonitoredResourceResponseOutput) ToMonitoredResourceResponseOutputWithContext(ctx context.Context) MonitoredResourceResponseOutput {
	return o
}

// Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
func (o MonitoredResourceResponseOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v MonitoredResourceResponse) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
func (o MonitoredResourceResponseOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v MonitoredResourceResponse) string { return v.Type }).(pulumi.StringOutput)
}

type MonitoredResourceResponseArrayOutput struct{ *pulumi.OutputState }

func (MonitoredResourceResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MonitoredResourceResponse)(nil)).Elem()
}

func (o MonitoredResourceResponseArrayOutput) ToMonitoredResourceResponseArrayOutput() MonitoredResourceResponseArrayOutput {
	return o
}

func (o MonitoredResourceResponseArrayOutput) ToMonitoredResourceResponseArrayOutputWithContext(ctx context.Context) MonitoredResourceResponseArrayOutput {
	return o
}

func (o MonitoredResourceResponseArrayOutput) Index(i pulumi.IntInput) MonitoredResourceResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) MonitoredResourceResponse {
		return vs[0].([]MonitoredResourceResponse)[vs[1].(int)]
	}).(MonitoredResourceResponseOutput)
}

// A mosaic layout divides the available space into a grid of blocks, and overlays the grid with tiles. Unlike GridLayout, tiles may span multiple grid blocks and can be placed at arbitrary locations in the grid.
type MosaicLayout struct {
	// The number of columns in the mosaic grid. The number of columns must be between 1 and 12, inclusive.
	Columns *int `pulumi:"columns"`
	// The tiles to display.
	Tiles []Tile `pulumi:"tiles"`
}

// MosaicLayoutInput is an input type that accepts MosaicLayoutArgs and MosaicLayoutOutput values.
// You can construct a concrete instance of `MosaicLayoutInput` via:
//
//	MosaicLayoutArgs{...}
type MosaicLayoutInput interface {
	pulumi.Input

	ToMosaicLayoutOutput() MosaicLayoutOutput
	ToMosaicLayoutOutputWithContext(context.Context) MosaicLayoutOutput
}

// A mosaic layout divides the available space into a grid of blocks, and overlays the grid with tiles. Unlike GridLayout, tiles may span multiple grid blocks and can be placed at arbitrary locations in the grid.
type MosaicLayoutArgs struct {
	// The number of columns in the mosaic grid. The number of columns must be between 1 and 12, inclusive.
	Columns pulumi.IntPtrInput `pulumi:"columns"`
	// The tiles to display.
	Tiles TileArrayInput `pulumi:"tiles"`
}

func (MosaicLayoutArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MosaicLayout)(nil)).Elem()
}

func (i MosaicLayoutArgs) ToMosaicLayoutOutput() MosaicLayoutOutput {
	return i.ToMosaicLayoutOutputWithContext(context.Background())
}

func (i MosaicLayoutArgs) ToMosaicLayoutOutputWithContext(ctx context.Context) MosaicLayoutOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MosaicLayoutOutput)
}

func (i MosaicLayoutArgs) ToMosaicLayoutPtrOutput() MosaicLayoutPtrOutput {
	return i.ToMosaicLayoutPtrOutputWithContext(context.Background())
}

func (i MosaicLayoutArgs) ToMosaicLayoutPtrOutputWithContext(ctx context.Context) MosaicLayoutPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MosaicLayoutOutput).ToMosaicLayoutPtrOutputWithContext(ctx)
}

// MosaicLayoutPtrInput is an input type that accepts MosaicLayoutArgs, MosaicLayoutPtr and MosaicLayoutPtrOutput values.
// You can construct a concrete instance of `MosaicLayoutPtrInput` via:
//
//	        MosaicLayoutArgs{...}
//
//	or:
//
//	        nil
type MosaicLayoutPtrInput interface {
	pulumi.Input

	ToMosaicLayoutPtrOutput() MosaicLayoutPtrOutput
	ToMosaicLayoutPtrOutputWithContext(context.Context) MosaicLayoutPtrOutput
}

type mosaicLayoutPtrType MosaicLayoutArgs

func MosaicLayoutPtr(v *MosaicLayoutArgs) MosaicLayoutPtrInput {
	return (*mosaicLayoutPtrType)(v)
}

func (*mosaicLayoutPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MosaicLayout)(nil)).Elem()
}

func (i *mosaicLayoutPtrType) ToMosaicLayoutPtrOutput() MosaicLayoutPtrOutput {
	return i.ToMosaicLayoutPtrOutputWithContext(context.Background())
}

func (i *mosaicLayoutPtrType) ToMosaicLayoutPtrOutputWithContext(ctx context.Context) MosaicLayoutPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MosaicLayoutPtrOutput)
}

// A mosaic layout divides the available space into a grid of blocks, and overlays the grid with tiles. Unlike GridLayout, tiles may span multiple grid blocks and can be placed at arbitrary locations in the grid.
type MosaicLayoutOutput struct{ *pulumi.OutputState }

func (MosaicLayoutOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MosaicLayout)(nil)).Elem()
}

func (o MosaicLayoutOutput) ToMosaicLayoutOutput() MosaicLayoutOutput {
	return o
}

func (o MosaicLayoutOutput) ToMosaicLayoutOutputWithContext(ctx context.Context) MosaicLayoutOutput {
	return o
}

func (o MosaicLayoutOutput) ToMosaicLayoutPtrOutput() MosaicLayoutPtrOutput {
	return o.ToMosaicLayoutPtrOutputWithContext(context.Background())
}

func (o MosaicLayoutOutput) ToMosaicLayoutPtrOutputWithContext(ctx context.Context) MosaicLayoutPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v MosaicLayout) *MosaicLayout {
		return &v
	}).(MosaicLayoutPtrOutput)
}

// The number of columns in the mosaic grid. The number of columns must be between 1 and 12, inclusive.
func (o MosaicLayoutOutput) Columns() pulumi.IntPtrOutput {
	return o.ApplyT(func(v MosaicLayout) *int { return v.Columns }).(pulumi.IntPtrOutput)
}

// The tiles to display.
func (o MosaicLayoutOutput) Tiles() TileArrayOutput {
	return o.ApplyT(func(v MosaicLayout) []Tile { return v.Tiles }).(TileArrayOutput)
}

type MosaicLayoutPtrOutput struct{ *pulumi.OutputState }

func (MosaicLayoutPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MosaicLayout)(nil)).Elem()
}

func (o MosaicLayoutPtrOutput) ToMosaicLayoutPtrOutput() MosaicLayoutPtrOutput {
	return o
}

func (o MosaicLayoutPtrOutput) ToMosaicLayoutPtrOutputWithContext(ctx context.Context) MosaicLayoutPtrOutput {
	return o
}

func (o MosaicLayoutPtrOutput) Elem() MosaicLayoutOutput {
	return o.ApplyT(func(v *MosaicLayout) MosaicLayout {
		if v != nil {
			return *v
		}
		var ret MosaicLayout
		return ret
	}).(MosaicLayoutOutput)
}

// The number of columns in the mosaic grid. The number of columns must be between 1 and 12, inclusive.
func (o MosaicLayoutPtrOutput) Columns() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *MosaicLayout) *int {
		if v == nil {
			return nil
		}
		return v.Columns
	}).(pulumi.IntPtrOutput)
}

// The tiles to display.
func (o MosaicLayoutPtrOutput) Tiles() TileArrayOutput {
	return o.ApplyT(func(v *MosaicLayout) []Tile {
		if v == nil {
			return nil
		}
		return v.Tiles
	}).(TileArrayOutput)
}

// A mosaic layout divides the available space into a grid of blocks, and overlays the grid with tiles. Unlike GridLayout, tiles may span multiple grid blocks and can be placed at arbitrary locations in the grid.
type MosaicLayoutResponse struct {
	// The number of columns in the mosaic grid. The number of columns must be between 1 and 12, inclusive.
	Columns int `pulumi:"columns"`
	// The tiles to display.
	Tiles []TileResponse `pulumi:"tiles"`
}

// A mosaic layout divides the available space into a grid of blocks, and overlays the grid with tiles. Unlike GridLayout, tiles may span multiple grid blocks and can be placed at arbitrary locations in the grid.
type MosaicLayoutResponseOutput struct{ *pulumi.OutputState }

func (MosaicLayoutResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MosaicLayoutResponse)(nil)).Elem()
}

func (o MosaicLayoutResponseOutput) ToMosaicLayoutResponseOutput() MosaicLayoutResponseOutput {
	return o
}

func (o MosaicLayoutResponseOutput) ToMosaicLayoutResponseOutputWithContext(ctx context.Context) MosaicLayoutResponseOutput {
	return o
}

// The number of columns in the mosaic grid. The number of columns must be between 1 and 12, inclusive.
func (o MosaicLayoutResponseOutput) Columns() pulumi.IntOutput {
	return o.ApplyT(func(v MosaicLayoutResponse) int { return v.Columns }).(pulumi.IntOutput)
}

// The tiles to display.
func (o MosaicLayoutResponseOutput) Tiles() TileResponseArrayOutput {
	return o.ApplyT(func(v MosaicLayoutResponse) []TileResponse { return v.Tiles }).(TileResponseArrayOutput)
}

// Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release.
type OpsAnalyticsQuery struct {
	// A SQL query to fetch time series, category series, or numeric series data.
	Sql *string `pulumi:"sql"`
}

// OpsAnalyticsQueryInput is an input type that accepts OpsAnalyticsQueryArgs and OpsAnalyticsQueryOutput values.
// You can construct a concrete instance of `OpsAnalyticsQueryInput` via:
//
//	OpsAnalyticsQueryArgs{...}
type OpsAnalyticsQueryInput interface {
	pulumi.Input

	ToOpsAnalyticsQueryOutput() OpsAnalyticsQueryOutput
	ToOpsAnalyticsQueryOutputWithContext(context.Context) OpsAnalyticsQueryOutput
}

// Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release.
type OpsAnalyticsQueryArgs struct {
	// A SQL query to fetch time series, category series, or numeric series data.
	Sql pulumi.StringPtrInput `pulumi:"sql"`
}

func (OpsAnalyticsQueryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*OpsAnalyticsQuery)(nil)).Elem()
}

func (i OpsAnalyticsQueryArgs) ToOpsAnalyticsQueryOutput() OpsAnalyticsQueryOutput {
	return i.ToOpsAnalyticsQueryOutputWithContext(context.Background())
}

func (i OpsAnalyticsQueryArgs) ToOpsAnalyticsQueryOutputWithContext(ctx context.Context) OpsAnalyticsQueryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OpsAnalyticsQueryOutput)
}

func (i OpsAnalyticsQueryArgs) ToOpsAnalyticsQueryPtrOutput() OpsAnalyticsQueryPtrOutput {
	return i.ToOpsAnalyticsQueryPtrOutputWithContext(context.Background())
}

func (i OpsAnalyticsQueryArgs) ToOpsAnalyticsQueryPtrOutputWithContext(ctx context.Context) OpsAnalyticsQueryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OpsAnalyticsQueryOutput).ToOpsAnalyticsQueryPtrOutputWithContext(ctx)
}

// OpsAnalyticsQueryPtrInput is an input type that accepts OpsAnalyticsQueryArgs, OpsAnalyticsQueryPtr and OpsAnalyticsQueryPtrOutput values.
// You can construct a concrete instance of `OpsAnalyticsQueryPtrInput` via:
//
//	        OpsAnalyticsQueryArgs{...}
//
//	or:
//
//	        nil
type OpsAnalyticsQueryPtrInput interface {
	pulumi.Input

	ToOpsAnalyticsQueryPtrOutput() OpsAnalyticsQueryPtrOutput
	ToOpsAnalyticsQueryPtrOutputWithContext(context.Context) OpsAnalyticsQueryPtrOutput
}

type opsAnalyticsQueryPtrType OpsAnalyticsQueryArgs

func OpsAnalyticsQueryPtr(v *OpsAnalyticsQueryArgs) OpsAnalyticsQueryPtrInput {
	return (*opsAnalyticsQueryPtrType)(v)
}

func (*opsAnalyticsQueryPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**OpsAnalyticsQuery)(nil)).Elem()
}

func (i *opsAnalyticsQueryPtrType) ToOpsAnalyticsQueryPtrOutput() OpsAnalyticsQueryPtrOutput {
	return i.ToOpsAnalyticsQueryPtrOutputWithContext(context.Background())
}

func (i *opsAnalyticsQueryPtrType) ToOpsAnalyticsQueryPtrOutputWithContext(ctx context.Context) OpsAnalyticsQueryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OpsAnalyticsQueryPtrOutput)
}

// Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release.
type OpsAnalyticsQueryOutput struct{ *pulumi.OutputState }

func (OpsAnalyticsQueryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OpsAnalyticsQuery)(nil)).Elem()
}

func (o OpsAnalyticsQueryOutput) ToOpsAnalyticsQueryOutput() OpsAnalyticsQueryOutput {
	return o
}

func (o OpsAnalyticsQueryOutput) ToOpsAnalyticsQueryOutputWithContext(ctx context.Context) OpsAnalyticsQueryOutput {
	return o
}

func (o OpsAnalyticsQueryOutput) ToOpsAnalyticsQueryPtrOutput() OpsAnalyticsQueryPtrOutput {
	return o.ToOpsAnalyticsQueryPtrOutputWithContext(context.Background())
}

func (o OpsAnalyticsQueryOutput) ToOpsAnalyticsQueryPtrOutputWithContext(ctx context.Context) OpsAnalyticsQueryPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v OpsAnalyticsQuery) *OpsAnalyticsQuery {
		return &v
	}).(OpsAnalyticsQueryPtrOutput)
}

// A SQL query to fetch time series, category series, or numeric series data.
func (o OpsAnalyticsQueryOutput) Sql() pulumi.StringPtrOutput {
	return o.ApplyT(func(v OpsAnalyticsQuery) *string { return v.Sql }).(pulumi.StringPtrOutput)
}

type OpsAnalyticsQueryPtrOutput struct{ *pulumi.OutputState }

func (OpsAnalyticsQueryPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**OpsAnalyticsQuery)(nil)).Elem()
}

func (o OpsAnalyticsQueryPtrOutput) ToOpsAnalyticsQueryPtrOutput() OpsAnalyticsQueryPtrOutput {
	return o
}

func (o OpsAnalyticsQueryPtrOutput) ToOpsAnalyticsQueryPtrOutputWithContext(ctx context.Context) OpsAnalyticsQueryPtrOutput {
	return o
}

func (o OpsAnalyticsQueryPtrOutput) Elem() OpsAnalyticsQueryOutput {
	return o.ApplyT(func(v *OpsAnalyticsQuery) OpsAnalyticsQuery {
		if v != nil {
			return *v
		}
		var ret OpsAnalyticsQuery
		return ret
	}).(OpsAnalyticsQueryOutput)
}

// A SQL query to fetch time series, category series, or numeric series data.
func (o OpsAnalyticsQueryPtrOutput) Sql() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *OpsAnalyticsQuery) *string {
		if v == nil {
			return nil
		}
		return v.Sql
	}).(pulumi.StringPtrOutput)
}

// Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release.
type OpsAnalyticsQueryResponse struct {
	// A SQL query to fetch time series, category series, or numeric series data.
	Sql string `pulumi:"sql"`
}

// Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release.
type OpsAnalyticsQueryResponseOutput struct{ *pulumi.OutputState }

func (OpsAnalyticsQueryResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*OpsAnalyticsQueryResponse)(nil)).Elem()
}

func (o OpsAnalyticsQueryResponseOutput) ToOpsAnalyticsQueryResponseOutput() OpsAnalyticsQueryResponseOutput {
	return o
}

func (o OpsAnalyticsQueryResponseOutput) ToOpsAnalyticsQueryResponseOutputWithContext(ctx context.Context) OpsAnalyticsQueryResponseOutput {
	return o
}

// A SQL query to fetch time series, category series, or numeric series data.
func (o OpsAnalyticsQueryResponseOutput) Sql() pulumi.StringOutput {
	return o.ApplyT(func(v OpsAnalyticsQueryResponse) string { return v.Sql }).(pulumi.StringOutput)
}

// Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
type Parameter struct {
	// A floating-point parameter value.
	DoubleValue *float64 `pulumi:"doubleValue"`
	// An integer parameter value.
	IntValue *string `pulumi:"intValue"`
}

// ParameterInput is an input type that accepts ParameterArgs and ParameterOutput values.
// You can construct a concrete instance of `ParameterInput` via:
//
//	ParameterArgs{...}
type ParameterInput interface {
	pulumi.Input

	ToParameterOutput() ParameterOutput
	ToParameterOutputWithContext(context.Context) ParameterOutput
}

// Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
type ParameterArgs struct {
	// A floating-point parameter value.
	DoubleValue pulumi.Float64PtrInput `pulumi:"doubleValue"`
	// An integer parameter value.
	IntValue pulumi.StringPtrInput `pulumi:"intValue"`
}

func (ParameterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Parameter)(nil)).Elem()
}

func (i ParameterArgs) ToParameterOutput() ParameterOutput {
	return i.ToParameterOutputWithContext(context.Background())
}

func (i ParameterArgs) ToParameterOutputWithContext(ctx context.Context) ParameterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ParameterOutput)
}

// ParameterArrayInput is an input type that accepts ParameterArray and ParameterArrayOutput values.
// You can construct a concrete instance of `ParameterArrayInput` via:
//
//	ParameterArray{ ParameterArgs{...} }
type ParameterArrayInput interface {
	pulumi.Input

	ToParameterArrayOutput() ParameterArrayOutput
	ToParameterArrayOutputWithContext(context.Context) ParameterArrayOutput
}

type ParameterArray []ParameterInput

func (ParameterArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Parameter)(nil)).Elem()
}

func (i ParameterArray) ToParameterArrayOutput() ParameterArrayOutput {
	return i.ToParameterArrayOutputWithContext(context.Background())
}

func (i ParameterArray) ToParameterArrayOutputWithContext(ctx context.Context) ParameterArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ParameterArrayOutput)
}

// Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
type ParameterOutput struct{ *pulumi.OutputState }

func (ParameterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Parameter)(nil)).Elem()
}

func (o ParameterOutput) ToParameterOutput() ParameterOutput {
	return o
}

func (o ParameterOutput) ToParameterOutputWithContext(ctx context.Context) ParameterOutput {
	return o
}

// A floating-point parameter value.
func (o ParameterOutput) DoubleValue() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Parameter) *float64 { return v.DoubleValue }).(pulumi.Float64PtrOutput)
}

// An integer parameter value.
func (o ParameterOutput) IntValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Parameter) *string { return v.IntValue }).(pulumi.StringPtrOutput)
}

type ParameterArrayOutput struct{ *pulumi.OutputState }

func (ParameterArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Parameter)(nil)).Elem()
}

func (o ParameterArrayOutput) ToParameterArrayOutput() ParameterArrayOutput {
	return o
}

func (o ParameterArrayOutput) ToParameterArrayOutputWithContext(ctx context.Context) ParameterArrayOutput {
	return o
}

func (o ParameterArrayOutput) Index(i pulumi.IntInput) ParameterOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Parameter {
		return vs[0].([]Parameter)[vs[1].(int)]
	}).(ParameterOutput)
}

// Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
type ParameterResponse struct {
	// A floating-point parameter value.
	DoubleValue float64 `pulumi:"doubleValue"`
	// An integer parameter value.
	IntValue string `pulumi:"intValue"`
}

// Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
type ParameterResponseOutput struct{ *pulumi.OutputState }

func (ParameterResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ParameterResponse)(nil)).Elem()
}

func (o ParameterResponseOutput) ToParameterResponseOutput() ParameterResponseOutput {
	return o
}

func (o ParameterResponseOutput) ToParameterResponseOutputWithContext(ctx context.Context) ParameterResponseOutput {
	return o
}

// A floating-point parameter value.
func (o ParameterResponseOutput) DoubleValue() pulumi.Float64Output {
	return o.ApplyT(func(v ParameterResponse) float64 { return v.DoubleValue }).(pulumi.Float64Output)
}

// An integer parameter value.
func (o ParameterResponseOutput) IntValue() pulumi.StringOutput {
	return o.ApplyT(func(v ParameterResponse) string { return v.IntValue }).(pulumi.StringOutput)
}

type ParameterResponseArrayOutput struct{ *pulumi.OutputState }

func (ParameterResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ParameterResponse)(nil)).Elem()
}

func (o ParameterResponseArrayOutput) ToParameterResponseArrayOutput() ParameterResponseArrayOutput {
	return o
}

func (o ParameterResponseArrayOutput) ToParameterResponseArrayOutputWithContext(ctx context.Context) ParameterResponseArrayOutput {
	return o
}

func (o ParameterResponseArrayOutput) Index(i pulumi.IntInput) ParameterResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ParameterResponse {
		return vs[0].([]ParameterResponse)[vs[1].(int)]
	}).(ParameterResponseOutput)
}

// Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter.
type PickTimeSeriesFilter struct {
	// How to use the ranking to select time series that pass through the filter.
	Direction *PickTimeSeriesFilterDirection `pulumi:"direction"`
	// Select the top N streams/time series within this time interval
	Interval *Interval `pulumi:"interval"`
	// How many time series to allow to pass through the filter.
	NumTimeSeries *int `pulumi:"numTimeSeries"`
	// ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
	RankingMethod *PickTimeSeriesFilterRankingMethod `pulumi:"rankingMethod"`
}

// PickTimeSeriesFilterInput is an input type that accepts PickTimeSeriesFilterArgs and PickTimeSeriesFilterOutput values.
// You can construct a concrete instance of `PickTimeSeriesFilterInput` via:
//
//	PickTimeSeriesFilterArgs{...}
type PickTimeSeriesFilterInput interface {
	pulumi.Input

	ToPickTimeSeriesFilterOutput() PickTimeSeriesFilterOutput
	ToPickTimeSeriesFilterOutputWithContext(context.Context) PickTimeSeriesFilterOutput
}

// Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter.
type PickTimeSeriesFilterArgs struct {
	// How to use the ranking to select time series that pass through the filter.
	Direction PickTimeSeriesFilterDirectionPtrInput `pulumi:"direction"`
	// Select the top N streams/time series within this time interval
	Interval IntervalPtrInput `pulumi:"interval"`
	// How many time series to allow to pass through the filter.
	NumTimeSeries pulumi.IntPtrInput `pulumi:"numTimeSeries"`
	// ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
	RankingMethod PickTimeSeriesFilterRankingMethodPtrInput `pulumi:"rankingMethod"`
}

func (PickTimeSeriesFilterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PickTimeSeriesFilter)(nil)).Elem()
}

func (i PickTimeSeriesFilterArgs) ToPickTimeSeriesFilterOutput() PickTimeSeriesFilterOutput {
	return i.ToPickTimeSeriesFilterOutputWithContext(context.Background())
}

func (i PickTimeSeriesFilterArgs) ToPickTimeSeriesFilterOutputWithContext(ctx context.Context) PickTimeSeriesFilterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PickTimeSeriesFilterOutput)
}

func (i PickTimeSeriesFilterArgs) ToPickTimeSeriesFilterPtrOutput() PickTimeSeriesFilterPtrOutput {
	return i.ToPickTimeSeriesFilterPtrOutputWithContext(context.Background())
}

func (i PickTimeSeriesFilterArgs) ToPickTimeSeriesFilterPtrOutputWithContext(ctx context.Context) PickTimeSeriesFilterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PickTimeSeriesFilterOutput).ToPickTimeSeriesFilterPtrOutputWithContext(ctx)
}

// PickTimeSeriesFilterPtrInput is an input type that accepts PickTimeSeriesFilterArgs, PickTimeSeriesFilterPtr and PickTimeSeriesFilterPtrOutput values.
// You can construct a concrete instance of `PickTimeSeriesFilterPtrInput` via:
//
//	        PickTimeSeriesFilterArgs{...}
//
//	or:
//
//	        nil
type PickTimeSeriesFilterPtrInput interface {
	pulumi.Input

	ToPickTimeSeriesFilterPtrOutput() PickTimeSeriesFilterPtrOutput
	ToPickTimeSeriesFilterPtrOutputWithContext(context.Context) PickTimeSeriesFilterPtrOutput
}

type pickTimeSeriesFilterPtrType PickTimeSeriesFilterArgs

func PickTimeSeriesFilterPtr(v *PickTimeSeriesFilterArgs) PickTimeSeriesFilterPtrInput {
	return (*pickTimeSeriesFilterPtrType)(v)
}

func (*pickTimeSeriesFilterPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PickTimeSeriesFilter)(nil)).Elem()
}

func (i *pickTimeSeriesFilterPtrType) ToPickTimeSeriesFilterPtrOutput() PickTimeSeriesFilterPtrOutput {
	return i.ToPickTimeSeriesFilterPtrOutputWithContext(context.Background())
}

func (i *pickTimeSeriesFilterPtrType) ToPickTimeSeriesFilterPtrOutputWithContext(ctx context.Context) PickTimeSeriesFilterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PickTimeSeriesFilterPtrOutput)
}

// Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter.
type PickTimeSeriesFilterOutput struct{ *pulumi.OutputState }

func (PickTimeSeriesFilterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PickTimeSeriesFilter)(nil)).Elem()
}

func (o PickTimeSeriesFilterOutput) ToPickTimeSeriesFilterOutput() PickTimeSeriesFilterOutput {
	return o
}

func (o PickTimeSeriesFilterOutput) ToPickTimeSeriesFilterOutputWithContext(ctx context.Context) PickTimeSeriesFilterOutput {
	return o
}

func (o PickTimeSeriesFilterOutput) ToPickTimeSeriesFilterPtrOutput() PickTimeSeriesFilterPtrOutput {
	return o.ToPickTimeSeriesFilterPtrOutputWithContext(context.Background())
}

func (o PickTimeSeriesFilterOutput) ToPickTimeSeriesFilterPtrOutputWithContext(ctx context.Context) PickTimeSeriesFilterPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PickTimeSeriesFilter) *PickTimeSeriesFilter {
		return &v
	}).(PickTimeSeriesFilterPtrOutput)
}

// How to use the ranking to select time series that pass through the filter.
func (o PickTimeSeriesFilterOutput) Direction() PickTimeSeriesFilterDirectionPtrOutput {
	return o.ApplyT(func(v PickTimeSeriesFilter) *PickTimeSeriesFilterDirection { return v.Direction }).(PickTimeSeriesFilterDirectionPtrOutput)
}

// Select the top N streams/time series within this time interval
func (o PickTimeSeriesFilterOutput) Interval() IntervalPtrOutput {
	return o.ApplyT(func(v PickTimeSeriesFilter) *Interval { return v.Interval }).(IntervalPtrOutput)
}

// How many time series to allow to pass through the filter.
func (o PickTimeSeriesFilterOutput) NumTimeSeries() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PickTimeSeriesFilter) *int { return v.NumTimeSeries }).(pulumi.IntPtrOutput)
}

// ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
func (o PickTimeSeriesFilterOutput) RankingMethod() PickTimeSeriesFilterRankingMethodPtrOutput {
	return o.ApplyT(func(v PickTimeSeriesFilter) *PickTimeSeriesFilterRankingMethod { return v.RankingMethod }).(PickTimeSeriesFilterRankingMethodPtrOutput)
}

type PickTimeSeriesFilterPtrOutput struct{ *pulumi.OutputState }

func (PickTimeSeriesFilterPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PickTimeSeriesFilter)(nil)).Elem()
}

func (o PickTimeSeriesFilterPtrOutput) ToPickTimeSeriesFilterPtrOutput() PickTimeSeriesFilterPtrOutput {
	return o
}

func (o PickTimeSeriesFilterPtrOutput) ToPickTimeSeriesFilterPtrOutputWithContext(ctx context.Context) PickTimeSeriesFilterPtrOutput {
	return o
}

func (o PickTimeSeriesFilterPtrOutput) Elem() PickTimeSeriesFilterOutput {
	return o.ApplyT(func(v *PickTimeSeriesFilter) PickTimeSeriesFilter {
		if v != nil {
			return *v
		}
		var ret PickTimeSeriesFilter
		return ret
	}).(PickTimeSeriesFilterOutput)
}

// How to use the ranking to select time series that pass through the filter.
func (o PickTimeSeriesFilterPtrOutput) Direction() PickTimeSeriesFilterDirectionPtrOutput {
	return o.ApplyT(func(v *PickTimeSeriesFilter) *PickTimeSeriesFilterDirection {
		if v == nil {
			return nil
		}
		return v.Direction
	}).(PickTimeSeriesFilterDirectionPtrOutput)
}

// Select the top N streams/time series within this time interval
func (o PickTimeSeriesFilterPtrOutput) Interval() IntervalPtrOutput {
	return o.ApplyT(func(v *PickTimeSeriesFilter) *Interval {
		if v == nil {
			return nil
		}
		return v.Interval
	}).(IntervalPtrOutput)
}

// How many time series to allow to pass through the filter.
func (o PickTimeSeriesFilterPtrOutput) NumTimeSeries() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PickTimeSeriesFilter) *int {
		if v == nil {
			return nil
		}
		return v.NumTimeSeries
	}).(pulumi.IntPtrOutput)
}

// ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
func (o PickTimeSeriesFilterPtrOutput) RankingMethod() PickTimeSeriesFilterRankingMethodPtrOutput {
	return o.ApplyT(func(v *PickTimeSeriesFilter) *PickTimeSeriesFilterRankingMethod {
		if v == nil {
			return nil
		}
		return v.RankingMethod
	}).(PickTimeSeriesFilterRankingMethodPtrOutput)
}

// Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter.
type PickTimeSeriesFilterResponse struct {
	// How to use the ranking to select time series that pass through the filter.
	Direction string `pulumi:"direction"`
	// Select the top N streams/time series within this time interval
	Interval IntervalResponse `pulumi:"interval"`
	// How many time series to allow to pass through the filter.
	NumTimeSeries int `pulumi:"numTimeSeries"`
	// ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
	RankingMethod string `pulumi:"rankingMethod"`
}

// Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter.
type PickTimeSeriesFilterResponseOutput struct{ *pulumi.OutputState }

func (PickTimeSeriesFilterResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PickTimeSeriesFilterResponse)(nil)).Elem()
}

func (o PickTimeSeriesFilterResponseOutput) ToPickTimeSeriesFilterResponseOutput() PickTimeSeriesFilterResponseOutput {
	return o
}

func (o PickTimeSeriesFilterResponseOutput) ToPickTimeSeriesFilterResponseOutputWithContext(ctx context.Context) PickTimeSeriesFilterResponseOutput {
	return o
}

// How to use the ranking to select time series that pass through the filter.
func (o PickTimeSeriesFilterResponseOutput) Direction() pulumi.StringOutput {
	return o.ApplyT(func(v PickTimeSeriesFilterResponse) string { return v.Direction }).(pulumi.StringOutput)
}

// Select the top N streams/time series within this time interval
func (o PickTimeSeriesFilterResponseOutput) Interval() IntervalResponseOutput {
	return o.ApplyT(func(v PickTimeSeriesFilterResponse) IntervalResponse { return v.Interval }).(IntervalResponseOutput)
}

// How many time series to allow to pass through the filter.
func (o PickTimeSeriesFilterResponseOutput) NumTimeSeries() pulumi.IntOutput {
	return o.ApplyT(func(v PickTimeSeriesFilterResponse) int { return v.NumTimeSeries }).(pulumi.IntOutput)
}

// ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
func (o PickTimeSeriesFilterResponseOutput) RankingMethod() pulumi.StringOutput {
	return o.ApplyT(func(v PickTimeSeriesFilterResponse) string { return v.RankingMethod }).(pulumi.StringOutput)
}

// A widget that displays timeseries data as a pie or a donut.
type PieChart struct {
	// Indicates the visualization type for the PieChart.
	ChartType PieChartChartType `pulumi:"chartType"`
	// The queries for the chart's data.
	DataSets []PieChartDataSet `pulumi:"dataSets"`
	// Optional. Indicates whether or not the pie chart should show slices' labels
	ShowLabels *bool `pulumi:"showLabels"`
}

// PieChartInput is an input type that accepts PieChartArgs and PieChartOutput values.
// You can construct a concrete instance of `PieChartInput` via:
//
//	PieChartArgs{...}
type PieChartInput interface {
	pulumi.Input

	ToPieChartOutput() PieChartOutput
	ToPieChartOutputWithContext(context.Context) PieChartOutput
}

// A widget that displays timeseries data as a pie or a donut.
type PieChartArgs struct {
	// Indicates the visualization type for the PieChart.
	ChartType PieChartChartTypeInput `pulumi:"chartType"`
	// The queries for the chart's data.
	DataSets PieChartDataSetArrayInput `pulumi:"dataSets"`
	// Optional. Indicates whether or not the pie chart should show slices' labels
	ShowLabels pulumi.BoolPtrInput `pulumi:"showLabels"`
}

func (PieChartArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PieChart)(nil)).Elem()
}

func (i PieChartArgs) ToPieChartOutput() PieChartOutput {
	return i.ToPieChartOutputWithContext(context.Background())
}

func (i PieChartArgs) ToPieChartOutputWithContext(ctx context.Context) PieChartOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PieChartOutput)
}

func (i PieChartArgs) ToPieChartPtrOutput() PieChartPtrOutput {
	return i.ToPieChartPtrOutputWithContext(context.Background())
}

func (i PieChartArgs) ToPieChartPtrOutputWithContext(ctx context.Context) PieChartPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PieChartOutput).ToPieChartPtrOutputWithContext(ctx)
}

// PieChartPtrInput is an input type that accepts PieChartArgs, PieChartPtr and PieChartPtrOutput values.
// You can construct a concrete instance of `PieChartPtrInput` via:
//
//	        PieChartArgs{...}
//
//	or:
//
//	        nil
type PieChartPtrInput interface {
	pulumi.Input

	ToPieChartPtrOutput() PieChartPtrOutput
	ToPieChartPtrOutputWithContext(context.Context) PieChartPtrOutput
}

type pieChartPtrType PieChartArgs

func PieChartPtr(v *PieChartArgs) PieChartPtrInput {
	return (*pieChartPtrType)(v)
}

func (*pieChartPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PieChart)(nil)).Elem()
}

func (i *pieChartPtrType) ToPieChartPtrOutput() PieChartPtrOutput {
	return i.ToPieChartPtrOutputWithContext(context.Background())
}

func (i *pieChartPtrType) ToPieChartPtrOutputWithContext(ctx context.Context) PieChartPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PieChartPtrOutput)
}

// A widget that displays timeseries data as a pie or a donut.
type PieChartOutput struct{ *pulumi.OutputState }

func (PieChartOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PieChart)(nil)).Elem()
}

func (o PieChartOutput) ToPieChartOutput() PieChartOutput {
	return o
}

func (o PieChartOutput) ToPieChartOutputWithContext(ctx context.Context) PieChartOutput {
	return o
}

func (o PieChartOutput) ToPieChartPtrOutput() PieChartPtrOutput {
	return o.ToPieChartPtrOutputWithContext(context.Background())
}

func (o PieChartOutput) ToPieChartPtrOutputWithContext(ctx context.Context) PieChartPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PieChart) *PieChart {
		return &v
	}).(PieChartPtrOutput)
}

// Indicates the visualization type for the PieChart.
func (o PieChartOutput) ChartType() PieChartChartTypeOutput {
	return o.ApplyT(func(v PieChart) PieChartChartType { return v.ChartType }).(PieChartChartTypeOutput)
}

// The queries for the chart's data.
func (o PieChartOutput) DataSets() PieChartDataSetArrayOutput {
	return o.ApplyT(func(v PieChart) []PieChartDataSet { return v.DataSets }).(PieChartDataSetArrayOutput)
}

// Optional. Indicates whether or not the pie chart should show slices' labels
func (o PieChartOutput) ShowLabels() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v PieChart) *bool { return v.ShowLabels }).(pulumi.BoolPtrOutput)
}

type PieChartPtrOutput struct{ *pulumi.OutputState }

func (PieChartPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PieChart)(nil)).Elem()
}

func (o PieChartPtrOutput) ToPieChartPtrOutput() PieChartPtrOutput {
	return o
}

func (o PieChartPtrOutput) ToPieChartPtrOutputWithContext(ctx context.Context) PieChartPtrOutput {
	return o
}

func (o PieChartPtrOutput) Elem() PieChartOutput {
	return o.ApplyT(func(v *PieChart) PieChart {
		if v != nil {
			return *v
		}
		var ret PieChart
		return ret
	}).(PieChartOutput)
}

// Indicates the visualization type for the PieChart.
func (o PieChartPtrOutput) ChartType() PieChartChartTypePtrOutput {
	return o.ApplyT(func(v *PieChart) *PieChartChartType {
		if v == nil {
			return nil
		}
		return &v.ChartType
	}).(PieChartChartTypePtrOutput)
}

// The queries for the chart's data.
func (o PieChartPtrOutput) DataSets() PieChartDataSetArrayOutput {
	return o.ApplyT(func(v *PieChart) []PieChartDataSet {
		if v == nil {
			return nil
		}
		return v.DataSets
	}).(PieChartDataSetArrayOutput)
}

// Optional. Indicates whether or not the pie chart should show slices' labels
func (o PieChartPtrOutput) ShowLabels() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *PieChart) *bool {
		if v == nil {
			return nil
		}
		return v.ShowLabels
	}).(pulumi.BoolPtrOutput)
}

// Groups a time series query definition.
type PieChartDataSet struct {
	// A dimension is a structured label, class, or category for a set of measurements in your data.
	Dimensions []Dimension `pulumi:"dimensions"`
	// A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
	Measures []Measure `pulumi:"measures"`
	// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
	MinAlignmentPeriod *string `pulumi:"minAlignmentPeriod"`
	// Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone's value will be used for the name instead of the default name.
	SliceNameTemplate *string `pulumi:"sliceNameTemplate"`
	// The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
	TimeSeriesQuery TimeSeriesQuery `pulumi:"timeSeriesQuery"`
}

// PieChartDataSetInput is an input type that accepts PieChartDataSetArgs and PieChartDataSetOutput values.
// You can construct a concrete instance of `PieChartDataSetInput` via:
//
//	PieChartDataSetArgs{...}
type PieChartDataSetInput interface {
	pulumi.Input

	ToPieChartDataSetOutput() PieChartDataSetOutput
	ToPieChartDataSetOutputWithContext(context.Context) PieChartDataSetOutput
}

// Groups a time series query definition.
type PieChartDataSetArgs struct {
	// A dimension is a structured label, class, or category for a set of measurements in your data.
	Dimensions DimensionArrayInput `pulumi:"dimensions"`
	// A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
	Measures MeasureArrayInput `pulumi:"measures"`
	// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
	MinAlignmentPeriod pulumi.StringPtrInput `pulumi:"minAlignmentPeriod"`
	// Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone's value will be used for the name instead of the default name.
	SliceNameTemplate pulumi.StringPtrInput `pulumi:"sliceNameTemplate"`
	// The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
	TimeSeriesQuery TimeSeriesQueryInput `pulumi:"timeSeriesQuery"`
}

func (PieChartDataSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PieChartDataSet)(nil)).Elem()
}

func (i PieChartDataSetArgs) ToPieChartDataSetOutput() PieChartDataSetOutput {
	return i.ToPieChartDataSetOutputWithContext(context.Background())
}

func (i PieChartDataSetArgs) ToPieChartDataSetOutputWithContext(ctx context.Context) PieChartDataSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PieChartDataSetOutput)
}

// PieChartDataSetArrayInput is an input type that accepts PieChartDataSetArray and PieChartDataSetArrayOutput values.
// You can construct a concrete instance of `PieChartDataSetArrayInput` via:
//
//	PieChartDataSetArray{ PieChartDataSetArgs{...} }
type PieChartDataSetArrayInput interface {
	pulumi.Input

	ToPieChartDataSetArrayOutput() PieChartDataSetArrayOutput
	ToPieChartDataSetArrayOutputWithContext(context.Context) PieChartDataSetArrayOutput
}

type PieChartDataSetArray []PieChartDataSetInput

func (PieChartDataSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PieChartDataSet)(nil)).Elem()
}

func (i PieChartDataSetArray) ToPieChartDataSetArrayOutput() PieChartDataSetArrayOutput {
	return i.ToPieChartDataSetArrayOutputWithContext(context.Background())
}

func (i PieChartDataSetArray) ToPieChartDataSetArrayOutputWithContext(ctx context.Context) PieChartDataSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PieChartDataSetArrayOutput)
}

// Groups a time series query definition.
type PieChartDataSetOutput struct{ *pulumi.OutputState }

func (PieChartDataSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PieChartDataSet)(nil)).Elem()
}

func (o PieChartDataSetOutput) ToPieChartDataSetOutput() PieChartDataSetOutput {
	return o
}

func (o PieChartDataSetOutput) ToPieChartDataSetOutputWithContext(ctx context.Context) PieChartDataSetOutput {
	return o
}

// A dimension is a structured label, class, or category for a set of measurements in your data.
func (o PieChartDataSetOutput) Dimensions() DimensionArrayOutput {
	return o.ApplyT(func(v PieChartDataSet) []Dimension { return v.Dimensions }).(DimensionArrayOutput)
}

// A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
func (o PieChartDataSetOutput) Measures() MeasureArrayOutput {
	return o.ApplyT(func(v PieChartDataSet) []Measure { return v.Measures }).(MeasureArrayOutput)
}

// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
func (o PieChartDataSetOutput) MinAlignmentPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PieChartDataSet) *string { return v.MinAlignmentPeriod }).(pulumi.StringPtrOutput)
}

// Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone's value will be used for the name instead of the default name.
func (o PieChartDataSetOutput) SliceNameTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PieChartDataSet) *string { return v.SliceNameTemplate }).(pulumi.StringPtrOutput)
}

// The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
func (o PieChartDataSetOutput) TimeSeriesQuery() TimeSeriesQueryOutput {
	return o.ApplyT(func(v PieChartDataSet) TimeSeriesQuery { return v.TimeSeriesQuery }).(TimeSeriesQueryOutput)
}

type PieChartDataSetArrayOutput struct{ *pulumi.OutputState }

func (PieChartDataSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PieChartDataSet)(nil)).Elem()
}

func (o PieChartDataSetArrayOutput) ToPieChartDataSetArrayOutput() PieChartDataSetArrayOutput {
	return o
}

func (o PieChartDataSetArrayOutput) ToPieChartDataSetArrayOutputWithContext(ctx context.Context) PieChartDataSetArrayOutput {
	return o
}

func (o PieChartDataSetArrayOutput) Index(i pulumi.IntInput) PieChartDataSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PieChartDataSet {
		return vs[0].([]PieChartDataSet)[vs[1].(int)]
	}).(PieChartDataSetOutput)
}

// Groups a time series query definition.
type PieChartDataSetResponse struct {
	// A dimension is a structured label, class, or category for a set of measurements in your data.
	Dimensions []DimensionResponse `pulumi:"dimensions"`
	// A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
	Measures []MeasureResponse `pulumi:"measures"`
	// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
	MinAlignmentPeriod string `pulumi:"minAlignmentPeriod"`
	// Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone's value will be used for the name instead of the default name.
	SliceNameTemplate string `pulumi:"sliceNameTemplate"`
	// The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
	TimeSeriesQuery TimeSeriesQueryResponse `pulumi:"timeSeriesQuery"`
}

// Groups a time series query definition.
type PieChartDataSetResponseOutput struct{ *pulumi.OutputState }

func (PieChartDataSetResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PieChartDataSetResponse)(nil)).Elem()
}

func (o PieChartDataSetResponseOutput) ToPieChartDataSetResponseOutput() PieChartDataSetResponseOutput {
	return o
}

func (o PieChartDataSetResponseOutput) ToPieChartDataSetResponseOutputWithContext(ctx context.Context) PieChartDataSetResponseOutput {
	return o
}

// A dimension is a structured label, class, or category for a set of measurements in your data.
func (o PieChartDataSetResponseOutput) Dimensions() DimensionResponseArrayOutput {
	return o.ApplyT(func(v PieChartDataSetResponse) []DimensionResponse { return v.Dimensions }).(DimensionResponseArrayOutput)
}

// A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
func (o PieChartDataSetResponseOutput) Measures() MeasureResponseArrayOutput {
	return o.ApplyT(func(v PieChartDataSetResponse) []MeasureResponse { return v.Measures }).(MeasureResponseArrayOutput)
}

// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
func (o PieChartDataSetResponseOutput) MinAlignmentPeriod() pulumi.StringOutput {
	return o.ApplyT(func(v PieChartDataSetResponse) string { return v.MinAlignmentPeriod }).(pulumi.StringOutput)
}

// Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone's value will be used for the name instead of the default name.
func (o PieChartDataSetResponseOutput) SliceNameTemplate() pulumi.StringOutput {
	return o.ApplyT(func(v PieChartDataSetResponse) string { return v.SliceNameTemplate }).(pulumi.StringOutput)
}

// The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
func (o PieChartDataSetResponseOutput) TimeSeriesQuery() TimeSeriesQueryResponseOutput {
	return o.ApplyT(func(v PieChartDataSetResponse) TimeSeriesQueryResponse { return v.TimeSeriesQuery }).(TimeSeriesQueryResponseOutput)
}

type PieChartDataSetResponseArrayOutput struct{ *pulumi.OutputState }

func (PieChartDataSetResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PieChartDataSetResponse)(nil)).Elem()
}

func (o PieChartDataSetResponseArrayOutput) ToPieChartDataSetResponseArrayOutput() PieChartDataSetResponseArrayOutput {
	return o
}

func (o PieChartDataSetResponseArrayOutput) ToPieChartDataSetResponseArrayOutputWithContext(ctx context.Context) PieChartDataSetResponseArrayOutput {
	return o
}

func (o PieChartDataSetResponseArrayOutput) Index(i pulumi.IntInput) PieChartDataSetResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PieChartDataSetResponse {
		return vs[0].([]PieChartDataSetResponse)[vs[1].(int)]
	}).(PieChartDataSetResponseOutput)
}

// A widget that displays timeseries data as a pie or a donut.
type PieChartResponse struct {
	// Indicates the visualization type for the PieChart.
	ChartType string `pulumi:"chartType"`
	// The queries for the chart's data.
	DataSets []PieChartDataSetResponse `pulumi:"dataSets"`
	// Optional. Indicates whether or not the pie chart should show slices' labels
	ShowLabels bool `pulumi:"showLabels"`
}

// A widget that displays timeseries data as a pie or a donut.
type PieChartResponseOutput struct{ *pulumi.OutputState }

func (PieChartResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PieChartResponse)(nil)).Elem()
}

func (o PieChartResponseOutput) ToPieChartResponseOutput() PieChartResponseOutput {
	return o
}

func (o PieChartResponseOutput) ToPieChartResponseOutputWithContext(ctx context.Context) PieChartResponseOutput {
	return o
}

// Indicates the visualization type for the PieChart.
func (o PieChartResponseOutput) ChartType() pulumi.StringOutput {
	return o.ApplyT(func(v PieChartResponse) string { return v.ChartType }).(pulumi.StringOutput)
}

// The queries for the chart's data.
func (o PieChartResponseOutput) DataSets() PieChartDataSetResponseArrayOutput {
	return o.ApplyT(func(v PieChartResponse) []PieChartDataSetResponse { return v.DataSets }).(PieChartDataSetResponseArrayOutput)
}

// Optional. Indicates whether or not the pie chart should show slices' labels
func (o PieChartResponseOutput) ShowLabels() pulumi.BoolOutput {
	return o.ApplyT(func(v PieChartResponse) bool { return v.ShowLabels }).(pulumi.BoolOutput)
}

// Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio.
type RatioPart struct {
	// By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
	Aggregation *Aggregation `pulumi:"aggregation"`
	// The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
	Filter string `pulumi:"filter"`
}

// RatioPartInput is an input type that accepts RatioPartArgs and RatioPartOutput values.
// You can construct a concrete instance of `RatioPartInput` via:
//
//	RatioPartArgs{...}
type RatioPartInput interface {
	pulumi.Input

	ToRatioPartOutput() RatioPartOutput
	ToRatioPartOutputWithContext(context.Context) RatioPartOutput
}

// Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio.
type RatioPartArgs struct {
	// By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
	Aggregation AggregationPtrInput `pulumi:"aggregation"`
	// The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
	Filter pulumi.StringInput `pulumi:"filter"`
}

func (RatioPartArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RatioPart)(nil)).Elem()
}

func (i RatioPartArgs) ToRatioPartOutput() RatioPartOutput {
	return i.ToRatioPartOutputWithContext(context.Background())
}

func (i RatioPartArgs) ToRatioPartOutputWithContext(ctx context.Context) RatioPartOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RatioPartOutput)
}

func (i RatioPartArgs) ToRatioPartPtrOutput() RatioPartPtrOutput {
	return i.ToRatioPartPtrOutputWithContext(context.Background())
}

func (i RatioPartArgs) ToRatioPartPtrOutputWithContext(ctx context.Context) RatioPartPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RatioPartOutput).ToRatioPartPtrOutputWithContext(ctx)
}

// RatioPartPtrInput is an input type that accepts RatioPartArgs, RatioPartPtr and RatioPartPtrOutput values.
// You can construct a concrete instance of `RatioPartPtrInput` via:
//
//	        RatioPartArgs{...}
//
//	or:
//
//	        nil
type RatioPartPtrInput interface {
	pulumi.Input

	ToRatioPartPtrOutput() RatioPartPtrOutput
	ToRatioPartPtrOutputWithContext(context.Context) RatioPartPtrOutput
}

type ratioPartPtrType RatioPartArgs

func RatioPartPtr(v *RatioPartArgs) RatioPartPtrInput {
	return (*ratioPartPtrType)(v)
}

func (*ratioPartPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RatioPart)(nil)).Elem()
}

func (i *ratioPartPtrType) ToRatioPartPtrOutput() RatioPartPtrOutput {
	return i.ToRatioPartPtrOutputWithContext(context.Background())
}

func (i *ratioPartPtrType) ToRatioPartPtrOutputWithContext(ctx context.Context) RatioPartPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RatioPartPtrOutput)
}

// Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio.
type RatioPartOutput struct{ *pulumi.OutputState }

func (RatioPartOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RatioPart)(nil)).Elem()
}

func (o RatioPartOutput) ToRatioPartOutput() RatioPartOutput {
	return o
}

func (o RatioPartOutput) ToRatioPartOutputWithContext(ctx context.Context) RatioPartOutput {
	return o
}

func (o RatioPartOutput) ToRatioPartPtrOutput() RatioPartPtrOutput {
	return o.ToRatioPartPtrOutputWithContext(context.Background())
}

func (o RatioPartOutput) ToRatioPartPtrOutputWithContext(ctx context.Context) RatioPartPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RatioPart) *RatioPart {
		return &v
	}).(RatioPartPtrOutput)
}

// By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
func (o RatioPartOutput) Aggregation() AggregationPtrOutput {
	return o.ApplyT(func(v RatioPart) *Aggregation { return v.Aggregation }).(AggregationPtrOutput)
}

// The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
func (o RatioPartOutput) Filter() pulumi.StringOutput {
	return o.ApplyT(func(v RatioPart) string { return v.Filter }).(pulumi.StringOutput)
}

type RatioPartPtrOutput struct{ *pulumi.OutputState }

func (RatioPartPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RatioPart)(nil)).Elem()
}

func (o RatioPartPtrOutput) ToRatioPartPtrOutput() RatioPartPtrOutput {
	return o
}

func (o RatioPartPtrOutput) ToRatioPartPtrOutputWithContext(ctx context.Context) RatioPartPtrOutput {
	return o
}

func (o RatioPartPtrOutput) Elem() RatioPartOutput {
	return o.ApplyT(func(v *RatioPart) RatioPart {
		if v != nil {
			return *v
		}
		var ret RatioPart
		return ret
	}).(RatioPartOutput)
}

// By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
func (o RatioPartPtrOutput) Aggregation() AggregationPtrOutput {
	return o.ApplyT(func(v *RatioPart) *Aggregation {
		if v == nil {
			return nil
		}
		return v.Aggregation
	}).(AggregationPtrOutput)
}

// The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
func (o RatioPartPtrOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RatioPart) *string {
		if v == nil {
			return nil
		}
		return &v.Filter
	}).(pulumi.StringPtrOutput)
}

// Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio.
type RatioPartResponse struct {
	// By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
	Aggregation AggregationResponse `pulumi:"aggregation"`
	// The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
	Filter string `pulumi:"filter"`
}

// Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio.
type RatioPartResponseOutput struct{ *pulumi.OutputState }

func (RatioPartResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RatioPartResponse)(nil)).Elem()
}

func (o RatioPartResponseOutput) ToRatioPartResponseOutput() RatioPartResponseOutput {
	return o
}

func (o RatioPartResponseOutput) ToRatioPartResponseOutputWithContext(ctx context.Context) RatioPartResponseOutput {
	return o
}

// By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
func (o RatioPartResponseOutput) Aggregation() AggregationResponseOutput {
	return o.ApplyT(func(v RatioPartResponse) AggregationResponse { return v.Aggregation }).(AggregationResponseOutput)
}

// The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
func (o RatioPartResponseOutput) Filter() pulumi.StringOutput {
	return o.ApplyT(func(v RatioPartResponse) string { return v.Filter }).(pulumi.StringOutput)
}

// Defines the layout properties and content for a row.
type Row struct {
	// The relative weight of this row. The row weight is used to adjust the height of rows on the screen (relative to peers). Greater the weight, greater the height of the row on the screen. If omitted, a value of 1 is used while rendering.
	Weight *string `pulumi:"weight"`
	// The display widgets arranged horizontally in this row.
	Widgets []Widget `pulumi:"widgets"`
}

// RowInput is an input type that accepts RowArgs and RowOutput values.
// You can construct a concrete instance of `RowInput` via:
//
//	RowArgs{...}
type RowInput interface {
	pulumi.Input

	ToRowOutput() RowOutput
	ToRowOutputWithContext(context.Context) RowOutput
}

// Defines the layout properties and content for a row.
type RowArgs struct {
	// The relative weight of this row. The row weight is used to adjust the height of rows on the screen (relative to peers). Greater the weight, greater the height of the row on the screen. If omitted, a value of 1 is used while rendering.
	Weight pulumi.StringPtrInput `pulumi:"weight"`
	// The display widgets arranged horizontally in this row.
	Widgets WidgetArrayInput `pulumi:"widgets"`
}

func (RowArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Row)(nil)).Elem()
}

func (i RowArgs) ToRowOutput() RowOutput {
	return i.ToRowOutputWithContext(context.Background())
}

func (i RowArgs) ToRowOutputWithContext(ctx context.Context) RowOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RowOutput)
}

// RowArrayInput is an input type that accepts RowArray and RowArrayOutput values.
// You can construct a concrete instance of `RowArrayInput` via:
//
//	RowArray{ RowArgs{...} }
type RowArrayInput interface {
	pulumi.Input

	ToRowArrayOutput() RowArrayOutput
	ToRowArrayOutputWithContext(context.Context) RowArrayOutput
}

type RowArray []RowInput

func (RowArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Row)(nil)).Elem()
}

func (i RowArray) ToRowArrayOutput() RowArrayOutput {
	return i.ToRowArrayOutputWithContext(context.Background())
}

func (i RowArray) ToRowArrayOutputWithContext(ctx context.Context) RowArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RowArrayOutput)
}

// Defines the layout properties and content for a row.
type RowOutput struct{ *pulumi.OutputState }

func (RowOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Row)(nil)).Elem()
}

func (o RowOutput) ToRowOutput() RowOutput {
	return o
}

func (o RowOutput) ToRowOutputWithContext(ctx context.Context) RowOutput {
	return o
}

// The relative weight of this row. The row weight is used to adjust the height of rows on the screen (relative to peers). Greater the weight, greater the height of the row on the screen. If omitted, a value of 1 is used while rendering.
func (o RowOutput) Weight() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Row) *string { return v.Weight }).(pulumi.StringPtrOutput)
}

// The display widgets arranged horizontally in this row.
func (o RowOutput) Widgets() WidgetArrayOutput {
	return o.ApplyT(func(v Row) []Widget { return v.Widgets }).(WidgetArrayOutput)
}

type RowArrayOutput struct{ *pulumi.OutputState }

func (RowArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Row)(nil)).Elem()
}

func (o RowArrayOutput) ToRowArrayOutput() RowArrayOutput {
	return o
}

func (o RowArrayOutput) ToRowArrayOutputWithContext(ctx context.Context) RowArrayOutput {
	return o
}

func (o RowArrayOutput) Index(i pulumi.IntInput) RowOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Row {
		return vs[0].([]Row)[vs[1].(int)]
	}).(RowOutput)
}

// A simplified layout that divides the available space into rows and arranges a set of widgets horizontally in each row.
type RowLayout struct {
	// The rows of content to display.
	Rows []Row `pulumi:"rows"`
}

// RowLayoutInput is an input type that accepts RowLayoutArgs and RowLayoutOutput values.
// You can construct a concrete instance of `RowLayoutInput` via:
//
//	RowLayoutArgs{...}
type RowLayoutInput interface {
	pulumi.Input

	ToRowLayoutOutput() RowLayoutOutput
	ToRowLayoutOutputWithContext(context.Context) RowLayoutOutput
}

// A simplified layout that divides the available space into rows and arranges a set of widgets horizontally in each row.
type RowLayoutArgs struct {
	// The rows of content to display.
	Rows RowArrayInput `pulumi:"rows"`
}

func (RowLayoutArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RowLayout)(nil)).Elem()
}

func (i RowLayoutArgs) ToRowLayoutOutput() RowLayoutOutput {
	return i.ToRowLayoutOutputWithContext(context.Background())
}

func (i RowLayoutArgs) ToRowLayoutOutputWithContext(ctx context.Context) RowLayoutOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RowLayoutOutput)
}

func (i RowLayoutArgs) ToRowLayoutPtrOutput() RowLayoutPtrOutput {
	return i.ToRowLayoutPtrOutputWithContext(context.Background())
}

func (i RowLayoutArgs) ToRowLayoutPtrOutputWithContext(ctx context.Context) RowLayoutPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RowLayoutOutput).ToRowLayoutPtrOutputWithContext(ctx)
}

// RowLayoutPtrInput is an input type that accepts RowLayoutArgs, RowLayoutPtr and RowLayoutPtrOutput values.
// You can construct a concrete instance of `RowLayoutPtrInput` via:
//
//	        RowLayoutArgs{...}
//
//	or:
//
//	        nil
type RowLayoutPtrInput interface {
	pulumi.Input

	ToRowLayoutPtrOutput() RowLayoutPtrOutput
	ToRowLayoutPtrOutputWithContext(context.Context) RowLayoutPtrOutput
}

type rowLayoutPtrType RowLayoutArgs

func RowLayoutPtr(v *RowLayoutArgs) RowLayoutPtrInput {
	return (*rowLayoutPtrType)(v)
}

func (*rowLayoutPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RowLayout)(nil)).Elem()
}

func (i *rowLayoutPtrType) ToRowLayoutPtrOutput() RowLayoutPtrOutput {
	return i.ToRowLayoutPtrOutputWithContext(context.Background())
}

func (i *rowLayoutPtrType) ToRowLayoutPtrOutputWithContext(ctx context.Context) RowLayoutPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RowLayoutPtrOutput)
}

// A simplified layout that divides the available space into rows and arranges a set of widgets horizontally in each row.
type RowLayoutOutput struct{ *pulumi.OutputState }

func (RowLayoutOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RowLayout)(nil)).Elem()
}

func (o RowLayoutOutput) ToRowLayoutOutput() RowLayoutOutput {
	return o
}

func (o RowLayoutOutput) ToRowLayoutOutputWithContext(ctx context.Context) RowLayoutOutput {
	return o
}

func (o RowLayoutOutput) ToRowLayoutPtrOutput() RowLayoutPtrOutput {
	return o.ToRowLayoutPtrOutputWithContext(context.Background())
}

func (o RowLayoutOutput) ToRowLayoutPtrOutputWithContext(ctx context.Context) RowLayoutPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RowLayout) *RowLayout {
		return &v
	}).(RowLayoutPtrOutput)
}

// The rows of content to display.
func (o RowLayoutOutput) Rows() RowArrayOutput {
	return o.ApplyT(func(v RowLayout) []Row { return v.Rows }).(RowArrayOutput)
}

type RowLayoutPtrOutput struct{ *pulumi.OutputState }

func (RowLayoutPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RowLayout)(nil)).Elem()
}

func (o RowLayoutPtrOutput) ToRowLayoutPtrOutput() RowLayoutPtrOutput {
	return o
}

func (o RowLayoutPtrOutput) ToRowLayoutPtrOutputWithContext(ctx context.Context) RowLayoutPtrOutput {
	return o
}

func (o RowLayoutPtrOutput) Elem() RowLayoutOutput {
	return o.ApplyT(func(v *RowLayout) RowLayout {
		if v != nil {
			return *v
		}
		var ret RowLayout
		return ret
	}).(RowLayoutOutput)
}

// The rows of content to display.
func (o RowLayoutPtrOutput) Rows() RowArrayOutput {
	return o.ApplyT(func(v *RowLayout) []Row {
		if v == nil {
			return nil
		}
		return v.Rows
	}).(RowArrayOutput)
}

// A simplified layout that divides the available space into rows and arranges a set of widgets horizontally in each row.
type RowLayoutResponse struct {
	// The rows of content to display.
	Rows []RowResponse `pulumi:"rows"`
}

// A simplified layout that divides the available space into rows and arranges a set of widgets horizontally in each row.
type RowLayoutResponseOutput struct{ *pulumi.OutputState }

func (RowLayoutResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RowLayoutResponse)(nil)).Elem()
}

func (o RowLayoutResponseOutput) ToRowLayoutResponseOutput() RowLayoutResponseOutput {
	return o
}

func (o RowLayoutResponseOutput) ToRowLayoutResponseOutputWithContext(ctx context.Context) RowLayoutResponseOutput {
	return o
}

// The rows of content to display.
func (o RowLayoutResponseOutput) Rows() RowResponseArrayOutput {
	return o.ApplyT(func(v RowLayoutResponse) []RowResponse { return v.Rows }).(RowResponseArrayOutput)
}

// Defines the layout properties and content for a row.
type RowResponse struct {
	// The relative weight of this row. The row weight is used to adjust the height of rows on the screen (relative to peers). Greater the weight, greater the height of the row on the screen. If omitted, a value of 1 is used while rendering.
	Weight string `pulumi:"weight"`
	// The display widgets arranged horizontally in this row.
	Widgets []WidgetResponse `pulumi:"widgets"`
}

// Defines the layout properties and content for a row.
type RowResponseOutput struct{ *pulumi.OutputState }

func (RowResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RowResponse)(nil)).Elem()
}

func (o RowResponseOutput) ToRowResponseOutput() RowResponseOutput {
	return o
}

func (o RowResponseOutput) ToRowResponseOutputWithContext(ctx context.Context) RowResponseOutput {
	return o
}

// The relative weight of this row. The row weight is used to adjust the height of rows on the screen (relative to peers). Greater the weight, greater the height of the row on the screen. If omitted, a value of 1 is used while rendering.
func (o RowResponseOutput) Weight() pulumi.StringOutput {
	return o.ApplyT(func(v RowResponse) string { return v.Weight }).(pulumi.StringOutput)
}

// The display widgets arranged horizontally in this row.
func (o RowResponseOutput) Widgets() WidgetResponseArrayOutput {
	return o.ApplyT(func(v RowResponse) []WidgetResponse { return v.Widgets }).(WidgetResponseArrayOutput)
}

type RowResponseArrayOutput struct{ *pulumi.OutputState }

func (RowResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RowResponse)(nil)).Elem()
}

func (o RowResponseArrayOutput) ToRowResponseArrayOutput() RowResponseArrayOutput {
	return o
}

func (o RowResponseArrayOutput) ToRowResponseArrayOutputWithContext(ctx context.Context) RowResponseArrayOutput {
	return o
}

func (o RowResponseArrayOutput) Index(i pulumi.IntInput) RowResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RowResponse {
		return vs[0].([]RowResponse)[vs[1].(int)]
	}).(RowResponseOutput)
}

// A widget showing the latest value of a metric, and how this value relates to one or more thresholds.
type Scorecard struct {
	// Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
	BlankView *Empty `pulumi:"blankView"`
	// Will cause the scorecard to show a gauge chart.
	GaugeView *GaugeView `pulumi:"gaugeView"`
	// Will cause the scorecard to show a spark chart.
	SparkChartView *SparkChartView `pulumi:"sparkChartView"`
	// The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: 'DANGER', trigger: 'ABOVE', }, { value: 70, category: 'WARNING', trigger: 'ABOVE', }, { value: 10, category: 'DANGER', trigger: 'BELOW', }, { value: 20, category: 'WARNING', trigger: 'BELOW', } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
	Thresholds []Threshold `pulumi:"thresholds"`
	// Fields for querying time series data from the Stackdriver metrics API.
	TimeSeriesQuery TimeSeriesQuery `pulumi:"timeSeriesQuery"`
}

// ScorecardInput is an input type that accepts ScorecardArgs and ScorecardOutput values.
// You can construct a concrete instance of `ScorecardInput` via:
//
//	ScorecardArgs{...}
type ScorecardInput interface {
	pulumi.Input

	ToScorecardOutput() ScorecardOutput
	ToScorecardOutputWithContext(context.Context) ScorecardOutput
}

// A widget showing the latest value of a metric, and how this value relates to one or more thresholds.
type ScorecardArgs struct {
	// Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
	BlankView EmptyPtrInput `pulumi:"blankView"`
	// Will cause the scorecard to show a gauge chart.
	GaugeView GaugeViewPtrInput `pulumi:"gaugeView"`
	// Will cause the scorecard to show a spark chart.
	SparkChartView SparkChartViewPtrInput `pulumi:"sparkChartView"`
	// The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: 'DANGER', trigger: 'ABOVE', }, { value: 70, category: 'WARNING', trigger: 'ABOVE', }, { value: 10, category: 'DANGER', trigger: 'BELOW', }, { value: 20, category: 'WARNING', trigger: 'BELOW', } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
	Thresholds ThresholdArrayInput `pulumi:"thresholds"`
	// Fields for querying time series data from the Stackdriver metrics API.
	TimeSeriesQuery TimeSeriesQueryInput `pulumi:"timeSeriesQuery"`
}

func (ScorecardArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Scorecard)(nil)).Elem()
}

func (i ScorecardArgs) ToScorecardOutput() ScorecardOutput {
	return i.ToScorecardOutputWithContext(context.Background())
}

func (i ScorecardArgs) ToScorecardOutputWithContext(ctx context.Context) ScorecardOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScorecardOutput)
}

func (i ScorecardArgs) ToScorecardPtrOutput() ScorecardPtrOutput {
	return i.ToScorecardPtrOutputWithContext(context.Background())
}

func (i ScorecardArgs) ToScorecardPtrOutputWithContext(ctx context.Context) ScorecardPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScorecardOutput).ToScorecardPtrOutputWithContext(ctx)
}

// ScorecardPtrInput is an input type that accepts ScorecardArgs, ScorecardPtr and ScorecardPtrOutput values.
// You can construct a concrete instance of `ScorecardPtrInput` via:
//
//	        ScorecardArgs{...}
//
//	or:
//
//	        nil
type ScorecardPtrInput interface {
	pulumi.Input

	ToScorecardPtrOutput() ScorecardPtrOutput
	ToScorecardPtrOutputWithContext(context.Context) ScorecardPtrOutput
}

type scorecardPtrType ScorecardArgs

func ScorecardPtr(v *ScorecardArgs) ScorecardPtrInput {
	return (*scorecardPtrType)(v)
}

func (*scorecardPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Scorecard)(nil)).Elem()
}

func (i *scorecardPtrType) ToScorecardPtrOutput() ScorecardPtrOutput {
	return i.ToScorecardPtrOutputWithContext(context.Background())
}

func (i *scorecardPtrType) ToScorecardPtrOutputWithContext(ctx context.Context) ScorecardPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScorecardPtrOutput)
}

// A widget showing the latest value of a metric, and how this value relates to one or more thresholds.
type ScorecardOutput struct{ *pulumi.OutputState }

func (ScorecardOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Scorecard)(nil)).Elem()
}

func (o ScorecardOutput) ToScorecardOutput() ScorecardOutput {
	return o
}

func (o ScorecardOutput) ToScorecardOutputWithContext(ctx context.Context) ScorecardOutput {
	return o
}

func (o ScorecardOutput) ToScorecardPtrOutput() ScorecardPtrOutput {
	return o.ToScorecardPtrOutputWithContext(context.Background())
}

func (o ScorecardOutput) ToScorecardPtrOutputWithContext(ctx context.Context) ScorecardPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Scorecard) *Scorecard {
		return &v
	}).(ScorecardPtrOutput)
}

// Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
func (o ScorecardOutput) BlankView() EmptyPtrOutput {
	return o.ApplyT(func(v Scorecard) *Empty { return v.BlankView }).(EmptyPtrOutput)
}

// Will cause the scorecard to show a gauge chart.
func (o ScorecardOutput) GaugeView() GaugeViewPtrOutput {
	return o.ApplyT(func(v Scorecard) *GaugeView { return v.GaugeView }).(GaugeViewPtrOutput)
}

// Will cause the scorecard to show a spark chart.
func (o ScorecardOutput) SparkChartView() SparkChartViewPtrOutput {
	return o.ApplyT(func(v Scorecard) *SparkChartView { return v.SparkChartView }).(SparkChartViewPtrOutput)
}

// The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: 'DANGER', trigger: 'ABOVE', }, { value: 70, category: 'WARNING', trigger: 'ABOVE', }, { value: 10, category: 'DANGER', trigger: 'BELOW', }, { value: 20, category: 'WARNING', trigger: 'BELOW', } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
func (o ScorecardOutput) Thresholds() ThresholdArrayOutput {
	return o.ApplyT(func(v Scorecard) []Threshold { return v.Thresholds }).(ThresholdArrayOutput)
}

// Fields for querying time series data from the Stackdriver metrics API.
func (o ScorecardOutput) TimeSeriesQuery() TimeSeriesQueryOutput {
	return o.ApplyT(func(v Scorecard) TimeSeriesQuery { return v.TimeSeriesQuery }).(TimeSeriesQueryOutput)
}

type ScorecardPtrOutput struct{ *pulumi.OutputState }

func (ScorecardPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Scorecard)(nil)).Elem()
}

func (o ScorecardPtrOutput) ToScorecardPtrOutput() ScorecardPtrOutput {
	return o
}

func (o ScorecardPtrOutput) ToScorecardPtrOutputWithContext(ctx context.Context) ScorecardPtrOutput {
	return o
}

func (o ScorecardPtrOutput) Elem() ScorecardOutput {
	return o.ApplyT(func(v *Scorecard) Scorecard {
		if v != nil {
			return *v
		}
		var ret Scorecard
		return ret
	}).(ScorecardOutput)
}

// Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
func (o ScorecardPtrOutput) BlankView() EmptyPtrOutput {
	return o.ApplyT(func(v *Scorecard) *Empty {
		if v == nil {
			return nil
		}
		return v.BlankView
	}).(EmptyPtrOutput)
}

// Will cause the scorecard to show a gauge chart.
func (o ScorecardPtrOutput) GaugeView() GaugeViewPtrOutput {
	return o.ApplyT(func(v *Scorecard) *GaugeView {
		if v == nil {
			return nil
		}
		return v.GaugeView
	}).(GaugeViewPtrOutput)
}

// Will cause the scorecard to show a spark chart.
func (o ScorecardPtrOutput) SparkChartView() SparkChartViewPtrOutput {
	return o.ApplyT(func(v *Scorecard) *SparkChartView {
		if v == nil {
			return nil
		}
		return v.SparkChartView
	}).(SparkChartViewPtrOutput)
}

// The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: 'DANGER', trigger: 'ABOVE', }, { value: 70, category: 'WARNING', trigger: 'ABOVE', }, { value: 10, category: 'DANGER', trigger: 'BELOW', }, { value: 20, category: 'WARNING', trigger: 'BELOW', } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
func (o ScorecardPtrOutput) Thresholds() ThresholdArrayOutput {
	return o.ApplyT(func(v *Scorecard) []Threshold {
		if v == nil {
			return nil
		}
		return v.Thresholds
	}).(ThresholdArrayOutput)
}

// Fields for querying time series data from the Stackdriver metrics API.
func (o ScorecardPtrOutput) TimeSeriesQuery() TimeSeriesQueryPtrOutput {
	return o.ApplyT(func(v *Scorecard) *TimeSeriesQuery {
		if v == nil {
			return nil
		}
		return &v.TimeSeriesQuery
	}).(TimeSeriesQueryPtrOutput)
}

// A widget showing the latest value of a metric, and how this value relates to one or more thresholds.
type ScorecardResponse struct {
	// Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
	BlankView EmptyResponse `pulumi:"blankView"`
	// Will cause the scorecard to show a gauge chart.
	GaugeView GaugeViewResponse `pulumi:"gaugeView"`
	// Will cause the scorecard to show a spark chart.
	SparkChartView SparkChartViewResponse `pulumi:"sparkChartView"`
	// The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: 'DANGER', trigger: 'ABOVE', }, { value: 70, category: 'WARNING', trigger: 'ABOVE', }, { value: 10, category: 'DANGER', trigger: 'BELOW', }, { value: 20, category: 'WARNING', trigger: 'BELOW', } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
	Thresholds []ThresholdResponse `pulumi:"thresholds"`
	// Fields for querying time series data from the Stackdriver metrics API.
	TimeSeriesQuery TimeSeriesQueryResponse `pulumi:"timeSeriesQuery"`
}

// A widget showing the latest value of a metric, and how this value relates to one or more thresholds.
type ScorecardResponseOutput struct{ *pulumi.OutputState }

func (ScorecardResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ScorecardResponse)(nil)).Elem()
}

func (o ScorecardResponseOutput) ToScorecardResponseOutput() ScorecardResponseOutput {
	return o
}

func (o ScorecardResponseOutput) ToScorecardResponseOutputWithContext(ctx context.Context) ScorecardResponseOutput {
	return o
}

// Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
func (o ScorecardResponseOutput) BlankView() EmptyResponseOutput {
	return o.ApplyT(func(v ScorecardResponse) EmptyResponse { return v.BlankView }).(EmptyResponseOutput)
}

// Will cause the scorecard to show a gauge chart.
func (o ScorecardResponseOutput) GaugeView() GaugeViewResponseOutput {
	return o.ApplyT(func(v ScorecardResponse) GaugeViewResponse { return v.GaugeView }).(GaugeViewResponseOutput)
}

// Will cause the scorecard to show a spark chart.
func (o ScorecardResponseOutput) SparkChartView() SparkChartViewResponseOutput {
	return o.ApplyT(func(v ScorecardResponse) SparkChartViewResponse { return v.SparkChartView }).(SparkChartViewResponseOutput)
}

// The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: 'DANGER', trigger: 'ABOVE', }, { value: 70, category: 'WARNING', trigger: 'ABOVE', }, { value: 10, category: 'DANGER', trigger: 'BELOW', }, { value: 20, category: 'WARNING', trigger: 'BELOW', } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
func (o ScorecardResponseOutput) Thresholds() ThresholdResponseArrayOutput {
	return o.ApplyT(func(v ScorecardResponse) []ThresholdResponse { return v.Thresholds }).(ThresholdResponseArrayOutput)
}

// Fields for querying time series data from the Stackdriver metrics API.
func (o ScorecardResponseOutput) TimeSeriesQuery() TimeSeriesQueryResponseOutput {
	return o.ApplyT(func(v ScorecardResponse) TimeSeriesQueryResponse { return v.TimeSeriesQuery }).(TimeSeriesQueryResponseOutput)
}

// A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content.
type SectionHeader struct {
	// Whether to insert a divider below the section in the table of contents
	DividerBelow *bool `pulumi:"dividerBelow"`
	// The subtitle of the section
	Subtitle *string `pulumi:"subtitle"`
}

// SectionHeaderInput is an input type that accepts SectionHeaderArgs and SectionHeaderOutput values.
// You can construct a concrete instance of `SectionHeaderInput` via:
//
//	SectionHeaderArgs{...}
type SectionHeaderInput interface {
	pulumi.Input

	ToSectionHeaderOutput() SectionHeaderOutput
	ToSectionHeaderOutputWithContext(context.Context) SectionHeaderOutput
}

// A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content.
type SectionHeaderArgs struct {
	// Whether to insert a divider below the section in the table of contents
	DividerBelow pulumi.BoolPtrInput `pulumi:"dividerBelow"`
	// The subtitle of the section
	Subtitle pulumi.StringPtrInput `pulumi:"subtitle"`
}

func (SectionHeaderArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SectionHeader)(nil)).Elem()
}

func (i SectionHeaderArgs) ToSectionHeaderOutput() SectionHeaderOutput {
	return i.ToSectionHeaderOutputWithContext(context.Background())
}

func (i SectionHeaderArgs) ToSectionHeaderOutputWithContext(ctx context.Context) SectionHeaderOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SectionHeaderOutput)
}

func (i SectionHeaderArgs) ToSectionHeaderPtrOutput() SectionHeaderPtrOutput {
	return i.ToSectionHeaderPtrOutputWithContext(context.Background())
}

func (i SectionHeaderArgs) ToSectionHeaderPtrOutputWithContext(ctx context.Context) SectionHeaderPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SectionHeaderOutput).ToSectionHeaderPtrOutputWithContext(ctx)
}

// SectionHeaderPtrInput is an input type that accepts SectionHeaderArgs, SectionHeaderPtr and SectionHeaderPtrOutput values.
// You can construct a concrete instance of `SectionHeaderPtrInput` via:
//
//	        SectionHeaderArgs{...}
//
//	or:
//
//	        nil
type SectionHeaderPtrInput interface {
	pulumi.Input

	ToSectionHeaderPtrOutput() SectionHeaderPtrOutput
	ToSectionHeaderPtrOutputWithContext(context.Context) SectionHeaderPtrOutput
}

type sectionHeaderPtrType SectionHeaderArgs

func SectionHeaderPtr(v *SectionHeaderArgs) SectionHeaderPtrInput {
	return (*sectionHeaderPtrType)(v)
}

func (*sectionHeaderPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SectionHeader)(nil)).Elem()
}

func (i *sectionHeaderPtrType) ToSectionHeaderPtrOutput() SectionHeaderPtrOutput {
	return i.ToSectionHeaderPtrOutputWithContext(context.Background())
}

func (i *sectionHeaderPtrType) ToSectionHeaderPtrOutputWithContext(ctx context.Context) SectionHeaderPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SectionHeaderPtrOutput)
}

// A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content.
type SectionHeaderOutput struct{ *pulumi.OutputState }

func (SectionHeaderOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SectionHeader)(nil)).Elem()
}

func (o SectionHeaderOutput) ToSectionHeaderOutput() SectionHeaderOutput {
	return o
}

func (o SectionHeaderOutput) ToSectionHeaderOutputWithContext(ctx context.Context) SectionHeaderOutput {
	return o
}

func (o SectionHeaderOutput) ToSectionHeaderPtrOutput() SectionHeaderPtrOutput {
	return o.ToSectionHeaderPtrOutputWithContext(context.Background())
}

func (o SectionHeaderOutput) ToSectionHeaderPtrOutputWithContext(ctx context.Context) SectionHeaderPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v SectionHeader) *SectionHeader {
		return &v
	}).(SectionHeaderPtrOutput)
}

// Whether to insert a divider below the section in the table of contents
func (o SectionHeaderOutput) DividerBelow() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SectionHeader) *bool { return v.DividerBelow }).(pulumi.BoolPtrOutput)
}

// The subtitle of the section
func (o SectionHeaderOutput) Subtitle() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SectionHeader) *string { return v.Subtitle }).(pulumi.StringPtrOutput)
}

type SectionHeaderPtrOutput struct{ *pulumi.OutputState }

func (SectionHeaderPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SectionHeader)(nil)).Elem()
}

func (o SectionHeaderPtrOutput) ToSectionHeaderPtrOutput() SectionHeaderPtrOutput {
	return o
}

func (o SectionHeaderPtrOutput) ToSectionHeaderPtrOutputWithContext(ctx context.Context) SectionHeaderPtrOutput {
	return o
}

func (o SectionHeaderPtrOutput) Elem() SectionHeaderOutput {
	return o.ApplyT(func(v *SectionHeader) SectionHeader {
		if v != nil {
			return *v
		}
		var ret SectionHeader
		return ret
	}).(SectionHeaderOutput)
}

// Whether to insert a divider below the section in the table of contents
func (o SectionHeaderPtrOutput) DividerBelow() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SectionHeader) *bool {
		if v == nil {
			return nil
		}
		return v.DividerBelow
	}).(pulumi.BoolPtrOutput)
}

// The subtitle of the section
func (o SectionHeaderPtrOutput) Subtitle() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SectionHeader) *string {
		if v == nil {
			return nil
		}
		return v.Subtitle
	}).(pulumi.StringPtrOutput)
}

// A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content.
type SectionHeaderResponse struct {
	// Whether to insert a divider below the section in the table of contents
	DividerBelow bool `pulumi:"dividerBelow"`
	// The subtitle of the section
	Subtitle string `pulumi:"subtitle"`
}

// A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content.
type SectionHeaderResponseOutput struct{ *pulumi.OutputState }

func (SectionHeaderResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SectionHeaderResponse)(nil)).Elem()
}

func (o SectionHeaderResponseOutput) ToSectionHeaderResponseOutput() SectionHeaderResponseOutput {
	return o
}

func (o SectionHeaderResponseOutput) ToSectionHeaderResponseOutputWithContext(ctx context.Context) SectionHeaderResponseOutput {
	return o
}

// Whether to insert a divider below the section in the table of contents
func (o SectionHeaderResponseOutput) DividerBelow() pulumi.BoolOutput {
	return o.ApplyT(func(v SectionHeaderResponse) bool { return v.DividerBelow }).(pulumi.BoolOutput)
}

// The subtitle of the section
func (o SectionHeaderResponseOutput) Subtitle() pulumi.StringOutput {
	return o.ApplyT(func(v SectionHeaderResponse) string { return v.Subtitle }).(pulumi.StringOutput)
}

// A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets.
type SingleViewGroup struct {
}

// SingleViewGroupInput is an input type that accepts SingleViewGroupArgs and SingleViewGroupOutput values.
// You can construct a concrete instance of `SingleViewGroupInput` via:
//
//	SingleViewGroupArgs{...}
type SingleViewGroupInput interface {
	pulumi.Input

	ToSingleViewGroupOutput() SingleViewGroupOutput
	ToSingleViewGroupOutputWithContext(context.Context) SingleViewGroupOutput
}

// A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets.
type SingleViewGroupArgs struct {
}

func (SingleViewGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SingleViewGroup)(nil)).Elem()
}

func (i SingleViewGroupArgs) ToSingleViewGroupOutput() SingleViewGroupOutput {
	return i.ToSingleViewGroupOutputWithContext(context.Background())
}

func (i SingleViewGroupArgs) ToSingleViewGroupOutputWithContext(ctx context.Context) SingleViewGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SingleViewGroupOutput)
}

func (i SingleViewGroupArgs) ToSingleViewGroupPtrOutput() SingleViewGroupPtrOutput {
	return i.ToSingleViewGroupPtrOutputWithContext(context.Background())
}

func (i SingleViewGroupArgs) ToSingleViewGroupPtrOutputWithContext(ctx context.Context) SingleViewGroupPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SingleViewGroupOutput).ToSingleViewGroupPtrOutputWithContext(ctx)
}

// SingleViewGroupPtrInput is an input type that accepts SingleViewGroupArgs, SingleViewGroupPtr and SingleViewGroupPtrOutput values.
// You can construct a concrete instance of `SingleViewGroupPtrInput` via:
//
//	        SingleViewGroupArgs{...}
//
//	or:
//
//	        nil
type SingleViewGroupPtrInput interface {
	pulumi.Input

	ToSingleViewGroupPtrOutput() SingleViewGroupPtrOutput
	ToSingleViewGroupPtrOutputWithContext(context.Context) SingleViewGroupPtrOutput
}

type singleViewGroupPtrType SingleViewGroupArgs

func SingleViewGroupPtr(v *SingleViewGroupArgs) SingleViewGroupPtrInput {
	return (*singleViewGroupPtrType)(v)
}

func (*singleViewGroupPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SingleViewGroup)(nil)).Elem()
}

func (i *singleViewGroupPtrType) ToSingleViewGroupPtrOutput() SingleViewGroupPtrOutput {
	return i.ToSingleViewGroupPtrOutputWithContext(context.Background())
}

func (i *singleViewGroupPtrType) ToSingleViewGroupPtrOutputWithContext(ctx context.Context) SingleViewGroupPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SingleViewGroupPtrOutput)
}

// A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets.
type SingleViewGroupOutput struct{ *pulumi.OutputState }

func (SingleViewGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SingleViewGroup)(nil)).Elem()
}

func (o SingleViewGroupOutput) ToSingleViewGroupOutput() SingleViewGroupOutput {
	return o
}

func (o SingleViewGroupOutput) ToSingleViewGroupOutputWithContext(ctx context.Context) SingleViewGroupOutput {
	return o
}

func (o SingleViewGroupOutput) ToSingleViewGroupPtrOutput() SingleViewGroupPtrOutput {
	return o.ToSingleViewGroupPtrOutputWithContext(context.Background())
}

func (o SingleViewGroupOutput) ToSingleViewGroupPtrOutputWithContext(ctx context.Context) SingleViewGroupPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v SingleViewGroup) *SingleViewGroup {
		return &v
	}).(SingleViewGroupPtrOutput)
}

type SingleViewGroupPtrOutput struct{ *pulumi.OutputState }

func (SingleViewGroupPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SingleViewGroup)(nil)).Elem()
}

func (o SingleViewGroupPtrOutput) ToSingleViewGroupPtrOutput() SingleViewGroupPtrOutput {
	return o
}

func (o SingleViewGroupPtrOutput) ToSingleViewGroupPtrOutputWithContext(ctx context.Context) SingleViewGroupPtrOutput {
	return o
}

func (o SingleViewGroupPtrOutput) Elem() SingleViewGroupOutput {
	return o.ApplyT(func(v *SingleViewGroup) SingleViewGroup {
		if v != nil {
			return *v
		}
		var ret SingleViewGroup
		return ret
	}).(SingleViewGroupOutput)
}

// A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets.
type SingleViewGroupResponse struct {
}

// A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets.
type SingleViewGroupResponseOutput struct{ *pulumi.OutputState }

func (SingleViewGroupResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SingleViewGroupResponse)(nil)).Elem()
}

func (o SingleViewGroupResponseOutput) ToSingleViewGroupResponseOutput() SingleViewGroupResponseOutput {
	return o
}

func (o SingleViewGroupResponseOutput) ToSingleViewGroupResponseOutputWithContext(ctx context.Context) SingleViewGroupResponseOutput {
	return o
}

// A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard's timeseries.
type SparkChartView struct {
	// The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
	MinAlignmentPeriod *string `pulumi:"minAlignmentPeriod"`
	// The type of sparkchart to show in this chartView.
	SparkChartType SparkChartViewSparkChartType `pulumi:"sparkChartType"`
}

// SparkChartViewInput is an input type that accepts SparkChartViewArgs and SparkChartViewOutput values.
// You can construct a concrete instance of `SparkChartViewInput` via:
//
//	SparkChartViewArgs{...}
type SparkChartViewInput interface {
	pulumi.Input

	ToSparkChartViewOutput() SparkChartViewOutput
	ToSparkChartViewOutputWithContext(context.Context) SparkChartViewOutput
}

// A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard's timeseries.
type SparkChartViewArgs struct {
	// The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
	MinAlignmentPeriod pulumi.StringPtrInput `pulumi:"minAlignmentPeriod"`
	// The type of sparkchart to show in this chartView.
	SparkChartType SparkChartViewSparkChartTypeInput `pulumi:"sparkChartType"`
}

func (SparkChartViewArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SparkChartView)(nil)).Elem()
}

func (i SparkChartViewArgs) ToSparkChartViewOutput() SparkChartViewOutput {
	return i.ToSparkChartViewOutputWithContext(context.Background())
}

func (i SparkChartViewArgs) ToSparkChartViewOutputWithContext(ctx context.Context) SparkChartViewOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SparkChartViewOutput)
}

func (i SparkChartViewArgs) ToSparkChartViewPtrOutput() SparkChartViewPtrOutput {
	return i.ToSparkChartViewPtrOutputWithContext(context.Background())
}

func (i SparkChartViewArgs) ToSparkChartViewPtrOutputWithContext(ctx context.Context) SparkChartViewPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SparkChartViewOutput).ToSparkChartViewPtrOutputWithContext(ctx)
}

// SparkChartViewPtrInput is an input type that accepts SparkChartViewArgs, SparkChartViewPtr and SparkChartViewPtrOutput values.
// You can construct a concrete instance of `SparkChartViewPtrInput` via:
//
//	        SparkChartViewArgs{...}
//
//	or:
//
//	        nil
type SparkChartViewPtrInput interface {
	pulumi.Input

	ToSparkChartViewPtrOutput() SparkChartViewPtrOutput
	ToSparkChartViewPtrOutputWithContext(context.Context) SparkChartViewPtrOutput
}

type sparkChartViewPtrType SparkChartViewArgs

func SparkChartViewPtr(v *SparkChartViewArgs) SparkChartViewPtrInput {
	return (*sparkChartViewPtrType)(v)
}

func (*sparkChartViewPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SparkChartView)(nil)).Elem()
}

func (i *sparkChartViewPtrType) ToSparkChartViewPtrOutput() SparkChartViewPtrOutput {
	return i.ToSparkChartViewPtrOutputWithContext(context.Background())
}

func (i *sparkChartViewPtrType) ToSparkChartViewPtrOutputWithContext(ctx context.Context) SparkChartViewPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SparkChartViewPtrOutput)
}

// A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard's timeseries.
type SparkChartViewOutput struct{ *pulumi.OutputState }

func (SparkChartViewOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SparkChartView)(nil)).Elem()
}

func (o SparkChartViewOutput) ToSparkChartViewOutput() SparkChartViewOutput {
	return o
}

func (o SparkChartViewOutput) ToSparkChartViewOutputWithContext(ctx context.Context) SparkChartViewOutput {
	return o
}

func (o SparkChartViewOutput) ToSparkChartViewPtrOutput() SparkChartViewPtrOutput {
	return o.ToSparkChartViewPtrOutputWithContext(context.Background())
}

func (o SparkChartViewOutput) ToSparkChartViewPtrOutputWithContext(ctx context.Context) SparkChartViewPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v SparkChartView) *SparkChartView {
		return &v
	}).(SparkChartViewPtrOutput)
}

// The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
func (o SparkChartViewOutput) MinAlignmentPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SparkChartView) *string { return v.MinAlignmentPeriod }).(pulumi.StringPtrOutput)
}

// The type of sparkchart to show in this chartView.
func (o SparkChartViewOutput) SparkChartType() SparkChartViewSparkChartTypeOutput {
	return o.ApplyT(func(v SparkChartView) SparkChartViewSparkChartType { return v.SparkChartType }).(SparkChartViewSparkChartTypeOutput)
}

type SparkChartViewPtrOutput struct{ *pulumi.OutputState }

func (SparkChartViewPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SparkChartView)(nil)).Elem()
}

func (o SparkChartViewPtrOutput) ToSparkChartViewPtrOutput() SparkChartViewPtrOutput {
	return o
}

func (o SparkChartViewPtrOutput) ToSparkChartViewPtrOutputWithContext(ctx context.Context) SparkChartViewPtrOutput {
	return o
}

func (o SparkChartViewPtrOutput) Elem() SparkChartViewOutput {
	return o.ApplyT(func(v *SparkChartView) SparkChartView {
		if v != nil {
			return *v
		}
		var ret SparkChartView
		return ret
	}).(SparkChartViewOutput)
}

// The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
func (o SparkChartViewPtrOutput) MinAlignmentPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SparkChartView) *string {
		if v == nil {
			return nil
		}
		return v.MinAlignmentPeriod
	}).(pulumi.StringPtrOutput)
}

// The type of sparkchart to show in this chartView.
func (o SparkChartViewPtrOutput) SparkChartType() SparkChartViewSparkChartTypePtrOutput {
	return o.ApplyT(func(v *SparkChartView) *SparkChartViewSparkChartType {
		if v == nil {
			return nil
		}
		return &v.SparkChartType
	}).(SparkChartViewSparkChartTypePtrOutput)
}

// A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard's timeseries.
type SparkChartViewResponse struct {
	// The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
	MinAlignmentPeriod string `pulumi:"minAlignmentPeriod"`
	// The type of sparkchart to show in this chartView.
	SparkChartType string `pulumi:"sparkChartType"`
}

// A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard's timeseries.
type SparkChartViewResponseOutput struct{ *pulumi.OutputState }

func (SparkChartViewResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SparkChartViewResponse)(nil)).Elem()
}

func (o SparkChartViewResponseOutput) ToSparkChartViewResponseOutput() SparkChartViewResponseOutput {
	return o
}

func (o SparkChartViewResponseOutput) ToSparkChartViewResponseOutputWithContext(ctx context.Context) SparkChartViewResponseOutput {
	return o
}

// The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
func (o SparkChartViewResponseOutput) MinAlignmentPeriod() pulumi.StringOutput {
	return o.ApplyT(func(v SparkChartViewResponse) string { return v.MinAlignmentPeriod }).(pulumi.StringOutput)
}

// The type of sparkchart to show in this chartView.
func (o SparkChartViewResponseOutput) SparkChartType() pulumi.StringOutput {
	return o.ApplyT(func(v SparkChartViewResponse) string { return v.SparkChartType }).(pulumi.StringOutput)
}

// A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API.
type StatisticalTimeSeriesFilter struct {
	// How many time series to output.
	NumTimeSeries *int `pulumi:"numTimeSeries"`
	// rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
	RankingMethod *StatisticalTimeSeriesFilterRankingMethod `pulumi:"rankingMethod"`
}

// StatisticalTimeSeriesFilterInput is an input type that accepts StatisticalTimeSeriesFilterArgs and StatisticalTimeSeriesFilterOutput values.
// You can construct a concrete instance of `StatisticalTimeSeriesFilterInput` via:
//
//	StatisticalTimeSeriesFilterArgs{...}
type StatisticalTimeSeriesFilterInput interface {
	pulumi.Input

	ToStatisticalTimeSeriesFilterOutput() StatisticalTimeSeriesFilterOutput
	ToStatisticalTimeSeriesFilterOutputWithContext(context.Context) StatisticalTimeSeriesFilterOutput
}

// A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API.
type StatisticalTimeSeriesFilterArgs struct {
	// How many time series to output.
	NumTimeSeries pulumi.IntPtrInput `pulumi:"numTimeSeries"`
	// rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
	RankingMethod StatisticalTimeSeriesFilterRankingMethodPtrInput `pulumi:"rankingMethod"`
}

func (StatisticalTimeSeriesFilterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*StatisticalTimeSeriesFilter)(nil)).Elem()
}

func (i StatisticalTimeSeriesFilterArgs) ToStatisticalTimeSeriesFilterOutput() StatisticalTimeSeriesFilterOutput {
	return i.ToStatisticalTimeSeriesFilterOutputWithContext(context.Background())
}

func (i StatisticalTimeSeriesFilterArgs) ToStatisticalTimeSeriesFilterOutputWithContext(ctx context.Context) StatisticalTimeSeriesFilterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatisticalTimeSeriesFilterOutput)
}

func (i StatisticalTimeSeriesFilterArgs) ToStatisticalTimeSeriesFilterPtrOutput() StatisticalTimeSeriesFilterPtrOutput {
	return i.ToStatisticalTimeSeriesFilterPtrOutputWithContext(context.Background())
}

func (i StatisticalTimeSeriesFilterArgs) ToStatisticalTimeSeriesFilterPtrOutputWithContext(ctx context.Context) StatisticalTimeSeriesFilterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatisticalTimeSeriesFilterOutput).ToStatisticalTimeSeriesFilterPtrOutputWithContext(ctx)
}

// StatisticalTimeSeriesFilterPtrInput is an input type that accepts StatisticalTimeSeriesFilterArgs, StatisticalTimeSeriesFilterPtr and StatisticalTimeSeriesFilterPtrOutput values.
// You can construct a concrete instance of `StatisticalTimeSeriesFilterPtrInput` via:
//
//	        StatisticalTimeSeriesFilterArgs{...}
//
//	or:
//
//	        nil
type StatisticalTimeSeriesFilterPtrInput interface {
	pulumi.Input

	ToStatisticalTimeSeriesFilterPtrOutput() StatisticalTimeSeriesFilterPtrOutput
	ToStatisticalTimeSeriesFilterPtrOutputWithContext(context.Context) StatisticalTimeSeriesFilterPtrOutput
}

type statisticalTimeSeriesFilterPtrType StatisticalTimeSeriesFilterArgs

func StatisticalTimeSeriesFilterPtr(v *StatisticalTimeSeriesFilterArgs) StatisticalTimeSeriesFilterPtrInput {
	return (*statisticalTimeSeriesFilterPtrType)(v)
}

func (*statisticalTimeSeriesFilterPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**StatisticalTimeSeriesFilter)(nil)).Elem()
}

func (i *statisticalTimeSeriesFilterPtrType) ToStatisticalTimeSeriesFilterPtrOutput() StatisticalTimeSeriesFilterPtrOutput {
	return i.ToStatisticalTimeSeriesFilterPtrOutputWithContext(context.Background())
}

func (i *statisticalTimeSeriesFilterPtrType) ToStatisticalTimeSeriesFilterPtrOutputWithContext(ctx context.Context) StatisticalTimeSeriesFilterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatisticalTimeSeriesFilterPtrOutput)
}

// A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API.
type StatisticalTimeSeriesFilterOutput struct{ *pulumi.OutputState }

func (StatisticalTimeSeriesFilterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StatisticalTimeSeriesFilter)(nil)).Elem()
}

func (o StatisticalTimeSeriesFilterOutput) ToStatisticalTimeSeriesFilterOutput() StatisticalTimeSeriesFilterOutput {
	return o
}

func (o StatisticalTimeSeriesFilterOutput) ToStatisticalTimeSeriesFilterOutputWithContext(ctx context.Context) StatisticalTimeSeriesFilterOutput {
	return o
}

func (o StatisticalTimeSeriesFilterOutput) ToStatisticalTimeSeriesFilterPtrOutput() StatisticalTimeSeriesFilterPtrOutput {
	return o.ToStatisticalTimeSeriesFilterPtrOutputWithContext(context.Background())
}

func (o StatisticalTimeSeriesFilterOutput) ToStatisticalTimeSeriesFilterPtrOutputWithContext(ctx context.Context) StatisticalTimeSeriesFilterPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v StatisticalTimeSeriesFilter) *StatisticalTimeSeriesFilter {
		return &v
	}).(StatisticalTimeSeriesFilterPtrOutput)
}

// How many time series to output.
func (o StatisticalTimeSeriesFilterOutput) NumTimeSeries() pulumi.IntPtrOutput {
	return o.ApplyT(func(v StatisticalTimeSeriesFilter) *int { return v.NumTimeSeries }).(pulumi.IntPtrOutput)
}

// rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
func (o StatisticalTimeSeriesFilterOutput) RankingMethod() StatisticalTimeSeriesFilterRankingMethodPtrOutput {
	return o.ApplyT(func(v StatisticalTimeSeriesFilter) *StatisticalTimeSeriesFilterRankingMethod { return v.RankingMethod }).(StatisticalTimeSeriesFilterRankingMethodPtrOutput)
}

type StatisticalTimeSeriesFilterPtrOutput struct{ *pulumi.OutputState }

func (StatisticalTimeSeriesFilterPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StatisticalTimeSeriesFilter)(nil)).Elem()
}

func (o StatisticalTimeSeriesFilterPtrOutput) ToStatisticalTimeSeriesFilterPtrOutput() StatisticalTimeSeriesFilterPtrOutput {
	return o
}

func (o StatisticalTimeSeriesFilterPtrOutput) ToStatisticalTimeSeriesFilterPtrOutputWithContext(ctx context.Context) StatisticalTimeSeriesFilterPtrOutput {
	return o
}

func (o StatisticalTimeSeriesFilterPtrOutput) Elem() StatisticalTimeSeriesFilterOutput {
	return o.ApplyT(func(v *StatisticalTimeSeriesFilter) StatisticalTimeSeriesFilter {
		if v != nil {
			return *v
		}
		var ret StatisticalTimeSeriesFilter
		return ret
	}).(StatisticalTimeSeriesFilterOutput)
}

// How many time series to output.
func (o StatisticalTimeSeriesFilterPtrOutput) NumTimeSeries() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *StatisticalTimeSeriesFilter) *int {
		if v == nil {
			return nil
		}
		return v.NumTimeSeries
	}).(pulumi.IntPtrOutput)
}

// rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
func (o StatisticalTimeSeriesFilterPtrOutput) RankingMethod() StatisticalTimeSeriesFilterRankingMethodPtrOutput {
	return o.ApplyT(func(v *StatisticalTimeSeriesFilter) *StatisticalTimeSeriesFilterRankingMethod {
		if v == nil {
			return nil
		}
		return v.RankingMethod
	}).(StatisticalTimeSeriesFilterRankingMethodPtrOutput)
}

// A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API.
type StatisticalTimeSeriesFilterResponse struct {
	// How many time series to output.
	NumTimeSeries int `pulumi:"numTimeSeries"`
	// rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
	RankingMethod string `pulumi:"rankingMethod"`
}

// A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API.
type StatisticalTimeSeriesFilterResponseOutput struct{ *pulumi.OutputState }

func (StatisticalTimeSeriesFilterResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*StatisticalTimeSeriesFilterResponse)(nil)).Elem()
}

func (o StatisticalTimeSeriesFilterResponseOutput) ToStatisticalTimeSeriesFilterResponseOutput() StatisticalTimeSeriesFilterResponseOutput {
	return o
}

func (o StatisticalTimeSeriesFilterResponseOutput) ToStatisticalTimeSeriesFilterResponseOutputWithContext(ctx context.Context) StatisticalTimeSeriesFilterResponseOutput {
	return o
}

// How many time series to output.
func (o StatisticalTimeSeriesFilterResponseOutput) NumTimeSeries() pulumi.IntOutput {
	return o.ApplyT(func(v StatisticalTimeSeriesFilterResponse) int { return v.NumTimeSeries }).(pulumi.IntOutput)
}

// rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
func (o StatisticalTimeSeriesFilterResponseOutput) RankingMethod() pulumi.StringOutput {
	return o.ApplyT(func(v StatisticalTimeSeriesFilterResponse) string { return v.RankingMethod }).(pulumi.StringOutput)
}

// Groups a time series query definition with table options.
type TableDataSet struct {
	// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
	MinAlignmentPeriod *string `pulumi:"minAlignmentPeriod"`
	// Optional. Table display options for configuring how the table is rendered.
	TableDisplayOptions *TableDisplayOptions `pulumi:"tableDisplayOptions"`
	// Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value i.e. "${resource.labels.project_id}."
	TableTemplate *string `pulumi:"tableTemplate"`
	// Fields for querying time series data from the Stackdriver metrics API.
	TimeSeriesQuery TimeSeriesQuery `pulumi:"timeSeriesQuery"`
}

// TableDataSetInput is an input type that accepts TableDataSetArgs and TableDataSetOutput values.
// You can construct a concrete instance of `TableDataSetInput` via:
//
//	TableDataSetArgs{...}
type TableDataSetInput interface {
	pulumi.Input

	ToTableDataSetOutput() TableDataSetOutput
	ToTableDataSetOutputWithContext(context.Context) TableDataSetOutput
}

// Groups a time series query definition with table options.
type TableDataSetArgs struct {
	// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
	MinAlignmentPeriod pulumi.StringPtrInput `pulumi:"minAlignmentPeriod"`
	// Optional. Table display options for configuring how the table is rendered.
	TableDisplayOptions TableDisplayOptionsPtrInput `pulumi:"tableDisplayOptions"`
	// Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value i.e. "${resource.labels.project_id}."
	TableTemplate pulumi.StringPtrInput `pulumi:"tableTemplate"`
	// Fields for querying time series data from the Stackdriver metrics API.
	TimeSeriesQuery TimeSeriesQueryInput `pulumi:"timeSeriesQuery"`
}

func (TableDataSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TableDataSet)(nil)).Elem()
}

func (i TableDataSetArgs) ToTableDataSetOutput() TableDataSetOutput {
	return i.ToTableDataSetOutputWithContext(context.Background())
}

func (i TableDataSetArgs) ToTableDataSetOutputWithContext(ctx context.Context) TableDataSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TableDataSetOutput)
}

// TableDataSetArrayInput is an input type that accepts TableDataSetArray and TableDataSetArrayOutput values.
// You can construct a concrete instance of `TableDataSetArrayInput` via:
//
//	TableDataSetArray{ TableDataSetArgs{...} }
type TableDataSetArrayInput interface {
	pulumi.Input

	ToTableDataSetArrayOutput() TableDataSetArrayOutput
	ToTableDataSetArrayOutputWithContext(context.Context) TableDataSetArrayOutput
}

type TableDataSetArray []TableDataSetInput

func (TableDataSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TableDataSet)(nil)).Elem()
}

func (i TableDataSetArray) ToTableDataSetArrayOutput() TableDataSetArrayOutput {
	return i.ToTableDataSetArrayOutputWithContext(context.Background())
}

func (i TableDataSetArray) ToTableDataSetArrayOutputWithContext(ctx context.Context) TableDataSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TableDataSetArrayOutput)
}

// Groups a time series query definition with table options.
type TableDataSetOutput struct{ *pulumi.OutputState }

func (TableDataSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TableDataSet)(nil)).Elem()
}

func (o TableDataSetOutput) ToTableDataSetOutput() TableDataSetOutput {
	return o
}

func (o TableDataSetOutput) ToTableDataSetOutputWithContext(ctx context.Context) TableDataSetOutput {
	return o
}

// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
func (o TableDataSetOutput) MinAlignmentPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TableDataSet) *string { return v.MinAlignmentPeriod }).(pulumi.StringPtrOutput)
}

// Optional. Table display options for configuring how the table is rendered.
func (o TableDataSetOutput) TableDisplayOptions() TableDisplayOptionsPtrOutput {
	return o.ApplyT(func(v TableDataSet) *TableDisplayOptions { return v.TableDisplayOptions }).(TableDisplayOptionsPtrOutput)
}

// Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value i.e. "${resource.labels.project_id}."
func (o TableDataSetOutput) TableTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TableDataSet) *string { return v.TableTemplate }).(pulumi.StringPtrOutput)
}

// Fields for querying time series data from the Stackdriver metrics API.
func (o TableDataSetOutput) TimeSeriesQuery() TimeSeriesQueryOutput {
	return o.ApplyT(func(v TableDataSet) TimeSeriesQuery { return v.TimeSeriesQuery }).(TimeSeriesQueryOutput)
}

type TableDataSetArrayOutput struct{ *pulumi.OutputState }

func (TableDataSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TableDataSet)(nil)).Elem()
}

func (o TableDataSetArrayOutput) ToTableDataSetArrayOutput() TableDataSetArrayOutput {
	return o
}

func (o TableDataSetArrayOutput) ToTableDataSetArrayOutputWithContext(ctx context.Context) TableDataSetArrayOutput {
	return o
}

func (o TableDataSetArrayOutput) Index(i pulumi.IntInput) TableDataSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TableDataSet {
		return vs[0].([]TableDataSet)[vs[1].(int)]
	}).(TableDataSetOutput)
}

// Groups a time series query definition with table options.
type TableDataSetResponse struct {
	// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
	MinAlignmentPeriod string `pulumi:"minAlignmentPeriod"`
	// Optional. Table display options for configuring how the table is rendered.
	TableDisplayOptions TableDisplayOptionsResponse `pulumi:"tableDisplayOptions"`
	// Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value i.e. "${resource.labels.project_id}."
	TableTemplate string `pulumi:"tableTemplate"`
	// Fields for querying time series data from the Stackdriver metrics API.
	TimeSeriesQuery TimeSeriesQueryResponse `pulumi:"timeSeriesQuery"`
}

// Groups a time series query definition with table options.
type TableDataSetResponseOutput struct{ *pulumi.OutputState }

func (TableDataSetResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TableDataSetResponse)(nil)).Elem()
}

func (o TableDataSetResponseOutput) ToTableDataSetResponseOutput() TableDataSetResponseOutput {
	return o
}

func (o TableDataSetResponseOutput) ToTableDataSetResponseOutputWithContext(ctx context.Context) TableDataSetResponseOutput {
	return o
}

// Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
func (o TableDataSetResponseOutput) MinAlignmentPeriod() pulumi.StringOutput {
	return o.ApplyT(func(v TableDataSetResponse) string { return v.MinAlignmentPeriod }).(pulumi.StringOutput)
}

// Optional. Table display options for configuring how the table is rendered.
func (o TableDataSetResponseOutput) TableDisplayOptions() TableDisplayOptionsResponseOutput {
	return o.ApplyT(func(v TableDataSetResponse) TableDisplayOptionsResponse { return v.TableDisplayOptions }).(TableDisplayOptionsResponseOutput)
}

// Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value i.e. "${resource.labels.project_id}."
func (o TableDataSetResponseOutput) TableTemplate() pulumi.StringOutput {
	return o.ApplyT(func(v TableDataSetResponse) string { return v.TableTemplate }).(pulumi.StringOutput)
}

// Fields for querying time series data from the Stackdriver metrics API.
func (o TableDataSetResponseOutput) TimeSeriesQuery() TimeSeriesQueryResponseOutput {
	return o.ApplyT(func(v TableDataSetResponse) TimeSeriesQueryResponse { return v.TimeSeriesQuery }).(TimeSeriesQueryResponseOutput)
}

type TableDataSetResponseArrayOutput struct{ *pulumi.OutputState }

func (TableDataSetResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TableDataSetResponse)(nil)).Elem()
}

func (o TableDataSetResponseArrayOutput) ToTableDataSetResponseArrayOutput() TableDataSetResponseArrayOutput {
	return o
}

func (o TableDataSetResponseArrayOutput) ToTableDataSetResponseArrayOutputWithContext(ctx context.Context) TableDataSetResponseArrayOutput {
	return o
}

func (o TableDataSetResponseArrayOutput) Index(i pulumi.IntInput) TableDataSetResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TableDataSetResponse {
		return vs[0].([]TableDataSetResponse)[vs[1].(int)]
	}).(TableDataSetResponseOutput)
}

// Table display options that can be reused.
type TableDisplayOptions struct {
	// Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
	ShownColumns []string `pulumi:"shownColumns"`
}

// TableDisplayOptionsInput is an input type that accepts TableDisplayOptionsArgs and TableDisplayOptionsOutput values.
// You can construct a concrete instance of `TableDisplayOptionsInput` via:
//
//	TableDisplayOptionsArgs{...}
type TableDisplayOptionsInput interface {
	pulumi.Input

	ToTableDisplayOptionsOutput() TableDisplayOptionsOutput
	ToTableDisplayOptionsOutputWithContext(context.Context) TableDisplayOptionsOutput
}

// Table display options that can be reused.
type TableDisplayOptionsArgs struct {
	// Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
	ShownColumns pulumi.StringArrayInput `pulumi:"shownColumns"`
}

func (TableDisplayOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TableDisplayOptions)(nil)).Elem()
}

func (i TableDisplayOptionsArgs) ToTableDisplayOptionsOutput() TableDisplayOptionsOutput {
	return i.ToTableDisplayOptionsOutputWithContext(context.Background())
}

func (i TableDisplayOptionsArgs) ToTableDisplayOptionsOutputWithContext(ctx context.Context) TableDisplayOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TableDisplayOptionsOutput)
}

func (i TableDisplayOptionsArgs) ToTableDisplayOptionsPtrOutput() TableDisplayOptionsPtrOutput {
	return i.ToTableDisplayOptionsPtrOutputWithContext(context.Background())
}

func (i TableDisplayOptionsArgs) ToTableDisplayOptionsPtrOutputWithContext(ctx context.Context) TableDisplayOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TableDisplayOptionsOutput).ToTableDisplayOptionsPtrOutputWithContext(ctx)
}

// TableDisplayOptionsPtrInput is an input type that accepts TableDisplayOptionsArgs, TableDisplayOptionsPtr and TableDisplayOptionsPtrOutput values.
// You can construct a concrete instance of `TableDisplayOptionsPtrInput` via:
//
//	        TableDisplayOptionsArgs{...}
//
//	or:
//
//	        nil
type TableDisplayOptionsPtrInput interface {
	pulumi.Input

	ToTableDisplayOptionsPtrOutput() TableDisplayOptionsPtrOutput
	ToTableDisplayOptionsPtrOutputWithContext(context.Context) TableDisplayOptionsPtrOutput
}

type tableDisplayOptionsPtrType TableDisplayOptionsArgs

func TableDisplayOptionsPtr(v *TableDisplayOptionsArgs) TableDisplayOptionsPtrInput {
	return (*tableDisplayOptionsPtrType)(v)
}

func (*tableDisplayOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TableDisplayOptions)(nil)).Elem()
}

func (i *tableDisplayOptionsPtrType) ToTableDisplayOptionsPtrOutput() TableDisplayOptionsPtrOutput {
	return i.ToTableDisplayOptionsPtrOutputWithContext(context.Background())
}

func (i *tableDisplayOptionsPtrType) ToTableDisplayOptionsPtrOutputWithContext(ctx context.Context) TableDisplayOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TableDisplayOptionsPtrOutput)
}

// Table display options that can be reused.
type TableDisplayOptionsOutput struct{ *pulumi.OutputState }

func (TableDisplayOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TableDisplayOptions)(nil)).Elem()
}

func (o TableDisplayOptionsOutput) ToTableDisplayOptionsOutput() TableDisplayOptionsOutput {
	return o
}

func (o TableDisplayOptionsOutput) ToTableDisplayOptionsOutputWithContext(ctx context.Context) TableDisplayOptionsOutput {
	return o
}

func (o TableDisplayOptionsOutput) ToTableDisplayOptionsPtrOutput() TableDisplayOptionsPtrOutput {
	return o.ToTableDisplayOptionsPtrOutputWithContext(context.Background())
}

func (o TableDisplayOptionsOutput) ToTableDisplayOptionsPtrOutputWithContext(ctx context.Context) TableDisplayOptionsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TableDisplayOptions) *TableDisplayOptions {
		return &v
	}).(TableDisplayOptionsPtrOutput)
}

// Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
func (o TableDisplayOptionsOutput) ShownColumns() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TableDisplayOptions) []string { return v.ShownColumns }).(pulumi.StringArrayOutput)
}

type TableDisplayOptionsPtrOutput struct{ *pulumi.OutputState }

func (TableDisplayOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TableDisplayOptions)(nil)).Elem()
}

func (o TableDisplayOptionsPtrOutput) ToTableDisplayOptionsPtrOutput() TableDisplayOptionsPtrOutput {
	return o
}

func (o TableDisplayOptionsPtrOutput) ToTableDisplayOptionsPtrOutputWithContext(ctx context.Context) TableDisplayOptionsPtrOutput {
	return o
}

func (o TableDisplayOptionsPtrOutput) Elem() TableDisplayOptionsOutput {
	return o.ApplyT(func(v *TableDisplayOptions) TableDisplayOptions {
		if v != nil {
			return *v
		}
		var ret TableDisplayOptions
		return ret
	}).(TableDisplayOptionsOutput)
}

// Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
func (o TableDisplayOptionsPtrOutput) ShownColumns() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TableDisplayOptions) []string {
		if v == nil {
			return nil
		}
		return v.ShownColumns
	}).(pulumi.StringArrayOutput)
}

// Table display options that can be reused.
type TableDisplayOptionsResponse struct {
	// Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
	ShownColumns []string `pulumi:"shownColumns"`
}

// Table display options that can be reused.
type TableDisplayOptionsResponseOutput struct{ *pulumi.OutputState }

func (TableDisplayOptionsResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TableDisplayOptionsResponse)(nil)).Elem()
}

func (o TableDisplayOptionsResponseOutput) ToTableDisplayOptionsResponseOutput() TableDisplayOptionsResponseOutput {
	return o
}

func (o TableDisplayOptionsResponseOutput) ToTableDisplayOptionsResponseOutputWithContext(ctx context.Context) TableDisplayOptionsResponseOutput {
	return o
}

// Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
func (o TableDisplayOptionsResponseOutput) ShownColumns() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TableDisplayOptionsResponse) []string { return v.ShownColumns }).(pulumi.StringArrayOutput)
}

// A widget that displays textual content.
type Text struct {
	// The text content to be displayed.
	Content *string `pulumi:"content"`
	// How the text content is formatted.
	Format *TextFormat `pulumi:"format"`
	// How the text is styled
	Style *TextStyle `pulumi:"style"`
}

// TextInput is an input type that accepts TextArgs and TextOutput values.
// You can construct a concrete instance of `TextInput` via:
//
//	TextArgs{...}
type TextInput interface {
	pulumi.Input

	ToTextOutput() TextOutput
	ToTextOutputWithContext(context.Context) TextOutput
}

// A widget that displays textual content.
type TextArgs struct {
	// The text content to be displayed.
	Content pulumi.StringPtrInput `pulumi:"content"`
	// How the text content is formatted.
	Format TextFormatPtrInput `pulumi:"format"`
	// How the text is styled
	Style TextStylePtrInput `pulumi:"style"`
}

func (TextArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Text)(nil)).Elem()
}

func (i TextArgs) ToTextOutput() TextOutput {
	return i.ToTextOutputWithContext(context.Background())
}

func (i TextArgs) ToTextOutputWithContext(ctx context.Context) TextOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TextOutput)
}

func (i TextArgs) ToTextPtrOutput() TextPtrOutput {
	return i.ToTextPtrOutputWithContext(context.Background())
}

func (i TextArgs) ToTextPtrOutputWithContext(ctx context.Context) TextPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TextOutput).ToTextPtrOutputWithContext(ctx)
}

// TextPtrInput is an input type that accepts TextArgs, TextPtr and TextPtrOutput values.
// You can construct a concrete instance of `TextPtrInput` via:
//
//	        TextArgs{...}
//
//	or:
//
//	        nil
type TextPtrInput interface {
	pulumi.Input

	ToTextPtrOutput() TextPtrOutput
	ToTextPtrOutputWithContext(context.Context) TextPtrOutput
}

type textPtrType TextArgs

func TextPtr(v *TextArgs) TextPtrInput {
	return (*textPtrType)(v)
}

func (*textPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Text)(nil)).Elem()
}

func (i *textPtrType) ToTextPtrOutput() TextPtrOutput {
	return i.ToTextPtrOutputWithContext(context.Background())
}

func (i *textPtrType) ToTextPtrOutputWithContext(ctx context.Context) TextPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TextPtrOutput)
}

// A widget that displays textual content.
type TextOutput struct{ *pulumi.OutputState }

func (TextOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Text)(nil)).Elem()
}

func (o TextOutput) ToTextOutput() TextOutput {
	return o
}

func (o TextOutput) ToTextOutputWithContext(ctx context.Context) TextOutput {
	return o
}

func (o TextOutput) ToTextPtrOutput() TextPtrOutput {
	return o.ToTextPtrOutputWithContext(context.Background())
}

func (o TextOutput) ToTextPtrOutputWithContext(ctx context.Context) TextPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Text) *Text {
		return &v
	}).(TextPtrOutput)
}

// The text content to be displayed.
func (o TextOutput) Content() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Text) *string { return v.Content }).(pulumi.StringPtrOutput)
}

// How the text content is formatted.
func (o TextOutput) Format() TextFormatPtrOutput {
	return o.ApplyT(func(v Text) *TextFormat { return v.Format }).(TextFormatPtrOutput)
}

// How the text is styled
func (o TextOutput) Style() TextStylePtrOutput {
	return o.ApplyT(func(v Text) *TextStyle { return v.Style }).(TextStylePtrOutput)
}

type TextPtrOutput struct{ *pulumi.OutputState }

func (TextPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Text)(nil)).Elem()
}

func (o TextPtrOutput) ToTextPtrOutput() TextPtrOutput {
	return o
}

func (o TextPtrOutput) ToTextPtrOutputWithContext(ctx context.Context) TextPtrOutput {
	return o
}

func (o TextPtrOutput) Elem() TextOutput {
	return o.ApplyT(func(v *Text) Text {
		if v != nil {
			return *v
		}
		var ret Text
		return ret
	}).(TextOutput)
}

// The text content to be displayed.
func (o TextPtrOutput) Content() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Text) *string {
		if v == nil {
			return nil
		}
		return v.Content
	}).(pulumi.StringPtrOutput)
}

// How the text content is formatted.
func (o TextPtrOutput) Format() TextFormatPtrOutput {
	return o.ApplyT(func(v *Text) *TextFormat {
		if v == nil {
			return nil
		}
		return v.Format
	}).(TextFormatPtrOutput)
}

// How the text is styled
func (o TextPtrOutput) Style() TextStylePtrOutput {
	return o.ApplyT(func(v *Text) *TextStyle {
		if v == nil {
			return nil
		}
		return v.Style
	}).(TextStylePtrOutput)
}

// A widget that displays textual content.
type TextResponse struct {
	// The text content to be displayed.
	Content string `pulumi:"content"`
	// How the text content is formatted.
	Format string `pulumi:"format"`
	// How the text is styled
	Style TextStyleResponse `pulumi:"style"`
}

// A widget that displays textual content.
type TextResponseOutput struct{ *pulumi.OutputState }

func (TextResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TextResponse)(nil)).Elem()
}

func (o TextResponseOutput) ToTextResponseOutput() TextResponseOutput {
	return o
}

func (o TextResponseOutput) ToTextResponseOutputWithContext(ctx context.Context) TextResponseOutput {
	return o
}

// The text content to be displayed.
func (o TextResponseOutput) Content() pulumi.StringOutput {
	return o.ApplyT(func(v TextResponse) string { return v.Content }).(pulumi.StringOutput)
}

// How the text content is formatted.
func (o TextResponseOutput) Format() pulumi.StringOutput {
	return o.ApplyT(func(v TextResponse) string { return v.Format }).(pulumi.StringOutput)
}

// How the text is styled
func (o TextResponseOutput) Style() TextStyleResponseOutput {
	return o.ApplyT(func(v TextResponse) TextStyleResponse { return v.Style }).(TextStyleResponseOutput)
}

// Properties that determine how the title and content are styled
type TextStyle struct {
	// The background color as a hex string. "#RRGGBB" or "#RGB"
	BackgroundColor *string `pulumi:"backgroundColor"`
	// Font sizes for both the title and content. The title will still be larger relative to the content.
	FontSize *TextStyleFontSize `pulumi:"fontSize"`
	// The horizontal alignment of both the title and content
	HorizontalAlignment *TextStyleHorizontalAlignment `pulumi:"horizontalAlignment"`
	// The amount of padding around the widget
	Padding *TextStylePadding `pulumi:"padding"`
	// The pointer location for this widget (also sometimes called a "tail")
	PointerLocation *TextStylePointerLocation `pulumi:"pointerLocation"`
	// The text color as a hex string. "#RRGGBB" or "#RGB"
	TextColor *string `pulumi:"textColor"`
	// The vertical alignment of both the title and content
	VerticalAlignment *TextStyleVerticalAlignment `pulumi:"verticalAlignment"`
}

// TextStyleInput is an input type that accepts TextStyleArgs and TextStyleOutput values.
// You can construct a concrete instance of `TextStyleInput` via:
//
//	TextStyleArgs{...}
type TextStyleInput interface {
	pulumi.Input

	ToTextStyleOutput() TextStyleOutput
	ToTextStyleOutputWithContext(context.Context) TextStyleOutput
}

// Properties that determine how the title and content are styled
type TextStyleArgs struct {
	// The background color as a hex string. "#RRGGBB" or "#RGB"
	BackgroundColor pulumi.StringPtrInput `pulumi:"backgroundColor"`
	// Font sizes for both the title and content. The title will still be larger relative to the content.
	FontSize TextStyleFontSizePtrInput `pulumi:"fontSize"`
	// The horizontal alignment of both the title and content
	HorizontalAlignment TextStyleHorizontalAlignmentPtrInput `pulumi:"horizontalAlignment"`
	// The amount of padding around the widget
	Padding TextStylePaddingPtrInput `pulumi:"padding"`
	// The pointer location for this widget (also sometimes called a "tail")
	PointerLocation TextStylePointerLocationPtrInput `pulumi:"pointerLocation"`
	// The text color as a hex string. "#RRGGBB" or "#RGB"
	TextColor pulumi.StringPtrInput `pulumi:"textColor"`
	// The vertical alignment of both the title and content
	VerticalAlignment TextStyleVerticalAlignmentPtrInput `pulumi:"verticalAlignment"`
}

func (TextStyleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TextStyle)(nil)).Elem()
}

func (i TextStyleArgs) ToTextStyleOutput() TextStyleOutput {
	return i.ToTextStyleOutputWithContext(context.Background())
}

func (i TextStyleArgs) ToTextStyleOutputWithContext(ctx context.Context) TextStyleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TextStyleOutput)
}

func (i TextStyleArgs) ToTextStylePtrOutput() TextStylePtrOutput {
	return i.ToTextStylePtrOutputWithContext(context.Background())
}

func (i TextStyleArgs) ToTextStylePtrOutputWithContext(ctx context.Context) TextStylePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TextStyleOutput).ToTextStylePtrOutputWithContext(ctx)
}

// TextStylePtrInput is an input type that accepts TextStyleArgs, TextStylePtr and TextStylePtrOutput values.
// You can construct a concrete instance of `TextStylePtrInput` via:
//
//	        TextStyleArgs{...}
//
//	or:
//
//	        nil
type TextStylePtrInput interface {
	pulumi.Input

	ToTextStylePtrOutput() TextStylePtrOutput
	ToTextStylePtrOutputWithContext(context.Context) TextStylePtrOutput
}

type textStylePtrType TextStyleArgs

func TextStylePtr(v *TextStyleArgs) TextStylePtrInput {
	return (*textStylePtrType)(v)
}

func (*textStylePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TextStyle)(nil)).Elem()
}

func (i *textStylePtrType) ToTextStylePtrOutput() TextStylePtrOutput {
	return i.ToTextStylePtrOutputWithContext(context.Background())
}

func (i *textStylePtrType) ToTextStylePtrOutputWithContext(ctx context.Context) TextStylePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TextStylePtrOutput)
}

// Properties that determine how the title and content are styled
type TextStyleOutput struct{ *pulumi.OutputState }

func (TextStyleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TextStyle)(nil)).Elem()
}

func (o TextStyleOutput) ToTextStyleOutput() TextStyleOutput {
	return o
}

func (o TextStyleOutput) ToTextStyleOutputWithContext(ctx context.Context) TextStyleOutput {
	return o
}

func (o TextStyleOutput) ToTextStylePtrOutput() TextStylePtrOutput {
	return o.ToTextStylePtrOutputWithContext(context.Background())
}

func (o TextStyleOutput) ToTextStylePtrOutputWithContext(ctx context.Context) TextStylePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TextStyle) *TextStyle {
		return &v
	}).(TextStylePtrOutput)
}

// The background color as a hex string. "#RRGGBB" or "#RGB"
func (o TextStyleOutput) BackgroundColor() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TextStyle) *string { return v.BackgroundColor }).(pulumi.StringPtrOutput)
}

// Font sizes for both the title and content. The title will still be larger relative to the content.
func (o TextStyleOutput) FontSize() TextStyleFontSizePtrOutput {
	return o.ApplyT(func(v TextStyle) *TextStyleFontSize { return v.FontSize }).(TextStyleFontSizePtrOutput)
}

// The horizontal alignment of both the title and content
func (o TextStyleOutput) HorizontalAlignment() TextStyleHorizontalAlignmentPtrOutput {
	return o.ApplyT(func(v TextStyle) *TextStyleHorizontalAlignment { return v.HorizontalAlignment }).(TextStyleHorizontalAlignmentPtrOutput)
}

// The amount of padding around the widget
func (o TextStyleOutput) Padding() TextStylePaddingPtrOutput {
	return o.ApplyT(func(v TextStyle) *TextStylePadding { return v.Padding }).(TextStylePaddingPtrOutput)
}

// The pointer location for this widget (also sometimes called a "tail")
func (o TextStyleOutput) PointerLocation() TextStylePointerLocationPtrOutput {
	return o.ApplyT(func(v TextStyle) *TextStylePointerLocation { return v.PointerLocation }).(TextStylePointerLocationPtrOutput)
}

// The text color as a hex string. "#RRGGBB" or "#RGB"
func (o TextStyleOutput) TextColor() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TextStyle) *string { return v.TextColor }).(pulumi.StringPtrOutput)
}

// The vertical alignment of both the title and content
func (o TextStyleOutput) VerticalAlignment() TextStyleVerticalAlignmentPtrOutput {
	return o.ApplyT(func(v TextStyle) *TextStyleVerticalAlignment { return v.VerticalAlignment }).(TextStyleVerticalAlignmentPtrOutput)
}

type TextStylePtrOutput struct{ *pulumi.OutputState }

func (TextStylePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TextStyle)(nil)).Elem()
}

func (o TextStylePtrOutput) ToTextStylePtrOutput() TextStylePtrOutput {
	return o
}

func (o TextStylePtrOutput) ToTextStylePtrOutputWithContext(ctx context.Context) TextStylePtrOutput {
	return o
}

func (o TextStylePtrOutput) Elem() TextStyleOutput {
	return o.ApplyT(func(v *TextStyle) TextStyle {
		if v != nil {
			return *v
		}
		var ret TextStyle
		return ret
	}).(TextStyleOutput)
}

// The background color as a hex string. "#RRGGBB" or "#RGB"
func (o TextStylePtrOutput) BackgroundColor() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TextStyle) *string {
		if v == nil {
			return nil
		}
		return v.BackgroundColor
	}).(pulumi.StringPtrOutput)
}

// Font sizes for both the title and content. The title will still be larger relative to the content.
func (o TextStylePtrOutput) FontSize() TextStyleFontSizePtrOutput {
	return o.ApplyT(func(v *TextStyle) *TextStyleFontSize {
		if v == nil {
			return nil
		}
		return v.FontSize
	}).(TextStyleFontSizePtrOutput)
}

// The horizontal alignment of both the title and content
func (o TextStylePtrOutput) HorizontalAlignment() TextStyleHorizontalAlignmentPtrOutput {
	return o.ApplyT(func(v *TextStyle) *TextStyleHorizontalAlignment {
		if v == nil {
			return nil
		}
		return v.HorizontalAlignment
	}).(TextStyleHorizontalAlignmentPtrOutput)
}

// The amount of padding around the widget
func (o TextStylePtrOutput) Padding() TextStylePaddingPtrOutput {
	return o.ApplyT(func(v *TextStyle) *TextStylePadding {
		if v == nil {
			return nil
		}
		return v.Padding
	}).(TextStylePaddingPtrOutput)
}

// The pointer location for this widget (also sometimes called a "tail")
func (o TextStylePtrOutput) PointerLocation() TextStylePointerLocationPtrOutput {
	return o.ApplyT(func(v *TextStyle) *TextStylePointerLocation {
		if v == nil {
			return nil
		}
		return v.PointerLocation
	}).(TextStylePointerLocationPtrOutput)
}

// The text color as a hex string. "#RRGGBB" or "#RGB"
func (o TextStylePtrOutput) TextColor() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TextStyle) *string {
		if v == nil {
			return nil
		}
		return v.TextColor
	}).(pulumi.StringPtrOutput)
}

// The vertical alignment of both the title and content
func (o TextStylePtrOutput) VerticalAlignment() TextStyleVerticalAlignmentPtrOutput {
	return o.ApplyT(func(v *TextStyle) *TextStyleVerticalAlignment {
		if v == nil {
			return nil
		}
		return v.VerticalAlignment
	}).(TextStyleVerticalAlignmentPtrOutput)
}

// Properties that determine how the title and content are styled
type TextStyleResponse struct {
	// The background color as a hex string. "#RRGGBB" or "#RGB"
	BackgroundColor string `pulumi:"backgroundColor"`
	// Font sizes for both the title and content. The title will still be larger relative to the content.
	FontSize string `pulumi:"fontSize"`
	// The horizontal alignment of both the title and content
	HorizontalAlignment string `pulumi:"horizontalAlignment"`
	// The amount of padding around the widget
	Padding string `pulumi:"padding"`
	// The pointer location for this widget (also sometimes called a "tail")
	PointerLocation string `pulumi:"pointerLocation"`
	// The text color as a hex string. "#RRGGBB" or "#RGB"
	TextColor string `pulumi:"textColor"`
	// The vertical alignment of both the title and content
	VerticalAlignment string `pulumi:"verticalAlignment"`
}

// Properties that determine how the title and content are styled
type TextStyleResponseOutput struct{ *pulumi.OutputState }

func (TextStyleResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TextStyleResponse)(nil)).Elem()
}

func (o TextStyleResponseOutput) ToTextStyleResponseOutput() TextStyleResponseOutput {
	return o
}

func (o TextStyleResponseOutput) ToTextStyleResponseOutputWithContext(ctx context.Context) TextStyleResponseOutput {
	return o
}

// The background color as a hex string. "#RRGGBB" or "#RGB"
func (o TextStyleResponseOutput) BackgroundColor() pulumi.StringOutput {
	return o.ApplyT(func(v TextStyleResponse) string { return v.BackgroundColor }).(pulumi.StringOutput)
}

// Font sizes for both the title and content. The title will still be larger relative to the content.
func (o TextStyleResponseOutput) FontSize() pulumi.StringOutput {
	return o.ApplyT(func(v TextStyleResponse) string { return v.FontSize }).(pulumi.StringOutput)
}

// The horizontal alignment of both the title and content
func (o TextStyleResponseOutput) HorizontalAlignment() pulumi.StringOutput {
	return o.ApplyT(func(v TextStyleResponse) string { return v.HorizontalAlignment }).(pulumi.StringOutput)
}

// The amount of padding around the widget
func (o TextStyleResponseOutput) Padding() pulumi.StringOutput {
	return o.ApplyT(func(v TextStyleResponse) string { return v.Padding }).(pulumi.StringOutput)
}

// The pointer location for this widget (also sometimes called a "tail")
func (o TextStyleResponseOutput) PointerLocation() pulumi.StringOutput {
	return o.ApplyT(func(v TextStyleResponse) string { return v.PointerLocation }).(pulumi.StringOutput)
}

// The text color as a hex string. "#RRGGBB" or "#RGB"
func (o TextStyleResponseOutput) TextColor() pulumi.StringOutput {
	return o.ApplyT(func(v TextStyleResponse) string { return v.TextColor }).(pulumi.StringOutput)
}

// The vertical alignment of both the title and content
func (o TextStyleResponseOutput) VerticalAlignment() pulumi.StringOutput {
	return o.ApplyT(func(v TextStyleResponse) string { return v.VerticalAlignment }).(pulumi.StringOutput)
}

// Defines a threshold for categorizing time series values.
type Threshold struct {
	// The state color for this threshold. Color is not allowed in a XyChart.
	Color *ThresholdColor `pulumi:"color"`
	// The direction for the current threshold. Direction is not allowed in a XyChart.
	Direction *ThresholdDirection `pulumi:"direction"`
	// A label for the threshold.
	Label *string `pulumi:"label"`
	// The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
	TargetAxis *ThresholdTargetAxis `pulumi:"targetAxis"`
	// The value of the threshold. The value should be defined in the native scale of the metric.
	Value *float64 `pulumi:"value"`
}

// ThresholdInput is an input type that accepts ThresholdArgs and ThresholdOutput values.
// You can construct a concrete instance of `ThresholdInput` via:
//
//	ThresholdArgs{...}
type ThresholdInput interface {
	pulumi.Input

	ToThresholdOutput() ThresholdOutput
	ToThresholdOutputWithContext(context.Context) ThresholdOutput
}

// Defines a threshold for categorizing time series values.
type ThresholdArgs struct {
	// The state color for this threshold. Color is not allowed in a XyChart.
	Color ThresholdColorPtrInput `pulumi:"color"`
	// The direction for the current threshold. Direction is not allowed in a XyChart.
	Direction ThresholdDirectionPtrInput `pulumi:"direction"`
	// A label for the threshold.
	Label pulumi.StringPtrInput `pulumi:"label"`
	// The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
	TargetAxis ThresholdTargetAxisPtrInput `pulumi:"targetAxis"`
	// The value of the threshold. The value should be defined in the native scale of the metric.
	Value pulumi.Float64PtrInput `pulumi:"value"`
}

func (ThresholdArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Threshold)(nil)).Elem()
}

func (i ThresholdArgs) ToThresholdOutput() ThresholdOutput {
	return i.ToThresholdOutputWithContext(context.Background())
}

func (i ThresholdArgs) ToThresholdOutputWithContext(ctx context.Context) ThresholdOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ThresholdOutput)
}

// ThresholdArrayInput is an input type that accepts ThresholdArray and ThresholdArrayOutput values.
// You can construct a concrete instance of `ThresholdArrayInput` via:
//
//	ThresholdArray{ ThresholdArgs{...} }
type ThresholdArrayInput interface {
	pulumi.Input

	ToThresholdArrayOutput() ThresholdArrayOutput
	ToThresholdArrayOutputWithContext(context.Context) ThresholdArrayOutput
}

type ThresholdArray []ThresholdInput

func (ThresholdArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Threshold)(nil)).Elem()
}

func (i ThresholdArray) ToThresholdArrayOutput() ThresholdArrayOutput {
	return i.ToThresholdArrayOutputWithContext(context.Background())
}

func (i ThresholdArray) ToThresholdArrayOutputWithContext(ctx context.Context) ThresholdArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ThresholdArrayOutput)
}

// Defines a threshold for categorizing time series values.
type ThresholdOutput struct{ *pulumi.OutputState }

func (ThresholdOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Threshold)(nil)).Elem()
}

func (o ThresholdOutput) ToThresholdOutput() ThresholdOutput {
	return o
}

func (o ThresholdOutput) ToThresholdOutputWithContext(ctx context.Context) ThresholdOutput {
	return o
}

// The state color for this threshold. Color is not allowed in a XyChart.
func (o ThresholdOutput) Color() ThresholdColorPtrOutput {
	return o.ApplyT(func(v Threshold) *ThresholdColor { return v.Color }).(ThresholdColorPtrOutput)
}

// The direction for the current threshold. Direction is not allowed in a XyChart.
func (o ThresholdOutput) Direction() ThresholdDirectionPtrOutput {
	return o.ApplyT(func(v Threshold) *ThresholdDirection { return v.Direction }).(ThresholdDirectionPtrOutput)
}

// A label for the threshold.
func (o ThresholdOutput) Label() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Threshold) *string { return v.Label }).(pulumi.StringPtrOutput)
}

// The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
func (o ThresholdOutput) TargetAxis() ThresholdTargetAxisPtrOutput {
	return o.ApplyT(func(v Threshold) *ThresholdTargetAxis { return v.TargetAxis }).(ThresholdTargetAxisPtrOutput)
}

// The value of the threshold. The value should be defined in the native scale of the metric.
func (o ThresholdOutput) Value() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Threshold) *float64 { return v.Value }).(pulumi.Float64PtrOutput)
}

type ThresholdArrayOutput struct{ *pulumi.OutputState }

func (ThresholdArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Threshold)(nil)).Elem()
}

func (o ThresholdArrayOutput) ToThresholdArrayOutput() ThresholdArrayOutput {
	return o
}

func (o ThresholdArrayOutput) ToThresholdArrayOutputWithContext(ctx context.Context) ThresholdArrayOutput {
	return o
}

func (o ThresholdArrayOutput) Index(i pulumi.IntInput) ThresholdOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Threshold {
		return vs[0].([]Threshold)[vs[1].(int)]
	}).(ThresholdOutput)
}

// Defines a threshold for categorizing time series values.
type ThresholdResponse struct {
	// The state color for this threshold. Color is not allowed in a XyChart.
	Color string `pulumi:"color"`
	// The direction for the current threshold. Direction is not allowed in a XyChart.
	Direction string `pulumi:"direction"`
	// A label for the threshold.
	Label string `pulumi:"label"`
	// The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
	TargetAxis string `pulumi:"targetAxis"`
	// The value of the threshold. The value should be defined in the native scale of the metric.
	Value float64 `pulumi:"value"`
}

// Defines a threshold for categorizing time series values.
type ThresholdResponseOutput struct{ *pulumi.OutputState }

func (ThresholdResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ThresholdResponse)(nil)).Elem()
}

func (o ThresholdResponseOutput) ToThresholdResponseOutput() ThresholdResponseOutput {
	return o
}

func (o ThresholdResponseOutput) ToThresholdResponseOutputWithContext(ctx context.Context) ThresholdResponseOutput {
	return o
}

// The state color for this threshold. Color is not allowed in a XyChart.
func (o ThresholdResponseOutput) Color() pulumi.StringOutput {
	return o.ApplyT(func(v ThresholdResponse) string { return v.Color }).(pulumi.StringOutput)
}

// The direction for the current threshold. Direction is not allowed in a XyChart.
func (o ThresholdResponseOutput) Direction() pulumi.StringOutput {
	return o.ApplyT(func(v ThresholdResponse) string { return v.Direction }).(pulumi.StringOutput)
}

// A label for the threshold.
func (o ThresholdResponseOutput) Label() pulumi.StringOutput {
	return o.ApplyT(func(v ThresholdResponse) string { return v.Label }).(pulumi.StringOutput)
}

// The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
func (o ThresholdResponseOutput) TargetAxis() pulumi.StringOutput {
	return o.ApplyT(func(v ThresholdResponse) string { return v.TargetAxis }).(pulumi.StringOutput)
}

// The value of the threshold. The value should be defined in the native scale of the metric.
func (o ThresholdResponseOutput) Value() pulumi.Float64Output {
	return o.ApplyT(func(v ThresholdResponse) float64 { return v.Value }).(pulumi.Float64Output)
}

type ThresholdResponseArrayOutput struct{ *pulumi.OutputState }

func (ThresholdResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ThresholdResponse)(nil)).Elem()
}

func (o ThresholdResponseArrayOutput) ToThresholdResponseArrayOutput() ThresholdResponseArrayOutput {
	return o
}

func (o ThresholdResponseArrayOutput) ToThresholdResponseArrayOutputWithContext(ctx context.Context) ThresholdResponseArrayOutput {
	return o
}

func (o ThresholdResponseArrayOutput) Index(i pulumi.IntInput) ThresholdResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ThresholdResponse {
		return vs[0].([]ThresholdResponse)[vs[1].(int)]
	}).(ThresholdResponseOutput)
}

// A single tile in the mosaic. The placement and size of the tile are configurable.
type Tile struct {
	// The height of the tile, measured in grid blocks. Tiles must have a minimum height of 1.
	Height *int `pulumi:"height"`
	// The informational widget contained in the tile. For example an XyChart.
	Widget *Widget `pulumi:"widget"`
	// The width of the tile, measured in grid blocks. Tiles must have a minimum width of 1.
	Width *int `pulumi:"width"`
	// The zero-indexed position of the tile in grid blocks relative to the left edge of the grid. Tiles must be contained within the specified number of columns. x_pos cannot be negative.
	XPos *int `pulumi:"xPos"`
	// The zero-indexed position of the tile in grid blocks relative to the top edge of the grid. y_pos cannot be negative.
	YPos *int `pulumi:"yPos"`
}

// TileInput is an input type that accepts TileArgs and TileOutput values.
// You can construct a concrete instance of `TileInput` via:
//
//	TileArgs{...}
type TileInput interface {
	pulumi.Input

	ToTileOutput() TileOutput
	ToTileOutputWithContext(context.Context) TileOutput
}

// A single tile in the mosaic. The placement and size of the tile are configurable.
type TileArgs struct {
	// The height of the tile, measured in grid blocks. Tiles must have a minimum height of 1.
	Height pulumi.IntPtrInput `pulumi:"height"`
	// The informational widget contained in the tile. For example an XyChart.
	Widget WidgetPtrInput `pulumi:"widget"`
	// The width of the tile, measured in grid blocks. Tiles must have a minimum width of 1.
	Width pulumi.IntPtrInput `pulumi:"width"`
	// The zero-indexed position of the tile in grid blocks relative to the left edge of the grid. Tiles must be contained within the specified number of columns. x_pos cannot be negative.
	XPos pulumi.IntPtrInput `pulumi:"xPos"`
	// The zero-indexed position of the tile in grid blocks relative to the top edge of the grid. y_pos cannot be negative.
	YPos pulumi.IntPtrInput `pulumi:"yPos"`
}

func (TileArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Tile)(nil)).Elem()
}

func (i TileArgs) ToTileOutput() TileOutput {
	return i.ToTileOutputWithContext(context.Background())
}

func (i TileArgs) ToTileOutputWithContext(ctx context.Context) TileOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TileOutput)
}

// TileArrayInput is an input type that accepts TileArray and TileArrayOutput values.
// You can construct a concrete instance of `TileArrayInput` via:
//
//	TileArray{ TileArgs{...} }
type TileArrayInput interface {
	pulumi.Input

	ToTileArrayOutput() TileArrayOutput
	ToTileArrayOutputWithContext(context.Context) TileArrayOutput
}

type TileArray []TileInput

func (TileArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Tile)(nil)).Elem()
}

func (i TileArray) ToTileArrayOutput() TileArrayOutput {
	return i.ToTileArrayOutputWithContext(context.Background())
}

func (i TileArray) ToTileArrayOutputWithContext(ctx context.Context) TileArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TileArrayOutput)
}

// A single tile in the mosaic. The placement and size of the tile are configurable.
type TileOutput struct{ *pulumi.OutputState }

func (TileOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Tile)(nil)).Elem()
}

func (o TileOutput) ToTileOutput() TileOutput {
	return o
}

func (o TileOutput) ToTileOutputWithContext(ctx context.Context) TileOutput {
	return o
}

// The height of the tile, measured in grid blocks. Tiles must have a minimum height of 1.
func (o TileOutput) Height() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Tile) *int { return v.Height }).(pulumi.IntPtrOutput)
}

// The informational widget contained in the tile. For example an XyChart.
func (o TileOutput) Widget() WidgetPtrOutput {
	return o.ApplyT(func(v Tile) *Widget { return v.Widget }).(WidgetPtrOutput)
}

// The width of the tile, measured in grid blocks. Tiles must have a minimum width of 1.
func (o TileOutput) Width() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Tile) *int { return v.Width }).(pulumi.IntPtrOutput)
}

// The zero-indexed position of the tile in grid blocks relative to the left edge of the grid. Tiles must be contained within the specified number of columns. x_pos cannot be negative.
func (o TileOutput) XPos() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Tile) *int { return v.XPos }).(pulumi.IntPtrOutput)
}

// The zero-indexed position of the tile in grid blocks relative to the top edge of the grid. y_pos cannot be negative.
func (o TileOutput) YPos() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Tile) *int { return v.YPos }).(pulumi.IntPtrOutput)
}

type TileArrayOutput struct{ *pulumi.OutputState }

func (TileArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Tile)(nil)).Elem()
}

func (o TileArrayOutput) ToTileArrayOutput() TileArrayOutput {
	return o
}

func (o TileArrayOutput) ToTileArrayOutputWithContext(ctx context.Context) TileArrayOutput {
	return o
}

func (o TileArrayOutput) Index(i pulumi.IntInput) TileOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Tile {
		return vs[0].([]Tile)[vs[1].(int)]
	}).(TileOutput)
}

// A single tile in the mosaic. The placement and size of the tile are configurable.
type TileResponse struct {
	// The height of the tile, measured in grid blocks. Tiles must have a minimum height of 1.
	Height int `pulumi:"height"`
	// The informational widget contained in the tile. For example an XyChart.
	Widget WidgetResponse `pulumi:"widget"`
	// The width of the tile, measured in grid blocks. Tiles must have a minimum width of 1.
	Width int `pulumi:"width"`
	// The zero-indexed position of the tile in grid blocks relative to the left edge of the grid. Tiles must be contained within the specified number of columns. x_pos cannot be negative.
	XPos int `pulumi:"xPos"`
	// The zero-indexed position of the tile in grid blocks relative to the top edge of the grid. y_pos cannot be negative.
	YPos int `pulumi:"yPos"`
}

// A single tile in the mosaic. The placement and size of the tile are configurable.
type TileResponseOutput struct{ *pulumi.OutputState }

func (TileResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TileResponse)(nil)).Elem()
}

func (o TileResponseOutput) ToTileResponseOutput() TileResponseOutput {
	return o
}

func (o TileResponseOutput) ToTileResponseOutputWithContext(ctx context.Context) TileResponseOutput {
	return o
}

// The height of the tile, measured in grid blocks. Tiles must have a minimum height of 1.
func (o TileResponseOutput) Height() pulumi.IntOutput {
	return o.ApplyT(func(v TileResponse) int { return v.Height }).(pulumi.IntOutput)
}

// The informational widget contained in the tile. For example an XyChart.
func (o TileResponseOutput) Widget() WidgetResponseOutput {
	return o.ApplyT(func(v TileResponse) WidgetResponse { return v.Widget }).(WidgetResponseOutput)
}

// The width of the tile, measured in grid blocks. Tiles must have a minimum width of 1.
func (o TileResponseOutput) Width() pulumi.IntOutput {
	return o.ApplyT(func(v TileResponse) int { return v.Width }).(pulumi.IntOutput)
}

// The zero-indexed position of the tile in grid blocks relative to the left edge of the grid. Tiles must be contained within the specified number of columns. x_pos cannot be negative.
func (o TileResponseOutput) XPos() pulumi.IntOutput {
	return o.ApplyT(func(v TileResponse) int { return v.XPos }).(pulumi.IntOutput)
}

// The zero-indexed position of the tile in grid blocks relative to the top edge of the grid. y_pos cannot be negative.
func (o TileResponseOutput) YPos() pulumi.IntOutput {
	return o.ApplyT(func(v TileResponse) int { return v.YPos }).(pulumi.IntOutput)
}

type TileResponseArrayOutput struct{ *pulumi.OutputState }

func (TileResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TileResponse)(nil)).Elem()
}

func (o TileResponseArrayOutput) ToTileResponseArrayOutput() TileResponseArrayOutput {
	return o
}

func (o TileResponseArrayOutput) ToTileResponseArrayOutputWithContext(ctx context.Context) TileResponseArrayOutput {
	return o
}

func (o TileResponseArrayOutput) Index(i pulumi.IntInput) TileResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TileResponse {
		return vs[0].([]TileResponse)[vs[1].(int)]
	}).(TileResponseOutput)
}

// A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method.
type TimeSeriesFilter struct {
	// By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
	Aggregation *Aggregation `pulumi:"aggregation"`
	// The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
	Filter string `pulumi:"filter"`
	// Ranking based time series filter.
	PickTimeSeriesFilter *PickTimeSeriesFilter `pulumi:"pickTimeSeriesFilter"`
	// Apply a second aggregation after aggregation is applied.
	SecondaryAggregation *Aggregation `pulumi:"secondaryAggregation"`
	// Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
	//
	// Deprecated: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
	StatisticalTimeSeriesFilter *StatisticalTimeSeriesFilter `pulumi:"statisticalTimeSeriesFilter"`
}

// TimeSeriesFilterInput is an input type that accepts TimeSeriesFilterArgs and TimeSeriesFilterOutput values.
// You can construct a concrete instance of `TimeSeriesFilterInput` via:
//
//	TimeSeriesFilterArgs{...}
type TimeSeriesFilterInput interface {
	pulumi.Input

	ToTimeSeriesFilterOutput() TimeSeriesFilterOutput
	ToTimeSeriesFilterOutputWithContext(context.Context) TimeSeriesFilterOutput
}

// A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method.
type TimeSeriesFilterArgs struct {
	// By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
	Aggregation AggregationPtrInput `pulumi:"aggregation"`
	// The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
	Filter pulumi.StringInput `pulumi:"filter"`
	// Ranking based time series filter.
	PickTimeSeriesFilter PickTimeSeriesFilterPtrInput `pulumi:"pickTimeSeriesFilter"`
	// Apply a second aggregation after aggregation is applied.
	SecondaryAggregation AggregationPtrInput `pulumi:"secondaryAggregation"`
	// Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
	//
	// Deprecated: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
	StatisticalTimeSeriesFilter StatisticalTimeSeriesFilterPtrInput `pulumi:"statisticalTimeSeriesFilter"`
}

func (TimeSeriesFilterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesFilter)(nil)).Elem()
}

func (i TimeSeriesFilterArgs) ToTimeSeriesFilterOutput() TimeSeriesFilterOutput {
	return i.ToTimeSeriesFilterOutputWithContext(context.Background())
}

func (i TimeSeriesFilterArgs) ToTimeSeriesFilterOutputWithContext(ctx context.Context) TimeSeriesFilterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesFilterOutput)
}

func (i TimeSeriesFilterArgs) ToTimeSeriesFilterPtrOutput() TimeSeriesFilterPtrOutput {
	return i.ToTimeSeriesFilterPtrOutputWithContext(context.Background())
}

func (i TimeSeriesFilterArgs) ToTimeSeriesFilterPtrOutputWithContext(ctx context.Context) TimeSeriesFilterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesFilterOutput).ToTimeSeriesFilterPtrOutputWithContext(ctx)
}

// TimeSeriesFilterPtrInput is an input type that accepts TimeSeriesFilterArgs, TimeSeriesFilterPtr and TimeSeriesFilterPtrOutput values.
// You can construct a concrete instance of `TimeSeriesFilterPtrInput` via:
//
//	        TimeSeriesFilterArgs{...}
//
//	or:
//
//	        nil
type TimeSeriesFilterPtrInput interface {
	pulumi.Input

	ToTimeSeriesFilterPtrOutput() TimeSeriesFilterPtrOutput
	ToTimeSeriesFilterPtrOutputWithContext(context.Context) TimeSeriesFilterPtrOutput
}

type timeSeriesFilterPtrType TimeSeriesFilterArgs

func TimeSeriesFilterPtr(v *TimeSeriesFilterArgs) TimeSeriesFilterPtrInput {
	return (*timeSeriesFilterPtrType)(v)
}

func (*timeSeriesFilterPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeSeriesFilter)(nil)).Elem()
}

func (i *timeSeriesFilterPtrType) ToTimeSeriesFilterPtrOutput() TimeSeriesFilterPtrOutput {
	return i.ToTimeSeriesFilterPtrOutputWithContext(context.Background())
}

func (i *timeSeriesFilterPtrType) ToTimeSeriesFilterPtrOutputWithContext(ctx context.Context) TimeSeriesFilterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesFilterPtrOutput)
}

// A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method.
type TimeSeriesFilterOutput struct{ *pulumi.OutputState }

func (TimeSeriesFilterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesFilter)(nil)).Elem()
}

func (o TimeSeriesFilterOutput) ToTimeSeriesFilterOutput() TimeSeriesFilterOutput {
	return o
}

func (o TimeSeriesFilterOutput) ToTimeSeriesFilterOutputWithContext(ctx context.Context) TimeSeriesFilterOutput {
	return o
}

func (o TimeSeriesFilterOutput) ToTimeSeriesFilterPtrOutput() TimeSeriesFilterPtrOutput {
	return o.ToTimeSeriesFilterPtrOutputWithContext(context.Background())
}

func (o TimeSeriesFilterOutput) ToTimeSeriesFilterPtrOutputWithContext(ctx context.Context) TimeSeriesFilterPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TimeSeriesFilter) *TimeSeriesFilter {
		return &v
	}).(TimeSeriesFilterPtrOutput)
}

// By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
func (o TimeSeriesFilterOutput) Aggregation() AggregationPtrOutput {
	return o.ApplyT(func(v TimeSeriesFilter) *Aggregation { return v.Aggregation }).(AggregationPtrOutput)
}

// The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
func (o TimeSeriesFilterOutput) Filter() pulumi.StringOutput {
	return o.ApplyT(func(v TimeSeriesFilter) string { return v.Filter }).(pulumi.StringOutput)
}

// Ranking based time series filter.
func (o TimeSeriesFilterOutput) PickTimeSeriesFilter() PickTimeSeriesFilterPtrOutput {
	return o.ApplyT(func(v TimeSeriesFilter) *PickTimeSeriesFilter { return v.PickTimeSeriesFilter }).(PickTimeSeriesFilterPtrOutput)
}

// Apply a second aggregation after aggregation is applied.
func (o TimeSeriesFilterOutput) SecondaryAggregation() AggregationPtrOutput {
	return o.ApplyT(func(v TimeSeriesFilter) *Aggregation { return v.SecondaryAggregation }).(AggregationPtrOutput)
}

// Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
//
// Deprecated: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
func (o TimeSeriesFilterOutput) StatisticalTimeSeriesFilter() StatisticalTimeSeriesFilterPtrOutput {
	return o.ApplyT(func(v TimeSeriesFilter) *StatisticalTimeSeriesFilter { return v.StatisticalTimeSeriesFilter }).(StatisticalTimeSeriesFilterPtrOutput)
}

type TimeSeriesFilterPtrOutput struct{ *pulumi.OutputState }

func (TimeSeriesFilterPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeSeriesFilter)(nil)).Elem()
}

func (o TimeSeriesFilterPtrOutput) ToTimeSeriesFilterPtrOutput() TimeSeriesFilterPtrOutput {
	return o
}

func (o TimeSeriesFilterPtrOutput) ToTimeSeriesFilterPtrOutputWithContext(ctx context.Context) TimeSeriesFilterPtrOutput {
	return o
}

func (o TimeSeriesFilterPtrOutput) Elem() TimeSeriesFilterOutput {
	return o.ApplyT(func(v *TimeSeriesFilter) TimeSeriesFilter {
		if v != nil {
			return *v
		}
		var ret TimeSeriesFilter
		return ret
	}).(TimeSeriesFilterOutput)
}

// By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
func (o TimeSeriesFilterPtrOutput) Aggregation() AggregationPtrOutput {
	return o.ApplyT(func(v *TimeSeriesFilter) *Aggregation {
		if v == nil {
			return nil
		}
		return v.Aggregation
	}).(AggregationPtrOutput)
}

// The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
func (o TimeSeriesFilterPtrOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeSeriesFilter) *string {
		if v == nil {
			return nil
		}
		return &v.Filter
	}).(pulumi.StringPtrOutput)
}

// Ranking based time series filter.
func (o TimeSeriesFilterPtrOutput) PickTimeSeriesFilter() PickTimeSeriesFilterPtrOutput {
	return o.ApplyT(func(v *TimeSeriesFilter) *PickTimeSeriesFilter {
		if v == nil {
			return nil
		}
		return v.PickTimeSeriesFilter
	}).(PickTimeSeriesFilterPtrOutput)
}

// Apply a second aggregation after aggregation is applied.
func (o TimeSeriesFilterPtrOutput) SecondaryAggregation() AggregationPtrOutput {
	return o.ApplyT(func(v *TimeSeriesFilter) *Aggregation {
		if v == nil {
			return nil
		}
		return v.SecondaryAggregation
	}).(AggregationPtrOutput)
}

// Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
//
// Deprecated: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
func (o TimeSeriesFilterPtrOutput) StatisticalTimeSeriesFilter() StatisticalTimeSeriesFilterPtrOutput {
	return o.ApplyT(func(v *TimeSeriesFilter) *StatisticalTimeSeriesFilter {
		if v == nil {
			return nil
		}
		return v.StatisticalTimeSeriesFilter
	}).(StatisticalTimeSeriesFilterPtrOutput)
}

// A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series.
type TimeSeriesFilterRatio struct {
	// The denominator of the ratio.
	Denominator *RatioPart `pulumi:"denominator"`
	// The numerator of the ratio.
	Numerator *RatioPart `pulumi:"numerator"`
	// Ranking based time series filter.
	PickTimeSeriesFilter *PickTimeSeriesFilter `pulumi:"pickTimeSeriesFilter"`
	// Apply a second aggregation after the ratio is computed.
	SecondaryAggregation *Aggregation `pulumi:"secondaryAggregation"`
	// Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
	//
	// Deprecated: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
	StatisticalTimeSeriesFilter *StatisticalTimeSeriesFilter `pulumi:"statisticalTimeSeriesFilter"`
}

// TimeSeriesFilterRatioInput is an input type that accepts TimeSeriesFilterRatioArgs and TimeSeriesFilterRatioOutput values.
// You can construct a concrete instance of `TimeSeriesFilterRatioInput` via:
//
//	TimeSeriesFilterRatioArgs{...}
type TimeSeriesFilterRatioInput interface {
	pulumi.Input

	ToTimeSeriesFilterRatioOutput() TimeSeriesFilterRatioOutput
	ToTimeSeriesFilterRatioOutputWithContext(context.Context) TimeSeriesFilterRatioOutput
}

// A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series.
type TimeSeriesFilterRatioArgs struct {
	// The denominator of the ratio.
	Denominator RatioPartPtrInput `pulumi:"denominator"`
	// The numerator of the ratio.
	Numerator RatioPartPtrInput `pulumi:"numerator"`
	// Ranking based time series filter.
	PickTimeSeriesFilter PickTimeSeriesFilterPtrInput `pulumi:"pickTimeSeriesFilter"`
	// Apply a second aggregation after the ratio is computed.
	SecondaryAggregation AggregationPtrInput `pulumi:"secondaryAggregation"`
	// Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
	//
	// Deprecated: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
	StatisticalTimeSeriesFilter StatisticalTimeSeriesFilterPtrInput `pulumi:"statisticalTimeSeriesFilter"`
}

func (TimeSeriesFilterRatioArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesFilterRatio)(nil)).Elem()
}

func (i TimeSeriesFilterRatioArgs) ToTimeSeriesFilterRatioOutput() TimeSeriesFilterRatioOutput {
	return i.ToTimeSeriesFilterRatioOutputWithContext(context.Background())
}

func (i TimeSeriesFilterRatioArgs) ToTimeSeriesFilterRatioOutputWithContext(ctx context.Context) TimeSeriesFilterRatioOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesFilterRatioOutput)
}

func (i TimeSeriesFilterRatioArgs) ToTimeSeriesFilterRatioPtrOutput() TimeSeriesFilterRatioPtrOutput {
	return i.ToTimeSeriesFilterRatioPtrOutputWithContext(context.Background())
}

func (i TimeSeriesFilterRatioArgs) ToTimeSeriesFilterRatioPtrOutputWithContext(ctx context.Context) TimeSeriesFilterRatioPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesFilterRatioOutput).ToTimeSeriesFilterRatioPtrOutputWithContext(ctx)
}

// TimeSeriesFilterRatioPtrInput is an input type that accepts TimeSeriesFilterRatioArgs, TimeSeriesFilterRatioPtr and TimeSeriesFilterRatioPtrOutput values.
// You can construct a concrete instance of `TimeSeriesFilterRatioPtrInput` via:
//
//	        TimeSeriesFilterRatioArgs{...}
//
//	or:
//
//	        nil
type TimeSeriesFilterRatioPtrInput interface {
	pulumi.Input

	ToTimeSeriesFilterRatioPtrOutput() TimeSeriesFilterRatioPtrOutput
	ToTimeSeriesFilterRatioPtrOutputWithContext(context.Context) TimeSeriesFilterRatioPtrOutput
}

type timeSeriesFilterRatioPtrType TimeSeriesFilterRatioArgs

func TimeSeriesFilterRatioPtr(v *TimeSeriesFilterRatioArgs) TimeSeriesFilterRatioPtrInput {
	return (*timeSeriesFilterRatioPtrType)(v)
}

func (*timeSeriesFilterRatioPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeSeriesFilterRatio)(nil)).Elem()
}

func (i *timeSeriesFilterRatioPtrType) ToTimeSeriesFilterRatioPtrOutput() TimeSeriesFilterRatioPtrOutput {
	return i.ToTimeSeriesFilterRatioPtrOutputWithContext(context.Background())
}

func (i *timeSeriesFilterRatioPtrType) ToTimeSeriesFilterRatioPtrOutputWithContext(ctx context.Context) TimeSeriesFilterRatioPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesFilterRatioPtrOutput)
}

// A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series.
type TimeSeriesFilterRatioOutput struct{ *pulumi.OutputState }

func (TimeSeriesFilterRatioOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesFilterRatio)(nil)).Elem()
}

func (o TimeSeriesFilterRatioOutput) ToTimeSeriesFilterRatioOutput() TimeSeriesFilterRatioOutput {
	return o
}

func (o TimeSeriesFilterRatioOutput) ToTimeSeriesFilterRatioOutputWithContext(ctx context.Context) TimeSeriesFilterRatioOutput {
	return o
}

func (o TimeSeriesFilterRatioOutput) ToTimeSeriesFilterRatioPtrOutput() TimeSeriesFilterRatioPtrOutput {
	return o.ToTimeSeriesFilterRatioPtrOutputWithContext(context.Background())
}

func (o TimeSeriesFilterRatioOutput) ToTimeSeriesFilterRatioPtrOutputWithContext(ctx context.Context) TimeSeriesFilterRatioPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TimeSeriesFilterRatio) *TimeSeriesFilterRatio {
		return &v
	}).(TimeSeriesFilterRatioPtrOutput)
}

// The denominator of the ratio.
func (o TimeSeriesFilterRatioOutput) Denominator() RatioPartPtrOutput {
	return o.ApplyT(func(v TimeSeriesFilterRatio) *RatioPart { return v.Denominator }).(RatioPartPtrOutput)
}

// The numerator of the ratio.
func (o TimeSeriesFilterRatioOutput) Numerator() RatioPartPtrOutput {
	return o.ApplyT(func(v TimeSeriesFilterRatio) *RatioPart { return v.Numerator }).(RatioPartPtrOutput)
}

// Ranking based time series filter.
func (o TimeSeriesFilterRatioOutput) PickTimeSeriesFilter() PickTimeSeriesFilterPtrOutput {
	return o.ApplyT(func(v TimeSeriesFilterRatio) *PickTimeSeriesFilter { return v.PickTimeSeriesFilter }).(PickTimeSeriesFilterPtrOutput)
}

// Apply a second aggregation after the ratio is computed.
func (o TimeSeriesFilterRatioOutput) SecondaryAggregation() AggregationPtrOutput {
	return o.ApplyT(func(v TimeSeriesFilterRatio) *Aggregation { return v.SecondaryAggregation }).(AggregationPtrOutput)
}

// Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
//
// Deprecated: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
func (o TimeSeriesFilterRatioOutput) StatisticalTimeSeriesFilter() StatisticalTimeSeriesFilterPtrOutput {
	return o.ApplyT(func(v TimeSeriesFilterRatio) *StatisticalTimeSeriesFilter { return v.StatisticalTimeSeriesFilter }).(StatisticalTimeSeriesFilterPtrOutput)
}

type TimeSeriesFilterRatioPtrOutput struct{ *pulumi.OutputState }

func (TimeSeriesFilterRatioPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeSeriesFilterRatio)(nil)).Elem()
}

func (o TimeSeriesFilterRatioPtrOutput) ToTimeSeriesFilterRatioPtrOutput() TimeSeriesFilterRatioPtrOutput {
	return o
}

func (o TimeSeriesFilterRatioPtrOutput) ToTimeSeriesFilterRatioPtrOutputWithContext(ctx context.Context) TimeSeriesFilterRatioPtrOutput {
	return o
}

func (o TimeSeriesFilterRatioPtrOutput) Elem() TimeSeriesFilterRatioOutput {
	return o.ApplyT(func(v *TimeSeriesFilterRatio) TimeSeriesFilterRatio {
		if v != nil {
			return *v
		}
		var ret TimeSeriesFilterRatio
		return ret
	}).(TimeSeriesFilterRatioOutput)
}

// The denominator of the ratio.
func (o TimeSeriesFilterRatioPtrOutput) Denominator() RatioPartPtrOutput {
	return o.ApplyT(func(v *TimeSeriesFilterRatio) *RatioPart {
		if v == nil {
			return nil
		}
		return v.Denominator
	}).(RatioPartPtrOutput)
}

// The numerator of the ratio.
func (o TimeSeriesFilterRatioPtrOutput) Numerator() RatioPartPtrOutput {
	return o.ApplyT(func(v *TimeSeriesFilterRatio) *RatioPart {
		if v == nil {
			return nil
		}
		return v.Numerator
	}).(RatioPartPtrOutput)
}

// Ranking based time series filter.
func (o TimeSeriesFilterRatioPtrOutput) PickTimeSeriesFilter() PickTimeSeriesFilterPtrOutput {
	return o.ApplyT(func(v *TimeSeriesFilterRatio) *PickTimeSeriesFilter {
		if v == nil {
			return nil
		}
		return v.PickTimeSeriesFilter
	}).(PickTimeSeriesFilterPtrOutput)
}

// Apply a second aggregation after the ratio is computed.
func (o TimeSeriesFilterRatioPtrOutput) SecondaryAggregation() AggregationPtrOutput {
	return o.ApplyT(func(v *TimeSeriesFilterRatio) *Aggregation {
		if v == nil {
			return nil
		}
		return v.SecondaryAggregation
	}).(AggregationPtrOutput)
}

// Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
//
// Deprecated: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
func (o TimeSeriesFilterRatioPtrOutput) StatisticalTimeSeriesFilter() StatisticalTimeSeriesFilterPtrOutput {
	return o.ApplyT(func(v *TimeSeriesFilterRatio) *StatisticalTimeSeriesFilter {
		if v == nil {
			return nil
		}
		return v.StatisticalTimeSeriesFilter
	}).(StatisticalTimeSeriesFilterPtrOutput)
}

// A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series.
type TimeSeriesFilterRatioResponse struct {
	// The denominator of the ratio.
	Denominator RatioPartResponse `pulumi:"denominator"`
	// The numerator of the ratio.
	Numerator RatioPartResponse `pulumi:"numerator"`
	// Ranking based time series filter.
	PickTimeSeriesFilter PickTimeSeriesFilterResponse `pulumi:"pickTimeSeriesFilter"`
	// Apply a second aggregation after the ratio is computed.
	SecondaryAggregation AggregationResponse `pulumi:"secondaryAggregation"`
	// Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
	//
	// Deprecated: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
	StatisticalTimeSeriesFilter StatisticalTimeSeriesFilterResponse `pulumi:"statisticalTimeSeriesFilter"`
}

// A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series.
type TimeSeriesFilterRatioResponseOutput struct{ *pulumi.OutputState }

func (TimeSeriesFilterRatioResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesFilterRatioResponse)(nil)).Elem()
}

func (o TimeSeriesFilterRatioResponseOutput) ToTimeSeriesFilterRatioResponseOutput() TimeSeriesFilterRatioResponseOutput {
	return o
}

func (o TimeSeriesFilterRatioResponseOutput) ToTimeSeriesFilterRatioResponseOutputWithContext(ctx context.Context) TimeSeriesFilterRatioResponseOutput {
	return o
}

// The denominator of the ratio.
func (o TimeSeriesFilterRatioResponseOutput) Denominator() RatioPartResponseOutput {
	return o.ApplyT(func(v TimeSeriesFilterRatioResponse) RatioPartResponse { return v.Denominator }).(RatioPartResponseOutput)
}

// The numerator of the ratio.
func (o TimeSeriesFilterRatioResponseOutput) Numerator() RatioPartResponseOutput {
	return o.ApplyT(func(v TimeSeriesFilterRatioResponse) RatioPartResponse { return v.Numerator }).(RatioPartResponseOutput)
}

// Ranking based time series filter.
func (o TimeSeriesFilterRatioResponseOutput) PickTimeSeriesFilter() PickTimeSeriesFilterResponseOutput {
	return o.ApplyT(func(v TimeSeriesFilterRatioResponse) PickTimeSeriesFilterResponse { return v.PickTimeSeriesFilter }).(PickTimeSeriesFilterResponseOutput)
}

// Apply a second aggregation after the ratio is computed.
func (o TimeSeriesFilterRatioResponseOutput) SecondaryAggregation() AggregationResponseOutput {
	return o.ApplyT(func(v TimeSeriesFilterRatioResponse) AggregationResponse { return v.SecondaryAggregation }).(AggregationResponseOutput)
}

// Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
//
// Deprecated: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
func (o TimeSeriesFilterRatioResponseOutput) StatisticalTimeSeriesFilter() StatisticalTimeSeriesFilterResponseOutput {
	return o.ApplyT(func(v TimeSeriesFilterRatioResponse) StatisticalTimeSeriesFilterResponse {
		return v.StatisticalTimeSeriesFilter
	}).(StatisticalTimeSeriesFilterResponseOutput)
}

// A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method.
type TimeSeriesFilterResponse struct {
	// By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
	Aggregation AggregationResponse `pulumi:"aggregation"`
	// The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
	Filter string `pulumi:"filter"`
	// Ranking based time series filter.
	PickTimeSeriesFilter PickTimeSeriesFilterResponse `pulumi:"pickTimeSeriesFilter"`
	// Apply a second aggregation after aggregation is applied.
	SecondaryAggregation AggregationResponse `pulumi:"secondaryAggregation"`
	// Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
	//
	// Deprecated: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
	StatisticalTimeSeriesFilter StatisticalTimeSeriesFilterResponse `pulumi:"statisticalTimeSeriesFilter"`
}

// A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method.
type TimeSeriesFilterResponseOutput struct{ *pulumi.OutputState }

func (TimeSeriesFilterResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesFilterResponse)(nil)).Elem()
}

func (o TimeSeriesFilterResponseOutput) ToTimeSeriesFilterResponseOutput() TimeSeriesFilterResponseOutput {
	return o
}

func (o TimeSeriesFilterResponseOutput) ToTimeSeriesFilterResponseOutputWithContext(ctx context.Context) TimeSeriesFilterResponseOutput {
	return o
}

// By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
func (o TimeSeriesFilterResponseOutput) Aggregation() AggregationResponseOutput {
	return o.ApplyT(func(v TimeSeriesFilterResponse) AggregationResponse { return v.Aggregation }).(AggregationResponseOutput)
}

// The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
func (o TimeSeriesFilterResponseOutput) Filter() pulumi.StringOutput {
	return o.ApplyT(func(v TimeSeriesFilterResponse) string { return v.Filter }).(pulumi.StringOutput)
}

// Ranking based time series filter.
func (o TimeSeriesFilterResponseOutput) PickTimeSeriesFilter() PickTimeSeriesFilterResponseOutput {
	return o.ApplyT(func(v TimeSeriesFilterResponse) PickTimeSeriesFilterResponse { return v.PickTimeSeriesFilter }).(PickTimeSeriesFilterResponseOutput)
}

// Apply a second aggregation after aggregation is applied.
func (o TimeSeriesFilterResponseOutput) SecondaryAggregation() AggregationResponseOutput {
	return o.ApplyT(func(v TimeSeriesFilterResponse) AggregationResponse { return v.SecondaryAggregation }).(AggregationResponseOutput)
}

// Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
//
// Deprecated: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
func (o TimeSeriesFilterResponseOutput) StatisticalTimeSeriesFilter() StatisticalTimeSeriesFilterResponseOutput {
	return o.ApplyT(func(v TimeSeriesFilterResponse) StatisticalTimeSeriesFilterResponse {
		return v.StatisticalTimeSeriesFilter
	}).(StatisticalTimeSeriesFilterResponseOutput)
}

// TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API.
type TimeSeriesQuery struct {
	// Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
	OpsAnalyticsQuery *OpsAnalyticsQuery `pulumi:"opsAnalyticsQuery"`
	// Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard's spark chart
	OutputFullDuration *bool `pulumi:"outputFullDuration"`
	// A query used to fetch time series with PromQL.
	PrometheusQuery *string `pulumi:"prometheusQuery"`
	// Filter parameters to fetch time series.
	TimeSeriesFilter *TimeSeriesFilter `pulumi:"timeSeriesFilter"`
	// Parameters to fetch a ratio between two time series filters.
	TimeSeriesFilterRatio *TimeSeriesFilterRatio `pulumi:"timeSeriesFilterRatio"`
	// A query used to fetch time series with MQL.
	TimeSeriesQueryLanguage *string `pulumi:"timeSeriesQueryLanguage"`
	// The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
	UnitOverride *string `pulumi:"unitOverride"`
}

// TimeSeriesQueryInput is an input type that accepts TimeSeriesQueryArgs and TimeSeriesQueryOutput values.
// You can construct a concrete instance of `TimeSeriesQueryInput` via:
//
//	TimeSeriesQueryArgs{...}
type TimeSeriesQueryInput interface {
	pulumi.Input

	ToTimeSeriesQueryOutput() TimeSeriesQueryOutput
	ToTimeSeriesQueryOutputWithContext(context.Context) TimeSeriesQueryOutput
}

// TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API.
type TimeSeriesQueryArgs struct {
	// Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
	OpsAnalyticsQuery OpsAnalyticsQueryPtrInput `pulumi:"opsAnalyticsQuery"`
	// Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard's spark chart
	OutputFullDuration pulumi.BoolPtrInput `pulumi:"outputFullDuration"`
	// A query used to fetch time series with PromQL.
	PrometheusQuery pulumi.StringPtrInput `pulumi:"prometheusQuery"`
	// Filter parameters to fetch time series.
	TimeSeriesFilter TimeSeriesFilterPtrInput `pulumi:"timeSeriesFilter"`
	// Parameters to fetch a ratio between two time series filters.
	TimeSeriesFilterRatio TimeSeriesFilterRatioPtrInput `pulumi:"timeSeriesFilterRatio"`
	// A query used to fetch time series with MQL.
	TimeSeriesQueryLanguage pulumi.StringPtrInput `pulumi:"timeSeriesQueryLanguage"`
	// The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
	UnitOverride pulumi.StringPtrInput `pulumi:"unitOverride"`
}

func (TimeSeriesQueryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesQuery)(nil)).Elem()
}

func (i TimeSeriesQueryArgs) ToTimeSeriesQueryOutput() TimeSeriesQueryOutput {
	return i.ToTimeSeriesQueryOutputWithContext(context.Background())
}

func (i TimeSeriesQueryArgs) ToTimeSeriesQueryOutputWithContext(ctx context.Context) TimeSeriesQueryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesQueryOutput)
}

func (i TimeSeriesQueryArgs) ToTimeSeriesQueryPtrOutput() TimeSeriesQueryPtrOutput {
	return i.ToTimeSeriesQueryPtrOutputWithContext(context.Background())
}

func (i TimeSeriesQueryArgs) ToTimeSeriesQueryPtrOutputWithContext(ctx context.Context) TimeSeriesQueryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesQueryOutput).ToTimeSeriesQueryPtrOutputWithContext(ctx)
}

// TimeSeriesQueryPtrInput is an input type that accepts TimeSeriesQueryArgs, TimeSeriesQueryPtr and TimeSeriesQueryPtrOutput values.
// You can construct a concrete instance of `TimeSeriesQueryPtrInput` via:
//
//	        TimeSeriesQueryArgs{...}
//
//	or:
//
//	        nil
type TimeSeriesQueryPtrInput interface {
	pulumi.Input

	ToTimeSeriesQueryPtrOutput() TimeSeriesQueryPtrOutput
	ToTimeSeriesQueryPtrOutputWithContext(context.Context) TimeSeriesQueryPtrOutput
}

type timeSeriesQueryPtrType TimeSeriesQueryArgs

func TimeSeriesQueryPtr(v *TimeSeriesQueryArgs) TimeSeriesQueryPtrInput {
	return (*timeSeriesQueryPtrType)(v)
}

func (*timeSeriesQueryPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeSeriesQuery)(nil)).Elem()
}

func (i *timeSeriesQueryPtrType) ToTimeSeriesQueryPtrOutput() TimeSeriesQueryPtrOutput {
	return i.ToTimeSeriesQueryPtrOutputWithContext(context.Background())
}

func (i *timeSeriesQueryPtrType) ToTimeSeriesQueryPtrOutputWithContext(ctx context.Context) TimeSeriesQueryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesQueryPtrOutput)
}

// TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API.
type TimeSeriesQueryOutput struct{ *pulumi.OutputState }

func (TimeSeriesQueryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesQuery)(nil)).Elem()
}

func (o TimeSeriesQueryOutput) ToTimeSeriesQueryOutput() TimeSeriesQueryOutput {
	return o
}

func (o TimeSeriesQueryOutput) ToTimeSeriesQueryOutputWithContext(ctx context.Context) TimeSeriesQueryOutput {
	return o
}

func (o TimeSeriesQueryOutput) ToTimeSeriesQueryPtrOutput() TimeSeriesQueryPtrOutput {
	return o.ToTimeSeriesQueryPtrOutputWithContext(context.Background())
}

func (o TimeSeriesQueryOutput) ToTimeSeriesQueryPtrOutputWithContext(ctx context.Context) TimeSeriesQueryPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TimeSeriesQuery) *TimeSeriesQuery {
		return &v
	}).(TimeSeriesQueryPtrOutput)
}

// Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
func (o TimeSeriesQueryOutput) OpsAnalyticsQuery() OpsAnalyticsQueryPtrOutput {
	return o.ApplyT(func(v TimeSeriesQuery) *OpsAnalyticsQuery { return v.OpsAnalyticsQuery }).(OpsAnalyticsQueryPtrOutput)
}

// Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard's spark chart
func (o TimeSeriesQueryOutput) OutputFullDuration() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v TimeSeriesQuery) *bool { return v.OutputFullDuration }).(pulumi.BoolPtrOutput)
}

// A query used to fetch time series with PromQL.
func (o TimeSeriesQueryOutput) PrometheusQuery() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeSeriesQuery) *string { return v.PrometheusQuery }).(pulumi.StringPtrOutput)
}

// Filter parameters to fetch time series.
func (o TimeSeriesQueryOutput) TimeSeriesFilter() TimeSeriesFilterPtrOutput {
	return o.ApplyT(func(v TimeSeriesQuery) *TimeSeriesFilter { return v.TimeSeriesFilter }).(TimeSeriesFilterPtrOutput)
}

// Parameters to fetch a ratio between two time series filters.
func (o TimeSeriesQueryOutput) TimeSeriesFilterRatio() TimeSeriesFilterRatioPtrOutput {
	return o.ApplyT(func(v TimeSeriesQuery) *TimeSeriesFilterRatio { return v.TimeSeriesFilterRatio }).(TimeSeriesFilterRatioPtrOutput)
}

// A query used to fetch time series with MQL.
func (o TimeSeriesQueryOutput) TimeSeriesQueryLanguage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeSeriesQuery) *string { return v.TimeSeriesQueryLanguage }).(pulumi.StringPtrOutput)
}

// The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
func (o TimeSeriesQueryOutput) UnitOverride() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeSeriesQuery) *string { return v.UnitOverride }).(pulumi.StringPtrOutput)
}

type TimeSeriesQueryPtrOutput struct{ *pulumi.OutputState }

func (TimeSeriesQueryPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeSeriesQuery)(nil)).Elem()
}

func (o TimeSeriesQueryPtrOutput) ToTimeSeriesQueryPtrOutput() TimeSeriesQueryPtrOutput {
	return o
}

func (o TimeSeriesQueryPtrOutput) ToTimeSeriesQueryPtrOutputWithContext(ctx context.Context) TimeSeriesQueryPtrOutput {
	return o
}

func (o TimeSeriesQueryPtrOutput) Elem() TimeSeriesQueryOutput {
	return o.ApplyT(func(v *TimeSeriesQuery) TimeSeriesQuery {
		if v != nil {
			return *v
		}
		var ret TimeSeriesQuery
		return ret
	}).(TimeSeriesQueryOutput)
}

// Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
func (o TimeSeriesQueryPtrOutput) OpsAnalyticsQuery() OpsAnalyticsQueryPtrOutput {
	return o.ApplyT(func(v *TimeSeriesQuery) *OpsAnalyticsQuery {
		if v == nil {
			return nil
		}
		return v.OpsAnalyticsQuery
	}).(OpsAnalyticsQueryPtrOutput)
}

// Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard's spark chart
func (o TimeSeriesQueryPtrOutput) OutputFullDuration() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *TimeSeriesQuery) *bool {
		if v == nil {
			return nil
		}
		return v.OutputFullDuration
	}).(pulumi.BoolPtrOutput)
}

// A query used to fetch time series with PromQL.
func (o TimeSeriesQueryPtrOutput) PrometheusQuery() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeSeriesQuery) *string {
		if v == nil {
			return nil
		}
		return v.PrometheusQuery
	}).(pulumi.StringPtrOutput)
}

// Filter parameters to fetch time series.
func (o TimeSeriesQueryPtrOutput) TimeSeriesFilter() TimeSeriesFilterPtrOutput {
	return o.ApplyT(func(v *TimeSeriesQuery) *TimeSeriesFilter {
		if v == nil {
			return nil
		}
		return v.TimeSeriesFilter
	}).(TimeSeriesFilterPtrOutput)
}

// Parameters to fetch a ratio between two time series filters.
func (o TimeSeriesQueryPtrOutput) TimeSeriesFilterRatio() TimeSeriesFilterRatioPtrOutput {
	return o.ApplyT(func(v *TimeSeriesQuery) *TimeSeriesFilterRatio {
		if v == nil {
			return nil
		}
		return v.TimeSeriesFilterRatio
	}).(TimeSeriesFilterRatioPtrOutput)
}

// A query used to fetch time series with MQL.
func (o TimeSeriesQueryPtrOutput) TimeSeriesQueryLanguage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeSeriesQuery) *string {
		if v == nil {
			return nil
		}
		return v.TimeSeriesQueryLanguage
	}).(pulumi.StringPtrOutput)
}

// The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
func (o TimeSeriesQueryPtrOutput) UnitOverride() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeSeriesQuery) *string {
		if v == nil {
			return nil
		}
		return v.UnitOverride
	}).(pulumi.StringPtrOutput)
}

// TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API.
type TimeSeriesQueryResponse struct {
	// Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
	OpsAnalyticsQuery OpsAnalyticsQueryResponse `pulumi:"opsAnalyticsQuery"`
	// Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard's spark chart
	OutputFullDuration bool `pulumi:"outputFullDuration"`
	// A query used to fetch time series with PromQL.
	PrometheusQuery string `pulumi:"prometheusQuery"`
	// Filter parameters to fetch time series.
	TimeSeriesFilter TimeSeriesFilterResponse `pulumi:"timeSeriesFilter"`
	// Parameters to fetch a ratio between two time series filters.
	TimeSeriesFilterRatio TimeSeriesFilterRatioResponse `pulumi:"timeSeriesFilterRatio"`
	// A query used to fetch time series with MQL.
	TimeSeriesQueryLanguage string `pulumi:"timeSeriesQueryLanguage"`
	// The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
	UnitOverride string `pulumi:"unitOverride"`
}

// TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API.
type TimeSeriesQueryResponseOutput struct{ *pulumi.OutputState }

func (TimeSeriesQueryResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesQueryResponse)(nil)).Elem()
}

func (o TimeSeriesQueryResponseOutput) ToTimeSeriesQueryResponseOutput() TimeSeriesQueryResponseOutput {
	return o
}

func (o TimeSeriesQueryResponseOutput) ToTimeSeriesQueryResponseOutputWithContext(ctx context.Context) TimeSeriesQueryResponseOutput {
	return o
}

// Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
func (o TimeSeriesQueryResponseOutput) OpsAnalyticsQuery() OpsAnalyticsQueryResponseOutput {
	return o.ApplyT(func(v TimeSeriesQueryResponse) OpsAnalyticsQueryResponse { return v.OpsAnalyticsQuery }).(OpsAnalyticsQueryResponseOutput)
}

// Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard's spark chart
func (o TimeSeriesQueryResponseOutput) OutputFullDuration() pulumi.BoolOutput {
	return o.ApplyT(func(v TimeSeriesQueryResponse) bool { return v.OutputFullDuration }).(pulumi.BoolOutput)
}

// A query used to fetch time series with PromQL.
func (o TimeSeriesQueryResponseOutput) PrometheusQuery() pulumi.StringOutput {
	return o.ApplyT(func(v TimeSeriesQueryResponse) string { return v.PrometheusQuery }).(pulumi.StringOutput)
}

// Filter parameters to fetch time series.
func (o TimeSeriesQueryResponseOutput) TimeSeriesFilter() TimeSeriesFilterResponseOutput {
	return o.ApplyT(func(v TimeSeriesQueryResponse) TimeSeriesFilterResponse { return v.TimeSeriesFilter }).(TimeSeriesFilterResponseOutput)
}

// Parameters to fetch a ratio between two time series filters.
func (o TimeSeriesQueryResponseOutput) TimeSeriesFilterRatio() TimeSeriesFilterRatioResponseOutput {
	return o.ApplyT(func(v TimeSeriesQueryResponse) TimeSeriesFilterRatioResponse { return v.TimeSeriesFilterRatio }).(TimeSeriesFilterRatioResponseOutput)
}

// A query used to fetch time series with MQL.
func (o TimeSeriesQueryResponseOutput) TimeSeriesQueryLanguage() pulumi.StringOutput {
	return o.ApplyT(func(v TimeSeriesQueryResponse) string { return v.TimeSeriesQueryLanguage }).(pulumi.StringOutput)
}

// The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
func (o TimeSeriesQueryResponseOutput) UnitOverride() pulumi.StringOutput {
	return o.ApplyT(func(v TimeSeriesQueryResponse) string { return v.UnitOverride }).(pulumi.StringOutput)
}

// A table that displays time series data.
type TimeSeriesTable struct {
	// Optional. The list of the persistent column settings for the table.
	ColumnSettings []ColumnSettings `pulumi:"columnSettings"`
	// The data displayed in this table.
	DataSets []TableDataSet `pulumi:"dataSets"`
	// Optional. Store rendering strategy
	MetricVisualization *TimeSeriesTableMetricVisualization `pulumi:"metricVisualization"`
}

// TimeSeriesTableInput is an input type that accepts TimeSeriesTableArgs and TimeSeriesTableOutput values.
// You can construct a concrete instance of `TimeSeriesTableInput` via:
//
//	TimeSeriesTableArgs{...}
type TimeSeriesTableInput interface {
	pulumi.Input

	ToTimeSeriesTableOutput() TimeSeriesTableOutput
	ToTimeSeriesTableOutputWithContext(context.Context) TimeSeriesTableOutput
}

// A table that displays time series data.
type TimeSeriesTableArgs struct {
	// Optional. The list of the persistent column settings for the table.
	ColumnSettings ColumnSettingsArrayInput `pulumi:"columnSettings"`
	// The data displayed in this table.
	DataSets TableDataSetArrayInput `pulumi:"dataSets"`
	// Optional. Store rendering strategy
	MetricVisualization TimeSeriesTableMetricVisualizationPtrInput `pulumi:"metricVisualization"`
}

func (TimeSeriesTableArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesTable)(nil)).Elem()
}

func (i TimeSeriesTableArgs) ToTimeSeriesTableOutput() TimeSeriesTableOutput {
	return i.ToTimeSeriesTableOutputWithContext(context.Background())
}

func (i TimeSeriesTableArgs) ToTimeSeriesTableOutputWithContext(ctx context.Context) TimeSeriesTableOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesTableOutput)
}

func (i TimeSeriesTableArgs) ToTimeSeriesTablePtrOutput() TimeSeriesTablePtrOutput {
	return i.ToTimeSeriesTablePtrOutputWithContext(context.Background())
}

func (i TimeSeriesTableArgs) ToTimeSeriesTablePtrOutputWithContext(ctx context.Context) TimeSeriesTablePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesTableOutput).ToTimeSeriesTablePtrOutputWithContext(ctx)
}

// TimeSeriesTablePtrInput is an input type that accepts TimeSeriesTableArgs, TimeSeriesTablePtr and TimeSeriesTablePtrOutput values.
// You can construct a concrete instance of `TimeSeriesTablePtrInput` via:
//
//	        TimeSeriesTableArgs{...}
//
//	or:
//
//	        nil
type TimeSeriesTablePtrInput interface {
	pulumi.Input

	ToTimeSeriesTablePtrOutput() TimeSeriesTablePtrOutput
	ToTimeSeriesTablePtrOutputWithContext(context.Context) TimeSeriesTablePtrOutput
}

type timeSeriesTablePtrType TimeSeriesTableArgs

func TimeSeriesTablePtr(v *TimeSeriesTableArgs) TimeSeriesTablePtrInput {
	return (*timeSeriesTablePtrType)(v)
}

func (*timeSeriesTablePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeSeriesTable)(nil)).Elem()
}

func (i *timeSeriesTablePtrType) ToTimeSeriesTablePtrOutput() TimeSeriesTablePtrOutput {
	return i.ToTimeSeriesTablePtrOutputWithContext(context.Background())
}

func (i *timeSeriesTablePtrType) ToTimeSeriesTablePtrOutputWithContext(ctx context.Context) TimeSeriesTablePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesTablePtrOutput)
}

// A table that displays time series data.
type TimeSeriesTableOutput struct{ *pulumi.OutputState }

func (TimeSeriesTableOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesTable)(nil)).Elem()
}

func (o TimeSeriesTableOutput) ToTimeSeriesTableOutput() TimeSeriesTableOutput {
	return o
}

func (o TimeSeriesTableOutput) ToTimeSeriesTableOutputWithContext(ctx context.Context) TimeSeriesTableOutput {
	return o
}

func (o TimeSeriesTableOutput) ToTimeSeriesTablePtrOutput() TimeSeriesTablePtrOutput {
	return o.ToTimeSeriesTablePtrOutputWithContext(context.Background())
}

func (o TimeSeriesTableOutput) ToTimeSeriesTablePtrOutputWithContext(ctx context.Context) TimeSeriesTablePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TimeSeriesTable) *TimeSeriesTable {
		return &v
	}).(TimeSeriesTablePtrOutput)
}

// Optional. The list of the persistent column settings for the table.
func (o TimeSeriesTableOutput) ColumnSettings() ColumnSettingsArrayOutput {
	return o.ApplyT(func(v TimeSeriesTable) []ColumnSettings { return v.ColumnSettings }).(ColumnSettingsArrayOutput)
}

// The data displayed in this table.
func (o TimeSeriesTableOutput) DataSets() TableDataSetArrayOutput {
	return o.ApplyT(func(v TimeSeriesTable) []TableDataSet { return v.DataSets }).(TableDataSetArrayOutput)
}

// Optional. Store rendering strategy
func (o TimeSeriesTableOutput) MetricVisualization() TimeSeriesTableMetricVisualizationPtrOutput {
	return o.ApplyT(func(v TimeSeriesTable) *TimeSeriesTableMetricVisualization { return v.MetricVisualization }).(TimeSeriesTableMetricVisualizationPtrOutput)
}

type TimeSeriesTablePtrOutput struct{ *pulumi.OutputState }

func (TimeSeriesTablePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeSeriesTable)(nil)).Elem()
}

func (o TimeSeriesTablePtrOutput) ToTimeSeriesTablePtrOutput() TimeSeriesTablePtrOutput {
	return o
}

func (o TimeSeriesTablePtrOutput) ToTimeSeriesTablePtrOutputWithContext(ctx context.Context) TimeSeriesTablePtrOutput {
	return o
}

func (o TimeSeriesTablePtrOutput) Elem() TimeSeriesTableOutput {
	return o.ApplyT(func(v *TimeSeriesTable) TimeSeriesTable {
		if v != nil {
			return *v
		}
		var ret TimeSeriesTable
		return ret
	}).(TimeSeriesTableOutput)
}

// Optional. The list of the persistent column settings for the table.
func (o TimeSeriesTablePtrOutput) ColumnSettings() ColumnSettingsArrayOutput {
	return o.ApplyT(func(v *TimeSeriesTable) []ColumnSettings {
		if v == nil {
			return nil
		}
		return v.ColumnSettings
	}).(ColumnSettingsArrayOutput)
}

// The data displayed in this table.
func (o TimeSeriesTablePtrOutput) DataSets() TableDataSetArrayOutput {
	return o.ApplyT(func(v *TimeSeriesTable) []TableDataSet {
		if v == nil {
			return nil
		}
		return v.DataSets
	}).(TableDataSetArrayOutput)
}

// Optional. Store rendering strategy
func (o TimeSeriesTablePtrOutput) MetricVisualization() TimeSeriesTableMetricVisualizationPtrOutput {
	return o.ApplyT(func(v *TimeSeriesTable) *TimeSeriesTableMetricVisualization {
		if v == nil {
			return nil
		}
		return v.MetricVisualization
	}).(TimeSeriesTableMetricVisualizationPtrOutput)
}

// A table that displays time series data.
type TimeSeriesTableResponse struct {
	// Optional. The list of the persistent column settings for the table.
	ColumnSettings []ColumnSettingsResponse `pulumi:"columnSettings"`
	// The data displayed in this table.
	DataSets []TableDataSetResponse `pulumi:"dataSets"`
	// Optional. Store rendering strategy
	MetricVisualization string `pulumi:"metricVisualization"`
}

// A table that displays time series data.
type TimeSeriesTableResponseOutput struct{ *pulumi.OutputState }

func (TimeSeriesTableResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesTableResponse)(nil)).Elem()
}

func (o TimeSeriesTableResponseOutput) ToTimeSeriesTableResponseOutput() TimeSeriesTableResponseOutput {
	return o
}

func (o TimeSeriesTableResponseOutput) ToTimeSeriesTableResponseOutputWithContext(ctx context.Context) TimeSeriesTableResponseOutput {
	return o
}

// Optional. The list of the persistent column settings for the table.
func (o TimeSeriesTableResponseOutput) ColumnSettings() ColumnSettingsResponseArrayOutput {
	return o.ApplyT(func(v TimeSeriesTableResponse) []ColumnSettingsResponse { return v.ColumnSettings }).(ColumnSettingsResponseArrayOutput)
}

// The data displayed in this table.
func (o TimeSeriesTableResponseOutput) DataSets() TableDataSetResponseArrayOutput {
	return o.ApplyT(func(v TimeSeriesTableResponse) []TableDataSetResponse { return v.DataSets }).(TableDataSetResponseArrayOutput)
}

// Optional. Store rendering strategy
func (o TimeSeriesTableResponseOutput) MetricVisualization() pulumi.StringOutput {
	return o.ApplyT(func(v TimeSeriesTableResponse) string { return v.MetricVisualization }).(pulumi.StringOutput)
}

// Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
type Widget struct {
	// A chart of alert policy data.
	AlertChart *AlertChart `pulumi:"alertChart"`
	// A blank space.
	Blank *Empty `pulumi:"blank"`
	// A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
	CollapsibleGroup *CollapsibleGroup `pulumi:"collapsibleGroup"`
	// A widget that displays a list of error groups.
	ErrorReportingPanel *ErrorReportingPanel `pulumi:"errorReportingPanel"`
	// Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
	Id *string `pulumi:"id"`
	// A widget that shows list of incidents.
	IncidentList *IncidentList `pulumi:"incidentList"`
	// A widget that shows a stream of logs.
	LogsPanel *LogsPanel `pulumi:"logsPanel"`
	// A widget that displays timeseries data as a pie chart.
	PieChart *PieChart `pulumi:"pieChart"`
	// A scorecard summarizing time series data.
	Scorecard *Scorecard `pulumi:"scorecard"`
	// A widget that defines a section header for easier navigation of the dashboard.
	SectionHeader *SectionHeader `pulumi:"sectionHeader"`
	// A widget that groups the other widgets by using a dropdown menu.
	SingleViewGroup *SingleViewGroup `pulumi:"singleViewGroup"`
	// A raw string or markdown displaying textual content.
	Text *Text `pulumi:"text"`
	// A widget that displays time series data in a tabular format.
	TimeSeriesTable *TimeSeriesTable `pulumi:"timeSeriesTable"`
	// Optional. The title of the widget.
	Title *string `pulumi:"title"`
	// A chart of time series data.
	XyChart *XyChart `pulumi:"xyChart"`
}

// WidgetInput is an input type that accepts WidgetArgs and WidgetOutput values.
// You can construct a concrete instance of `WidgetInput` via:
//
//	WidgetArgs{...}
type WidgetInput interface {
	pulumi.Input

	ToWidgetOutput() WidgetOutput
	ToWidgetOutputWithContext(context.Context) WidgetOutput
}

// Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
type WidgetArgs struct {
	// A chart of alert policy data.
	AlertChart AlertChartPtrInput `pulumi:"alertChart"`
	// A blank space.
	Blank EmptyPtrInput `pulumi:"blank"`
	// A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
	CollapsibleGroup CollapsibleGroupPtrInput `pulumi:"collapsibleGroup"`
	// A widget that displays a list of error groups.
	ErrorReportingPanel ErrorReportingPanelPtrInput `pulumi:"errorReportingPanel"`
	// Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
	Id pulumi.StringPtrInput `pulumi:"id"`
	// A widget that shows list of incidents.
	IncidentList IncidentListPtrInput `pulumi:"incidentList"`
	// A widget that shows a stream of logs.
	LogsPanel LogsPanelPtrInput `pulumi:"logsPanel"`
	// A widget that displays timeseries data as a pie chart.
	PieChart PieChartPtrInput `pulumi:"pieChart"`
	// A scorecard summarizing time series data.
	Scorecard ScorecardPtrInput `pulumi:"scorecard"`
	// A widget that defines a section header for easier navigation of the dashboard.
	SectionHeader SectionHeaderPtrInput `pulumi:"sectionHeader"`
	// A widget that groups the other widgets by using a dropdown menu.
	SingleViewGroup SingleViewGroupPtrInput `pulumi:"singleViewGroup"`
	// A raw string or markdown displaying textual content.
	Text TextPtrInput `pulumi:"text"`
	// A widget that displays time series data in a tabular format.
	TimeSeriesTable TimeSeriesTablePtrInput `pulumi:"timeSeriesTable"`
	// Optional. The title of the widget.
	Title pulumi.StringPtrInput `pulumi:"title"`
	// A chart of time series data.
	XyChart XyChartPtrInput `pulumi:"xyChart"`
}

func (WidgetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Widget)(nil)).Elem()
}

func (i WidgetArgs) ToWidgetOutput() WidgetOutput {
	return i.ToWidgetOutputWithContext(context.Background())
}

func (i WidgetArgs) ToWidgetOutputWithContext(ctx context.Context) WidgetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WidgetOutput)
}

func (i WidgetArgs) ToWidgetPtrOutput() WidgetPtrOutput {
	return i.ToWidgetPtrOutputWithContext(context.Background())
}

func (i WidgetArgs) ToWidgetPtrOutputWithContext(ctx context.Context) WidgetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WidgetOutput).ToWidgetPtrOutputWithContext(ctx)
}

// WidgetPtrInput is an input type that accepts WidgetArgs, WidgetPtr and WidgetPtrOutput values.
// You can construct a concrete instance of `WidgetPtrInput` via:
//
//	        WidgetArgs{...}
//
//	or:
//
//	        nil
type WidgetPtrInput interface {
	pulumi.Input

	ToWidgetPtrOutput() WidgetPtrOutput
	ToWidgetPtrOutputWithContext(context.Context) WidgetPtrOutput
}

type widgetPtrType WidgetArgs

func WidgetPtr(v *WidgetArgs) WidgetPtrInput {
	return (*widgetPtrType)(v)
}

func (*widgetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Widget)(nil)).Elem()
}

func (i *widgetPtrType) ToWidgetPtrOutput() WidgetPtrOutput {
	return i.ToWidgetPtrOutputWithContext(context.Background())
}

func (i *widgetPtrType) ToWidgetPtrOutputWithContext(ctx context.Context) WidgetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WidgetPtrOutput)
}

// WidgetArrayInput is an input type that accepts WidgetArray and WidgetArrayOutput values.
// You can construct a concrete instance of `WidgetArrayInput` via:
//
//	WidgetArray{ WidgetArgs{...} }
type WidgetArrayInput interface {
	pulumi.Input

	ToWidgetArrayOutput() WidgetArrayOutput
	ToWidgetArrayOutputWithContext(context.Context) WidgetArrayOutput
}

type WidgetArray []WidgetInput

func (WidgetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Widget)(nil)).Elem()
}

func (i WidgetArray) ToWidgetArrayOutput() WidgetArrayOutput {
	return i.ToWidgetArrayOutputWithContext(context.Background())
}

func (i WidgetArray) ToWidgetArrayOutputWithContext(ctx context.Context) WidgetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WidgetArrayOutput)
}

// Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
type WidgetOutput struct{ *pulumi.OutputState }

func (WidgetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Widget)(nil)).Elem()
}

func (o WidgetOutput) ToWidgetOutput() WidgetOutput {
	return o
}

func (o WidgetOutput) ToWidgetOutputWithContext(ctx context.Context) WidgetOutput {
	return o
}

func (o WidgetOutput) ToWidgetPtrOutput() WidgetPtrOutput {
	return o.ToWidgetPtrOutputWithContext(context.Background())
}

func (o WidgetOutput) ToWidgetPtrOutputWithContext(ctx context.Context) WidgetPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Widget) *Widget {
		return &v
	}).(WidgetPtrOutput)
}

// A chart of alert policy data.
func (o WidgetOutput) AlertChart() AlertChartPtrOutput {
	return o.ApplyT(func(v Widget) *AlertChart { return v.AlertChart }).(AlertChartPtrOutput)
}

// A blank space.
func (o WidgetOutput) Blank() EmptyPtrOutput {
	return o.ApplyT(func(v Widget) *Empty { return v.Blank }).(EmptyPtrOutput)
}

// A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
func (o WidgetOutput) CollapsibleGroup() CollapsibleGroupPtrOutput {
	return o.ApplyT(func(v Widget) *CollapsibleGroup { return v.CollapsibleGroup }).(CollapsibleGroupPtrOutput)
}

// A widget that displays a list of error groups.
func (o WidgetOutput) ErrorReportingPanel() ErrorReportingPanelPtrOutput {
	return o.ApplyT(func(v Widget) *ErrorReportingPanel { return v.ErrorReportingPanel }).(ErrorReportingPanelPtrOutput)
}

// Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
func (o WidgetOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Widget) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// A widget that shows list of incidents.
func (o WidgetOutput) IncidentList() IncidentListPtrOutput {
	return o.ApplyT(func(v Widget) *IncidentList { return v.IncidentList }).(IncidentListPtrOutput)
}

// A widget that shows a stream of logs.
func (o WidgetOutput) LogsPanel() LogsPanelPtrOutput {
	return o.ApplyT(func(v Widget) *LogsPanel { return v.LogsPanel }).(LogsPanelPtrOutput)
}

// A widget that displays timeseries data as a pie chart.
func (o WidgetOutput) PieChart() PieChartPtrOutput {
	return o.ApplyT(func(v Widget) *PieChart { return v.PieChart }).(PieChartPtrOutput)
}

// A scorecard summarizing time series data.
func (o WidgetOutput) Scorecard() ScorecardPtrOutput {
	return o.ApplyT(func(v Widget) *Scorecard { return v.Scorecard }).(ScorecardPtrOutput)
}

// A widget that defines a section header for easier navigation of the dashboard.
func (o WidgetOutput) SectionHeader() SectionHeaderPtrOutput {
	return o.ApplyT(func(v Widget) *SectionHeader { return v.SectionHeader }).(SectionHeaderPtrOutput)
}

// A widget that groups the other widgets by using a dropdown menu.
func (o WidgetOutput) SingleViewGroup() SingleViewGroupPtrOutput {
	return o.ApplyT(func(v Widget) *SingleViewGroup { return v.SingleViewGroup }).(SingleViewGroupPtrOutput)
}

// A raw string or markdown displaying textual content.
func (o WidgetOutput) Text() TextPtrOutput {
	return o.ApplyT(func(v Widget) *Text { return v.Text }).(TextPtrOutput)
}

// A widget that displays time series data in a tabular format.
func (o WidgetOutput) TimeSeriesTable() TimeSeriesTablePtrOutput {
	return o.ApplyT(func(v Widget) *TimeSeriesTable { return v.TimeSeriesTable }).(TimeSeriesTablePtrOutput)
}

// Optional. The title of the widget.
func (o WidgetOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Widget) *string { return v.Title }).(pulumi.StringPtrOutput)
}

// A chart of time series data.
func (o WidgetOutput) XyChart() XyChartPtrOutput {
	return o.ApplyT(func(v Widget) *XyChart { return v.XyChart }).(XyChartPtrOutput)
}

type WidgetPtrOutput struct{ *pulumi.OutputState }

func (WidgetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Widget)(nil)).Elem()
}

func (o WidgetPtrOutput) ToWidgetPtrOutput() WidgetPtrOutput {
	return o
}

func (o WidgetPtrOutput) ToWidgetPtrOutputWithContext(ctx context.Context) WidgetPtrOutput {
	return o
}

func (o WidgetPtrOutput) Elem() WidgetOutput {
	return o.ApplyT(func(v *Widget) Widget {
		if v != nil {
			return *v
		}
		var ret Widget
		return ret
	}).(WidgetOutput)
}

// A chart of alert policy data.
func (o WidgetPtrOutput) AlertChart() AlertChartPtrOutput {
	return o.ApplyT(func(v *Widget) *AlertChart {
		if v == nil {
			return nil
		}
		return v.AlertChart
	}).(AlertChartPtrOutput)
}

// A blank space.
func (o WidgetPtrOutput) Blank() EmptyPtrOutput {
	return o.ApplyT(func(v *Widget) *Empty {
		if v == nil {
			return nil
		}
		return v.Blank
	}).(EmptyPtrOutput)
}

// A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
func (o WidgetPtrOutput) CollapsibleGroup() CollapsibleGroupPtrOutput {
	return o.ApplyT(func(v *Widget) *CollapsibleGroup {
		if v == nil {
			return nil
		}
		return v.CollapsibleGroup
	}).(CollapsibleGroupPtrOutput)
}

// A widget that displays a list of error groups.
func (o WidgetPtrOutput) ErrorReportingPanel() ErrorReportingPanelPtrOutput {
	return o.ApplyT(func(v *Widget) *ErrorReportingPanel {
		if v == nil {
			return nil
		}
		return v.ErrorReportingPanel
	}).(ErrorReportingPanelPtrOutput)
}

// Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
func (o WidgetPtrOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Widget) *string {
		if v == nil {
			return nil
		}
		return v.Id
	}).(pulumi.StringPtrOutput)
}

// A widget that shows list of incidents.
func (o WidgetPtrOutput) IncidentList() IncidentListPtrOutput {
	return o.ApplyT(func(v *Widget) *IncidentList {
		if v == nil {
			return nil
		}
		return v.IncidentList
	}).(IncidentListPtrOutput)
}

// A widget that shows a stream of logs.
func (o WidgetPtrOutput) LogsPanel() LogsPanelPtrOutput {
	return o.ApplyT(func(v *Widget) *LogsPanel {
		if v == nil {
			return nil
		}
		return v.LogsPanel
	}).(LogsPanelPtrOutput)
}

// A widget that displays timeseries data as a pie chart.
func (o WidgetPtrOutput) PieChart() PieChartPtrOutput {
	return o.ApplyT(func(v *Widget) *PieChart {
		if v == nil {
			return nil
		}
		return v.PieChart
	}).(PieChartPtrOutput)
}

// A scorecard summarizing time series data.
func (o WidgetPtrOutput) Scorecard() ScorecardPtrOutput {
	return o.ApplyT(func(v *Widget) *Scorecard {
		if v == nil {
			return nil
		}
		return v.Scorecard
	}).(ScorecardPtrOutput)
}

// A widget that defines a section header for easier navigation of the dashboard.
func (o WidgetPtrOutput) SectionHeader() SectionHeaderPtrOutput {
	return o.ApplyT(func(v *Widget) *SectionHeader {
		if v == nil {
			return nil
		}
		return v.SectionHeader
	}).(SectionHeaderPtrOutput)
}

// A widget that groups the other widgets by using a dropdown menu.
func (o WidgetPtrOutput) SingleViewGroup() SingleViewGroupPtrOutput {
	return o.ApplyT(func(v *Widget) *SingleViewGroup {
		if v == nil {
			return nil
		}
		return v.SingleViewGroup
	}).(SingleViewGroupPtrOutput)
}

// A raw string or markdown displaying textual content.
func (o WidgetPtrOutput) Text() TextPtrOutput {
	return o.ApplyT(func(v *Widget) *Text {
		if v == nil {
			return nil
		}
		return v.Text
	}).(TextPtrOutput)
}

// A widget that displays time series data in a tabular format.
func (o WidgetPtrOutput) TimeSeriesTable() TimeSeriesTablePtrOutput {
	return o.ApplyT(func(v *Widget) *TimeSeriesTable {
		if v == nil {
			return nil
		}
		return v.TimeSeriesTable
	}).(TimeSeriesTablePtrOutput)
}

// Optional. The title of the widget.
func (o WidgetPtrOutput) Title() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Widget) *string {
		if v == nil {
			return nil
		}
		return v.Title
	}).(pulumi.StringPtrOutput)
}

// A chart of time series data.
func (o WidgetPtrOutput) XyChart() XyChartPtrOutput {
	return o.ApplyT(func(v *Widget) *XyChart {
		if v == nil {
			return nil
		}
		return v.XyChart
	}).(XyChartPtrOutput)
}

type WidgetArrayOutput struct{ *pulumi.OutputState }

func (WidgetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Widget)(nil)).Elem()
}

func (o WidgetArrayOutput) ToWidgetArrayOutput() WidgetArrayOutput {
	return o
}

func (o WidgetArrayOutput) ToWidgetArrayOutputWithContext(ctx context.Context) WidgetArrayOutput {
	return o
}

func (o WidgetArrayOutput) Index(i pulumi.IntInput) WidgetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Widget {
		return vs[0].([]Widget)[vs[1].(int)]
	}).(WidgetOutput)
}

// Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
type WidgetResponse struct {
	// A chart of alert policy data.
	AlertChart AlertChartResponse `pulumi:"alertChart"`
	// A blank space.
	Blank EmptyResponse `pulumi:"blank"`
	// A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
	CollapsibleGroup CollapsibleGroupResponse `pulumi:"collapsibleGroup"`
	// A widget that displays a list of error groups.
	ErrorReportingPanel ErrorReportingPanelResponse `pulumi:"errorReportingPanel"`
	// A widget that shows list of incidents.
	IncidentList IncidentListResponse `pulumi:"incidentList"`
	// A widget that shows a stream of logs.
	LogsPanel LogsPanelResponse `pulumi:"logsPanel"`
	// A widget that displays timeseries data as a pie chart.
	PieChart PieChartResponse `pulumi:"pieChart"`
	// A scorecard summarizing time series data.
	Scorecard ScorecardResponse `pulumi:"scorecard"`
	// A widget that defines a section header for easier navigation of the dashboard.
	SectionHeader SectionHeaderResponse `pulumi:"sectionHeader"`
	// A widget that groups the other widgets by using a dropdown menu.
	SingleViewGroup SingleViewGroupResponse `pulumi:"singleViewGroup"`
	// A raw string or markdown displaying textual content.
	Text TextResponse `pulumi:"text"`
	// A widget that displays time series data in a tabular format.
	TimeSeriesTable TimeSeriesTableResponse `pulumi:"timeSeriesTable"`
	// Optional. The title of the widget.
	Title string `pulumi:"title"`
	// A chart of time series data.
	XyChart XyChartResponse `pulumi:"xyChart"`
}

// Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
type WidgetResponseOutput struct{ *pulumi.OutputState }

func (WidgetResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WidgetResponse)(nil)).Elem()
}

func (o WidgetResponseOutput) ToWidgetResponseOutput() WidgetResponseOutput {
	return o
}

func (o WidgetResponseOutput) ToWidgetResponseOutputWithContext(ctx context.Context) WidgetResponseOutput {
	return o
}

// A chart of alert policy data.
func (o WidgetResponseOutput) AlertChart() AlertChartResponseOutput {
	return o.ApplyT(func(v WidgetResponse) AlertChartResponse { return v.AlertChart }).(AlertChartResponseOutput)
}

// A blank space.
func (o WidgetResponseOutput) Blank() EmptyResponseOutput {
	return o.ApplyT(func(v WidgetResponse) EmptyResponse { return v.Blank }).(EmptyResponseOutput)
}

// A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
func (o WidgetResponseOutput) CollapsibleGroup() CollapsibleGroupResponseOutput {
	return o.ApplyT(func(v WidgetResponse) CollapsibleGroupResponse { return v.CollapsibleGroup }).(CollapsibleGroupResponseOutput)
}

// A widget that displays a list of error groups.
func (o WidgetResponseOutput) ErrorReportingPanel() ErrorReportingPanelResponseOutput {
	return o.ApplyT(func(v WidgetResponse) ErrorReportingPanelResponse { return v.ErrorReportingPanel }).(ErrorReportingPanelResponseOutput)
}

// A widget that shows list of incidents.
func (o WidgetResponseOutput) IncidentList() IncidentListResponseOutput {
	return o.ApplyT(func(v WidgetResponse) IncidentListResponse { return v.IncidentList }).(IncidentListResponseOutput)
}

// A widget that shows a stream of logs.
func (o WidgetResponseOutput) LogsPanel() LogsPanelResponseOutput {
	return o.ApplyT(func(v WidgetResponse) LogsPanelResponse { return v.LogsPanel }).(LogsPanelResponseOutput)
}

// A widget that displays timeseries data as a pie chart.
func (o WidgetResponseOutput) PieChart() PieChartResponseOutput {
	return o.ApplyT(func(v WidgetResponse) PieChartResponse { return v.PieChart }).(PieChartResponseOutput)
}

// A scorecard summarizing time series data.
func (o WidgetResponseOutput) Scorecard() ScorecardResponseOutput {
	return o.ApplyT(func(v WidgetResponse) ScorecardResponse { return v.Scorecard }).(ScorecardResponseOutput)
}

// A widget that defines a section header for easier navigation of the dashboard.
func (o WidgetResponseOutput) SectionHeader() SectionHeaderResponseOutput {
	return o.ApplyT(func(v WidgetResponse) SectionHeaderResponse { return v.SectionHeader }).(SectionHeaderResponseOutput)
}

// A widget that groups the other widgets by using a dropdown menu.
func (o WidgetResponseOutput) SingleViewGroup() SingleViewGroupResponseOutput {
	return o.ApplyT(func(v WidgetResponse) SingleViewGroupResponse { return v.SingleViewGroup }).(SingleViewGroupResponseOutput)
}

// A raw string or markdown displaying textual content.
func (o WidgetResponseOutput) Text() TextResponseOutput {
	return o.ApplyT(func(v WidgetResponse) TextResponse { return v.Text }).(TextResponseOutput)
}

// A widget that displays time series data in a tabular format.
func (o WidgetResponseOutput) TimeSeriesTable() TimeSeriesTableResponseOutput {
	return o.ApplyT(func(v WidgetResponse) TimeSeriesTableResponse { return v.TimeSeriesTable }).(TimeSeriesTableResponseOutput)
}

// Optional. The title of the widget.
func (o WidgetResponseOutput) Title() pulumi.StringOutput {
	return o.ApplyT(func(v WidgetResponse) string { return v.Title }).(pulumi.StringOutput)
}

// A chart of time series data.
func (o WidgetResponseOutput) XyChart() XyChartResponseOutput {
	return o.ApplyT(func(v WidgetResponse) XyChartResponse { return v.XyChart }).(XyChartResponseOutput)
}

type WidgetResponseArrayOutput struct{ *pulumi.OutputState }

func (WidgetResponseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WidgetResponse)(nil)).Elem()
}

func (o WidgetResponseArrayOutput) ToWidgetResponseArrayOutput() WidgetResponseArrayOutput {
	return o
}

func (o WidgetResponseArrayOutput) ToWidgetResponseArrayOutputWithContext(ctx context.Context) WidgetResponseArrayOutput {
	return o
}

func (o WidgetResponseArrayOutput) Index(i pulumi.IntInput) WidgetResponseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) WidgetResponse {
		return vs[0].([]WidgetResponse)[vs[1].(int)]
	}).(WidgetResponseOutput)
}

// A chart that displays data on a 2D (X and Y axes) plane.
type XyChart struct {
	// Display options for the chart.
	ChartOptions *ChartOptions `pulumi:"chartOptions"`
	// The data displayed in this chart.
	DataSets []DataSet `pulumi:"dataSets"`
	// Threshold lines drawn horizontally across the chart.
	Thresholds []Threshold `pulumi:"thresholds"`
	// The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
	TimeshiftDuration *string `pulumi:"timeshiftDuration"`
	// The properties applied to the x-axis.
	XAxis *Axis `pulumi:"xAxis"`
	// The properties applied to the y2-axis.
	Y2Axis *Axis `pulumi:"y2Axis"`
	// The properties applied to the y-axis.
	YAxis *Axis `pulumi:"yAxis"`
}

// XyChartInput is an input type that accepts XyChartArgs and XyChartOutput values.
// You can construct a concrete instance of `XyChartInput` via:
//
//	XyChartArgs{...}
type XyChartInput interface {
	pulumi.Input

	ToXyChartOutput() XyChartOutput
	ToXyChartOutputWithContext(context.Context) XyChartOutput
}

// A chart that displays data on a 2D (X and Y axes) plane.
type XyChartArgs struct {
	// Display options for the chart.
	ChartOptions ChartOptionsPtrInput `pulumi:"chartOptions"`
	// The data displayed in this chart.
	DataSets DataSetArrayInput `pulumi:"dataSets"`
	// Threshold lines drawn horizontally across the chart.
	Thresholds ThresholdArrayInput `pulumi:"thresholds"`
	// The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
	TimeshiftDuration pulumi.StringPtrInput `pulumi:"timeshiftDuration"`
	// The properties applied to the x-axis.
	XAxis AxisPtrInput `pulumi:"xAxis"`
	// The properties applied to the y2-axis.
	Y2Axis AxisPtrInput `pulumi:"y2Axis"`
	// The properties applied to the y-axis.
	YAxis AxisPtrInput `pulumi:"yAxis"`
}

func (XyChartArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XyChart)(nil)).Elem()
}

func (i XyChartArgs) ToXyChartOutput() XyChartOutput {
	return i.ToXyChartOutputWithContext(context.Background())
}

func (i XyChartArgs) ToXyChartOutputWithContext(ctx context.Context) XyChartOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XyChartOutput)
}

func (i XyChartArgs) ToXyChartPtrOutput() XyChartPtrOutput {
	return i.ToXyChartPtrOutputWithContext(context.Background())
}

func (i XyChartArgs) ToXyChartPtrOutputWithContext(ctx context.Context) XyChartPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XyChartOutput).ToXyChartPtrOutputWithContext(ctx)
}

// XyChartPtrInput is an input type that accepts XyChartArgs, XyChartPtr and XyChartPtrOutput values.
// You can construct a concrete instance of `XyChartPtrInput` via:
//
//	        XyChartArgs{...}
//
//	or:
//
//	        nil
type XyChartPtrInput interface {
	pulumi.Input

	ToXyChartPtrOutput() XyChartPtrOutput
	ToXyChartPtrOutputWithContext(context.Context) XyChartPtrOutput
}

type xyChartPtrType XyChartArgs

func XyChartPtr(v *XyChartArgs) XyChartPtrInput {
	return (*xyChartPtrType)(v)
}

func (*xyChartPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XyChart)(nil)).Elem()
}

func (i *xyChartPtrType) ToXyChartPtrOutput() XyChartPtrOutput {
	return i.ToXyChartPtrOutputWithContext(context.Background())
}

func (i *xyChartPtrType) ToXyChartPtrOutputWithContext(ctx context.Context) XyChartPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XyChartPtrOutput)
}

// A chart that displays data on a 2D (X and Y axes) plane.
type XyChartOutput struct{ *pulumi.OutputState }

func (XyChartOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XyChart)(nil)).Elem()
}

func (o XyChartOutput) ToXyChartOutput() XyChartOutput {
	return o
}

func (o XyChartOutput) ToXyChartOutputWithContext(ctx context.Context) XyChartOutput {
	return o
}

func (o XyChartOutput) ToXyChartPtrOutput() XyChartPtrOutput {
	return o.ToXyChartPtrOutputWithContext(context.Background())
}

func (o XyChartOutput) ToXyChartPtrOutputWithContext(ctx context.Context) XyChartPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XyChart) *XyChart {
		return &v
	}).(XyChartPtrOutput)
}

// Display options for the chart.
func (o XyChartOutput) ChartOptions() ChartOptionsPtrOutput {
	return o.ApplyT(func(v XyChart) *ChartOptions { return v.ChartOptions }).(ChartOptionsPtrOutput)
}

// The data displayed in this chart.
func (o XyChartOutput) DataSets() DataSetArrayOutput {
	return o.ApplyT(func(v XyChart) []DataSet { return v.DataSets }).(DataSetArrayOutput)
}

// Threshold lines drawn horizontally across the chart.
func (o XyChartOutput) Thresholds() ThresholdArrayOutput {
	return o.ApplyT(func(v XyChart) []Threshold { return v.Thresholds }).(ThresholdArrayOutput)
}

// The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
func (o XyChartOutput) TimeshiftDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XyChart) *string { return v.TimeshiftDuration }).(pulumi.StringPtrOutput)
}

// The properties applied to the x-axis.
func (o XyChartOutput) XAxis() AxisPtrOutput {
	return o.ApplyT(func(v XyChart) *Axis { return v.XAxis }).(AxisPtrOutput)
}

// The properties applied to the y2-axis.
func (o XyChartOutput) Y2Axis() AxisPtrOutput {
	return o.ApplyT(func(v XyChart) *Axis { return v.Y2Axis }).(AxisPtrOutput)
}

// The properties applied to the y-axis.
func (o XyChartOutput) YAxis() AxisPtrOutput {
	return o.ApplyT(func(v XyChart) *Axis { return v.YAxis }).(AxisPtrOutput)
}

type XyChartPtrOutput struct{ *pulumi.OutputState }

func (XyChartPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XyChart)(nil)).Elem()
}

func (o XyChartPtrOutput) ToXyChartPtrOutput() XyChartPtrOutput {
	return o
}

func (o XyChartPtrOutput) ToXyChartPtrOutputWithContext(ctx context.Context) XyChartPtrOutput {
	return o
}

func (o XyChartPtrOutput) Elem() XyChartOutput {
	return o.ApplyT(func(v *XyChart) XyChart {
		if v != nil {
			return *v
		}
		var ret XyChart
		return ret
	}).(XyChartOutput)
}

// Display options for the chart.
func (o XyChartPtrOutput) ChartOptions() ChartOptionsPtrOutput {
	return o.ApplyT(func(v *XyChart) *ChartOptions {
		if v == nil {
			return nil
		}
		return v.ChartOptions
	}).(ChartOptionsPtrOutput)
}

// The data displayed in this chart.
func (o XyChartPtrOutput) DataSets() DataSetArrayOutput {
	return o.ApplyT(func(v *XyChart) []DataSet {
		if v == nil {
			return nil
		}
		return v.DataSets
	}).(DataSetArrayOutput)
}

// Threshold lines drawn horizontally across the chart.
func (o XyChartPtrOutput) Thresholds() ThresholdArrayOutput {
	return o.ApplyT(func(v *XyChart) []Threshold {
		if v == nil {
			return nil
		}
		return v.Thresholds
	}).(ThresholdArrayOutput)
}

// The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
func (o XyChartPtrOutput) TimeshiftDuration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XyChart) *string {
		if v == nil {
			return nil
		}
		return v.TimeshiftDuration
	}).(pulumi.StringPtrOutput)
}

// The properties applied to the x-axis.
func (o XyChartPtrOutput) XAxis() AxisPtrOutput {
	return o.ApplyT(func(v *XyChart) *Axis {
		if v == nil {
			return nil
		}
		return v.XAxis
	}).(AxisPtrOutput)
}

// The properties applied to the y2-axis.
func (o XyChartPtrOutput) Y2Axis() AxisPtrOutput {
	return o.ApplyT(func(v *XyChart) *Axis {
		if v == nil {
			return nil
		}
		return v.Y2Axis
	}).(AxisPtrOutput)
}

// The properties applied to the y-axis.
func (o XyChartPtrOutput) YAxis() AxisPtrOutput {
	return o.ApplyT(func(v *XyChart) *Axis {
		if v == nil {
			return nil
		}
		return v.YAxis
	}).(AxisPtrOutput)
}

// A chart that displays data on a 2D (X and Y axes) plane.
type XyChartResponse struct {
	// Display options for the chart.
	ChartOptions ChartOptionsResponse `pulumi:"chartOptions"`
	// The data displayed in this chart.
	DataSets []DataSetResponse `pulumi:"dataSets"`
	// Threshold lines drawn horizontally across the chart.
	Thresholds []ThresholdResponse `pulumi:"thresholds"`
	// The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
	TimeshiftDuration string `pulumi:"timeshiftDuration"`
	// The properties applied to the x-axis.
	XAxis AxisResponse `pulumi:"xAxis"`
	// The properties applied to the y2-axis.
	Y2Axis AxisResponse `pulumi:"y2Axis"`
	// The properties applied to the y-axis.
	YAxis AxisResponse `pulumi:"yAxis"`
}

// A chart that displays data on a 2D (X and Y axes) plane.
type XyChartResponseOutput struct{ *pulumi.OutputState }

func (XyChartResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XyChartResponse)(nil)).Elem()
}

func (o XyChartResponseOutput) ToXyChartResponseOutput() XyChartResponseOutput {
	return o
}

func (o XyChartResponseOutput) ToXyChartResponseOutputWithContext(ctx context.Context) XyChartResponseOutput {
	return o
}

// Display options for the chart.
func (o XyChartResponseOutput) ChartOptions() ChartOptionsResponseOutput {
	return o.ApplyT(func(v XyChartResponse) ChartOptionsResponse { return v.ChartOptions }).(ChartOptionsResponseOutput)
}

// The data displayed in this chart.
func (o XyChartResponseOutput) DataSets() DataSetResponseArrayOutput {
	return o.ApplyT(func(v XyChartResponse) []DataSetResponse { return v.DataSets }).(DataSetResponseArrayOutput)
}

// Threshold lines drawn horizontally across the chart.
func (o XyChartResponseOutput) Thresholds() ThresholdResponseArrayOutput {
	return o.ApplyT(func(v XyChartResponse) []ThresholdResponse { return v.Thresholds }).(ThresholdResponseArrayOutput)
}

// The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
func (o XyChartResponseOutput) TimeshiftDuration() pulumi.StringOutput {
	return o.ApplyT(func(v XyChartResponse) string { return v.TimeshiftDuration }).(pulumi.StringOutput)
}

// The properties applied to the x-axis.
func (o XyChartResponseOutput) XAxis() AxisResponseOutput {
	return o.ApplyT(func(v XyChartResponse) AxisResponse { return v.XAxis }).(AxisResponseOutput)
}

// The properties applied to the y2-axis.
func (o XyChartResponseOutput) Y2Axis() AxisResponseOutput {
	return o.ApplyT(func(v XyChartResponse) AxisResponse { return v.Y2Axis }).(AxisResponseOutput)
}

// The properties applied to the y-axis.
func (o XyChartResponseOutput) YAxis() AxisResponseOutput {
	return o.ApplyT(func(v XyChartResponse) AxisResponse { return v.YAxis }).(AxisResponseOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AggregationInput)(nil)).Elem(), AggregationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AggregationPtrInput)(nil)).Elem(), AggregationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AggregationFunctionInput)(nil)).Elem(), AggregationFunctionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlertChartInput)(nil)).Elem(), AlertChartArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlertChartPtrInput)(nil)).Elem(), AlertChartArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AxisInput)(nil)).Elem(), AxisArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AxisPtrInput)(nil)).Elem(), AxisArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BreakdownInput)(nil)).Elem(), BreakdownArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BreakdownArrayInput)(nil)).Elem(), BreakdownArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChartOptionsInput)(nil)).Elem(), ChartOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChartOptionsPtrInput)(nil)).Elem(), ChartOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CollapsibleGroupInput)(nil)).Elem(), CollapsibleGroupArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CollapsibleGroupPtrInput)(nil)).Elem(), CollapsibleGroupArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ColumnInput)(nil)).Elem(), ColumnArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ColumnArrayInput)(nil)).Elem(), ColumnArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ColumnLayoutInput)(nil)).Elem(), ColumnLayoutArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ColumnLayoutPtrInput)(nil)).Elem(), ColumnLayoutArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ColumnSettingsInput)(nil)).Elem(), ColumnSettingsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ColumnSettingsArrayInput)(nil)).Elem(), ColumnSettingsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DashboardFilterInput)(nil)).Elem(), DashboardFilterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DashboardFilterArrayInput)(nil)).Elem(), DashboardFilterArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DataSetInput)(nil)).Elem(), DataSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DataSetArrayInput)(nil)).Elem(), DataSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DimensionInput)(nil)).Elem(), DimensionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DimensionArrayInput)(nil)).Elem(), DimensionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*EmptyInput)(nil)).Elem(), EmptyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*EmptyPtrInput)(nil)).Elem(), EmptyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ErrorReportingPanelInput)(nil)).Elem(), ErrorReportingPanelArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ErrorReportingPanelPtrInput)(nil)).Elem(), ErrorReportingPanelArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GaugeViewInput)(nil)).Elem(), GaugeViewArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GaugeViewPtrInput)(nil)).Elem(), GaugeViewArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GridLayoutInput)(nil)).Elem(), GridLayoutArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GridLayoutPtrInput)(nil)).Elem(), GridLayoutArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IncidentListInput)(nil)).Elem(), IncidentListArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IncidentListPtrInput)(nil)).Elem(), IncidentListArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IntervalInput)(nil)).Elem(), IntervalArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IntervalPtrInput)(nil)).Elem(), IntervalArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogsPanelInput)(nil)).Elem(), LogsPanelArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogsPanelPtrInput)(nil)).Elem(), LogsPanelArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MeasureInput)(nil)).Elem(), MeasureArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MeasureArrayInput)(nil)).Elem(), MeasureArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MonitoredResourceInput)(nil)).Elem(), MonitoredResourceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MonitoredResourceArrayInput)(nil)).Elem(), MonitoredResourceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MosaicLayoutInput)(nil)).Elem(), MosaicLayoutArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MosaicLayoutPtrInput)(nil)).Elem(), MosaicLayoutArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OpsAnalyticsQueryInput)(nil)).Elem(), OpsAnalyticsQueryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*OpsAnalyticsQueryPtrInput)(nil)).Elem(), OpsAnalyticsQueryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ParameterInput)(nil)).Elem(), ParameterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ParameterArrayInput)(nil)).Elem(), ParameterArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PickTimeSeriesFilterInput)(nil)).Elem(), PickTimeSeriesFilterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PickTimeSeriesFilterPtrInput)(nil)).Elem(), PickTimeSeriesFilterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PieChartInput)(nil)).Elem(), PieChartArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PieChartPtrInput)(nil)).Elem(), PieChartArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PieChartDataSetInput)(nil)).Elem(), PieChartDataSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PieChartDataSetArrayInput)(nil)).Elem(), PieChartDataSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RatioPartInput)(nil)).Elem(), RatioPartArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RatioPartPtrInput)(nil)).Elem(), RatioPartArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RowInput)(nil)).Elem(), RowArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RowArrayInput)(nil)).Elem(), RowArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RowLayoutInput)(nil)).Elem(), RowLayoutArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RowLayoutPtrInput)(nil)).Elem(), RowLayoutArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ScorecardInput)(nil)).Elem(), ScorecardArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ScorecardPtrInput)(nil)).Elem(), ScorecardArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SectionHeaderInput)(nil)).Elem(), SectionHeaderArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SectionHeaderPtrInput)(nil)).Elem(), SectionHeaderArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SingleViewGroupInput)(nil)).Elem(), SingleViewGroupArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SingleViewGroupPtrInput)(nil)).Elem(), SingleViewGroupArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SparkChartViewInput)(nil)).Elem(), SparkChartViewArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SparkChartViewPtrInput)(nil)).Elem(), SparkChartViewArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*StatisticalTimeSeriesFilterInput)(nil)).Elem(), StatisticalTimeSeriesFilterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*StatisticalTimeSeriesFilterPtrInput)(nil)).Elem(), StatisticalTimeSeriesFilterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TableDataSetInput)(nil)).Elem(), TableDataSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TableDataSetArrayInput)(nil)).Elem(), TableDataSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TableDisplayOptionsInput)(nil)).Elem(), TableDisplayOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TableDisplayOptionsPtrInput)(nil)).Elem(), TableDisplayOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TextInput)(nil)).Elem(), TextArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TextPtrInput)(nil)).Elem(), TextArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TextStyleInput)(nil)).Elem(), TextStyleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TextStylePtrInput)(nil)).Elem(), TextStyleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ThresholdInput)(nil)).Elem(), ThresholdArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ThresholdArrayInput)(nil)).Elem(), ThresholdArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TileInput)(nil)).Elem(), TileArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TileArrayInput)(nil)).Elem(), TileArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TimeSeriesFilterInput)(nil)).Elem(), TimeSeriesFilterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TimeSeriesFilterPtrInput)(nil)).Elem(), TimeSeriesFilterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TimeSeriesFilterRatioInput)(nil)).Elem(), TimeSeriesFilterRatioArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TimeSeriesFilterRatioPtrInput)(nil)).Elem(), TimeSeriesFilterRatioArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TimeSeriesQueryInput)(nil)).Elem(), TimeSeriesQueryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TimeSeriesQueryPtrInput)(nil)).Elem(), TimeSeriesQueryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TimeSeriesTableInput)(nil)).Elem(), TimeSeriesTableArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TimeSeriesTablePtrInput)(nil)).Elem(), TimeSeriesTableArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WidgetInput)(nil)).Elem(), WidgetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WidgetPtrInput)(nil)).Elem(), WidgetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WidgetArrayInput)(nil)).Elem(), WidgetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XyChartInput)(nil)).Elem(), XyChartArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XyChartPtrInput)(nil)).Elem(), XyChartArgs{})
	pulumi.RegisterOutputType(AggregationOutput{})
	pulumi.RegisterOutputType(AggregationPtrOutput{})
	pulumi.RegisterOutputType(AggregationFunctionOutput{})
	pulumi.RegisterOutputType(AggregationFunctionResponseOutput{})
	pulumi.RegisterOutputType(AggregationResponseOutput{})
	pulumi.RegisterOutputType(AlertChartOutput{})
	pulumi.RegisterOutputType(AlertChartPtrOutput{})
	pulumi.RegisterOutputType(AlertChartResponseOutput{})
	pulumi.RegisterOutputType(AxisOutput{})
	pulumi.RegisterOutputType(AxisPtrOutput{})
	pulumi.RegisterOutputType(AxisResponseOutput{})
	pulumi.RegisterOutputType(BreakdownOutput{})
	pulumi.RegisterOutputType(BreakdownArrayOutput{})
	pulumi.RegisterOutputType(BreakdownResponseOutput{})
	pulumi.RegisterOutputType(BreakdownResponseArrayOutput{})
	pulumi.RegisterOutputType(ChartOptionsOutput{})
	pulumi.RegisterOutputType(ChartOptionsPtrOutput{})
	pulumi.RegisterOutputType(ChartOptionsResponseOutput{})
	pulumi.RegisterOutputType(CollapsibleGroupOutput{})
	pulumi.RegisterOutputType(CollapsibleGroupPtrOutput{})
	pulumi.RegisterOutputType(CollapsibleGroupResponseOutput{})
	pulumi.RegisterOutputType(ColumnOutput{})
	pulumi.RegisterOutputType(ColumnArrayOutput{})
	pulumi.RegisterOutputType(ColumnLayoutOutput{})
	pulumi.RegisterOutputType(ColumnLayoutPtrOutput{})
	pulumi.RegisterOutputType(ColumnLayoutResponseOutput{})
	pulumi.RegisterOutputType(ColumnResponseOutput{})
	pulumi.RegisterOutputType(ColumnResponseArrayOutput{})
	pulumi.RegisterOutputType(ColumnSettingsOutput{})
	pulumi.RegisterOutputType(ColumnSettingsArrayOutput{})
	pulumi.RegisterOutputType(ColumnSettingsResponseOutput{})
	pulumi.RegisterOutputType(ColumnSettingsResponseArrayOutput{})
	pulumi.RegisterOutputType(DashboardFilterOutput{})
	pulumi.RegisterOutputType(DashboardFilterArrayOutput{})
	pulumi.RegisterOutputType(DashboardFilterResponseOutput{})
	pulumi.RegisterOutputType(DashboardFilterResponseArrayOutput{})
	pulumi.RegisterOutputType(DataSetOutput{})
	pulumi.RegisterOutputType(DataSetArrayOutput{})
	pulumi.RegisterOutputType(DataSetResponseOutput{})
	pulumi.RegisterOutputType(DataSetResponseArrayOutput{})
	pulumi.RegisterOutputType(DimensionOutput{})
	pulumi.RegisterOutputType(DimensionArrayOutput{})
	pulumi.RegisterOutputType(DimensionResponseOutput{})
	pulumi.RegisterOutputType(DimensionResponseArrayOutput{})
	pulumi.RegisterOutputType(EmptyOutput{})
	pulumi.RegisterOutputType(EmptyPtrOutput{})
	pulumi.RegisterOutputType(EmptyResponseOutput{})
	pulumi.RegisterOutputType(ErrorReportingPanelOutput{})
	pulumi.RegisterOutputType(ErrorReportingPanelPtrOutput{})
	pulumi.RegisterOutputType(ErrorReportingPanelResponseOutput{})
	pulumi.RegisterOutputType(GaugeViewOutput{})
	pulumi.RegisterOutputType(GaugeViewPtrOutput{})
	pulumi.RegisterOutputType(GaugeViewResponseOutput{})
	pulumi.RegisterOutputType(GridLayoutOutput{})
	pulumi.RegisterOutputType(GridLayoutPtrOutput{})
	pulumi.RegisterOutputType(GridLayoutResponseOutput{})
	pulumi.RegisterOutputType(IncidentListOutput{})
	pulumi.RegisterOutputType(IncidentListPtrOutput{})
	pulumi.RegisterOutputType(IncidentListResponseOutput{})
	pulumi.RegisterOutputType(IntervalOutput{})
	pulumi.RegisterOutputType(IntervalPtrOutput{})
	pulumi.RegisterOutputType(IntervalResponseOutput{})
	pulumi.RegisterOutputType(LogsPanelOutput{})
	pulumi.RegisterOutputType(LogsPanelPtrOutput{})
	pulumi.RegisterOutputType(LogsPanelResponseOutput{})
	pulumi.RegisterOutputType(MeasureOutput{})
	pulumi.RegisterOutputType(MeasureArrayOutput{})
	pulumi.RegisterOutputType(MeasureResponseOutput{})
	pulumi.RegisterOutputType(MeasureResponseArrayOutput{})
	pulumi.RegisterOutputType(MonitoredResourceOutput{})
	pulumi.RegisterOutputType(MonitoredResourceArrayOutput{})
	pulumi.RegisterOutputType(MonitoredResourceResponseOutput{})
	pulumi.RegisterOutputType(MonitoredResourceResponseArrayOutput{})
	pulumi.RegisterOutputType(MosaicLayoutOutput{})
	pulumi.RegisterOutputType(MosaicLayoutPtrOutput{})
	pulumi.RegisterOutputType(MosaicLayoutResponseOutput{})
	pulumi.RegisterOutputType(OpsAnalyticsQueryOutput{})
	pulumi.RegisterOutputType(OpsAnalyticsQueryPtrOutput{})
	pulumi.RegisterOutputType(OpsAnalyticsQueryResponseOutput{})
	pulumi.RegisterOutputType(ParameterOutput{})
	pulumi.RegisterOutputType(ParameterArrayOutput{})
	pulumi.RegisterOutputType(ParameterResponseOutput{})
	pulumi.RegisterOutputType(ParameterResponseArrayOutput{})
	pulumi.RegisterOutputType(PickTimeSeriesFilterOutput{})
	pulumi.RegisterOutputType(PickTimeSeriesFilterPtrOutput{})
	pulumi.RegisterOutputType(PickTimeSeriesFilterResponseOutput{})
	pulumi.RegisterOutputType(PieChartOutput{})
	pulumi.RegisterOutputType(PieChartPtrOutput{})
	pulumi.RegisterOutputType(PieChartDataSetOutput{})
	pulumi.RegisterOutputType(PieChartDataSetArrayOutput{})
	pulumi.RegisterOutputType(PieChartDataSetResponseOutput{})
	pulumi.RegisterOutputType(PieChartDataSetResponseArrayOutput{})
	pulumi.RegisterOutputType(PieChartResponseOutput{})
	pulumi.RegisterOutputType(RatioPartOutput{})
	pulumi.RegisterOutputType(RatioPartPtrOutput{})
	pulumi.RegisterOutputType(RatioPartResponseOutput{})
	pulumi.RegisterOutputType(RowOutput{})
	pulumi.RegisterOutputType(RowArrayOutput{})
	pulumi.RegisterOutputType(RowLayoutOutput{})
	pulumi.RegisterOutputType(RowLayoutPtrOutput{})
	pulumi.RegisterOutputType(RowLayoutResponseOutput{})
	pulumi.RegisterOutputType(RowResponseOutput{})
	pulumi.RegisterOutputType(RowResponseArrayOutput{})
	pulumi.RegisterOutputType(ScorecardOutput{})
	pulumi.RegisterOutputType(ScorecardPtrOutput{})
	pulumi.RegisterOutputType(ScorecardResponseOutput{})
	pulumi.RegisterOutputType(SectionHeaderOutput{})
	pulumi.RegisterOutputType(SectionHeaderPtrOutput{})
	pulumi.RegisterOutputType(SectionHeaderResponseOutput{})
	pulumi.RegisterOutputType(SingleViewGroupOutput{})
	pulumi.RegisterOutputType(SingleViewGroupPtrOutput{})
	pulumi.RegisterOutputType(SingleViewGroupResponseOutput{})
	pulumi.RegisterOutputType(SparkChartViewOutput{})
	pulumi.RegisterOutputType(SparkChartViewPtrOutput{})
	pulumi.RegisterOutputType(SparkChartViewResponseOutput{})
	pulumi.RegisterOutputType(StatisticalTimeSeriesFilterOutput{})
	pulumi.RegisterOutputType(StatisticalTimeSeriesFilterPtrOutput{})
	pulumi.RegisterOutputType(StatisticalTimeSeriesFilterResponseOutput{})
	pulumi.RegisterOutputType(TableDataSetOutput{})
	pulumi.RegisterOutputType(TableDataSetArrayOutput{})
	pulumi.RegisterOutputType(TableDataSetResponseOutput{})
	pulumi.RegisterOutputType(TableDataSetResponseArrayOutput{})
	pulumi.RegisterOutputType(TableDisplayOptionsOutput{})
	pulumi.RegisterOutputType(TableDisplayOptionsPtrOutput{})
	pulumi.RegisterOutputType(TableDisplayOptionsResponseOutput{})
	pulumi.RegisterOutputType(TextOutput{})
	pulumi.RegisterOutputType(TextPtrOutput{})
	pulumi.RegisterOutputType(TextResponseOutput{})
	pulumi.RegisterOutputType(TextStyleOutput{})
	pulumi.RegisterOutputType(TextStylePtrOutput{})
	pulumi.RegisterOutputType(TextStyleResponseOutput{})
	pulumi.RegisterOutputType(ThresholdOutput{})
	pulumi.RegisterOutputType(ThresholdArrayOutput{})
	pulumi.RegisterOutputType(ThresholdResponseOutput{})
	pulumi.RegisterOutputType(ThresholdResponseArrayOutput{})
	pulumi.RegisterOutputType(TileOutput{})
	pulumi.RegisterOutputType(TileArrayOutput{})
	pulumi.RegisterOutputType(TileResponseOutput{})
	pulumi.RegisterOutputType(TileResponseArrayOutput{})
	pulumi.RegisterOutputType(TimeSeriesFilterOutput{})
	pulumi.RegisterOutputType(TimeSeriesFilterPtrOutput{})
	pulumi.RegisterOutputType(TimeSeriesFilterRatioOutput{})
	pulumi.RegisterOutputType(TimeSeriesFilterRatioPtrOutput{})
	pulumi.RegisterOutputType(TimeSeriesFilterRatioResponseOutput{})
	pulumi.RegisterOutputType(TimeSeriesFilterResponseOutput{})
	pulumi.RegisterOutputType(TimeSeriesQueryOutput{})
	pulumi.RegisterOutputType(TimeSeriesQueryPtrOutput{})
	pulumi.RegisterOutputType(TimeSeriesQueryResponseOutput{})
	pulumi.RegisterOutputType(TimeSeriesTableOutput{})
	pulumi.RegisterOutputType(TimeSeriesTablePtrOutput{})
	pulumi.RegisterOutputType(TimeSeriesTableResponseOutput{})
	pulumi.RegisterOutputType(WidgetOutput{})
	pulumi.RegisterOutputType(WidgetPtrOutput{})
	pulumi.RegisterOutputType(WidgetArrayOutput{})
	pulumi.RegisterOutputType(WidgetResponseOutput{})
	pulumi.RegisterOutputType(WidgetResponseArrayOutput{})
	pulumi.RegisterOutputType(XyChartOutput{})
	pulumi.RegisterOutputType(XyChartPtrOutput{})
	pulumi.RegisterOutputType(XyChartResponseOutput{})
}
