// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v3

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
type Aggregation struct {
	// The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 104 weeks (2 years) for charts, and 90,000 seconds (25 hours) for alerting policies.
	AlignmentPeriod *string `pulumi:"alignmentPeriod"`
	// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
	CrossSeriesReducer *string `pulumi:"crossSeriesReducer"`
	// The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
	GroupByFields []string `pulumi:"groupByFields"`
	// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
	PerSeriesAligner *string `pulumi:"perSeriesAligner"`
}

// AggregationInput is an input type that accepts AggregationArgs and AggregationOutput values.
// You can construct a concrete instance of `AggregationInput` via:
//
//          AggregationArgs{...}
type AggregationInput interface {
	pulumi.Input

	ToAggregationOutput() AggregationOutput
	ToAggregationOutputWithContext(context.Context) AggregationOutput
}

// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
type AggregationArgs struct {
	// The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 104 weeks (2 years) for charts, and 90,000 seconds (25 hours) for alerting policies.
	AlignmentPeriod pulumi.StringPtrInput `pulumi:"alignmentPeriod"`
	// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
	CrossSeriesReducer pulumi.StringPtrInput `pulumi:"crossSeriesReducer"`
	// The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
	GroupByFields pulumi.StringArrayInput `pulumi:"groupByFields"`
	// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
	PerSeriesAligner pulumi.StringPtrInput `pulumi:"perSeriesAligner"`
}

func (AggregationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Aggregation)(nil)).Elem()
}

func (i AggregationArgs) ToAggregationOutput() AggregationOutput {
	return i.ToAggregationOutputWithContext(context.Background())
}

func (i AggregationArgs) ToAggregationOutputWithContext(ctx context.Context) AggregationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AggregationOutput)
}

// AggregationArrayInput is an input type that accepts AggregationArray and AggregationArrayOutput values.
// You can construct a concrete instance of `AggregationArrayInput` via:
//
//          AggregationArray{ AggregationArgs{...} }
type AggregationArrayInput interface {
	pulumi.Input

	ToAggregationArrayOutput() AggregationArrayOutput
	ToAggregationArrayOutputWithContext(context.Context) AggregationArrayOutput
}

type AggregationArray []AggregationInput

func (AggregationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Aggregation)(nil)).Elem()
}

func (i AggregationArray) ToAggregationArrayOutput() AggregationArrayOutput {
	return i.ToAggregationArrayOutputWithContext(context.Background())
}

func (i AggregationArray) ToAggregationArrayOutputWithContext(ctx context.Context) AggregationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AggregationArrayOutput)
}

// Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
type AggregationOutput struct{ *pulumi.OutputState }

func (AggregationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Aggregation)(nil)).Elem()
}

func (o AggregationOutput) ToAggregationOutput() AggregationOutput {
	return o
}

func (o AggregationOutput) ToAggregationOutputWithContext(ctx context.Context) AggregationOutput {
	return o
}

// The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 104 weeks (2 years) for charts, and 90,000 seconds (25 hours) for alerting policies.
func (o AggregationOutput) AlignmentPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Aggregation) *string { return v.AlignmentPeriod }).(pulumi.StringPtrOutput)
}

// The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
func (o AggregationOutput) CrossSeriesReducer() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Aggregation) *string { return v.CrossSeriesReducer }).(pulumi.StringPtrOutput)
}

// The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
func (o AggregationOutput) GroupByFields() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Aggregation) []string { return v.GroupByFields }).(pulumi.StringArrayOutput)
}

// An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
func (o AggregationOutput) PerSeriesAligner() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Aggregation) *string { return v.PerSeriesAligner }).(pulumi.StringPtrOutput)
}

type AggregationArrayOutput struct{ *pulumi.OutputState }

func (AggregationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Aggregation)(nil)).Elem()
}

func (o AggregationArrayOutput) ToAggregationArrayOutput() AggregationArrayOutput {
	return o
}

func (o AggregationArrayOutput) ToAggregationArrayOutputWithContext(ctx context.Context) AggregationArrayOutput {
	return o
}

func (o AggregationArrayOutput) Index(i pulumi.IntInput) AggregationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Aggregation {
		return vs[0].([]Aggregation)[vs[1].(int)]
	}).(AggregationOutput)
}

// App Engine service. Learn more at https://cloud.google.com/appengine.
type AppEngine struct {
	// The ID of the App Engine module underlying this service. Corresponds to the module_id resource label in the gae_app monitored resource: https://cloud.google.com/monitoring/api/resources#tag_gae_app
	ModuleId *string `pulumi:"moduleId"`
}

// AppEngineInput is an input type that accepts AppEngineArgs and AppEngineOutput values.
// You can construct a concrete instance of `AppEngineInput` via:
//
//          AppEngineArgs{...}
type AppEngineInput interface {
	pulumi.Input

	ToAppEngineOutput() AppEngineOutput
	ToAppEngineOutputWithContext(context.Context) AppEngineOutput
}

// App Engine service. Learn more at https://cloud.google.com/appengine.
type AppEngineArgs struct {
	// The ID of the App Engine module underlying this service. Corresponds to the module_id resource label in the gae_app monitored resource: https://cloud.google.com/monitoring/api/resources#tag_gae_app
	ModuleId pulumi.StringPtrInput `pulumi:"moduleId"`
}

func (AppEngineArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AppEngine)(nil)).Elem()
}

func (i AppEngineArgs) ToAppEngineOutput() AppEngineOutput {
	return i.ToAppEngineOutputWithContext(context.Background())
}

func (i AppEngineArgs) ToAppEngineOutputWithContext(ctx context.Context) AppEngineOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AppEngineOutput)
}

func (i AppEngineArgs) ToAppEnginePtrOutput() AppEnginePtrOutput {
	return i.ToAppEnginePtrOutputWithContext(context.Background())
}

func (i AppEngineArgs) ToAppEnginePtrOutputWithContext(ctx context.Context) AppEnginePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AppEngineOutput).ToAppEnginePtrOutputWithContext(ctx)
}

// AppEnginePtrInput is an input type that accepts AppEngineArgs, AppEnginePtr and AppEnginePtrOutput values.
// You can construct a concrete instance of `AppEnginePtrInput` via:
//
//          AppEngineArgs{...}
//
//  or:
//
//          nil
type AppEnginePtrInput interface {
	pulumi.Input

	ToAppEnginePtrOutput() AppEnginePtrOutput
	ToAppEnginePtrOutputWithContext(context.Context) AppEnginePtrOutput
}

type appEnginePtrType AppEngineArgs

func AppEnginePtr(v *AppEngineArgs) AppEnginePtrInput {
	return (*appEnginePtrType)(v)
}

func (*appEnginePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AppEngine)(nil)).Elem()
}

func (i *appEnginePtrType) ToAppEnginePtrOutput() AppEnginePtrOutput {
	return i.ToAppEnginePtrOutputWithContext(context.Background())
}

func (i *appEnginePtrType) ToAppEnginePtrOutputWithContext(ctx context.Context) AppEnginePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AppEnginePtrOutput)
}

// App Engine service. Learn more at https://cloud.google.com/appengine.
type AppEngineOutput struct{ *pulumi.OutputState }

func (AppEngineOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AppEngine)(nil)).Elem()
}

func (o AppEngineOutput) ToAppEngineOutput() AppEngineOutput {
	return o
}

func (o AppEngineOutput) ToAppEngineOutputWithContext(ctx context.Context) AppEngineOutput {
	return o
}

func (o AppEngineOutput) ToAppEnginePtrOutput() AppEnginePtrOutput {
	return o.ToAppEnginePtrOutputWithContext(context.Background())
}

func (o AppEngineOutput) ToAppEnginePtrOutputWithContext(ctx context.Context) AppEnginePtrOutput {
	return o.ApplyT(func(v AppEngine) *AppEngine {
		return &v
	}).(AppEnginePtrOutput)
}

// The ID of the App Engine module underlying this service. Corresponds to the module_id resource label in the gae_app monitored resource: https://cloud.google.com/monitoring/api/resources#tag_gae_app
func (o AppEngineOutput) ModuleId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AppEngine) *string { return v.ModuleId }).(pulumi.StringPtrOutput)
}

type AppEnginePtrOutput struct{ *pulumi.OutputState }

func (AppEnginePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AppEngine)(nil)).Elem()
}

func (o AppEnginePtrOutput) ToAppEnginePtrOutput() AppEnginePtrOutput {
	return o
}

func (o AppEnginePtrOutput) ToAppEnginePtrOutputWithContext(ctx context.Context) AppEnginePtrOutput {
	return o
}

func (o AppEnginePtrOutput) Elem() AppEngineOutput {
	return o.ApplyT(func(v *AppEngine) AppEngine { return *v }).(AppEngineOutput)
}

// The ID of the App Engine module underlying this service. Corresponds to the module_id resource label in the gae_app monitored resource: https://cloud.google.com/monitoring/api/resources#tag_gae_app
func (o AppEnginePtrOutput) ModuleId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AppEngine) *string {
		if v == nil {
			return nil
		}
		return v.ModuleId
	}).(pulumi.StringPtrOutput)
}

// Future parameters for the availability SLI.
type AvailabilityCriteria struct {
}

// AvailabilityCriteriaInput is an input type that accepts AvailabilityCriteriaArgs and AvailabilityCriteriaOutput values.
// You can construct a concrete instance of `AvailabilityCriteriaInput` via:
//
//          AvailabilityCriteriaArgs{...}
type AvailabilityCriteriaInput interface {
	pulumi.Input

	ToAvailabilityCriteriaOutput() AvailabilityCriteriaOutput
	ToAvailabilityCriteriaOutputWithContext(context.Context) AvailabilityCriteriaOutput
}

// Future parameters for the availability SLI.
type AvailabilityCriteriaArgs struct {
}

func (AvailabilityCriteriaArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AvailabilityCriteria)(nil)).Elem()
}

func (i AvailabilityCriteriaArgs) ToAvailabilityCriteriaOutput() AvailabilityCriteriaOutput {
	return i.ToAvailabilityCriteriaOutputWithContext(context.Background())
}

func (i AvailabilityCriteriaArgs) ToAvailabilityCriteriaOutputWithContext(ctx context.Context) AvailabilityCriteriaOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AvailabilityCriteriaOutput)
}

func (i AvailabilityCriteriaArgs) ToAvailabilityCriteriaPtrOutput() AvailabilityCriteriaPtrOutput {
	return i.ToAvailabilityCriteriaPtrOutputWithContext(context.Background())
}

func (i AvailabilityCriteriaArgs) ToAvailabilityCriteriaPtrOutputWithContext(ctx context.Context) AvailabilityCriteriaPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AvailabilityCriteriaOutput).ToAvailabilityCriteriaPtrOutputWithContext(ctx)
}

// AvailabilityCriteriaPtrInput is an input type that accepts AvailabilityCriteriaArgs, AvailabilityCriteriaPtr and AvailabilityCriteriaPtrOutput values.
// You can construct a concrete instance of `AvailabilityCriteriaPtrInput` via:
//
//          AvailabilityCriteriaArgs{...}
//
//  or:
//
//          nil
type AvailabilityCriteriaPtrInput interface {
	pulumi.Input

	ToAvailabilityCriteriaPtrOutput() AvailabilityCriteriaPtrOutput
	ToAvailabilityCriteriaPtrOutputWithContext(context.Context) AvailabilityCriteriaPtrOutput
}

type availabilityCriteriaPtrType AvailabilityCriteriaArgs

func AvailabilityCriteriaPtr(v *AvailabilityCriteriaArgs) AvailabilityCriteriaPtrInput {
	return (*availabilityCriteriaPtrType)(v)
}

func (*availabilityCriteriaPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AvailabilityCriteria)(nil)).Elem()
}

func (i *availabilityCriteriaPtrType) ToAvailabilityCriteriaPtrOutput() AvailabilityCriteriaPtrOutput {
	return i.ToAvailabilityCriteriaPtrOutputWithContext(context.Background())
}

func (i *availabilityCriteriaPtrType) ToAvailabilityCriteriaPtrOutputWithContext(ctx context.Context) AvailabilityCriteriaPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AvailabilityCriteriaPtrOutput)
}

// Future parameters for the availability SLI.
type AvailabilityCriteriaOutput struct{ *pulumi.OutputState }

func (AvailabilityCriteriaOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AvailabilityCriteria)(nil)).Elem()
}

func (o AvailabilityCriteriaOutput) ToAvailabilityCriteriaOutput() AvailabilityCriteriaOutput {
	return o
}

func (o AvailabilityCriteriaOutput) ToAvailabilityCriteriaOutputWithContext(ctx context.Context) AvailabilityCriteriaOutput {
	return o
}

func (o AvailabilityCriteriaOutput) ToAvailabilityCriteriaPtrOutput() AvailabilityCriteriaPtrOutput {
	return o.ToAvailabilityCriteriaPtrOutputWithContext(context.Background())
}

func (o AvailabilityCriteriaOutput) ToAvailabilityCriteriaPtrOutputWithContext(ctx context.Context) AvailabilityCriteriaPtrOutput {
	return o.ApplyT(func(v AvailabilityCriteria) *AvailabilityCriteria {
		return &v
	}).(AvailabilityCriteriaPtrOutput)
}

type AvailabilityCriteriaPtrOutput struct{ *pulumi.OutputState }

func (AvailabilityCriteriaPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AvailabilityCriteria)(nil)).Elem()
}

func (o AvailabilityCriteriaPtrOutput) ToAvailabilityCriteriaPtrOutput() AvailabilityCriteriaPtrOutput {
	return o
}

func (o AvailabilityCriteriaPtrOutput) ToAvailabilityCriteriaPtrOutputWithContext(ctx context.Context) AvailabilityCriteriaPtrOutput {
	return o
}

func (o AvailabilityCriteriaPtrOutput) Elem() AvailabilityCriteriaOutput {
	return o.ApplyT(func(v *AvailabilityCriteria) AvailabilityCriteria { return *v }).(AvailabilityCriteriaOutput)
}

// The authentication parameters to provide to the specified resource or URL that requires a username and password. Currently, only Basic HTTP authentication (https://tools.ietf.org/html/rfc7617) is supported in Uptime checks.
type BasicAuthentication struct {
	// The password to use when authenticating with the HTTP server.
	Password *string `pulumi:"password"`
	// The username to use when authenticating with the HTTP server.
	Username *string `pulumi:"username"`
}

// BasicAuthenticationInput is an input type that accepts BasicAuthenticationArgs and BasicAuthenticationOutput values.
// You can construct a concrete instance of `BasicAuthenticationInput` via:
//
//          BasicAuthenticationArgs{...}
type BasicAuthenticationInput interface {
	pulumi.Input

	ToBasicAuthenticationOutput() BasicAuthenticationOutput
	ToBasicAuthenticationOutputWithContext(context.Context) BasicAuthenticationOutput
}

// The authentication parameters to provide to the specified resource or URL that requires a username and password. Currently, only Basic HTTP authentication (https://tools.ietf.org/html/rfc7617) is supported in Uptime checks.
type BasicAuthenticationArgs struct {
	// The password to use when authenticating with the HTTP server.
	Password pulumi.StringPtrInput `pulumi:"password"`
	// The username to use when authenticating with the HTTP server.
	Username pulumi.StringPtrInput `pulumi:"username"`
}

func (BasicAuthenticationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicAuthentication)(nil)).Elem()
}

func (i BasicAuthenticationArgs) ToBasicAuthenticationOutput() BasicAuthenticationOutput {
	return i.ToBasicAuthenticationOutputWithContext(context.Background())
}

func (i BasicAuthenticationArgs) ToBasicAuthenticationOutputWithContext(ctx context.Context) BasicAuthenticationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicAuthenticationOutput)
}

func (i BasicAuthenticationArgs) ToBasicAuthenticationPtrOutput() BasicAuthenticationPtrOutput {
	return i.ToBasicAuthenticationPtrOutputWithContext(context.Background())
}

func (i BasicAuthenticationArgs) ToBasicAuthenticationPtrOutputWithContext(ctx context.Context) BasicAuthenticationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicAuthenticationOutput).ToBasicAuthenticationPtrOutputWithContext(ctx)
}

// BasicAuthenticationPtrInput is an input type that accepts BasicAuthenticationArgs, BasicAuthenticationPtr and BasicAuthenticationPtrOutput values.
// You can construct a concrete instance of `BasicAuthenticationPtrInput` via:
//
//          BasicAuthenticationArgs{...}
//
//  or:
//
//          nil
type BasicAuthenticationPtrInput interface {
	pulumi.Input

	ToBasicAuthenticationPtrOutput() BasicAuthenticationPtrOutput
	ToBasicAuthenticationPtrOutputWithContext(context.Context) BasicAuthenticationPtrOutput
}

type basicAuthenticationPtrType BasicAuthenticationArgs

func BasicAuthenticationPtr(v *BasicAuthenticationArgs) BasicAuthenticationPtrInput {
	return (*basicAuthenticationPtrType)(v)
}

func (*basicAuthenticationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicAuthentication)(nil)).Elem()
}

func (i *basicAuthenticationPtrType) ToBasicAuthenticationPtrOutput() BasicAuthenticationPtrOutput {
	return i.ToBasicAuthenticationPtrOutputWithContext(context.Background())
}

func (i *basicAuthenticationPtrType) ToBasicAuthenticationPtrOutputWithContext(ctx context.Context) BasicAuthenticationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicAuthenticationPtrOutput)
}

// The authentication parameters to provide to the specified resource or URL that requires a username and password. Currently, only Basic HTTP authentication (https://tools.ietf.org/html/rfc7617) is supported in Uptime checks.
type BasicAuthenticationOutput struct{ *pulumi.OutputState }

func (BasicAuthenticationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicAuthentication)(nil)).Elem()
}

func (o BasicAuthenticationOutput) ToBasicAuthenticationOutput() BasicAuthenticationOutput {
	return o
}

func (o BasicAuthenticationOutput) ToBasicAuthenticationOutputWithContext(ctx context.Context) BasicAuthenticationOutput {
	return o
}

func (o BasicAuthenticationOutput) ToBasicAuthenticationPtrOutput() BasicAuthenticationPtrOutput {
	return o.ToBasicAuthenticationPtrOutputWithContext(context.Background())
}

func (o BasicAuthenticationOutput) ToBasicAuthenticationPtrOutputWithContext(ctx context.Context) BasicAuthenticationPtrOutput {
	return o.ApplyT(func(v BasicAuthentication) *BasicAuthentication {
		return &v
	}).(BasicAuthenticationPtrOutput)
}

// The password to use when authenticating with the HTTP server.
func (o BasicAuthenticationOutput) Password() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BasicAuthentication) *string { return v.Password }).(pulumi.StringPtrOutput)
}

// The username to use when authenticating with the HTTP server.
func (o BasicAuthenticationOutput) Username() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BasicAuthentication) *string { return v.Username }).(pulumi.StringPtrOutput)
}

type BasicAuthenticationPtrOutput struct{ *pulumi.OutputState }

func (BasicAuthenticationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicAuthentication)(nil)).Elem()
}

func (o BasicAuthenticationPtrOutput) ToBasicAuthenticationPtrOutput() BasicAuthenticationPtrOutput {
	return o
}

func (o BasicAuthenticationPtrOutput) ToBasicAuthenticationPtrOutputWithContext(ctx context.Context) BasicAuthenticationPtrOutput {
	return o
}

func (o BasicAuthenticationPtrOutput) Elem() BasicAuthenticationOutput {
	return o.ApplyT(func(v *BasicAuthentication) BasicAuthentication { return *v }).(BasicAuthenticationOutput)
}

// The password to use when authenticating with the HTTP server.
func (o BasicAuthenticationPtrOutput) Password() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BasicAuthentication) *string {
		if v == nil {
			return nil
		}
		return v.Password
	}).(pulumi.StringPtrOutput)
}

// The username to use when authenticating with the HTTP server.
func (o BasicAuthenticationPtrOutput) Username() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BasicAuthentication) *string {
		if v == nil {
			return nil
		}
		return v.Username
	}).(pulumi.StringPtrOutput)
}

// An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service.
type BasicSli struct {
	// Good service is defined to be the count of requests made to this service that return successfully.
	Availability *AvailabilityCriteria `pulumi:"availability"`
	// Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
	Latency *LatencyCriteria `pulumi:"latency"`
	// OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.
	Location []string `pulumi:"location"`
	// OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.
	Method []string `pulumi:"method"`
	// OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error.
	Version []string `pulumi:"version"`
}

// BasicSliInput is an input type that accepts BasicSliArgs and BasicSliOutput values.
// You can construct a concrete instance of `BasicSliInput` via:
//
//          BasicSliArgs{...}
type BasicSliInput interface {
	pulumi.Input

	ToBasicSliOutput() BasicSliOutput
	ToBasicSliOutputWithContext(context.Context) BasicSliOutput
}

// An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service.
type BasicSliArgs struct {
	// Good service is defined to be the count of requests made to this service that return successfully.
	Availability AvailabilityCriteriaPtrInput `pulumi:"availability"`
	// Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
	Latency LatencyCriteriaPtrInput `pulumi:"latency"`
	// OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.
	Location pulumi.StringArrayInput `pulumi:"location"`
	// OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.
	Method pulumi.StringArrayInput `pulumi:"method"`
	// OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error.
	Version pulumi.StringArrayInput `pulumi:"version"`
}

func (BasicSliArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicSli)(nil)).Elem()
}

func (i BasicSliArgs) ToBasicSliOutput() BasicSliOutput {
	return i.ToBasicSliOutputWithContext(context.Background())
}

func (i BasicSliArgs) ToBasicSliOutputWithContext(ctx context.Context) BasicSliOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicSliOutput)
}

func (i BasicSliArgs) ToBasicSliPtrOutput() BasicSliPtrOutput {
	return i.ToBasicSliPtrOutputWithContext(context.Background())
}

func (i BasicSliArgs) ToBasicSliPtrOutputWithContext(ctx context.Context) BasicSliPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicSliOutput).ToBasicSliPtrOutputWithContext(ctx)
}

// BasicSliPtrInput is an input type that accepts BasicSliArgs, BasicSliPtr and BasicSliPtrOutput values.
// You can construct a concrete instance of `BasicSliPtrInput` via:
//
//          BasicSliArgs{...}
//
//  or:
//
//          nil
type BasicSliPtrInput interface {
	pulumi.Input

	ToBasicSliPtrOutput() BasicSliPtrOutput
	ToBasicSliPtrOutputWithContext(context.Context) BasicSliPtrOutput
}

type basicSliPtrType BasicSliArgs

func BasicSliPtr(v *BasicSliArgs) BasicSliPtrInput {
	return (*basicSliPtrType)(v)
}

func (*basicSliPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicSli)(nil)).Elem()
}

func (i *basicSliPtrType) ToBasicSliPtrOutput() BasicSliPtrOutput {
	return i.ToBasicSliPtrOutputWithContext(context.Background())
}

func (i *basicSliPtrType) ToBasicSliPtrOutputWithContext(ctx context.Context) BasicSliPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BasicSliPtrOutput)
}

// An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service.
type BasicSliOutput struct{ *pulumi.OutputState }

func (BasicSliOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BasicSli)(nil)).Elem()
}

func (o BasicSliOutput) ToBasicSliOutput() BasicSliOutput {
	return o
}

func (o BasicSliOutput) ToBasicSliOutputWithContext(ctx context.Context) BasicSliOutput {
	return o
}

func (o BasicSliOutput) ToBasicSliPtrOutput() BasicSliPtrOutput {
	return o.ToBasicSliPtrOutputWithContext(context.Background())
}

func (o BasicSliOutput) ToBasicSliPtrOutputWithContext(ctx context.Context) BasicSliPtrOutput {
	return o.ApplyT(func(v BasicSli) *BasicSli {
		return &v
	}).(BasicSliPtrOutput)
}

// Good service is defined to be the count of requests made to this service that return successfully.
func (o BasicSliOutput) Availability() AvailabilityCriteriaPtrOutput {
	return o.ApplyT(func(v BasicSli) *AvailabilityCriteria { return v.Availability }).(AvailabilityCriteriaPtrOutput)
}

// Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
func (o BasicSliOutput) Latency() LatencyCriteriaPtrOutput {
	return o.ApplyT(func(v BasicSli) *LatencyCriteria { return v.Latency }).(LatencyCriteriaPtrOutput)
}

// OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.
func (o BasicSliOutput) Location() pulumi.StringArrayOutput {
	return o.ApplyT(func(v BasicSli) []string { return v.Location }).(pulumi.StringArrayOutput)
}

// OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.
func (o BasicSliOutput) Method() pulumi.StringArrayOutput {
	return o.ApplyT(func(v BasicSli) []string { return v.Method }).(pulumi.StringArrayOutput)
}

// OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error.
func (o BasicSliOutput) Version() pulumi.StringArrayOutput {
	return o.ApplyT(func(v BasicSli) []string { return v.Version }).(pulumi.StringArrayOutput)
}

type BasicSliPtrOutput struct{ *pulumi.OutputState }

func (BasicSliPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BasicSli)(nil)).Elem()
}

func (o BasicSliPtrOutput) ToBasicSliPtrOutput() BasicSliPtrOutput {
	return o
}

func (o BasicSliPtrOutput) ToBasicSliPtrOutputWithContext(ctx context.Context) BasicSliPtrOutput {
	return o
}

func (o BasicSliPtrOutput) Elem() BasicSliOutput {
	return o.ApplyT(func(v *BasicSli) BasicSli { return *v }).(BasicSliOutput)
}

// Good service is defined to be the count of requests made to this service that return successfully.
func (o BasicSliPtrOutput) Availability() AvailabilityCriteriaPtrOutput {
	return o.ApplyT(func(v *BasicSli) *AvailabilityCriteria {
		if v == nil {
			return nil
		}
		return v.Availability
	}).(AvailabilityCriteriaPtrOutput)
}

// Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
func (o BasicSliPtrOutput) Latency() LatencyCriteriaPtrOutput {
	return o.ApplyT(func(v *BasicSli) *LatencyCriteria {
		if v == nil {
			return nil
		}
		return v.Latency
	}).(LatencyCriteriaPtrOutput)
}

// OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.
func (o BasicSliPtrOutput) Location() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *BasicSli) []string {
		if v == nil {
			return nil
		}
		return v.Location
	}).(pulumi.StringArrayOutput)
}

// OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.
func (o BasicSliPtrOutput) Method() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *BasicSli) []string {
		if v == nil {
			return nil
		}
		return v.Method
	}).(pulumi.StringArrayOutput)
}

// OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error.
func (o BasicSliPtrOutput) Version() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *BasicSli) []string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringArrayOutput)
}

// BucketOptions describes the bucket boundaries used to create a histogram for the distribution. The buckets can be in a linear sequence, an exponential sequence, or each bucket can be specified explicitly. BucketOptions does not include the number of values in each bucket.A bucket has an inclusive lower bound and exclusive upper bound for the values that are counted for that bucket. The upper bound of a bucket must be strictly greater than the lower bound. The sequence of N buckets for a distribution consists of an underflow bucket (number 0), zero or more finite buckets (number 1 through N - 2) and an overflow bucket (number N - 1). The buckets are contiguous: the lower bound of bucket i (i > 0) is the same as the upper bound of bucket i - 1. The buckets span the whole range of finite values: lower bound of the underflow bucket is -infinity and the upper bound of the overflow bucket is +infinity. The finite buckets are so-called because both bounds are finite.
type BucketOptions struct {
	// The explicit buckets.
	ExplicitBuckets *Explicit `pulumi:"explicitBuckets"`
	// The exponential buckets.
	ExponentialBuckets *Exponential `pulumi:"exponentialBuckets"`
	// The linear bucket.
	LinearBuckets *Linear `pulumi:"linearBuckets"`
}

// BucketOptionsInput is an input type that accepts BucketOptionsArgs and BucketOptionsOutput values.
// You can construct a concrete instance of `BucketOptionsInput` via:
//
//          BucketOptionsArgs{...}
type BucketOptionsInput interface {
	pulumi.Input

	ToBucketOptionsOutput() BucketOptionsOutput
	ToBucketOptionsOutputWithContext(context.Context) BucketOptionsOutput
}

// BucketOptions describes the bucket boundaries used to create a histogram for the distribution. The buckets can be in a linear sequence, an exponential sequence, or each bucket can be specified explicitly. BucketOptions does not include the number of values in each bucket.A bucket has an inclusive lower bound and exclusive upper bound for the values that are counted for that bucket. The upper bound of a bucket must be strictly greater than the lower bound. The sequence of N buckets for a distribution consists of an underflow bucket (number 0), zero or more finite buckets (number 1 through N - 2) and an overflow bucket (number N - 1). The buckets are contiguous: the lower bound of bucket i (i > 0) is the same as the upper bound of bucket i - 1. The buckets span the whole range of finite values: lower bound of the underflow bucket is -infinity and the upper bound of the overflow bucket is +infinity. The finite buckets are so-called because both bounds are finite.
type BucketOptionsArgs struct {
	// The explicit buckets.
	ExplicitBuckets ExplicitPtrInput `pulumi:"explicitBuckets"`
	// The exponential buckets.
	ExponentialBuckets ExponentialPtrInput `pulumi:"exponentialBuckets"`
	// The linear bucket.
	LinearBuckets LinearPtrInput `pulumi:"linearBuckets"`
}

func (BucketOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BucketOptions)(nil)).Elem()
}

func (i BucketOptionsArgs) ToBucketOptionsOutput() BucketOptionsOutput {
	return i.ToBucketOptionsOutputWithContext(context.Background())
}

func (i BucketOptionsArgs) ToBucketOptionsOutputWithContext(ctx context.Context) BucketOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BucketOptionsOutput)
}

func (i BucketOptionsArgs) ToBucketOptionsPtrOutput() BucketOptionsPtrOutput {
	return i.ToBucketOptionsPtrOutputWithContext(context.Background())
}

func (i BucketOptionsArgs) ToBucketOptionsPtrOutputWithContext(ctx context.Context) BucketOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BucketOptionsOutput).ToBucketOptionsPtrOutputWithContext(ctx)
}

// BucketOptionsPtrInput is an input type that accepts BucketOptionsArgs, BucketOptionsPtr and BucketOptionsPtrOutput values.
// You can construct a concrete instance of `BucketOptionsPtrInput` via:
//
//          BucketOptionsArgs{...}
//
//  or:
//
//          nil
type BucketOptionsPtrInput interface {
	pulumi.Input

	ToBucketOptionsPtrOutput() BucketOptionsPtrOutput
	ToBucketOptionsPtrOutputWithContext(context.Context) BucketOptionsPtrOutput
}

type bucketOptionsPtrType BucketOptionsArgs

func BucketOptionsPtr(v *BucketOptionsArgs) BucketOptionsPtrInput {
	return (*bucketOptionsPtrType)(v)
}

func (*bucketOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BucketOptions)(nil)).Elem()
}

func (i *bucketOptionsPtrType) ToBucketOptionsPtrOutput() BucketOptionsPtrOutput {
	return i.ToBucketOptionsPtrOutputWithContext(context.Background())
}

func (i *bucketOptionsPtrType) ToBucketOptionsPtrOutputWithContext(ctx context.Context) BucketOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BucketOptionsPtrOutput)
}

// BucketOptions describes the bucket boundaries used to create a histogram for the distribution. The buckets can be in a linear sequence, an exponential sequence, or each bucket can be specified explicitly. BucketOptions does not include the number of values in each bucket.A bucket has an inclusive lower bound and exclusive upper bound for the values that are counted for that bucket. The upper bound of a bucket must be strictly greater than the lower bound. The sequence of N buckets for a distribution consists of an underflow bucket (number 0), zero or more finite buckets (number 1 through N - 2) and an overflow bucket (number N - 1). The buckets are contiguous: the lower bound of bucket i (i > 0) is the same as the upper bound of bucket i - 1. The buckets span the whole range of finite values: lower bound of the underflow bucket is -infinity and the upper bound of the overflow bucket is +infinity. The finite buckets are so-called because both bounds are finite.
type BucketOptionsOutput struct{ *pulumi.OutputState }

func (BucketOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BucketOptions)(nil)).Elem()
}

func (o BucketOptionsOutput) ToBucketOptionsOutput() BucketOptionsOutput {
	return o
}

func (o BucketOptionsOutput) ToBucketOptionsOutputWithContext(ctx context.Context) BucketOptionsOutput {
	return o
}

func (o BucketOptionsOutput) ToBucketOptionsPtrOutput() BucketOptionsPtrOutput {
	return o.ToBucketOptionsPtrOutputWithContext(context.Background())
}

func (o BucketOptionsOutput) ToBucketOptionsPtrOutputWithContext(ctx context.Context) BucketOptionsPtrOutput {
	return o.ApplyT(func(v BucketOptions) *BucketOptions {
		return &v
	}).(BucketOptionsPtrOutput)
}

// The explicit buckets.
func (o BucketOptionsOutput) ExplicitBuckets() ExplicitPtrOutput {
	return o.ApplyT(func(v BucketOptions) *Explicit { return v.ExplicitBuckets }).(ExplicitPtrOutput)
}

// The exponential buckets.
func (o BucketOptionsOutput) ExponentialBuckets() ExponentialPtrOutput {
	return o.ApplyT(func(v BucketOptions) *Exponential { return v.ExponentialBuckets }).(ExponentialPtrOutput)
}

// The linear bucket.
func (o BucketOptionsOutput) LinearBuckets() LinearPtrOutput {
	return o.ApplyT(func(v BucketOptions) *Linear { return v.LinearBuckets }).(LinearPtrOutput)
}

type BucketOptionsPtrOutput struct{ *pulumi.OutputState }

func (BucketOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BucketOptions)(nil)).Elem()
}

func (o BucketOptionsPtrOutput) ToBucketOptionsPtrOutput() BucketOptionsPtrOutput {
	return o
}

func (o BucketOptionsPtrOutput) ToBucketOptionsPtrOutputWithContext(ctx context.Context) BucketOptionsPtrOutput {
	return o
}

func (o BucketOptionsPtrOutput) Elem() BucketOptionsOutput {
	return o.ApplyT(func(v *BucketOptions) BucketOptions { return *v }).(BucketOptionsOutput)
}

// The explicit buckets.
func (o BucketOptionsPtrOutput) ExplicitBuckets() ExplicitPtrOutput {
	return o.ApplyT(func(v *BucketOptions) *Explicit {
		if v == nil {
			return nil
		}
		return v.ExplicitBuckets
	}).(ExplicitPtrOutput)
}

// The exponential buckets.
func (o BucketOptionsPtrOutput) ExponentialBuckets() ExponentialPtrOutput {
	return o.ApplyT(func(v *BucketOptions) *Exponential {
		if v == nil {
			return nil
		}
		return v.ExponentialBuckets
	}).(ExponentialPtrOutput)
}

// The linear bucket.
func (o BucketOptionsPtrOutput) LinearBuckets() LinearPtrOutput {
	return o.ApplyT(func(v *BucketOptions) *Linear {
		if v == nil {
			return nil
		}
		return v.LinearBuckets
	}).(LinearPtrOutput)
}

// Cloud Endpoints service. Learn more at https://cloud.google.com/endpoints.
type CloudEndpoints struct {
	// The name of the Cloud Endpoints service underlying this service. Corresponds to the service resource label in the api monitored resource: https://cloud.google.com/monitoring/api/resources#tag_api
	Service *string `pulumi:"service"`
}

// CloudEndpointsInput is an input type that accepts CloudEndpointsArgs and CloudEndpointsOutput values.
// You can construct a concrete instance of `CloudEndpointsInput` via:
//
//          CloudEndpointsArgs{...}
type CloudEndpointsInput interface {
	pulumi.Input

	ToCloudEndpointsOutput() CloudEndpointsOutput
	ToCloudEndpointsOutputWithContext(context.Context) CloudEndpointsOutput
}

// Cloud Endpoints service. Learn more at https://cloud.google.com/endpoints.
type CloudEndpointsArgs struct {
	// The name of the Cloud Endpoints service underlying this service. Corresponds to the service resource label in the api monitored resource: https://cloud.google.com/monitoring/api/resources#tag_api
	Service pulumi.StringPtrInput `pulumi:"service"`
}

func (CloudEndpointsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudEndpoints)(nil)).Elem()
}

func (i CloudEndpointsArgs) ToCloudEndpointsOutput() CloudEndpointsOutput {
	return i.ToCloudEndpointsOutputWithContext(context.Background())
}

func (i CloudEndpointsArgs) ToCloudEndpointsOutputWithContext(ctx context.Context) CloudEndpointsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudEndpointsOutput)
}

func (i CloudEndpointsArgs) ToCloudEndpointsPtrOutput() CloudEndpointsPtrOutput {
	return i.ToCloudEndpointsPtrOutputWithContext(context.Background())
}

func (i CloudEndpointsArgs) ToCloudEndpointsPtrOutputWithContext(ctx context.Context) CloudEndpointsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudEndpointsOutput).ToCloudEndpointsPtrOutputWithContext(ctx)
}

// CloudEndpointsPtrInput is an input type that accepts CloudEndpointsArgs, CloudEndpointsPtr and CloudEndpointsPtrOutput values.
// You can construct a concrete instance of `CloudEndpointsPtrInput` via:
//
//          CloudEndpointsArgs{...}
//
//  or:
//
//          nil
type CloudEndpointsPtrInput interface {
	pulumi.Input

	ToCloudEndpointsPtrOutput() CloudEndpointsPtrOutput
	ToCloudEndpointsPtrOutputWithContext(context.Context) CloudEndpointsPtrOutput
}

type cloudEndpointsPtrType CloudEndpointsArgs

func CloudEndpointsPtr(v *CloudEndpointsArgs) CloudEndpointsPtrInput {
	return (*cloudEndpointsPtrType)(v)
}

func (*cloudEndpointsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CloudEndpoints)(nil)).Elem()
}

func (i *cloudEndpointsPtrType) ToCloudEndpointsPtrOutput() CloudEndpointsPtrOutput {
	return i.ToCloudEndpointsPtrOutputWithContext(context.Background())
}

func (i *cloudEndpointsPtrType) ToCloudEndpointsPtrOutputWithContext(ctx context.Context) CloudEndpointsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CloudEndpointsPtrOutput)
}

// Cloud Endpoints service. Learn more at https://cloud.google.com/endpoints.
type CloudEndpointsOutput struct{ *pulumi.OutputState }

func (CloudEndpointsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CloudEndpoints)(nil)).Elem()
}

func (o CloudEndpointsOutput) ToCloudEndpointsOutput() CloudEndpointsOutput {
	return o
}

func (o CloudEndpointsOutput) ToCloudEndpointsOutputWithContext(ctx context.Context) CloudEndpointsOutput {
	return o
}

func (o CloudEndpointsOutput) ToCloudEndpointsPtrOutput() CloudEndpointsPtrOutput {
	return o.ToCloudEndpointsPtrOutputWithContext(context.Background())
}

func (o CloudEndpointsOutput) ToCloudEndpointsPtrOutputWithContext(ctx context.Context) CloudEndpointsPtrOutput {
	return o.ApplyT(func(v CloudEndpoints) *CloudEndpoints {
		return &v
	}).(CloudEndpointsPtrOutput)
}

// The name of the Cloud Endpoints service underlying this service. Corresponds to the service resource label in the api monitored resource: https://cloud.google.com/monitoring/api/resources#tag_api
func (o CloudEndpointsOutput) Service() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CloudEndpoints) *string { return v.Service }).(pulumi.StringPtrOutput)
}

type CloudEndpointsPtrOutput struct{ *pulumi.OutputState }

func (CloudEndpointsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CloudEndpoints)(nil)).Elem()
}

func (o CloudEndpointsPtrOutput) ToCloudEndpointsPtrOutput() CloudEndpointsPtrOutput {
	return o
}

func (o CloudEndpointsPtrOutput) ToCloudEndpointsPtrOutputWithContext(ctx context.Context) CloudEndpointsPtrOutput {
	return o
}

func (o CloudEndpointsPtrOutput) Elem() CloudEndpointsOutput {
	return o.ApplyT(func(v *CloudEndpoints) CloudEndpoints { return *v }).(CloudEndpointsOutput)
}

// The name of the Cloud Endpoints service underlying this service. Corresponds to the service resource label in the api monitored resource: https://cloud.google.com/monitoring/api/resources#tag_api
func (o CloudEndpointsPtrOutput) Service() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CloudEndpoints) *string {
		if v == nil {
			return nil
		}
		return v.Service
	}).(pulumi.StringPtrOutput)
}

// Istio service scoped to a single Kubernetes cluster. Learn more at https://istio.io. Clusters running OSS Istio will have their services ingested as this type.
type ClusterIstio struct {
	// The name of the Kubernetes cluster in which this Istio service is defined. Corresponds to the cluster_name resource label in k8s_cluster resources.
	ClusterName *string `pulumi:"clusterName"`
	// The location of the Kubernetes cluster in which this Istio service is defined. Corresponds to the location resource label in k8s_cluster resources.
	Location *string `pulumi:"location"`
	// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
	ServiceName *string `pulumi:"serviceName"`
	// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
	ServiceNamespace *string `pulumi:"serviceNamespace"`
}

// ClusterIstioInput is an input type that accepts ClusterIstioArgs and ClusterIstioOutput values.
// You can construct a concrete instance of `ClusterIstioInput` via:
//
//          ClusterIstioArgs{...}
type ClusterIstioInput interface {
	pulumi.Input

	ToClusterIstioOutput() ClusterIstioOutput
	ToClusterIstioOutputWithContext(context.Context) ClusterIstioOutput
}

// Istio service scoped to a single Kubernetes cluster. Learn more at https://istio.io. Clusters running OSS Istio will have their services ingested as this type.
type ClusterIstioArgs struct {
	// The name of the Kubernetes cluster in which this Istio service is defined. Corresponds to the cluster_name resource label in k8s_cluster resources.
	ClusterName pulumi.StringPtrInput `pulumi:"clusterName"`
	// The location of the Kubernetes cluster in which this Istio service is defined. Corresponds to the location resource label in k8s_cluster resources.
	Location pulumi.StringPtrInput `pulumi:"location"`
	// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
	ServiceName pulumi.StringPtrInput `pulumi:"serviceName"`
	// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
	ServiceNamespace pulumi.StringPtrInput `pulumi:"serviceNamespace"`
}

func (ClusterIstioArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterIstio)(nil)).Elem()
}

func (i ClusterIstioArgs) ToClusterIstioOutput() ClusterIstioOutput {
	return i.ToClusterIstioOutputWithContext(context.Background())
}

func (i ClusterIstioArgs) ToClusterIstioOutputWithContext(ctx context.Context) ClusterIstioOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterIstioOutput)
}

func (i ClusterIstioArgs) ToClusterIstioPtrOutput() ClusterIstioPtrOutput {
	return i.ToClusterIstioPtrOutputWithContext(context.Background())
}

func (i ClusterIstioArgs) ToClusterIstioPtrOutputWithContext(ctx context.Context) ClusterIstioPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterIstioOutput).ToClusterIstioPtrOutputWithContext(ctx)
}

// ClusterIstioPtrInput is an input type that accepts ClusterIstioArgs, ClusterIstioPtr and ClusterIstioPtrOutput values.
// You can construct a concrete instance of `ClusterIstioPtrInput` via:
//
//          ClusterIstioArgs{...}
//
//  or:
//
//          nil
type ClusterIstioPtrInput interface {
	pulumi.Input

	ToClusterIstioPtrOutput() ClusterIstioPtrOutput
	ToClusterIstioPtrOutputWithContext(context.Context) ClusterIstioPtrOutput
}

type clusterIstioPtrType ClusterIstioArgs

func ClusterIstioPtr(v *ClusterIstioArgs) ClusterIstioPtrInput {
	return (*clusterIstioPtrType)(v)
}

func (*clusterIstioPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterIstio)(nil)).Elem()
}

func (i *clusterIstioPtrType) ToClusterIstioPtrOutput() ClusterIstioPtrOutput {
	return i.ToClusterIstioPtrOutputWithContext(context.Background())
}

func (i *clusterIstioPtrType) ToClusterIstioPtrOutputWithContext(ctx context.Context) ClusterIstioPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterIstioPtrOutput)
}

// Istio service scoped to a single Kubernetes cluster. Learn more at https://istio.io. Clusters running OSS Istio will have their services ingested as this type.
type ClusterIstioOutput struct{ *pulumi.OutputState }

func (ClusterIstioOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterIstio)(nil)).Elem()
}

func (o ClusterIstioOutput) ToClusterIstioOutput() ClusterIstioOutput {
	return o
}

func (o ClusterIstioOutput) ToClusterIstioOutputWithContext(ctx context.Context) ClusterIstioOutput {
	return o
}

func (o ClusterIstioOutput) ToClusterIstioPtrOutput() ClusterIstioPtrOutput {
	return o.ToClusterIstioPtrOutputWithContext(context.Background())
}

func (o ClusterIstioOutput) ToClusterIstioPtrOutputWithContext(ctx context.Context) ClusterIstioPtrOutput {
	return o.ApplyT(func(v ClusterIstio) *ClusterIstio {
		return &v
	}).(ClusterIstioPtrOutput)
}

// The name of the Kubernetes cluster in which this Istio service is defined. Corresponds to the cluster_name resource label in k8s_cluster resources.
func (o ClusterIstioOutput) ClusterName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterIstio) *string { return v.ClusterName }).(pulumi.StringPtrOutput)
}

// The location of the Kubernetes cluster in which this Istio service is defined. Corresponds to the location resource label in k8s_cluster resources.
func (o ClusterIstioOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterIstio) *string { return v.Location }).(pulumi.StringPtrOutput)
}

// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
func (o ClusterIstioOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterIstio) *string { return v.ServiceName }).(pulumi.StringPtrOutput)
}

// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
func (o ClusterIstioOutput) ServiceNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterIstio) *string { return v.ServiceNamespace }).(pulumi.StringPtrOutput)
}

type ClusterIstioPtrOutput struct{ *pulumi.OutputState }

func (ClusterIstioPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterIstio)(nil)).Elem()
}

func (o ClusterIstioPtrOutput) ToClusterIstioPtrOutput() ClusterIstioPtrOutput {
	return o
}

func (o ClusterIstioPtrOutput) ToClusterIstioPtrOutputWithContext(ctx context.Context) ClusterIstioPtrOutput {
	return o
}

func (o ClusterIstioPtrOutput) Elem() ClusterIstioOutput {
	return o.ApplyT(func(v *ClusterIstio) ClusterIstio { return *v }).(ClusterIstioOutput)
}

// The name of the Kubernetes cluster in which this Istio service is defined. Corresponds to the cluster_name resource label in k8s_cluster resources.
func (o ClusterIstioPtrOutput) ClusterName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterIstio) *string {
		if v == nil {
			return nil
		}
		return v.ClusterName
	}).(pulumi.StringPtrOutput)
}

// The location of the Kubernetes cluster in which this Istio service is defined. Corresponds to the location resource label in k8s_cluster resources.
func (o ClusterIstioPtrOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterIstio) *string {
		if v == nil {
			return nil
		}
		return v.Location
	}).(pulumi.StringPtrOutput)
}

// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
func (o ClusterIstioPtrOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterIstio) *string {
		if v == nil {
			return nil
		}
		return v.ServiceName
	}).(pulumi.StringPtrOutput)
}

// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
func (o ClusterIstioPtrOutput) ServiceNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterIstio) *string {
		if v == nil {
			return nil
		}
		return v.ServiceNamespace
	}).(pulumi.StringPtrOutput)
}

// A collection of data points sent from a collectd-based plugin. See the collectd documentation for more information.
type CollectdPayload struct {
	// The end time of the interval.
	EndTime *string `pulumi:"endTime"`
	// The measurement metadata. Example: "process_id" -> 12345
	Metadata map[string]string `pulumi:"metadata"`
	// The name of the plugin. Example: "disk".
	Plugin *string `pulumi:"plugin"`
	// The instance name of the plugin Example: "hdcl".
	PluginInstance *string `pulumi:"pluginInstance"`
	// The start time of the interval.
	StartTime *string `pulumi:"startTime"`
	// The measurement type. Example: "memory".
	Type *string `pulumi:"type"`
	// The measurement type instance. Example: "used".
	TypeInstance *string `pulumi:"typeInstance"`
	// The measured values during this time interval. Each value must have a different data_source_name.
	Values []CollectdValue `pulumi:"values"`
}

// CollectdPayloadInput is an input type that accepts CollectdPayloadArgs and CollectdPayloadOutput values.
// You can construct a concrete instance of `CollectdPayloadInput` via:
//
//          CollectdPayloadArgs{...}
type CollectdPayloadInput interface {
	pulumi.Input

	ToCollectdPayloadOutput() CollectdPayloadOutput
	ToCollectdPayloadOutputWithContext(context.Context) CollectdPayloadOutput
}

// A collection of data points sent from a collectd-based plugin. See the collectd documentation for more information.
type CollectdPayloadArgs struct {
	// The end time of the interval.
	EndTime pulumi.StringPtrInput `pulumi:"endTime"`
	// The measurement metadata. Example: "process_id" -> 12345
	Metadata pulumi.StringMapInput `pulumi:"metadata"`
	// The name of the plugin. Example: "disk".
	Plugin pulumi.StringPtrInput `pulumi:"plugin"`
	// The instance name of the plugin Example: "hdcl".
	PluginInstance pulumi.StringPtrInput `pulumi:"pluginInstance"`
	// The start time of the interval.
	StartTime pulumi.StringPtrInput `pulumi:"startTime"`
	// The measurement type. Example: "memory".
	Type pulumi.StringPtrInput `pulumi:"type"`
	// The measurement type instance. Example: "used".
	TypeInstance pulumi.StringPtrInput `pulumi:"typeInstance"`
	// The measured values during this time interval. Each value must have a different data_source_name.
	Values CollectdValueArrayInput `pulumi:"values"`
}

func (CollectdPayloadArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CollectdPayload)(nil)).Elem()
}

func (i CollectdPayloadArgs) ToCollectdPayloadOutput() CollectdPayloadOutput {
	return i.ToCollectdPayloadOutputWithContext(context.Background())
}

func (i CollectdPayloadArgs) ToCollectdPayloadOutputWithContext(ctx context.Context) CollectdPayloadOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CollectdPayloadOutput)
}

// CollectdPayloadArrayInput is an input type that accepts CollectdPayloadArray and CollectdPayloadArrayOutput values.
// You can construct a concrete instance of `CollectdPayloadArrayInput` via:
//
//          CollectdPayloadArray{ CollectdPayloadArgs{...} }
type CollectdPayloadArrayInput interface {
	pulumi.Input

	ToCollectdPayloadArrayOutput() CollectdPayloadArrayOutput
	ToCollectdPayloadArrayOutputWithContext(context.Context) CollectdPayloadArrayOutput
}

type CollectdPayloadArray []CollectdPayloadInput

func (CollectdPayloadArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CollectdPayload)(nil)).Elem()
}

func (i CollectdPayloadArray) ToCollectdPayloadArrayOutput() CollectdPayloadArrayOutput {
	return i.ToCollectdPayloadArrayOutputWithContext(context.Background())
}

func (i CollectdPayloadArray) ToCollectdPayloadArrayOutputWithContext(ctx context.Context) CollectdPayloadArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CollectdPayloadArrayOutput)
}

// A collection of data points sent from a collectd-based plugin. See the collectd documentation for more information.
type CollectdPayloadOutput struct{ *pulumi.OutputState }

func (CollectdPayloadOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CollectdPayload)(nil)).Elem()
}

func (o CollectdPayloadOutput) ToCollectdPayloadOutput() CollectdPayloadOutput {
	return o
}

func (o CollectdPayloadOutput) ToCollectdPayloadOutputWithContext(ctx context.Context) CollectdPayloadOutput {
	return o
}

// The end time of the interval.
func (o CollectdPayloadOutput) EndTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CollectdPayload) *string { return v.EndTime }).(pulumi.StringPtrOutput)
}

// The measurement metadata. Example: "process_id" -> 12345
func (o CollectdPayloadOutput) Metadata() pulumi.StringMapOutput {
	return o.ApplyT(func(v CollectdPayload) map[string]string { return v.Metadata }).(pulumi.StringMapOutput)
}

// The name of the plugin. Example: "disk".
func (o CollectdPayloadOutput) Plugin() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CollectdPayload) *string { return v.Plugin }).(pulumi.StringPtrOutput)
}

// The instance name of the plugin Example: "hdcl".
func (o CollectdPayloadOutput) PluginInstance() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CollectdPayload) *string { return v.PluginInstance }).(pulumi.StringPtrOutput)
}

// The start time of the interval.
func (o CollectdPayloadOutput) StartTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CollectdPayload) *string { return v.StartTime }).(pulumi.StringPtrOutput)
}

// The measurement type. Example: "memory".
func (o CollectdPayloadOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CollectdPayload) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// The measurement type instance. Example: "used".
func (o CollectdPayloadOutput) TypeInstance() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CollectdPayload) *string { return v.TypeInstance }).(pulumi.StringPtrOutput)
}

// The measured values during this time interval. Each value must have a different data_source_name.
func (o CollectdPayloadOutput) Values() CollectdValueArrayOutput {
	return o.ApplyT(func(v CollectdPayload) []CollectdValue { return v.Values }).(CollectdValueArrayOutput)
}

type CollectdPayloadArrayOutput struct{ *pulumi.OutputState }

func (CollectdPayloadArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CollectdPayload)(nil)).Elem()
}

func (o CollectdPayloadArrayOutput) ToCollectdPayloadArrayOutput() CollectdPayloadArrayOutput {
	return o
}

func (o CollectdPayloadArrayOutput) ToCollectdPayloadArrayOutputWithContext(ctx context.Context) CollectdPayloadArrayOutput {
	return o
}

func (o CollectdPayloadArrayOutput) Index(i pulumi.IntInput) CollectdPayloadOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CollectdPayload {
		return vs[0].([]CollectdPayload)[vs[1].(int)]
	}).(CollectdPayloadOutput)
}

// A single data point from a collectd-based plugin.
type CollectdValue struct {
	// The data source for the collectd value. For example, there are two data sources for network measurements: "rx" and "tx".
	DataSourceName *string `pulumi:"dataSourceName"`
	// The type of measurement.
	DataSourceType *string `pulumi:"dataSourceType"`
	// The measurement value.
	Value *TypedValue `pulumi:"value"`
}

// CollectdValueInput is an input type that accepts CollectdValueArgs and CollectdValueOutput values.
// You can construct a concrete instance of `CollectdValueInput` via:
//
//          CollectdValueArgs{...}
type CollectdValueInput interface {
	pulumi.Input

	ToCollectdValueOutput() CollectdValueOutput
	ToCollectdValueOutputWithContext(context.Context) CollectdValueOutput
}

// A single data point from a collectd-based plugin.
type CollectdValueArgs struct {
	// The data source for the collectd value. For example, there are two data sources for network measurements: "rx" and "tx".
	DataSourceName pulumi.StringPtrInput `pulumi:"dataSourceName"`
	// The type of measurement.
	DataSourceType pulumi.StringPtrInput `pulumi:"dataSourceType"`
	// The measurement value.
	Value TypedValuePtrInput `pulumi:"value"`
}

func (CollectdValueArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CollectdValue)(nil)).Elem()
}

func (i CollectdValueArgs) ToCollectdValueOutput() CollectdValueOutput {
	return i.ToCollectdValueOutputWithContext(context.Background())
}

func (i CollectdValueArgs) ToCollectdValueOutputWithContext(ctx context.Context) CollectdValueOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CollectdValueOutput)
}

// CollectdValueArrayInput is an input type that accepts CollectdValueArray and CollectdValueArrayOutput values.
// You can construct a concrete instance of `CollectdValueArrayInput` via:
//
//          CollectdValueArray{ CollectdValueArgs{...} }
type CollectdValueArrayInput interface {
	pulumi.Input

	ToCollectdValueArrayOutput() CollectdValueArrayOutput
	ToCollectdValueArrayOutputWithContext(context.Context) CollectdValueArrayOutput
}

type CollectdValueArray []CollectdValueInput

func (CollectdValueArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CollectdValue)(nil)).Elem()
}

func (i CollectdValueArray) ToCollectdValueArrayOutput() CollectdValueArrayOutput {
	return i.ToCollectdValueArrayOutputWithContext(context.Background())
}

func (i CollectdValueArray) ToCollectdValueArrayOutputWithContext(ctx context.Context) CollectdValueArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CollectdValueArrayOutput)
}

// A single data point from a collectd-based plugin.
type CollectdValueOutput struct{ *pulumi.OutputState }

func (CollectdValueOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CollectdValue)(nil)).Elem()
}

func (o CollectdValueOutput) ToCollectdValueOutput() CollectdValueOutput {
	return o
}

func (o CollectdValueOutput) ToCollectdValueOutputWithContext(ctx context.Context) CollectdValueOutput {
	return o
}

// The data source for the collectd value. For example, there are two data sources for network measurements: "rx" and "tx".
func (o CollectdValueOutput) DataSourceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CollectdValue) *string { return v.DataSourceName }).(pulumi.StringPtrOutput)
}

// The type of measurement.
func (o CollectdValueOutput) DataSourceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CollectdValue) *string { return v.DataSourceType }).(pulumi.StringPtrOutput)
}

// The measurement value.
func (o CollectdValueOutput) Value() TypedValuePtrOutput {
	return o.ApplyT(func(v CollectdValue) *TypedValue { return v.Value }).(TypedValuePtrOutput)
}

type CollectdValueArrayOutput struct{ *pulumi.OutputState }

func (CollectdValueArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CollectdValue)(nil)).Elem()
}

func (o CollectdValueArrayOutput) ToCollectdValueArrayOutput() CollectdValueArrayOutput {
	return o
}

func (o CollectdValueArrayOutput) ToCollectdValueArrayOutputWithContext(ctx context.Context) CollectdValueArrayOutput {
	return o
}

func (o CollectdValueArrayOutput) Index(i pulumi.IntInput) CollectdValueOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CollectdValue {
		return vs[0].([]CollectdValue)[vs[1].(int)]
	}).(CollectdValueOutput)
}

// A condition is a true/false test that determines when an alerting policy should open an incident. If a condition evaluates to true, it signifies that something is wrong.
type Condition struct {
	// A condition that checks that a time series continues to receive new data points.
	ConditionAbsent *MetricAbsence `pulumi:"conditionAbsent"`
	// A condition that uses the Monitoring Query Language to define alerts.
	ConditionMonitoringQueryLanguage *MonitoringQueryLanguageCondition `pulumi:"conditionMonitoringQueryLanguage"`
	// A condition that compares a time series against a threshold.
	ConditionThreshold *MetricThreshold `pulumi:"conditionThreshold"`
	// A short name or phrase used to identify the condition in dashboards, notifications, and incidents. To avoid confusion, don't use the same display name for multiple conditions in the same policy.
	DisplayName *string `pulumi:"displayName"`
	// Required if the condition exists. The unique resource name for this condition. Its format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID] [CONDITION_ID] is assigned by Stackdriver Monitoring when the condition is created as part of a new or updated alerting policy.When calling the alertPolicies.create method, do not include the name field in the conditions of the requested alerting policy. Stackdriver Monitoring creates the condition identifiers and includes them in the new policy.When calling the alertPolicies.update method to update a policy, including a condition name causes the existing condition to be updated. Conditions without names are added to the updated policy. Existing conditions are deleted if they are not updated.Best practice is to preserve [CONDITION_ID] if you make only small changes, such as those to condition thresholds, durations, or trigger values. Otherwise, treat the change as a new condition and let the existing condition be deleted.
	Name *string `pulumi:"name"`
}

// ConditionInput is an input type that accepts ConditionArgs and ConditionOutput values.
// You can construct a concrete instance of `ConditionInput` via:
//
//          ConditionArgs{...}
type ConditionInput interface {
	pulumi.Input

	ToConditionOutput() ConditionOutput
	ToConditionOutputWithContext(context.Context) ConditionOutput
}

// A condition is a true/false test that determines when an alerting policy should open an incident. If a condition evaluates to true, it signifies that something is wrong.
type ConditionArgs struct {
	// A condition that checks that a time series continues to receive new data points.
	ConditionAbsent MetricAbsencePtrInput `pulumi:"conditionAbsent"`
	// A condition that uses the Monitoring Query Language to define alerts.
	ConditionMonitoringQueryLanguage MonitoringQueryLanguageConditionPtrInput `pulumi:"conditionMonitoringQueryLanguage"`
	// A condition that compares a time series against a threshold.
	ConditionThreshold MetricThresholdPtrInput `pulumi:"conditionThreshold"`
	// A short name or phrase used to identify the condition in dashboards, notifications, and incidents. To avoid confusion, don't use the same display name for multiple conditions in the same policy.
	DisplayName pulumi.StringPtrInput `pulumi:"displayName"`
	// Required if the condition exists. The unique resource name for this condition. Its format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID] [CONDITION_ID] is assigned by Stackdriver Monitoring when the condition is created as part of a new or updated alerting policy.When calling the alertPolicies.create method, do not include the name field in the conditions of the requested alerting policy. Stackdriver Monitoring creates the condition identifiers and includes them in the new policy.When calling the alertPolicies.update method to update a policy, including a condition name causes the existing condition to be updated. Conditions without names are added to the updated policy. Existing conditions are deleted if they are not updated.Best practice is to preserve [CONDITION_ID] if you make only small changes, such as those to condition thresholds, durations, or trigger values. Otherwise, treat the change as a new condition and let the existing condition be deleted.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Condition)(nil)).Elem()
}

func (i ConditionArgs) ToConditionOutput() ConditionOutput {
	return i.ToConditionOutputWithContext(context.Background())
}

func (i ConditionArgs) ToConditionOutputWithContext(ctx context.Context) ConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConditionOutput)
}

// ConditionArrayInput is an input type that accepts ConditionArray and ConditionArrayOutput values.
// You can construct a concrete instance of `ConditionArrayInput` via:
//
//          ConditionArray{ ConditionArgs{...} }
type ConditionArrayInput interface {
	pulumi.Input

	ToConditionArrayOutput() ConditionArrayOutput
	ToConditionArrayOutputWithContext(context.Context) ConditionArrayOutput
}

type ConditionArray []ConditionInput

func (ConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Condition)(nil)).Elem()
}

func (i ConditionArray) ToConditionArrayOutput() ConditionArrayOutput {
	return i.ToConditionArrayOutputWithContext(context.Background())
}

func (i ConditionArray) ToConditionArrayOutputWithContext(ctx context.Context) ConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConditionArrayOutput)
}

// A condition is a true/false test that determines when an alerting policy should open an incident. If a condition evaluates to true, it signifies that something is wrong.
type ConditionOutput struct{ *pulumi.OutputState }

func (ConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Condition)(nil)).Elem()
}

func (o ConditionOutput) ToConditionOutput() ConditionOutput {
	return o
}

func (o ConditionOutput) ToConditionOutputWithContext(ctx context.Context) ConditionOutput {
	return o
}

// A condition that checks that a time series continues to receive new data points.
func (o ConditionOutput) ConditionAbsent() MetricAbsencePtrOutput {
	return o.ApplyT(func(v Condition) *MetricAbsence { return v.ConditionAbsent }).(MetricAbsencePtrOutput)
}

// A condition that uses the Monitoring Query Language to define alerts.
func (o ConditionOutput) ConditionMonitoringQueryLanguage() MonitoringQueryLanguageConditionPtrOutput {
	return o.ApplyT(func(v Condition) *MonitoringQueryLanguageCondition { return v.ConditionMonitoringQueryLanguage }).(MonitoringQueryLanguageConditionPtrOutput)
}

// A condition that compares a time series against a threshold.
func (o ConditionOutput) ConditionThreshold() MetricThresholdPtrOutput {
	return o.ApplyT(func(v Condition) *MetricThreshold { return v.ConditionThreshold }).(MetricThresholdPtrOutput)
}

// A short name or phrase used to identify the condition in dashboards, notifications, and incidents. To avoid confusion, don't use the same display name for multiple conditions in the same policy.
func (o ConditionOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Condition) *string { return v.DisplayName }).(pulumi.StringPtrOutput)
}

// Required if the condition exists. The unique resource name for this condition. Its format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID] [CONDITION_ID] is assigned by Stackdriver Monitoring when the condition is created as part of a new or updated alerting policy.When calling the alertPolicies.create method, do not include the name field in the conditions of the requested alerting policy. Stackdriver Monitoring creates the condition identifiers and includes them in the new policy.When calling the alertPolicies.update method to update a policy, including a condition name causes the existing condition to be updated. Conditions without names are added to the updated policy. Existing conditions are deleted if they are not updated.Best practice is to preserve [CONDITION_ID] if you make only small changes, such as those to condition thresholds, durations, or trigger values. Otherwise, treat the change as a new condition and let the existing condition be deleted.
func (o ConditionOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Condition) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ConditionArrayOutput struct{ *pulumi.OutputState }

func (ConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Condition)(nil)).Elem()
}

func (o ConditionArrayOutput) ToConditionArrayOutput() ConditionArrayOutput {
	return o
}

func (o ConditionArrayOutput) ToConditionArrayOutputWithContext(ctx context.Context) ConditionArrayOutput {
	return o
}

func (o ConditionArrayOutput) Index(i pulumi.IntInput) ConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Condition {
		return vs[0].([]Condition)[vs[1].(int)]
	}).(ConditionOutput)
}

// Optional. Used to perform content matching. This allows matching based on substrings and regular expressions, together with their negations. Only the first 4 MB of an HTTP or HTTPS check's response (and the first 1 MB of a TCP check's response) are examined for purposes of content matching.
type ContentMatcher struct {
	// String or regex content to match. Maximum 1024 bytes. An empty content string indicates no content matching is to be performed.
	Content *string `pulumi:"content"`
	// The type of content matcher that will be applied to the server output, compared to the content string when the check is run.
	Matcher *string `pulumi:"matcher"`
}

// ContentMatcherInput is an input type that accepts ContentMatcherArgs and ContentMatcherOutput values.
// You can construct a concrete instance of `ContentMatcherInput` via:
//
//          ContentMatcherArgs{...}
type ContentMatcherInput interface {
	pulumi.Input

	ToContentMatcherOutput() ContentMatcherOutput
	ToContentMatcherOutputWithContext(context.Context) ContentMatcherOutput
}

// Optional. Used to perform content matching. This allows matching based on substrings and regular expressions, together with their negations. Only the first 4 MB of an HTTP or HTTPS check's response (and the first 1 MB of a TCP check's response) are examined for purposes of content matching.
type ContentMatcherArgs struct {
	// String or regex content to match. Maximum 1024 bytes. An empty content string indicates no content matching is to be performed.
	Content pulumi.StringPtrInput `pulumi:"content"`
	// The type of content matcher that will be applied to the server output, compared to the content string when the check is run.
	Matcher pulumi.StringPtrInput `pulumi:"matcher"`
}

func (ContentMatcherArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentMatcher)(nil)).Elem()
}

func (i ContentMatcherArgs) ToContentMatcherOutput() ContentMatcherOutput {
	return i.ToContentMatcherOutputWithContext(context.Background())
}

func (i ContentMatcherArgs) ToContentMatcherOutputWithContext(ctx context.Context) ContentMatcherOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentMatcherOutput)
}

// ContentMatcherArrayInput is an input type that accepts ContentMatcherArray and ContentMatcherArrayOutput values.
// You can construct a concrete instance of `ContentMatcherArrayInput` via:
//
//          ContentMatcherArray{ ContentMatcherArgs{...} }
type ContentMatcherArrayInput interface {
	pulumi.Input

	ToContentMatcherArrayOutput() ContentMatcherArrayOutput
	ToContentMatcherArrayOutputWithContext(context.Context) ContentMatcherArrayOutput
}

type ContentMatcherArray []ContentMatcherInput

func (ContentMatcherArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContentMatcher)(nil)).Elem()
}

func (i ContentMatcherArray) ToContentMatcherArrayOutput() ContentMatcherArrayOutput {
	return i.ToContentMatcherArrayOutputWithContext(context.Background())
}

func (i ContentMatcherArray) ToContentMatcherArrayOutputWithContext(ctx context.Context) ContentMatcherArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentMatcherArrayOutput)
}

// Optional. Used to perform content matching. This allows matching based on substrings and regular expressions, together with their negations. Only the first 4 MB of an HTTP or HTTPS check's response (and the first 1 MB of a TCP check's response) are examined for purposes of content matching.
type ContentMatcherOutput struct{ *pulumi.OutputState }

func (ContentMatcherOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContentMatcher)(nil)).Elem()
}

func (o ContentMatcherOutput) ToContentMatcherOutput() ContentMatcherOutput {
	return o
}

func (o ContentMatcherOutput) ToContentMatcherOutputWithContext(ctx context.Context) ContentMatcherOutput {
	return o
}

// String or regex content to match. Maximum 1024 bytes. An empty content string indicates no content matching is to be performed.
func (o ContentMatcherOutput) Content() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentMatcher) *string { return v.Content }).(pulumi.StringPtrOutput)
}

// The type of content matcher that will be applied to the server output, compared to the content string when the check is run.
func (o ContentMatcherOutput) Matcher() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContentMatcher) *string { return v.Matcher }).(pulumi.StringPtrOutput)
}

type ContentMatcherArrayOutput struct{ *pulumi.OutputState }

func (ContentMatcherArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContentMatcher)(nil)).Elem()
}

func (o ContentMatcherArrayOutput) ToContentMatcherArrayOutput() ContentMatcherArrayOutput {
	return o
}

func (o ContentMatcherArrayOutput) ToContentMatcherArrayOutputWithContext(ctx context.Context) ContentMatcherArrayOutput {
	return o
}

func (o ContentMatcherArrayOutput) Index(i pulumi.IntInput) ContentMatcherOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ContentMatcher {
		return vs[0].([]ContentMatcher)[vs[1].(int)]
	}).(ContentMatcherOutput)
}

// Custom view of service telemetry. Currently a place-holder pending final design.
type Custom struct {
}

// CustomInput is an input type that accepts CustomArgs and CustomOutput values.
// You can construct a concrete instance of `CustomInput` via:
//
//          CustomArgs{...}
type CustomInput interface {
	pulumi.Input

	ToCustomOutput() CustomOutput
	ToCustomOutputWithContext(context.Context) CustomOutput
}

// Custom view of service telemetry. Currently a place-holder pending final design.
type CustomArgs struct {
}

func (CustomArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Custom)(nil)).Elem()
}

func (i CustomArgs) ToCustomOutput() CustomOutput {
	return i.ToCustomOutputWithContext(context.Background())
}

func (i CustomArgs) ToCustomOutputWithContext(ctx context.Context) CustomOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomOutput)
}

func (i CustomArgs) ToCustomPtrOutput() CustomPtrOutput {
	return i.ToCustomPtrOutputWithContext(context.Background())
}

func (i CustomArgs) ToCustomPtrOutputWithContext(ctx context.Context) CustomPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomOutput).ToCustomPtrOutputWithContext(ctx)
}

// CustomPtrInput is an input type that accepts CustomArgs, CustomPtr and CustomPtrOutput values.
// You can construct a concrete instance of `CustomPtrInput` via:
//
//          CustomArgs{...}
//
//  or:
//
//          nil
type CustomPtrInput interface {
	pulumi.Input

	ToCustomPtrOutput() CustomPtrOutput
	ToCustomPtrOutputWithContext(context.Context) CustomPtrOutput
}

type customPtrType CustomArgs

func CustomPtr(v *CustomArgs) CustomPtrInput {
	return (*customPtrType)(v)
}

func (*customPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Custom)(nil)).Elem()
}

func (i *customPtrType) ToCustomPtrOutput() CustomPtrOutput {
	return i.ToCustomPtrOutputWithContext(context.Background())
}

func (i *customPtrType) ToCustomPtrOutputWithContext(ctx context.Context) CustomPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomPtrOutput)
}

// Custom view of service telemetry. Currently a place-holder pending final design.
type CustomOutput struct{ *pulumi.OutputState }

func (CustomOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Custom)(nil)).Elem()
}

func (o CustomOutput) ToCustomOutput() CustomOutput {
	return o
}

func (o CustomOutput) ToCustomOutputWithContext(ctx context.Context) CustomOutput {
	return o
}

func (o CustomOutput) ToCustomPtrOutput() CustomPtrOutput {
	return o.ToCustomPtrOutputWithContext(context.Background())
}

func (o CustomOutput) ToCustomPtrOutputWithContext(ctx context.Context) CustomPtrOutput {
	return o.ApplyT(func(v Custom) *Custom {
		return &v
	}).(CustomPtrOutput)
}

type CustomPtrOutput struct{ *pulumi.OutputState }

func (CustomPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Custom)(nil)).Elem()
}

func (o CustomPtrOutput) ToCustomPtrOutput() CustomPtrOutput {
	return o
}

func (o CustomPtrOutput) ToCustomPtrOutputWithContext(ctx context.Context) CustomPtrOutput {
	return o
}

func (o CustomPtrOutput) Elem() CustomOutput {
	return o.ApplyT(func(v *Custom) Custom { return *v }).(CustomOutput)
}

// Distribution contains summary statistics for a population of values. It optionally contains a histogram representing the distribution of those values across a set of buckets.The summary statistics are the count, mean, sum of the squared deviation from the mean, the minimum, and the maximum of the set of population of values. The histogram is based on a sequence of buckets and gives a count of values that fall into each bucket. The boundaries of the buckets are given either explicitly or by formulas for buckets of fixed or exponentially increasing widths.Although it is not forbidden, it is generally a bad idea to include non-finite values (infinities or NaNs) in the population of values, as this will render the mean and sum_of_squared_deviation fields meaningless.
type Distribution struct {
	// Required in the Cloud Monitoring API v3. The values for each bucket specified in bucket_options. The sum of the values in bucketCounts must equal the value in the count field of the Distribution object. The order of the bucket counts follows the numbering schemes described for the three bucket types. The underflow bucket has number 0; the finite buckets, if any, have numbers 1 through N-2; and the overflow bucket has number N-1. The size of bucket_counts must not be greater than N. If the size is less than N, then the remaining buckets are assigned values of zero.
	BucketCounts []string `pulumi:"bucketCounts"`
	// Required in the Cloud Monitoring API v3. Defines the histogram bucket boundaries.
	BucketOptions *BucketOptions `pulumi:"bucketOptions"`
	// The number of values in the population. Must be non-negative. This value must equal the sum of the values in bucket_counts if a histogram is provided.
	Count *string `pulumi:"count"`
	// Must be in increasing order of value field.
	Exemplars []Exemplar `pulumi:"exemplars"`
	// The arithmetic mean of the values in the population. If count is zero then this field must be zero.
	Mean *float64 `pulumi:"mean"`
	// If specified, contains the range of the population values. The field must not be present if the count is zero. This field is presently ignored by the Cloud Monitoring API v3.
	Range *Range `pulumi:"range"`
	// The sum of squared deviations from the mean of the values in the population. For values x_i this is: Sum[i=1..n]((x_i - mean)^2) Knuth, "The Art of Computer Programming", Vol. 2, page 232, 3rd edition describes Welford's method for accumulating this sum in one pass.If count is zero then this field must be zero.
	SumOfSquaredDeviation *float64 `pulumi:"sumOfSquaredDeviation"`
}

// DistributionInput is an input type that accepts DistributionArgs and DistributionOutput values.
// You can construct a concrete instance of `DistributionInput` via:
//
//          DistributionArgs{...}
type DistributionInput interface {
	pulumi.Input

	ToDistributionOutput() DistributionOutput
	ToDistributionOutputWithContext(context.Context) DistributionOutput
}

// Distribution contains summary statistics for a population of values. It optionally contains a histogram representing the distribution of those values across a set of buckets.The summary statistics are the count, mean, sum of the squared deviation from the mean, the minimum, and the maximum of the set of population of values. The histogram is based on a sequence of buckets and gives a count of values that fall into each bucket. The boundaries of the buckets are given either explicitly or by formulas for buckets of fixed or exponentially increasing widths.Although it is not forbidden, it is generally a bad idea to include non-finite values (infinities or NaNs) in the population of values, as this will render the mean and sum_of_squared_deviation fields meaningless.
type DistributionArgs struct {
	// Required in the Cloud Monitoring API v3. The values for each bucket specified in bucket_options. The sum of the values in bucketCounts must equal the value in the count field of the Distribution object. The order of the bucket counts follows the numbering schemes described for the three bucket types. The underflow bucket has number 0; the finite buckets, if any, have numbers 1 through N-2; and the overflow bucket has number N-1. The size of bucket_counts must not be greater than N. If the size is less than N, then the remaining buckets are assigned values of zero.
	BucketCounts pulumi.StringArrayInput `pulumi:"bucketCounts"`
	// Required in the Cloud Monitoring API v3. Defines the histogram bucket boundaries.
	BucketOptions BucketOptionsPtrInput `pulumi:"bucketOptions"`
	// The number of values in the population. Must be non-negative. This value must equal the sum of the values in bucket_counts if a histogram is provided.
	Count pulumi.StringPtrInput `pulumi:"count"`
	// Must be in increasing order of value field.
	Exemplars ExemplarArrayInput `pulumi:"exemplars"`
	// The arithmetic mean of the values in the population. If count is zero then this field must be zero.
	Mean pulumi.Float64PtrInput `pulumi:"mean"`
	// If specified, contains the range of the population values. The field must not be present if the count is zero. This field is presently ignored by the Cloud Monitoring API v3.
	Range RangePtrInput `pulumi:"range"`
	// The sum of squared deviations from the mean of the values in the population. For values x_i this is: Sum[i=1..n]((x_i - mean)^2) Knuth, "The Art of Computer Programming", Vol. 2, page 232, 3rd edition describes Welford's method for accumulating this sum in one pass.If count is zero then this field must be zero.
	SumOfSquaredDeviation pulumi.Float64PtrInput `pulumi:"sumOfSquaredDeviation"`
}

func (DistributionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Distribution)(nil)).Elem()
}

func (i DistributionArgs) ToDistributionOutput() DistributionOutput {
	return i.ToDistributionOutputWithContext(context.Background())
}

func (i DistributionArgs) ToDistributionOutputWithContext(ctx context.Context) DistributionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributionOutput)
}

func (i DistributionArgs) ToDistributionPtrOutput() DistributionPtrOutput {
	return i.ToDistributionPtrOutputWithContext(context.Background())
}

func (i DistributionArgs) ToDistributionPtrOutputWithContext(ctx context.Context) DistributionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributionOutput).ToDistributionPtrOutputWithContext(ctx)
}

// DistributionPtrInput is an input type that accepts DistributionArgs, DistributionPtr and DistributionPtrOutput values.
// You can construct a concrete instance of `DistributionPtrInput` via:
//
//          DistributionArgs{...}
//
//  or:
//
//          nil
type DistributionPtrInput interface {
	pulumi.Input

	ToDistributionPtrOutput() DistributionPtrOutput
	ToDistributionPtrOutputWithContext(context.Context) DistributionPtrOutput
}

type distributionPtrType DistributionArgs

func DistributionPtr(v *DistributionArgs) DistributionPtrInput {
	return (*distributionPtrType)(v)
}

func (*distributionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Distribution)(nil)).Elem()
}

func (i *distributionPtrType) ToDistributionPtrOutput() DistributionPtrOutput {
	return i.ToDistributionPtrOutputWithContext(context.Background())
}

func (i *distributionPtrType) ToDistributionPtrOutputWithContext(ctx context.Context) DistributionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributionPtrOutput)
}

// Distribution contains summary statistics for a population of values. It optionally contains a histogram representing the distribution of those values across a set of buckets.The summary statistics are the count, mean, sum of the squared deviation from the mean, the minimum, and the maximum of the set of population of values. The histogram is based on a sequence of buckets and gives a count of values that fall into each bucket. The boundaries of the buckets are given either explicitly or by formulas for buckets of fixed or exponentially increasing widths.Although it is not forbidden, it is generally a bad idea to include non-finite values (infinities or NaNs) in the population of values, as this will render the mean and sum_of_squared_deviation fields meaningless.
type DistributionOutput struct{ *pulumi.OutputState }

func (DistributionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Distribution)(nil)).Elem()
}

func (o DistributionOutput) ToDistributionOutput() DistributionOutput {
	return o
}

func (o DistributionOutput) ToDistributionOutputWithContext(ctx context.Context) DistributionOutput {
	return o
}

func (o DistributionOutput) ToDistributionPtrOutput() DistributionPtrOutput {
	return o.ToDistributionPtrOutputWithContext(context.Background())
}

func (o DistributionOutput) ToDistributionPtrOutputWithContext(ctx context.Context) DistributionPtrOutput {
	return o.ApplyT(func(v Distribution) *Distribution {
		return &v
	}).(DistributionPtrOutput)
}

// Required in the Cloud Monitoring API v3. The values for each bucket specified in bucket_options. The sum of the values in bucketCounts must equal the value in the count field of the Distribution object. The order of the bucket counts follows the numbering schemes described for the three bucket types. The underflow bucket has number 0; the finite buckets, if any, have numbers 1 through N-2; and the overflow bucket has number N-1. The size of bucket_counts must not be greater than N. If the size is less than N, then the remaining buckets are assigned values of zero.
func (o DistributionOutput) BucketCounts() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Distribution) []string { return v.BucketCounts }).(pulumi.StringArrayOutput)
}

// Required in the Cloud Monitoring API v3. Defines the histogram bucket boundaries.
func (o DistributionOutput) BucketOptions() BucketOptionsPtrOutput {
	return o.ApplyT(func(v Distribution) *BucketOptions { return v.BucketOptions }).(BucketOptionsPtrOutput)
}

// The number of values in the population. Must be non-negative. This value must equal the sum of the values in bucket_counts if a histogram is provided.
func (o DistributionOutput) Count() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Distribution) *string { return v.Count }).(pulumi.StringPtrOutput)
}

// Must be in increasing order of value field.
func (o DistributionOutput) Exemplars() ExemplarArrayOutput {
	return o.ApplyT(func(v Distribution) []Exemplar { return v.Exemplars }).(ExemplarArrayOutput)
}

// The arithmetic mean of the values in the population. If count is zero then this field must be zero.
func (o DistributionOutput) Mean() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Distribution) *float64 { return v.Mean }).(pulumi.Float64PtrOutput)
}

// If specified, contains the range of the population values. The field must not be present if the count is zero. This field is presently ignored by the Cloud Monitoring API v3.
func (o DistributionOutput) Range() RangePtrOutput {
	return o.ApplyT(func(v Distribution) *Range { return v.Range }).(RangePtrOutput)
}

// The sum of squared deviations from the mean of the values in the population. For values x_i this is: Sum[i=1..n]((x_i - mean)^2) Knuth, "The Art of Computer Programming", Vol. 2, page 232, 3rd edition describes Welford's method for accumulating this sum in one pass.If count is zero then this field must be zero.
func (o DistributionOutput) SumOfSquaredDeviation() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Distribution) *float64 { return v.SumOfSquaredDeviation }).(pulumi.Float64PtrOutput)
}

type DistributionPtrOutput struct{ *pulumi.OutputState }

func (DistributionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Distribution)(nil)).Elem()
}

func (o DistributionPtrOutput) ToDistributionPtrOutput() DistributionPtrOutput {
	return o
}

func (o DistributionPtrOutput) ToDistributionPtrOutputWithContext(ctx context.Context) DistributionPtrOutput {
	return o
}

func (o DistributionPtrOutput) Elem() DistributionOutput {
	return o.ApplyT(func(v *Distribution) Distribution { return *v }).(DistributionOutput)
}

// Required in the Cloud Monitoring API v3. The values for each bucket specified in bucket_options. The sum of the values in bucketCounts must equal the value in the count field of the Distribution object. The order of the bucket counts follows the numbering schemes described for the three bucket types. The underflow bucket has number 0; the finite buckets, if any, have numbers 1 through N-2; and the overflow bucket has number N-1. The size of bucket_counts must not be greater than N. If the size is less than N, then the remaining buckets are assigned values of zero.
func (o DistributionPtrOutput) BucketCounts() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Distribution) []string {
		if v == nil {
			return nil
		}
		return v.BucketCounts
	}).(pulumi.StringArrayOutput)
}

// Required in the Cloud Monitoring API v3. Defines the histogram bucket boundaries.
func (o DistributionPtrOutput) BucketOptions() BucketOptionsPtrOutput {
	return o.ApplyT(func(v *Distribution) *BucketOptions {
		if v == nil {
			return nil
		}
		return v.BucketOptions
	}).(BucketOptionsPtrOutput)
}

// The number of values in the population. Must be non-negative. This value must equal the sum of the values in bucket_counts if a histogram is provided.
func (o DistributionPtrOutput) Count() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Distribution) *string {
		if v == nil {
			return nil
		}
		return v.Count
	}).(pulumi.StringPtrOutput)
}

// Must be in increasing order of value field.
func (o DistributionPtrOutput) Exemplars() ExemplarArrayOutput {
	return o.ApplyT(func(v *Distribution) []Exemplar {
		if v == nil {
			return nil
		}
		return v.Exemplars
	}).(ExemplarArrayOutput)
}

// The arithmetic mean of the values in the population. If count is zero then this field must be zero.
func (o DistributionPtrOutput) Mean() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *Distribution) *float64 {
		if v == nil {
			return nil
		}
		return v.Mean
	}).(pulumi.Float64PtrOutput)
}

// If specified, contains the range of the population values. The field must not be present if the count is zero. This field is presently ignored by the Cloud Monitoring API v3.
func (o DistributionPtrOutput) Range() RangePtrOutput {
	return o.ApplyT(func(v *Distribution) *Range {
		if v == nil {
			return nil
		}
		return v.Range
	}).(RangePtrOutput)
}

// The sum of squared deviations from the mean of the values in the population. For values x_i this is: Sum[i=1..n]((x_i - mean)^2) Knuth, "The Art of Computer Programming", Vol. 2, page 232, 3rd edition describes Welford's method for accumulating this sum in one pass.If count is zero then this field must be zero.
func (o DistributionPtrOutput) SumOfSquaredDeviation() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *Distribution) *float64 {
		if v == nil {
			return nil
		}
		return v.SumOfSquaredDeviation
	}).(pulumi.Float64PtrOutput)
}

// A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the count of values x in the Distribution such that range.min <= x < range.max.
type DistributionCut struct {
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
	DistributionFilter *string `pulumi:"distributionFilter"`
	// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
	Range *GoogleMonitoringV3Range `pulumi:"range"`
}

// DistributionCutInput is an input type that accepts DistributionCutArgs and DistributionCutOutput values.
// You can construct a concrete instance of `DistributionCutInput` via:
//
//          DistributionCutArgs{...}
type DistributionCutInput interface {
	pulumi.Input

	ToDistributionCutOutput() DistributionCutOutput
	ToDistributionCutOutputWithContext(context.Context) DistributionCutOutput
}

// A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the count of values x in the Distribution such that range.min <= x < range.max.
type DistributionCutArgs struct {
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
	DistributionFilter pulumi.StringPtrInput `pulumi:"distributionFilter"`
	// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
	Range GoogleMonitoringV3RangePtrInput `pulumi:"range"`
}

func (DistributionCutArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DistributionCut)(nil)).Elem()
}

func (i DistributionCutArgs) ToDistributionCutOutput() DistributionCutOutput {
	return i.ToDistributionCutOutputWithContext(context.Background())
}

func (i DistributionCutArgs) ToDistributionCutOutputWithContext(ctx context.Context) DistributionCutOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributionCutOutput)
}

func (i DistributionCutArgs) ToDistributionCutPtrOutput() DistributionCutPtrOutput {
	return i.ToDistributionCutPtrOutputWithContext(context.Background())
}

func (i DistributionCutArgs) ToDistributionCutPtrOutputWithContext(ctx context.Context) DistributionCutPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributionCutOutput).ToDistributionCutPtrOutputWithContext(ctx)
}

// DistributionCutPtrInput is an input type that accepts DistributionCutArgs, DistributionCutPtr and DistributionCutPtrOutput values.
// You can construct a concrete instance of `DistributionCutPtrInput` via:
//
//          DistributionCutArgs{...}
//
//  or:
//
//          nil
type DistributionCutPtrInput interface {
	pulumi.Input

	ToDistributionCutPtrOutput() DistributionCutPtrOutput
	ToDistributionCutPtrOutputWithContext(context.Context) DistributionCutPtrOutput
}

type distributionCutPtrType DistributionCutArgs

func DistributionCutPtr(v *DistributionCutArgs) DistributionCutPtrInput {
	return (*distributionCutPtrType)(v)
}

func (*distributionCutPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DistributionCut)(nil)).Elem()
}

func (i *distributionCutPtrType) ToDistributionCutPtrOutput() DistributionCutPtrOutput {
	return i.ToDistributionCutPtrOutputWithContext(context.Background())
}

func (i *distributionCutPtrType) ToDistributionCutPtrOutputWithContext(ctx context.Context) DistributionCutPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributionCutPtrOutput)
}

// A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the count of values x in the Distribution such that range.min <= x < range.max.
type DistributionCutOutput struct{ *pulumi.OutputState }

func (DistributionCutOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DistributionCut)(nil)).Elem()
}

func (o DistributionCutOutput) ToDistributionCutOutput() DistributionCutOutput {
	return o
}

func (o DistributionCutOutput) ToDistributionCutOutputWithContext(ctx context.Context) DistributionCutOutput {
	return o
}

func (o DistributionCutOutput) ToDistributionCutPtrOutput() DistributionCutPtrOutput {
	return o.ToDistributionCutPtrOutputWithContext(context.Background())
}

func (o DistributionCutOutput) ToDistributionCutPtrOutputWithContext(ctx context.Context) DistributionCutPtrOutput {
	return o.ApplyT(func(v DistributionCut) *DistributionCut {
		return &v
	}).(DistributionCutPtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o DistributionCutOutput) DistributionFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DistributionCut) *string { return v.DistributionFilter }).(pulumi.StringPtrOutput)
}

// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
func (o DistributionCutOutput) Range() GoogleMonitoringV3RangePtrOutput {
	return o.ApplyT(func(v DistributionCut) *GoogleMonitoringV3Range { return v.Range }).(GoogleMonitoringV3RangePtrOutput)
}

type DistributionCutPtrOutput struct{ *pulumi.OutputState }

func (DistributionCutPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DistributionCut)(nil)).Elem()
}

func (o DistributionCutPtrOutput) ToDistributionCutPtrOutput() DistributionCutPtrOutput {
	return o
}

func (o DistributionCutPtrOutput) ToDistributionCutPtrOutputWithContext(ctx context.Context) DistributionCutPtrOutput {
	return o
}

func (o DistributionCutPtrOutput) Elem() DistributionCutOutput {
	return o.ApplyT(func(v *DistributionCut) DistributionCut { return *v }).(DistributionCutOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o DistributionCutPtrOutput) DistributionFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DistributionCut) *string {
		if v == nil {
			return nil
		}
		return v.DistributionFilter
	}).(pulumi.StringPtrOutput)
}

// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
func (o DistributionCutPtrOutput) Range() GoogleMonitoringV3RangePtrOutput {
	return o.ApplyT(func(v *DistributionCut) *GoogleMonitoringV3Range {
		if v == nil {
			return nil
		}
		return v.Range
	}).(GoogleMonitoringV3RangePtrOutput)
}

// A content string and a MIME type that describes the content string's format.
type Documentation struct {
	// The text of the documentation, interpreted according to mime_type. The content may not exceed 8,192 Unicode characters and may not exceed more than 10,240 bytes when encoded in UTF-8 format, whichever is smaller.
	Content *string `pulumi:"content"`
	// The format of the content field. Presently, only the value "text/markdown" is supported. See Markdown (https://en.wikipedia.org/wiki/Markdown) for more information.
	MimeType *string `pulumi:"mimeType"`
}

// DocumentationInput is an input type that accepts DocumentationArgs and DocumentationOutput values.
// You can construct a concrete instance of `DocumentationInput` via:
//
//          DocumentationArgs{...}
type DocumentationInput interface {
	pulumi.Input

	ToDocumentationOutput() DocumentationOutput
	ToDocumentationOutputWithContext(context.Context) DocumentationOutput
}

// A content string and a MIME type that describes the content string's format.
type DocumentationArgs struct {
	// The text of the documentation, interpreted according to mime_type. The content may not exceed 8,192 Unicode characters and may not exceed more than 10,240 bytes when encoded in UTF-8 format, whichever is smaller.
	Content pulumi.StringPtrInput `pulumi:"content"`
	// The format of the content field. Presently, only the value "text/markdown" is supported. See Markdown (https://en.wikipedia.org/wiki/Markdown) for more information.
	MimeType pulumi.StringPtrInput `pulumi:"mimeType"`
}

func (DocumentationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Documentation)(nil)).Elem()
}

func (i DocumentationArgs) ToDocumentationOutput() DocumentationOutput {
	return i.ToDocumentationOutputWithContext(context.Background())
}

func (i DocumentationArgs) ToDocumentationOutputWithContext(ctx context.Context) DocumentationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DocumentationOutput)
}

func (i DocumentationArgs) ToDocumentationPtrOutput() DocumentationPtrOutput {
	return i.ToDocumentationPtrOutputWithContext(context.Background())
}

func (i DocumentationArgs) ToDocumentationPtrOutputWithContext(ctx context.Context) DocumentationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DocumentationOutput).ToDocumentationPtrOutputWithContext(ctx)
}

// DocumentationPtrInput is an input type that accepts DocumentationArgs, DocumentationPtr and DocumentationPtrOutput values.
// You can construct a concrete instance of `DocumentationPtrInput` via:
//
//          DocumentationArgs{...}
//
//  or:
//
//          nil
type DocumentationPtrInput interface {
	pulumi.Input

	ToDocumentationPtrOutput() DocumentationPtrOutput
	ToDocumentationPtrOutputWithContext(context.Context) DocumentationPtrOutput
}

type documentationPtrType DocumentationArgs

func DocumentationPtr(v *DocumentationArgs) DocumentationPtrInput {
	return (*documentationPtrType)(v)
}

func (*documentationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Documentation)(nil)).Elem()
}

func (i *documentationPtrType) ToDocumentationPtrOutput() DocumentationPtrOutput {
	return i.ToDocumentationPtrOutputWithContext(context.Background())
}

func (i *documentationPtrType) ToDocumentationPtrOutputWithContext(ctx context.Context) DocumentationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DocumentationPtrOutput)
}

// A content string and a MIME type that describes the content string's format.
type DocumentationOutput struct{ *pulumi.OutputState }

func (DocumentationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Documentation)(nil)).Elem()
}

func (o DocumentationOutput) ToDocumentationOutput() DocumentationOutput {
	return o
}

func (o DocumentationOutput) ToDocumentationOutputWithContext(ctx context.Context) DocumentationOutput {
	return o
}

func (o DocumentationOutput) ToDocumentationPtrOutput() DocumentationPtrOutput {
	return o.ToDocumentationPtrOutputWithContext(context.Background())
}

func (o DocumentationOutput) ToDocumentationPtrOutputWithContext(ctx context.Context) DocumentationPtrOutput {
	return o.ApplyT(func(v Documentation) *Documentation {
		return &v
	}).(DocumentationPtrOutput)
}

// The text of the documentation, interpreted according to mime_type. The content may not exceed 8,192 Unicode characters and may not exceed more than 10,240 bytes when encoded in UTF-8 format, whichever is smaller.
func (o DocumentationOutput) Content() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Documentation) *string { return v.Content }).(pulumi.StringPtrOutput)
}

// The format of the content field. Presently, only the value "text/markdown" is supported. See Markdown (https://en.wikipedia.org/wiki/Markdown) for more information.
func (o DocumentationOutput) MimeType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Documentation) *string { return v.MimeType }).(pulumi.StringPtrOutput)
}

type DocumentationPtrOutput struct{ *pulumi.OutputState }

func (DocumentationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Documentation)(nil)).Elem()
}

func (o DocumentationPtrOutput) ToDocumentationPtrOutput() DocumentationPtrOutput {
	return o
}

func (o DocumentationPtrOutput) ToDocumentationPtrOutputWithContext(ctx context.Context) DocumentationPtrOutput {
	return o
}

func (o DocumentationPtrOutput) Elem() DocumentationOutput {
	return o.ApplyT(func(v *Documentation) Documentation { return *v }).(DocumentationOutput)
}

// The text of the documentation, interpreted according to mime_type. The content may not exceed 8,192 Unicode characters and may not exceed more than 10,240 bytes when encoded in UTF-8 format, whichever is smaller.
func (o DocumentationPtrOutput) Content() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Documentation) *string {
		if v == nil {
			return nil
		}
		return v.Content
	}).(pulumi.StringPtrOutput)
}

// The format of the content field. Presently, only the value "text/markdown" is supported. See Markdown (https://en.wikipedia.org/wiki/Markdown) for more information.
func (o DocumentationPtrOutput) MimeType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Documentation) *string {
		if v == nil {
			return nil
		}
		return v.MimeType
	}).(pulumi.StringPtrOutput)
}

// Exemplars are example points that may be used to annotate aggregated distribution values. They are metadata that gives information about a particular value added to a Distribution bucket, such as a trace ID that was active when a value was added. They may contain further information, such as a example values and timestamps, origin, etc.
type Exemplar struct {
	// Contextual information about the example value. Examples are:Trace: type.googleapis.com/google.monitoring.v3.SpanContextLiteral string: type.googleapis.com/google.protobuf.StringValueLabels dropped during aggregation: type.googleapis.com/google.monitoring.v3.DroppedLabelsThere may be only a single attachment of any given message type in a single exemplar, and this is enforced by the system.
	Attachments []map[string]string `pulumi:"attachments"`
	// The observation (sampling) time of the above value.
	Timestamp *string `pulumi:"timestamp"`
	// Value of the exemplar point. This value determines to which bucket the exemplar belongs.
	Value *float64 `pulumi:"value"`
}

// ExemplarInput is an input type that accepts ExemplarArgs and ExemplarOutput values.
// You can construct a concrete instance of `ExemplarInput` via:
//
//          ExemplarArgs{...}
type ExemplarInput interface {
	pulumi.Input

	ToExemplarOutput() ExemplarOutput
	ToExemplarOutputWithContext(context.Context) ExemplarOutput
}

// Exemplars are example points that may be used to annotate aggregated distribution values. They are metadata that gives information about a particular value added to a Distribution bucket, such as a trace ID that was active when a value was added. They may contain further information, such as a example values and timestamps, origin, etc.
type ExemplarArgs struct {
	// Contextual information about the example value. Examples are:Trace: type.googleapis.com/google.monitoring.v3.SpanContextLiteral string: type.googleapis.com/google.protobuf.StringValueLabels dropped during aggregation: type.googleapis.com/google.monitoring.v3.DroppedLabelsThere may be only a single attachment of any given message type in a single exemplar, and this is enforced by the system.
	Attachments pulumi.StringMapArrayInput `pulumi:"attachments"`
	// The observation (sampling) time of the above value.
	Timestamp pulumi.StringPtrInput `pulumi:"timestamp"`
	// Value of the exemplar point. This value determines to which bucket the exemplar belongs.
	Value pulumi.Float64PtrInput `pulumi:"value"`
}

func (ExemplarArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Exemplar)(nil)).Elem()
}

func (i ExemplarArgs) ToExemplarOutput() ExemplarOutput {
	return i.ToExemplarOutputWithContext(context.Background())
}

func (i ExemplarArgs) ToExemplarOutputWithContext(ctx context.Context) ExemplarOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExemplarOutput)
}

// ExemplarArrayInput is an input type that accepts ExemplarArray and ExemplarArrayOutput values.
// You can construct a concrete instance of `ExemplarArrayInput` via:
//
//          ExemplarArray{ ExemplarArgs{...} }
type ExemplarArrayInput interface {
	pulumi.Input

	ToExemplarArrayOutput() ExemplarArrayOutput
	ToExemplarArrayOutputWithContext(context.Context) ExemplarArrayOutput
}

type ExemplarArray []ExemplarInput

func (ExemplarArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Exemplar)(nil)).Elem()
}

func (i ExemplarArray) ToExemplarArrayOutput() ExemplarArrayOutput {
	return i.ToExemplarArrayOutputWithContext(context.Background())
}

func (i ExemplarArray) ToExemplarArrayOutputWithContext(ctx context.Context) ExemplarArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExemplarArrayOutput)
}

// Exemplars are example points that may be used to annotate aggregated distribution values. They are metadata that gives information about a particular value added to a Distribution bucket, such as a trace ID that was active when a value was added. They may contain further information, such as a example values and timestamps, origin, etc.
type ExemplarOutput struct{ *pulumi.OutputState }

func (ExemplarOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Exemplar)(nil)).Elem()
}

func (o ExemplarOutput) ToExemplarOutput() ExemplarOutput {
	return o
}

func (o ExemplarOutput) ToExemplarOutputWithContext(ctx context.Context) ExemplarOutput {
	return o
}

// Contextual information about the example value. Examples are:Trace: type.googleapis.com/google.monitoring.v3.SpanContextLiteral string: type.googleapis.com/google.protobuf.StringValueLabels dropped during aggregation: type.googleapis.com/google.monitoring.v3.DroppedLabelsThere may be only a single attachment of any given message type in a single exemplar, and this is enforced by the system.
func (o ExemplarOutput) Attachments() pulumi.StringMapArrayOutput {
	return o.ApplyT(func(v Exemplar) []map[string]string { return v.Attachments }).(pulumi.StringMapArrayOutput)
}

// The observation (sampling) time of the above value.
func (o ExemplarOutput) Timestamp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Exemplar) *string { return v.Timestamp }).(pulumi.StringPtrOutput)
}

// Value of the exemplar point. This value determines to which bucket the exemplar belongs.
func (o ExemplarOutput) Value() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Exemplar) *float64 { return v.Value }).(pulumi.Float64PtrOutput)
}

type ExemplarArrayOutput struct{ *pulumi.OutputState }

func (ExemplarArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Exemplar)(nil)).Elem()
}

func (o ExemplarArrayOutput) ToExemplarArrayOutput() ExemplarArrayOutput {
	return o
}

func (o ExemplarArrayOutput) ToExemplarArrayOutputWithContext(ctx context.Context) ExemplarArrayOutput {
	return o
}

func (o ExemplarArrayOutput) Index(i pulumi.IntInput) ExemplarOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Exemplar {
		return vs[0].([]Exemplar)[vs[1].(int)]
	}).(ExemplarOutput)
}

// Specifies a set of buckets with arbitrary widths.There are size(bounds) + 1 (= N) buckets. Bucket i has the following boundaries:Upper bound (0 <= i < N-1): boundsi Lower bound (1 <= i < N); boundsi - 1The bounds field must contain at least one element. If bounds has only one element, then there are no finite buckets, and that single element is the common boundary of the overflow and underflow buckets.
type Explicit struct {
	// The values must be monotonically increasing.
	Bounds []float64 `pulumi:"bounds"`
}

// ExplicitInput is an input type that accepts ExplicitArgs and ExplicitOutput values.
// You can construct a concrete instance of `ExplicitInput` via:
//
//          ExplicitArgs{...}
type ExplicitInput interface {
	pulumi.Input

	ToExplicitOutput() ExplicitOutput
	ToExplicitOutputWithContext(context.Context) ExplicitOutput
}

// Specifies a set of buckets with arbitrary widths.There are size(bounds) + 1 (= N) buckets. Bucket i has the following boundaries:Upper bound (0 <= i < N-1): boundsi Lower bound (1 <= i < N); boundsi - 1The bounds field must contain at least one element. If bounds has only one element, then there are no finite buckets, and that single element is the common boundary of the overflow and underflow buckets.
type ExplicitArgs struct {
	// The values must be monotonically increasing.
	Bounds pulumi.Float64ArrayInput `pulumi:"bounds"`
}

func (ExplicitArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Explicit)(nil)).Elem()
}

func (i ExplicitArgs) ToExplicitOutput() ExplicitOutput {
	return i.ToExplicitOutputWithContext(context.Background())
}

func (i ExplicitArgs) ToExplicitOutputWithContext(ctx context.Context) ExplicitOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExplicitOutput)
}

func (i ExplicitArgs) ToExplicitPtrOutput() ExplicitPtrOutput {
	return i.ToExplicitPtrOutputWithContext(context.Background())
}

func (i ExplicitArgs) ToExplicitPtrOutputWithContext(ctx context.Context) ExplicitPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExplicitOutput).ToExplicitPtrOutputWithContext(ctx)
}

// ExplicitPtrInput is an input type that accepts ExplicitArgs, ExplicitPtr and ExplicitPtrOutput values.
// You can construct a concrete instance of `ExplicitPtrInput` via:
//
//          ExplicitArgs{...}
//
//  or:
//
//          nil
type ExplicitPtrInput interface {
	pulumi.Input

	ToExplicitPtrOutput() ExplicitPtrOutput
	ToExplicitPtrOutputWithContext(context.Context) ExplicitPtrOutput
}

type explicitPtrType ExplicitArgs

func ExplicitPtr(v *ExplicitArgs) ExplicitPtrInput {
	return (*explicitPtrType)(v)
}

func (*explicitPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Explicit)(nil)).Elem()
}

func (i *explicitPtrType) ToExplicitPtrOutput() ExplicitPtrOutput {
	return i.ToExplicitPtrOutputWithContext(context.Background())
}

func (i *explicitPtrType) ToExplicitPtrOutputWithContext(ctx context.Context) ExplicitPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExplicitPtrOutput)
}

// Specifies a set of buckets with arbitrary widths.There are size(bounds) + 1 (= N) buckets. Bucket i has the following boundaries:Upper bound (0 <= i < N-1): boundsi Lower bound (1 <= i < N); boundsi - 1The bounds field must contain at least one element. If bounds has only one element, then there are no finite buckets, and that single element is the common boundary of the overflow and underflow buckets.
type ExplicitOutput struct{ *pulumi.OutputState }

func (ExplicitOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Explicit)(nil)).Elem()
}

func (o ExplicitOutput) ToExplicitOutput() ExplicitOutput {
	return o
}

func (o ExplicitOutput) ToExplicitOutputWithContext(ctx context.Context) ExplicitOutput {
	return o
}

func (o ExplicitOutput) ToExplicitPtrOutput() ExplicitPtrOutput {
	return o.ToExplicitPtrOutputWithContext(context.Background())
}

func (o ExplicitOutput) ToExplicitPtrOutputWithContext(ctx context.Context) ExplicitPtrOutput {
	return o.ApplyT(func(v Explicit) *Explicit {
		return &v
	}).(ExplicitPtrOutput)
}

// The values must be monotonically increasing.
func (o ExplicitOutput) Bounds() pulumi.Float64ArrayOutput {
	return o.ApplyT(func(v Explicit) []float64 { return v.Bounds }).(pulumi.Float64ArrayOutput)
}

type ExplicitPtrOutput struct{ *pulumi.OutputState }

func (ExplicitPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Explicit)(nil)).Elem()
}

func (o ExplicitPtrOutput) ToExplicitPtrOutput() ExplicitPtrOutput {
	return o
}

func (o ExplicitPtrOutput) ToExplicitPtrOutputWithContext(ctx context.Context) ExplicitPtrOutput {
	return o
}

func (o ExplicitPtrOutput) Elem() ExplicitOutput {
	return o.ApplyT(func(v *Explicit) Explicit { return *v }).(ExplicitOutput)
}

// The values must be monotonically increasing.
func (o ExplicitPtrOutput) Bounds() pulumi.Float64ArrayOutput {
	return o.ApplyT(func(v *Explicit) []float64 {
		if v == nil {
			return nil
		}
		return v.Bounds
	}).(pulumi.Float64ArrayOutput)
}

// Specifies an exponential sequence of buckets that have a width that is proportional to the value of the lower bound. Each bucket represents a constant relative uncertainty on a specific value in the bucket.There are num_finite_buckets + 2 (= N) buckets. Bucket i has the following boundaries:Upper bound (0 <= i < N-1): scale * (growth_factor ^ i). Lower bound (1 <= i < N): scale * (growth_factor ^ (i - 1)).
type Exponential struct {
	// Must be greater than 1.
	GrowthFactor *float64 `pulumi:"growthFactor"`
	// Must be greater than 0.
	NumFiniteBuckets *int `pulumi:"numFiniteBuckets"`
	// Must be greater than 0.
	Scale *float64 `pulumi:"scale"`
}

// ExponentialInput is an input type that accepts ExponentialArgs and ExponentialOutput values.
// You can construct a concrete instance of `ExponentialInput` via:
//
//          ExponentialArgs{...}
type ExponentialInput interface {
	pulumi.Input

	ToExponentialOutput() ExponentialOutput
	ToExponentialOutputWithContext(context.Context) ExponentialOutput
}

// Specifies an exponential sequence of buckets that have a width that is proportional to the value of the lower bound. Each bucket represents a constant relative uncertainty on a specific value in the bucket.There are num_finite_buckets + 2 (= N) buckets. Bucket i has the following boundaries:Upper bound (0 <= i < N-1): scale * (growth_factor ^ i). Lower bound (1 <= i < N): scale * (growth_factor ^ (i - 1)).
type ExponentialArgs struct {
	// Must be greater than 1.
	GrowthFactor pulumi.Float64PtrInput `pulumi:"growthFactor"`
	// Must be greater than 0.
	NumFiniteBuckets pulumi.IntPtrInput `pulumi:"numFiniteBuckets"`
	// Must be greater than 0.
	Scale pulumi.Float64PtrInput `pulumi:"scale"`
}

func (ExponentialArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Exponential)(nil)).Elem()
}

func (i ExponentialArgs) ToExponentialOutput() ExponentialOutput {
	return i.ToExponentialOutputWithContext(context.Background())
}

func (i ExponentialArgs) ToExponentialOutputWithContext(ctx context.Context) ExponentialOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExponentialOutput)
}

func (i ExponentialArgs) ToExponentialPtrOutput() ExponentialPtrOutput {
	return i.ToExponentialPtrOutputWithContext(context.Background())
}

func (i ExponentialArgs) ToExponentialPtrOutputWithContext(ctx context.Context) ExponentialPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExponentialOutput).ToExponentialPtrOutputWithContext(ctx)
}

// ExponentialPtrInput is an input type that accepts ExponentialArgs, ExponentialPtr and ExponentialPtrOutput values.
// You can construct a concrete instance of `ExponentialPtrInput` via:
//
//          ExponentialArgs{...}
//
//  or:
//
//          nil
type ExponentialPtrInput interface {
	pulumi.Input

	ToExponentialPtrOutput() ExponentialPtrOutput
	ToExponentialPtrOutputWithContext(context.Context) ExponentialPtrOutput
}

type exponentialPtrType ExponentialArgs

func ExponentialPtr(v *ExponentialArgs) ExponentialPtrInput {
	return (*exponentialPtrType)(v)
}

func (*exponentialPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Exponential)(nil)).Elem()
}

func (i *exponentialPtrType) ToExponentialPtrOutput() ExponentialPtrOutput {
	return i.ToExponentialPtrOutputWithContext(context.Background())
}

func (i *exponentialPtrType) ToExponentialPtrOutputWithContext(ctx context.Context) ExponentialPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ExponentialPtrOutput)
}

// Specifies an exponential sequence of buckets that have a width that is proportional to the value of the lower bound. Each bucket represents a constant relative uncertainty on a specific value in the bucket.There are num_finite_buckets + 2 (= N) buckets. Bucket i has the following boundaries:Upper bound (0 <= i < N-1): scale * (growth_factor ^ i). Lower bound (1 <= i < N): scale * (growth_factor ^ (i - 1)).
type ExponentialOutput struct{ *pulumi.OutputState }

func (ExponentialOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Exponential)(nil)).Elem()
}

func (o ExponentialOutput) ToExponentialOutput() ExponentialOutput {
	return o
}

func (o ExponentialOutput) ToExponentialOutputWithContext(ctx context.Context) ExponentialOutput {
	return o
}

func (o ExponentialOutput) ToExponentialPtrOutput() ExponentialPtrOutput {
	return o.ToExponentialPtrOutputWithContext(context.Background())
}

func (o ExponentialOutput) ToExponentialPtrOutputWithContext(ctx context.Context) ExponentialPtrOutput {
	return o.ApplyT(func(v Exponential) *Exponential {
		return &v
	}).(ExponentialPtrOutput)
}

// Must be greater than 1.
func (o ExponentialOutput) GrowthFactor() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Exponential) *float64 { return v.GrowthFactor }).(pulumi.Float64PtrOutput)
}

// Must be greater than 0.
func (o ExponentialOutput) NumFiniteBuckets() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Exponential) *int { return v.NumFiniteBuckets }).(pulumi.IntPtrOutput)
}

// Must be greater than 0.
func (o ExponentialOutput) Scale() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Exponential) *float64 { return v.Scale }).(pulumi.Float64PtrOutput)
}

type ExponentialPtrOutput struct{ *pulumi.OutputState }

func (ExponentialPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Exponential)(nil)).Elem()
}

func (o ExponentialPtrOutput) ToExponentialPtrOutput() ExponentialPtrOutput {
	return o
}

func (o ExponentialPtrOutput) ToExponentialPtrOutputWithContext(ctx context.Context) ExponentialPtrOutput {
	return o
}

func (o ExponentialPtrOutput) Elem() ExponentialOutput {
	return o.ApplyT(func(v *Exponential) Exponential { return *v }).(ExponentialOutput)
}

// Must be greater than 1.
func (o ExponentialPtrOutput) GrowthFactor() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *Exponential) *float64 {
		if v == nil {
			return nil
		}
		return v.GrowthFactor
	}).(pulumi.Float64PtrOutput)
}

// Must be greater than 0.
func (o ExponentialPtrOutput) NumFiniteBuckets() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Exponential) *int {
		if v == nil {
			return nil
		}
		return v.NumFiniteBuckets
	}).(pulumi.IntPtrOutput)
}

// Must be greater than 0.
func (o ExponentialPtrOutput) Scale() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *Exponential) *float64 {
		if v == nil {
			return nil
		}
		return v.Scale
	}).(pulumi.Float64PtrOutput)
}

// Range of numerical values, inclusive of min and exclusive of max. If the open range "< range.max" is desired, set range.min = -infinity. If the open range ">= range.min" is desired, set range.max = infinity.
type GoogleMonitoringV3Range struct {
	// Range maximum.
	Max *float64 `pulumi:"max"`
	// Range minimum.
	Min *float64 `pulumi:"min"`
}

// GoogleMonitoringV3RangeInput is an input type that accepts GoogleMonitoringV3RangeArgs and GoogleMonitoringV3RangeOutput values.
// You can construct a concrete instance of `GoogleMonitoringV3RangeInput` via:
//
//          GoogleMonitoringV3RangeArgs{...}
type GoogleMonitoringV3RangeInput interface {
	pulumi.Input

	ToGoogleMonitoringV3RangeOutput() GoogleMonitoringV3RangeOutput
	ToGoogleMonitoringV3RangeOutputWithContext(context.Context) GoogleMonitoringV3RangeOutput
}

// Range of numerical values, inclusive of min and exclusive of max. If the open range "< range.max" is desired, set range.min = -infinity. If the open range ">= range.min" is desired, set range.max = infinity.
type GoogleMonitoringV3RangeArgs struct {
	// Range maximum.
	Max pulumi.Float64PtrInput `pulumi:"max"`
	// Range minimum.
	Min pulumi.Float64PtrInput `pulumi:"min"`
}

func (GoogleMonitoringV3RangeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleMonitoringV3Range)(nil)).Elem()
}

func (i GoogleMonitoringV3RangeArgs) ToGoogleMonitoringV3RangeOutput() GoogleMonitoringV3RangeOutput {
	return i.ToGoogleMonitoringV3RangeOutputWithContext(context.Background())
}

func (i GoogleMonitoringV3RangeArgs) ToGoogleMonitoringV3RangeOutputWithContext(ctx context.Context) GoogleMonitoringV3RangeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleMonitoringV3RangeOutput)
}

func (i GoogleMonitoringV3RangeArgs) ToGoogleMonitoringV3RangePtrOutput() GoogleMonitoringV3RangePtrOutput {
	return i.ToGoogleMonitoringV3RangePtrOutputWithContext(context.Background())
}

func (i GoogleMonitoringV3RangeArgs) ToGoogleMonitoringV3RangePtrOutputWithContext(ctx context.Context) GoogleMonitoringV3RangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleMonitoringV3RangeOutput).ToGoogleMonitoringV3RangePtrOutputWithContext(ctx)
}

// GoogleMonitoringV3RangePtrInput is an input type that accepts GoogleMonitoringV3RangeArgs, GoogleMonitoringV3RangePtr and GoogleMonitoringV3RangePtrOutput values.
// You can construct a concrete instance of `GoogleMonitoringV3RangePtrInput` via:
//
//          GoogleMonitoringV3RangeArgs{...}
//
//  or:
//
//          nil
type GoogleMonitoringV3RangePtrInput interface {
	pulumi.Input

	ToGoogleMonitoringV3RangePtrOutput() GoogleMonitoringV3RangePtrOutput
	ToGoogleMonitoringV3RangePtrOutputWithContext(context.Context) GoogleMonitoringV3RangePtrOutput
}

type googleMonitoringV3RangePtrType GoogleMonitoringV3RangeArgs

func GoogleMonitoringV3RangePtr(v *GoogleMonitoringV3RangeArgs) GoogleMonitoringV3RangePtrInput {
	return (*googleMonitoringV3RangePtrType)(v)
}

func (*googleMonitoringV3RangePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GoogleMonitoringV3Range)(nil)).Elem()
}

func (i *googleMonitoringV3RangePtrType) ToGoogleMonitoringV3RangePtrOutput() GoogleMonitoringV3RangePtrOutput {
	return i.ToGoogleMonitoringV3RangePtrOutputWithContext(context.Background())
}

func (i *googleMonitoringV3RangePtrType) ToGoogleMonitoringV3RangePtrOutputWithContext(ctx context.Context) GoogleMonitoringV3RangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GoogleMonitoringV3RangePtrOutput)
}

// Range of numerical values, inclusive of min and exclusive of max. If the open range "< range.max" is desired, set range.min = -infinity. If the open range ">= range.min" is desired, set range.max = infinity.
type GoogleMonitoringV3RangeOutput struct{ *pulumi.OutputState }

func (GoogleMonitoringV3RangeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GoogleMonitoringV3Range)(nil)).Elem()
}

func (o GoogleMonitoringV3RangeOutput) ToGoogleMonitoringV3RangeOutput() GoogleMonitoringV3RangeOutput {
	return o
}

func (o GoogleMonitoringV3RangeOutput) ToGoogleMonitoringV3RangeOutputWithContext(ctx context.Context) GoogleMonitoringV3RangeOutput {
	return o
}

func (o GoogleMonitoringV3RangeOutput) ToGoogleMonitoringV3RangePtrOutput() GoogleMonitoringV3RangePtrOutput {
	return o.ToGoogleMonitoringV3RangePtrOutputWithContext(context.Background())
}

func (o GoogleMonitoringV3RangeOutput) ToGoogleMonitoringV3RangePtrOutputWithContext(ctx context.Context) GoogleMonitoringV3RangePtrOutput {
	return o.ApplyT(func(v GoogleMonitoringV3Range) *GoogleMonitoringV3Range {
		return &v
	}).(GoogleMonitoringV3RangePtrOutput)
}

// Range maximum.
func (o GoogleMonitoringV3RangeOutput) Max() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v GoogleMonitoringV3Range) *float64 { return v.Max }).(pulumi.Float64PtrOutput)
}

// Range minimum.
func (o GoogleMonitoringV3RangeOutput) Min() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v GoogleMonitoringV3Range) *float64 { return v.Min }).(pulumi.Float64PtrOutput)
}

type GoogleMonitoringV3RangePtrOutput struct{ *pulumi.OutputState }

func (GoogleMonitoringV3RangePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GoogleMonitoringV3Range)(nil)).Elem()
}

func (o GoogleMonitoringV3RangePtrOutput) ToGoogleMonitoringV3RangePtrOutput() GoogleMonitoringV3RangePtrOutput {
	return o
}

func (o GoogleMonitoringV3RangePtrOutput) ToGoogleMonitoringV3RangePtrOutputWithContext(ctx context.Context) GoogleMonitoringV3RangePtrOutput {
	return o
}

func (o GoogleMonitoringV3RangePtrOutput) Elem() GoogleMonitoringV3RangeOutput {
	return o.ApplyT(func(v *GoogleMonitoringV3Range) GoogleMonitoringV3Range { return *v }).(GoogleMonitoringV3RangeOutput)
}

// Range maximum.
func (o GoogleMonitoringV3RangePtrOutput) Max() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *GoogleMonitoringV3Range) *float64 {
		if v == nil {
			return nil
		}
		return v.Max
	}).(pulumi.Float64PtrOutput)
}

// Range minimum.
func (o GoogleMonitoringV3RangePtrOutput) Min() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *GoogleMonitoringV3Range) *float64 {
		if v == nil {
			return nil
		}
		return v.Min
	}).(pulumi.Float64PtrOutput)
}

// Information involved in an HTTP/HTTPS Uptime check request.
type HttpCheck struct {
	// The authentication information. Optional when creating an HTTP check; defaults to empty.
	AuthInfo *BasicAuthentication `pulumi:"authInfo"`
	// The request body associated with the HTTP POST request. If content_type is URL_ENCODED, the body passed in must be URL-encoded. Users can provide a Content-Length header via the headers field or the API will do so. If the request_method is GET and body is not empty, the API will return an error. The maximum byte size is 1 megabyte. Note: As with all bytes fields, JSON representations are base64 encoded. e.g.: "foo=bar" in URL-encoded form is "foo%3Dbar" and in base64 encoding is "Zm9vJTI1M0RiYXI=".
	Body *string `pulumi:"body"`
	// The content type header to use for the check. The following configurations result in errors: 1. Content type is specified in both the headers field and the content_type field. 2. Request method is GET and content_type is not TYPE_UNSPECIFIED 3. Request method is POST and content_type is TYPE_UNSPECIFIED. 4. Request method is POST and a "Content-Type" header is provided via headers field. The content_type field should be used instead.
	ContentType *string `pulumi:"contentType"`
	// The list of headers to send as part of the Uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
	Headers map[string]string `pulumi:"headers"`
	// Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if mask_headers is set to true then the headers will be obscured with ******.
	MaskHeaders *bool `pulumi:"maskHeaders"`
	// Optional (defaults to "/"). The path to the page against which to run the check. Will be combined with the host (specified within the monitored_resource) and port to construct the full URL. If the provided path does not begin with "/", a "/" will be prepended automatically.
	Path *string `pulumi:"path"`
	// Optional (defaults to 80 when use_ssl is false, and 443 when use_ssl is true). The TCP port on the HTTP server against which to run the check. Will be combined with host (specified within the monitored_resource) and path to construct the full URL.
	Port *int `pulumi:"port"`
	// The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED then request_method defaults to GET.
	RequestMethod *string `pulumi:"requestMethod"`
	// If true, use HTTPS instead of HTTP to run the check.
	UseSsl *bool `pulumi:"useSsl"`
	// Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitored_resource is set to uptime_url. If use_ssl is false, setting validate_ssl to true has no effect.
	ValidateSsl *bool `pulumi:"validateSsl"`
}

// HttpCheckInput is an input type that accepts HttpCheckArgs and HttpCheckOutput values.
// You can construct a concrete instance of `HttpCheckInput` via:
//
//          HttpCheckArgs{...}
type HttpCheckInput interface {
	pulumi.Input

	ToHttpCheckOutput() HttpCheckOutput
	ToHttpCheckOutputWithContext(context.Context) HttpCheckOutput
}

// Information involved in an HTTP/HTTPS Uptime check request.
type HttpCheckArgs struct {
	// The authentication information. Optional when creating an HTTP check; defaults to empty.
	AuthInfo BasicAuthenticationPtrInput `pulumi:"authInfo"`
	// The request body associated with the HTTP POST request. If content_type is URL_ENCODED, the body passed in must be URL-encoded. Users can provide a Content-Length header via the headers field or the API will do so. If the request_method is GET and body is not empty, the API will return an error. The maximum byte size is 1 megabyte. Note: As with all bytes fields, JSON representations are base64 encoded. e.g.: "foo=bar" in URL-encoded form is "foo%3Dbar" and in base64 encoding is "Zm9vJTI1M0RiYXI=".
	Body pulumi.StringPtrInput `pulumi:"body"`
	// The content type header to use for the check. The following configurations result in errors: 1. Content type is specified in both the headers field and the content_type field. 2. Request method is GET and content_type is not TYPE_UNSPECIFIED 3. Request method is POST and content_type is TYPE_UNSPECIFIED. 4. Request method is POST and a "Content-Type" header is provided via headers field. The content_type field should be used instead.
	ContentType pulumi.StringPtrInput `pulumi:"contentType"`
	// The list of headers to send as part of the Uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
	Headers pulumi.StringMapInput `pulumi:"headers"`
	// Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if mask_headers is set to true then the headers will be obscured with ******.
	MaskHeaders pulumi.BoolPtrInput `pulumi:"maskHeaders"`
	// Optional (defaults to "/"). The path to the page against which to run the check. Will be combined with the host (specified within the monitored_resource) and port to construct the full URL. If the provided path does not begin with "/", a "/" will be prepended automatically.
	Path pulumi.StringPtrInput `pulumi:"path"`
	// Optional (defaults to 80 when use_ssl is false, and 443 when use_ssl is true). The TCP port on the HTTP server against which to run the check. Will be combined with host (specified within the monitored_resource) and path to construct the full URL.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED then request_method defaults to GET.
	RequestMethod pulumi.StringPtrInput `pulumi:"requestMethod"`
	// If true, use HTTPS instead of HTTP to run the check.
	UseSsl pulumi.BoolPtrInput `pulumi:"useSsl"`
	// Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitored_resource is set to uptime_url. If use_ssl is false, setting validate_ssl to true has no effect.
	ValidateSsl pulumi.BoolPtrInput `pulumi:"validateSsl"`
}

func (HttpCheckArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HttpCheck)(nil)).Elem()
}

func (i HttpCheckArgs) ToHttpCheckOutput() HttpCheckOutput {
	return i.ToHttpCheckOutputWithContext(context.Background())
}

func (i HttpCheckArgs) ToHttpCheckOutputWithContext(ctx context.Context) HttpCheckOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HttpCheckOutput)
}

func (i HttpCheckArgs) ToHttpCheckPtrOutput() HttpCheckPtrOutput {
	return i.ToHttpCheckPtrOutputWithContext(context.Background())
}

func (i HttpCheckArgs) ToHttpCheckPtrOutputWithContext(ctx context.Context) HttpCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HttpCheckOutput).ToHttpCheckPtrOutputWithContext(ctx)
}

// HttpCheckPtrInput is an input type that accepts HttpCheckArgs, HttpCheckPtr and HttpCheckPtrOutput values.
// You can construct a concrete instance of `HttpCheckPtrInput` via:
//
//          HttpCheckArgs{...}
//
//  or:
//
//          nil
type HttpCheckPtrInput interface {
	pulumi.Input

	ToHttpCheckPtrOutput() HttpCheckPtrOutput
	ToHttpCheckPtrOutputWithContext(context.Context) HttpCheckPtrOutput
}

type httpCheckPtrType HttpCheckArgs

func HttpCheckPtr(v *HttpCheckArgs) HttpCheckPtrInput {
	return (*httpCheckPtrType)(v)
}

func (*httpCheckPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HttpCheck)(nil)).Elem()
}

func (i *httpCheckPtrType) ToHttpCheckPtrOutput() HttpCheckPtrOutput {
	return i.ToHttpCheckPtrOutputWithContext(context.Background())
}

func (i *httpCheckPtrType) ToHttpCheckPtrOutputWithContext(ctx context.Context) HttpCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HttpCheckPtrOutput)
}

// Information involved in an HTTP/HTTPS Uptime check request.
type HttpCheckOutput struct{ *pulumi.OutputState }

func (HttpCheckOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HttpCheck)(nil)).Elem()
}

func (o HttpCheckOutput) ToHttpCheckOutput() HttpCheckOutput {
	return o
}

func (o HttpCheckOutput) ToHttpCheckOutputWithContext(ctx context.Context) HttpCheckOutput {
	return o
}

func (o HttpCheckOutput) ToHttpCheckPtrOutput() HttpCheckPtrOutput {
	return o.ToHttpCheckPtrOutputWithContext(context.Background())
}

func (o HttpCheckOutput) ToHttpCheckPtrOutputWithContext(ctx context.Context) HttpCheckPtrOutput {
	return o.ApplyT(func(v HttpCheck) *HttpCheck {
		return &v
	}).(HttpCheckPtrOutput)
}

// The authentication information. Optional when creating an HTTP check; defaults to empty.
func (o HttpCheckOutput) AuthInfo() BasicAuthenticationPtrOutput {
	return o.ApplyT(func(v HttpCheck) *BasicAuthentication { return v.AuthInfo }).(BasicAuthenticationPtrOutput)
}

// The request body associated with the HTTP POST request. If content_type is URL_ENCODED, the body passed in must be URL-encoded. Users can provide a Content-Length header via the headers field or the API will do so. If the request_method is GET and body is not empty, the API will return an error. The maximum byte size is 1 megabyte. Note: As with all bytes fields, JSON representations are base64 encoded. e.g.: "foo=bar" in URL-encoded form is "foo%3Dbar" and in base64 encoding is "Zm9vJTI1M0RiYXI=".
func (o HttpCheckOutput) Body() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HttpCheck) *string { return v.Body }).(pulumi.StringPtrOutput)
}

// The content type header to use for the check. The following configurations result in errors: 1. Content type is specified in both the headers field and the content_type field. 2. Request method is GET and content_type is not TYPE_UNSPECIFIED 3. Request method is POST and content_type is TYPE_UNSPECIFIED. 4. Request method is POST and a "Content-Type" header is provided via headers field. The content_type field should be used instead.
func (o HttpCheckOutput) ContentType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HttpCheck) *string { return v.ContentType }).(pulumi.StringPtrOutput)
}

// The list of headers to send as part of the Uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
func (o HttpCheckOutput) Headers() pulumi.StringMapOutput {
	return o.ApplyT(func(v HttpCheck) map[string]string { return v.Headers }).(pulumi.StringMapOutput)
}

// Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if mask_headers is set to true then the headers will be obscured with ******.
func (o HttpCheckOutput) MaskHeaders() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v HttpCheck) *bool { return v.MaskHeaders }).(pulumi.BoolPtrOutput)
}

// Optional (defaults to "/"). The path to the page against which to run the check. Will be combined with the host (specified within the monitored_resource) and port to construct the full URL. If the provided path does not begin with "/", a "/" will be prepended automatically.
func (o HttpCheckOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HttpCheck) *string { return v.Path }).(pulumi.StringPtrOutput)
}

// Optional (defaults to 80 when use_ssl is false, and 443 when use_ssl is true). The TCP port on the HTTP server against which to run the check. Will be combined with host (specified within the monitored_resource) and path to construct the full URL.
func (o HttpCheckOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HttpCheck) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED then request_method defaults to GET.
func (o HttpCheckOutput) RequestMethod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HttpCheck) *string { return v.RequestMethod }).(pulumi.StringPtrOutput)
}

// If true, use HTTPS instead of HTTP to run the check.
func (o HttpCheckOutput) UseSsl() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v HttpCheck) *bool { return v.UseSsl }).(pulumi.BoolPtrOutput)
}

// Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitored_resource is set to uptime_url. If use_ssl is false, setting validate_ssl to true has no effect.
func (o HttpCheckOutput) ValidateSsl() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v HttpCheck) *bool { return v.ValidateSsl }).(pulumi.BoolPtrOutput)
}

type HttpCheckPtrOutput struct{ *pulumi.OutputState }

func (HttpCheckPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HttpCheck)(nil)).Elem()
}

func (o HttpCheckPtrOutput) ToHttpCheckPtrOutput() HttpCheckPtrOutput {
	return o
}

func (o HttpCheckPtrOutput) ToHttpCheckPtrOutputWithContext(ctx context.Context) HttpCheckPtrOutput {
	return o
}

func (o HttpCheckPtrOutput) Elem() HttpCheckOutput {
	return o.ApplyT(func(v *HttpCheck) HttpCheck { return *v }).(HttpCheckOutput)
}

// The authentication information. Optional when creating an HTTP check; defaults to empty.
func (o HttpCheckPtrOutput) AuthInfo() BasicAuthenticationPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *BasicAuthentication {
		if v == nil {
			return nil
		}
		return v.AuthInfo
	}).(BasicAuthenticationPtrOutput)
}

// The request body associated with the HTTP POST request. If content_type is URL_ENCODED, the body passed in must be URL-encoded. Users can provide a Content-Length header via the headers field or the API will do so. If the request_method is GET and body is not empty, the API will return an error. The maximum byte size is 1 megabyte. Note: As with all bytes fields, JSON representations are base64 encoded. e.g.: "foo=bar" in URL-encoded form is "foo%3Dbar" and in base64 encoding is "Zm9vJTI1M0RiYXI=".
func (o HttpCheckPtrOutput) Body() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *string {
		if v == nil {
			return nil
		}
		return v.Body
	}).(pulumi.StringPtrOutput)
}

// The content type header to use for the check. The following configurations result in errors: 1. Content type is specified in both the headers field and the content_type field. 2. Request method is GET and content_type is not TYPE_UNSPECIFIED 3. Request method is POST and content_type is TYPE_UNSPECIFIED. 4. Request method is POST and a "Content-Type" header is provided via headers field. The content_type field should be used instead.
func (o HttpCheckPtrOutput) ContentType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *string {
		if v == nil {
			return nil
		}
		return v.ContentType
	}).(pulumi.StringPtrOutput)
}

// The list of headers to send as part of the Uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
func (o HttpCheckPtrOutput) Headers() pulumi.StringMapOutput {
	return o.ApplyT(func(v *HttpCheck) map[string]string {
		if v == nil {
			return nil
		}
		return v.Headers
	}).(pulumi.StringMapOutput)
}

// Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if mask_headers is set to true then the headers will be obscured with ******.
func (o HttpCheckPtrOutput) MaskHeaders() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *bool {
		if v == nil {
			return nil
		}
		return v.MaskHeaders
	}).(pulumi.BoolPtrOutput)
}

// Optional (defaults to "/"). The path to the page against which to run the check. Will be combined with the host (specified within the monitored_resource) and port to construct the full URL. If the provided path does not begin with "/", a "/" will be prepended automatically.
func (o HttpCheckPtrOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *string {
		if v == nil {
			return nil
		}
		return v.Path
	}).(pulumi.StringPtrOutput)
}

// Optional (defaults to 80 when use_ssl is false, and 443 when use_ssl is true). The TCP port on the HTTP server against which to run the check. Will be combined with host (specified within the monitored_resource) and path to construct the full URL.
func (o HttpCheckPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED then request_method defaults to GET.
func (o HttpCheckPtrOutput) RequestMethod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *string {
		if v == nil {
			return nil
		}
		return v.RequestMethod
	}).(pulumi.StringPtrOutput)
}

// If true, use HTTPS instead of HTTP to run the check.
func (o HttpCheckPtrOutput) UseSsl() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *bool {
		if v == nil {
			return nil
		}
		return v.UseSsl
	}).(pulumi.BoolPtrOutput)
}

// Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitored_resource is set to uptime_url. If use_ssl is false, setting validate_ssl to true has no effect.
func (o HttpCheckPtrOutput) ValidateSsl() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *HttpCheck) *bool {
		if v == nil {
			return nil
		}
		return v.ValidateSsl
	}).(pulumi.BoolPtrOutput)
}

// An internal checker allows Uptime checks to run on private/internal GCP resources.
type InternalChecker struct {
	// The checker's human-readable name. The display name should be unique within a Stackdriver Workspace in order to make it easier to identify; however, uniqueness is not enforced.
	DisplayName *string `pulumi:"displayName"`
	// The GCP zone the Uptime check should egress from. Only respected for internal Uptime checks, where internal_network is specified.
	GcpZone *string `pulumi:"gcpZone"`
	// A unique resource name for this InternalChecker. The format is: projects/[PROJECT_ID_OR_NUMBER]/internalCheckers/[INTERNAL_CHECKER_ID] [PROJECT_ID_OR_NUMBER] is the Stackdriver Workspace project for the Uptime check config associated with the internal checker.
	Name *string `pulumi:"name"`
	// The GCP VPC network (https://cloud.google.com/vpc/docs/vpc) where the internal resource lives (ex: "default").
	Network *string `pulumi:"network"`
	// The GCP project ID where the internal checker lives. Not necessary the same as the Workspace project.
	PeerProjectId *string `pulumi:"peerProjectId"`
	// The current operational state of the internal checker.
	State *string `pulumi:"state"`
}

// InternalCheckerInput is an input type that accepts InternalCheckerArgs and InternalCheckerOutput values.
// You can construct a concrete instance of `InternalCheckerInput` via:
//
//          InternalCheckerArgs{...}
type InternalCheckerInput interface {
	pulumi.Input

	ToInternalCheckerOutput() InternalCheckerOutput
	ToInternalCheckerOutputWithContext(context.Context) InternalCheckerOutput
}

// An internal checker allows Uptime checks to run on private/internal GCP resources.
type InternalCheckerArgs struct {
	// The checker's human-readable name. The display name should be unique within a Stackdriver Workspace in order to make it easier to identify; however, uniqueness is not enforced.
	DisplayName pulumi.StringPtrInput `pulumi:"displayName"`
	// The GCP zone the Uptime check should egress from. Only respected for internal Uptime checks, where internal_network is specified.
	GcpZone pulumi.StringPtrInput `pulumi:"gcpZone"`
	// A unique resource name for this InternalChecker. The format is: projects/[PROJECT_ID_OR_NUMBER]/internalCheckers/[INTERNAL_CHECKER_ID] [PROJECT_ID_OR_NUMBER] is the Stackdriver Workspace project for the Uptime check config associated with the internal checker.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// The GCP VPC network (https://cloud.google.com/vpc/docs/vpc) where the internal resource lives (ex: "default").
	Network pulumi.StringPtrInput `pulumi:"network"`
	// The GCP project ID where the internal checker lives. Not necessary the same as the Workspace project.
	PeerProjectId pulumi.StringPtrInput `pulumi:"peerProjectId"`
	// The current operational state of the internal checker.
	State pulumi.StringPtrInput `pulumi:"state"`
}

func (InternalCheckerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InternalChecker)(nil)).Elem()
}

func (i InternalCheckerArgs) ToInternalCheckerOutput() InternalCheckerOutput {
	return i.ToInternalCheckerOutputWithContext(context.Background())
}

func (i InternalCheckerArgs) ToInternalCheckerOutputWithContext(ctx context.Context) InternalCheckerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InternalCheckerOutput)
}

// InternalCheckerArrayInput is an input type that accepts InternalCheckerArray and InternalCheckerArrayOutput values.
// You can construct a concrete instance of `InternalCheckerArrayInput` via:
//
//          InternalCheckerArray{ InternalCheckerArgs{...} }
type InternalCheckerArrayInput interface {
	pulumi.Input

	ToInternalCheckerArrayOutput() InternalCheckerArrayOutput
	ToInternalCheckerArrayOutputWithContext(context.Context) InternalCheckerArrayOutput
}

type InternalCheckerArray []InternalCheckerInput

func (InternalCheckerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InternalChecker)(nil)).Elem()
}

func (i InternalCheckerArray) ToInternalCheckerArrayOutput() InternalCheckerArrayOutput {
	return i.ToInternalCheckerArrayOutputWithContext(context.Background())
}

func (i InternalCheckerArray) ToInternalCheckerArrayOutputWithContext(ctx context.Context) InternalCheckerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InternalCheckerArrayOutput)
}

// An internal checker allows Uptime checks to run on private/internal GCP resources.
type InternalCheckerOutput struct{ *pulumi.OutputState }

func (InternalCheckerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InternalChecker)(nil)).Elem()
}

func (o InternalCheckerOutput) ToInternalCheckerOutput() InternalCheckerOutput {
	return o
}

func (o InternalCheckerOutput) ToInternalCheckerOutputWithContext(ctx context.Context) InternalCheckerOutput {
	return o
}

// The checker's human-readable name. The display name should be unique within a Stackdriver Workspace in order to make it easier to identify; however, uniqueness is not enforced.
func (o InternalCheckerOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InternalChecker) *string { return v.DisplayName }).(pulumi.StringPtrOutput)
}

// The GCP zone the Uptime check should egress from. Only respected for internal Uptime checks, where internal_network is specified.
func (o InternalCheckerOutput) GcpZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InternalChecker) *string { return v.GcpZone }).(pulumi.StringPtrOutput)
}

// A unique resource name for this InternalChecker. The format is: projects/[PROJECT_ID_OR_NUMBER]/internalCheckers/[INTERNAL_CHECKER_ID] [PROJECT_ID_OR_NUMBER] is the Stackdriver Workspace project for the Uptime check config associated with the internal checker.
func (o InternalCheckerOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InternalChecker) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// The GCP VPC network (https://cloud.google.com/vpc/docs/vpc) where the internal resource lives (ex: "default").
func (o InternalCheckerOutput) Network() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InternalChecker) *string { return v.Network }).(pulumi.StringPtrOutput)
}

// The GCP project ID where the internal checker lives. Not necessary the same as the Workspace project.
func (o InternalCheckerOutput) PeerProjectId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InternalChecker) *string { return v.PeerProjectId }).(pulumi.StringPtrOutput)
}

// The current operational state of the internal checker.
func (o InternalCheckerOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InternalChecker) *string { return v.State }).(pulumi.StringPtrOutput)
}

type InternalCheckerArrayOutput struct{ *pulumi.OutputState }

func (InternalCheckerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InternalChecker)(nil)).Elem()
}

func (o InternalCheckerArrayOutput) ToInternalCheckerArrayOutput() InternalCheckerArrayOutput {
	return o
}

func (o InternalCheckerArrayOutput) ToInternalCheckerArrayOutputWithContext(ctx context.Context) InternalCheckerArrayOutput {
	return o
}

func (o InternalCheckerArrayOutput) Index(i pulumi.IntInput) InternalCheckerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) InternalChecker {
		return vs[0].([]InternalChecker)[vs[1].(int)]
	}).(InternalCheckerOutput)
}

// A description of a label.
type LabelDescriptor struct {
	// A human-readable description for the label.
	Description *string `pulumi:"description"`
	// The key for this label. The key must meet the following criteria: Does not exceed 100 characters. Matches the following regular expression: [a-zA-Z][a-zA-Z0-9_]* The first character must be an upper- or lower-case letter. The remaining characters must be letters, digits, or underscores.
	Key *string `pulumi:"key"`
	// The type of data that can be assigned to the label.
	ValueType *string `pulumi:"valueType"`
}

// LabelDescriptorInput is an input type that accepts LabelDescriptorArgs and LabelDescriptorOutput values.
// You can construct a concrete instance of `LabelDescriptorInput` via:
//
//          LabelDescriptorArgs{...}
type LabelDescriptorInput interface {
	pulumi.Input

	ToLabelDescriptorOutput() LabelDescriptorOutput
	ToLabelDescriptorOutputWithContext(context.Context) LabelDescriptorOutput
}

// A description of a label.
type LabelDescriptorArgs struct {
	// A human-readable description for the label.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// The key for this label. The key must meet the following criteria: Does not exceed 100 characters. Matches the following regular expression: [a-zA-Z][a-zA-Z0-9_]* The first character must be an upper- or lower-case letter. The remaining characters must be letters, digits, or underscores.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// The type of data that can be assigned to the label.
	ValueType pulumi.StringPtrInput `pulumi:"valueType"`
}

func (LabelDescriptorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LabelDescriptor)(nil)).Elem()
}

func (i LabelDescriptorArgs) ToLabelDescriptorOutput() LabelDescriptorOutput {
	return i.ToLabelDescriptorOutputWithContext(context.Background())
}

func (i LabelDescriptorArgs) ToLabelDescriptorOutputWithContext(ctx context.Context) LabelDescriptorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LabelDescriptorOutput)
}

// LabelDescriptorArrayInput is an input type that accepts LabelDescriptorArray and LabelDescriptorArrayOutput values.
// You can construct a concrete instance of `LabelDescriptorArrayInput` via:
//
//          LabelDescriptorArray{ LabelDescriptorArgs{...} }
type LabelDescriptorArrayInput interface {
	pulumi.Input

	ToLabelDescriptorArrayOutput() LabelDescriptorArrayOutput
	ToLabelDescriptorArrayOutputWithContext(context.Context) LabelDescriptorArrayOutput
}

type LabelDescriptorArray []LabelDescriptorInput

func (LabelDescriptorArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LabelDescriptor)(nil)).Elem()
}

func (i LabelDescriptorArray) ToLabelDescriptorArrayOutput() LabelDescriptorArrayOutput {
	return i.ToLabelDescriptorArrayOutputWithContext(context.Background())
}

func (i LabelDescriptorArray) ToLabelDescriptorArrayOutputWithContext(ctx context.Context) LabelDescriptorArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LabelDescriptorArrayOutput)
}

// A description of a label.
type LabelDescriptorOutput struct{ *pulumi.OutputState }

func (LabelDescriptorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LabelDescriptor)(nil)).Elem()
}

func (o LabelDescriptorOutput) ToLabelDescriptorOutput() LabelDescriptorOutput {
	return o
}

func (o LabelDescriptorOutput) ToLabelDescriptorOutputWithContext(ctx context.Context) LabelDescriptorOutput {
	return o
}

// A human-readable description for the label.
func (o LabelDescriptorOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelDescriptor) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// The key for this label. The key must meet the following criteria: Does not exceed 100 characters. Matches the following regular expression: [a-zA-Z][a-zA-Z0-9_]* The first character must be an upper- or lower-case letter. The remaining characters must be letters, digits, or underscores.
func (o LabelDescriptorOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelDescriptor) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// The type of data that can be assigned to the label.
func (o LabelDescriptorOutput) ValueType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LabelDescriptor) *string { return v.ValueType }).(pulumi.StringPtrOutput)
}

type LabelDescriptorArrayOutput struct{ *pulumi.OutputState }

func (LabelDescriptorArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LabelDescriptor)(nil)).Elem()
}

func (o LabelDescriptorArrayOutput) ToLabelDescriptorArrayOutput() LabelDescriptorArrayOutput {
	return o
}

func (o LabelDescriptorArrayOutput) ToLabelDescriptorArrayOutputWithContext(ctx context.Context) LabelDescriptorArrayOutput {
	return o
}

func (o LabelDescriptorArrayOutput) Index(i pulumi.IntInput) LabelDescriptorOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LabelDescriptor {
		return vs[0].([]LabelDescriptor)[vs[1].(int)]
	}).(LabelDescriptorOutput)
}

// Parameters for a latency threshold SLI.
type LatencyCriteria struct {
	// Good service is defined to be the count of requests made to this service that return in no more than threshold.
	Threshold *string `pulumi:"threshold"`
}

// LatencyCriteriaInput is an input type that accepts LatencyCriteriaArgs and LatencyCriteriaOutput values.
// You can construct a concrete instance of `LatencyCriteriaInput` via:
//
//          LatencyCriteriaArgs{...}
type LatencyCriteriaInput interface {
	pulumi.Input

	ToLatencyCriteriaOutput() LatencyCriteriaOutput
	ToLatencyCriteriaOutputWithContext(context.Context) LatencyCriteriaOutput
}

// Parameters for a latency threshold SLI.
type LatencyCriteriaArgs struct {
	// Good service is defined to be the count of requests made to this service that return in no more than threshold.
	Threshold pulumi.StringPtrInput `pulumi:"threshold"`
}

func (LatencyCriteriaArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LatencyCriteria)(nil)).Elem()
}

func (i LatencyCriteriaArgs) ToLatencyCriteriaOutput() LatencyCriteriaOutput {
	return i.ToLatencyCriteriaOutputWithContext(context.Background())
}

func (i LatencyCriteriaArgs) ToLatencyCriteriaOutputWithContext(ctx context.Context) LatencyCriteriaOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LatencyCriteriaOutput)
}

func (i LatencyCriteriaArgs) ToLatencyCriteriaPtrOutput() LatencyCriteriaPtrOutput {
	return i.ToLatencyCriteriaPtrOutputWithContext(context.Background())
}

func (i LatencyCriteriaArgs) ToLatencyCriteriaPtrOutputWithContext(ctx context.Context) LatencyCriteriaPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LatencyCriteriaOutput).ToLatencyCriteriaPtrOutputWithContext(ctx)
}

// LatencyCriteriaPtrInput is an input type that accepts LatencyCriteriaArgs, LatencyCriteriaPtr and LatencyCriteriaPtrOutput values.
// You can construct a concrete instance of `LatencyCriteriaPtrInput` via:
//
//          LatencyCriteriaArgs{...}
//
//  or:
//
//          nil
type LatencyCriteriaPtrInput interface {
	pulumi.Input

	ToLatencyCriteriaPtrOutput() LatencyCriteriaPtrOutput
	ToLatencyCriteriaPtrOutputWithContext(context.Context) LatencyCriteriaPtrOutput
}

type latencyCriteriaPtrType LatencyCriteriaArgs

func LatencyCriteriaPtr(v *LatencyCriteriaArgs) LatencyCriteriaPtrInput {
	return (*latencyCriteriaPtrType)(v)
}

func (*latencyCriteriaPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LatencyCriteria)(nil)).Elem()
}

func (i *latencyCriteriaPtrType) ToLatencyCriteriaPtrOutput() LatencyCriteriaPtrOutput {
	return i.ToLatencyCriteriaPtrOutputWithContext(context.Background())
}

func (i *latencyCriteriaPtrType) ToLatencyCriteriaPtrOutputWithContext(ctx context.Context) LatencyCriteriaPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LatencyCriteriaPtrOutput)
}

// Parameters for a latency threshold SLI.
type LatencyCriteriaOutput struct{ *pulumi.OutputState }

func (LatencyCriteriaOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LatencyCriteria)(nil)).Elem()
}

func (o LatencyCriteriaOutput) ToLatencyCriteriaOutput() LatencyCriteriaOutput {
	return o
}

func (o LatencyCriteriaOutput) ToLatencyCriteriaOutputWithContext(ctx context.Context) LatencyCriteriaOutput {
	return o
}

func (o LatencyCriteriaOutput) ToLatencyCriteriaPtrOutput() LatencyCriteriaPtrOutput {
	return o.ToLatencyCriteriaPtrOutputWithContext(context.Background())
}

func (o LatencyCriteriaOutput) ToLatencyCriteriaPtrOutputWithContext(ctx context.Context) LatencyCriteriaPtrOutput {
	return o.ApplyT(func(v LatencyCriteria) *LatencyCriteria {
		return &v
	}).(LatencyCriteriaPtrOutput)
}

// Good service is defined to be the count of requests made to this service that return in no more than threshold.
func (o LatencyCriteriaOutput) Threshold() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LatencyCriteria) *string { return v.Threshold }).(pulumi.StringPtrOutput)
}

type LatencyCriteriaPtrOutput struct{ *pulumi.OutputState }

func (LatencyCriteriaPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LatencyCriteria)(nil)).Elem()
}

func (o LatencyCriteriaPtrOutput) ToLatencyCriteriaPtrOutput() LatencyCriteriaPtrOutput {
	return o
}

func (o LatencyCriteriaPtrOutput) ToLatencyCriteriaPtrOutputWithContext(ctx context.Context) LatencyCriteriaPtrOutput {
	return o
}

func (o LatencyCriteriaPtrOutput) Elem() LatencyCriteriaOutput {
	return o.ApplyT(func(v *LatencyCriteria) LatencyCriteria { return *v }).(LatencyCriteriaOutput)
}

// Good service is defined to be the count of requests made to this service that return in no more than threshold.
func (o LatencyCriteriaPtrOutput) Threshold() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LatencyCriteria) *string {
		if v == nil {
			return nil
		}
		return v.Threshold
	}).(pulumi.StringPtrOutput)
}

// Specifies a linear sequence of buckets that all have the same width (except overflow and underflow). Each bucket represents a constant absolute uncertainty on the specific value in the bucket.There are num_finite_buckets + 2 (= N) buckets. Bucket i has the following boundaries:Upper bound (0 <= i < N-1): offset + (width * i). Lower bound (1 <= i < N): offset + (width * (i - 1)).
type Linear struct {
	// Must be greater than 0.
	NumFiniteBuckets *int `pulumi:"numFiniteBuckets"`
	// Lower bound of the first bucket.
	Offset *float64 `pulumi:"offset"`
	// Must be greater than 0.
	Width *float64 `pulumi:"width"`
}

// LinearInput is an input type that accepts LinearArgs and LinearOutput values.
// You can construct a concrete instance of `LinearInput` via:
//
//          LinearArgs{...}
type LinearInput interface {
	pulumi.Input

	ToLinearOutput() LinearOutput
	ToLinearOutputWithContext(context.Context) LinearOutput
}

// Specifies a linear sequence of buckets that all have the same width (except overflow and underflow). Each bucket represents a constant absolute uncertainty on the specific value in the bucket.There are num_finite_buckets + 2 (= N) buckets. Bucket i has the following boundaries:Upper bound (0 <= i < N-1): offset + (width * i). Lower bound (1 <= i < N): offset + (width * (i - 1)).
type LinearArgs struct {
	// Must be greater than 0.
	NumFiniteBuckets pulumi.IntPtrInput `pulumi:"numFiniteBuckets"`
	// Lower bound of the first bucket.
	Offset pulumi.Float64PtrInput `pulumi:"offset"`
	// Must be greater than 0.
	Width pulumi.Float64PtrInput `pulumi:"width"`
}

func (LinearArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Linear)(nil)).Elem()
}

func (i LinearArgs) ToLinearOutput() LinearOutput {
	return i.ToLinearOutputWithContext(context.Background())
}

func (i LinearArgs) ToLinearOutputWithContext(ctx context.Context) LinearOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LinearOutput)
}

func (i LinearArgs) ToLinearPtrOutput() LinearPtrOutput {
	return i.ToLinearPtrOutputWithContext(context.Background())
}

func (i LinearArgs) ToLinearPtrOutputWithContext(ctx context.Context) LinearPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LinearOutput).ToLinearPtrOutputWithContext(ctx)
}

// LinearPtrInput is an input type that accepts LinearArgs, LinearPtr and LinearPtrOutput values.
// You can construct a concrete instance of `LinearPtrInput` via:
//
//          LinearArgs{...}
//
//  or:
//
//          nil
type LinearPtrInput interface {
	pulumi.Input

	ToLinearPtrOutput() LinearPtrOutput
	ToLinearPtrOutputWithContext(context.Context) LinearPtrOutput
}

type linearPtrType LinearArgs

func LinearPtr(v *LinearArgs) LinearPtrInput {
	return (*linearPtrType)(v)
}

func (*linearPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Linear)(nil)).Elem()
}

func (i *linearPtrType) ToLinearPtrOutput() LinearPtrOutput {
	return i.ToLinearPtrOutputWithContext(context.Background())
}

func (i *linearPtrType) ToLinearPtrOutputWithContext(ctx context.Context) LinearPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LinearPtrOutput)
}

// Specifies a linear sequence of buckets that all have the same width (except overflow and underflow). Each bucket represents a constant absolute uncertainty on the specific value in the bucket.There are num_finite_buckets + 2 (= N) buckets. Bucket i has the following boundaries:Upper bound (0 <= i < N-1): offset + (width * i). Lower bound (1 <= i < N): offset + (width * (i - 1)).
type LinearOutput struct{ *pulumi.OutputState }

func (LinearOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Linear)(nil)).Elem()
}

func (o LinearOutput) ToLinearOutput() LinearOutput {
	return o
}

func (o LinearOutput) ToLinearOutputWithContext(ctx context.Context) LinearOutput {
	return o
}

func (o LinearOutput) ToLinearPtrOutput() LinearPtrOutput {
	return o.ToLinearPtrOutputWithContext(context.Background())
}

func (o LinearOutput) ToLinearPtrOutputWithContext(ctx context.Context) LinearPtrOutput {
	return o.ApplyT(func(v Linear) *Linear {
		return &v
	}).(LinearPtrOutput)
}

// Must be greater than 0.
func (o LinearOutput) NumFiniteBuckets() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Linear) *int { return v.NumFiniteBuckets }).(pulumi.IntPtrOutput)
}

// Lower bound of the first bucket.
func (o LinearOutput) Offset() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Linear) *float64 { return v.Offset }).(pulumi.Float64PtrOutput)
}

// Must be greater than 0.
func (o LinearOutput) Width() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Linear) *float64 { return v.Width }).(pulumi.Float64PtrOutput)
}

type LinearPtrOutput struct{ *pulumi.OutputState }

func (LinearPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Linear)(nil)).Elem()
}

func (o LinearPtrOutput) ToLinearPtrOutput() LinearPtrOutput {
	return o
}

func (o LinearPtrOutput) ToLinearPtrOutputWithContext(ctx context.Context) LinearPtrOutput {
	return o
}

func (o LinearPtrOutput) Elem() LinearOutput {
	return o.ApplyT(func(v *Linear) Linear { return *v }).(LinearOutput)
}

// Must be greater than 0.
func (o LinearPtrOutput) NumFiniteBuckets() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Linear) *int {
		if v == nil {
			return nil
		}
		return v.NumFiniteBuckets
	}).(pulumi.IntPtrOutput)
}

// Lower bound of the first bucket.
func (o LinearPtrOutput) Offset() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *Linear) *float64 {
		if v == nil {
			return nil
		}
		return v.Offset
	}).(pulumi.Float64PtrOutput)
}

// Must be greater than 0.
func (o LinearPtrOutput) Width() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *Linear) *float64 {
		if v == nil {
			return nil
		}
		return v.Width
	}).(pulumi.Float64PtrOutput)
}

// Istio service scoped to an Istio mesh. Anthos clusters running ASM < 1.6.8 will have their services ingested as this type.
type MeshIstio struct {
	// Identifier for the mesh in which this Istio service is defined. Corresponds to the mesh_uid metric label in Istio metrics.
	MeshUid *string `pulumi:"meshUid"`
	// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
	ServiceName *string `pulumi:"serviceName"`
	// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
	ServiceNamespace *string `pulumi:"serviceNamespace"`
}

// MeshIstioInput is an input type that accepts MeshIstioArgs and MeshIstioOutput values.
// You can construct a concrete instance of `MeshIstioInput` via:
//
//          MeshIstioArgs{...}
type MeshIstioInput interface {
	pulumi.Input

	ToMeshIstioOutput() MeshIstioOutput
	ToMeshIstioOutputWithContext(context.Context) MeshIstioOutput
}

// Istio service scoped to an Istio mesh. Anthos clusters running ASM < 1.6.8 will have their services ingested as this type.
type MeshIstioArgs struct {
	// Identifier for the mesh in which this Istio service is defined. Corresponds to the mesh_uid metric label in Istio metrics.
	MeshUid pulumi.StringPtrInput `pulumi:"meshUid"`
	// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
	ServiceName pulumi.StringPtrInput `pulumi:"serviceName"`
	// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
	ServiceNamespace pulumi.StringPtrInput `pulumi:"serviceNamespace"`
}

func (MeshIstioArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MeshIstio)(nil)).Elem()
}

func (i MeshIstioArgs) ToMeshIstioOutput() MeshIstioOutput {
	return i.ToMeshIstioOutputWithContext(context.Background())
}

func (i MeshIstioArgs) ToMeshIstioOutputWithContext(ctx context.Context) MeshIstioOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeshIstioOutput)
}

func (i MeshIstioArgs) ToMeshIstioPtrOutput() MeshIstioPtrOutput {
	return i.ToMeshIstioPtrOutputWithContext(context.Background())
}

func (i MeshIstioArgs) ToMeshIstioPtrOutputWithContext(ctx context.Context) MeshIstioPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeshIstioOutput).ToMeshIstioPtrOutputWithContext(ctx)
}

// MeshIstioPtrInput is an input type that accepts MeshIstioArgs, MeshIstioPtr and MeshIstioPtrOutput values.
// You can construct a concrete instance of `MeshIstioPtrInput` via:
//
//          MeshIstioArgs{...}
//
//  or:
//
//          nil
type MeshIstioPtrInput interface {
	pulumi.Input

	ToMeshIstioPtrOutput() MeshIstioPtrOutput
	ToMeshIstioPtrOutputWithContext(context.Context) MeshIstioPtrOutput
}

type meshIstioPtrType MeshIstioArgs

func MeshIstioPtr(v *MeshIstioArgs) MeshIstioPtrInput {
	return (*meshIstioPtrType)(v)
}

func (*meshIstioPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MeshIstio)(nil)).Elem()
}

func (i *meshIstioPtrType) ToMeshIstioPtrOutput() MeshIstioPtrOutput {
	return i.ToMeshIstioPtrOutputWithContext(context.Background())
}

func (i *meshIstioPtrType) ToMeshIstioPtrOutputWithContext(ctx context.Context) MeshIstioPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeshIstioPtrOutput)
}

// Istio service scoped to an Istio mesh. Anthos clusters running ASM < 1.6.8 will have their services ingested as this type.
type MeshIstioOutput struct{ *pulumi.OutputState }

func (MeshIstioOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MeshIstio)(nil)).Elem()
}

func (o MeshIstioOutput) ToMeshIstioOutput() MeshIstioOutput {
	return o
}

func (o MeshIstioOutput) ToMeshIstioOutputWithContext(ctx context.Context) MeshIstioOutput {
	return o
}

func (o MeshIstioOutput) ToMeshIstioPtrOutput() MeshIstioPtrOutput {
	return o.ToMeshIstioPtrOutputWithContext(context.Background())
}

func (o MeshIstioOutput) ToMeshIstioPtrOutputWithContext(ctx context.Context) MeshIstioPtrOutput {
	return o.ApplyT(func(v MeshIstio) *MeshIstio {
		return &v
	}).(MeshIstioPtrOutput)
}

// Identifier for the mesh in which this Istio service is defined. Corresponds to the mesh_uid metric label in Istio metrics.
func (o MeshIstioOutput) MeshUid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MeshIstio) *string { return v.MeshUid }).(pulumi.StringPtrOutput)
}

// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
func (o MeshIstioOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MeshIstio) *string { return v.ServiceName }).(pulumi.StringPtrOutput)
}

// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
func (o MeshIstioOutput) ServiceNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MeshIstio) *string { return v.ServiceNamespace }).(pulumi.StringPtrOutput)
}

type MeshIstioPtrOutput struct{ *pulumi.OutputState }

func (MeshIstioPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MeshIstio)(nil)).Elem()
}

func (o MeshIstioPtrOutput) ToMeshIstioPtrOutput() MeshIstioPtrOutput {
	return o
}

func (o MeshIstioPtrOutput) ToMeshIstioPtrOutputWithContext(ctx context.Context) MeshIstioPtrOutput {
	return o
}

func (o MeshIstioPtrOutput) Elem() MeshIstioOutput {
	return o.ApplyT(func(v *MeshIstio) MeshIstio { return *v }).(MeshIstioOutput)
}

// Identifier for the mesh in which this Istio service is defined. Corresponds to the mesh_uid metric label in Istio metrics.
func (o MeshIstioPtrOutput) MeshUid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MeshIstio) *string {
		if v == nil {
			return nil
		}
		return v.MeshUid
	}).(pulumi.StringPtrOutput)
}

// The name of the Istio service underlying this service. Corresponds to the destination_service_name metric label in Istio metrics.
func (o MeshIstioPtrOutput) ServiceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MeshIstio) *string {
		if v == nil {
			return nil
		}
		return v.ServiceName
	}).(pulumi.StringPtrOutput)
}

// The namespace of the Istio service underlying this service. Corresponds to the destination_service_namespace metric label in Istio metrics.
func (o MeshIstioPtrOutput) ServiceNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MeshIstio) *string {
		if v == nil {
			return nil
		}
		return v.ServiceNamespace
	}).(pulumi.StringPtrOutput)
}

// A specific metric, identified by specifying values for all of the labels of a MetricDescriptor.
type Metric struct {
	// The set of label values that uniquely identify this metric. All labels listed in the MetricDescriptor must be assigned values.
	Labels map[string]string `pulumi:"labels"`
	// An existing metric type, see google.api.MetricDescriptor. For example, custom.googleapis.com/invoice/paid/amount.
	Type *string `pulumi:"type"`
}

// MetricInput is an input type that accepts MetricArgs and MetricOutput values.
// You can construct a concrete instance of `MetricInput` via:
//
//          MetricArgs{...}
type MetricInput interface {
	pulumi.Input

	ToMetricOutput() MetricOutput
	ToMetricOutputWithContext(context.Context) MetricOutput
}

// A specific metric, identified by specifying values for all of the labels of a MetricDescriptor.
type MetricArgs struct {
	// The set of label values that uniquely identify this metric. All labels listed in the MetricDescriptor must be assigned values.
	Labels pulumi.StringMapInput `pulumi:"labels"`
	// An existing metric type, see google.api.MetricDescriptor. For example, custom.googleapis.com/invoice/paid/amount.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (MetricArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Metric)(nil)).Elem()
}

func (i MetricArgs) ToMetricOutput() MetricOutput {
	return i.ToMetricOutputWithContext(context.Background())
}

func (i MetricArgs) ToMetricOutputWithContext(ctx context.Context) MetricOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricOutput)
}

func (i MetricArgs) ToMetricPtrOutput() MetricPtrOutput {
	return i.ToMetricPtrOutputWithContext(context.Background())
}

func (i MetricArgs) ToMetricPtrOutputWithContext(ctx context.Context) MetricPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricOutput).ToMetricPtrOutputWithContext(ctx)
}

// MetricPtrInput is an input type that accepts MetricArgs, MetricPtr and MetricPtrOutput values.
// You can construct a concrete instance of `MetricPtrInput` via:
//
//          MetricArgs{...}
//
//  or:
//
//          nil
type MetricPtrInput interface {
	pulumi.Input

	ToMetricPtrOutput() MetricPtrOutput
	ToMetricPtrOutputWithContext(context.Context) MetricPtrOutput
}

type metricPtrType MetricArgs

func MetricPtr(v *MetricArgs) MetricPtrInput {
	return (*metricPtrType)(v)
}

func (*metricPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Metric)(nil)).Elem()
}

func (i *metricPtrType) ToMetricPtrOutput() MetricPtrOutput {
	return i.ToMetricPtrOutputWithContext(context.Background())
}

func (i *metricPtrType) ToMetricPtrOutputWithContext(ctx context.Context) MetricPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricPtrOutput)
}

// A specific metric, identified by specifying values for all of the labels of a MetricDescriptor.
type MetricOutput struct{ *pulumi.OutputState }

func (MetricOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Metric)(nil)).Elem()
}

func (o MetricOutput) ToMetricOutput() MetricOutput {
	return o
}

func (o MetricOutput) ToMetricOutputWithContext(ctx context.Context) MetricOutput {
	return o
}

func (o MetricOutput) ToMetricPtrOutput() MetricPtrOutput {
	return o.ToMetricPtrOutputWithContext(context.Background())
}

func (o MetricOutput) ToMetricPtrOutputWithContext(ctx context.Context) MetricPtrOutput {
	return o.ApplyT(func(v Metric) *Metric {
		return &v
	}).(MetricPtrOutput)
}

// The set of label values that uniquely identify this metric. All labels listed in the MetricDescriptor must be assigned values.
func (o MetricOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v Metric) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// An existing metric type, see google.api.MetricDescriptor. For example, custom.googleapis.com/invoice/paid/amount.
func (o MetricOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Metric) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type MetricPtrOutput struct{ *pulumi.OutputState }

func (MetricPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Metric)(nil)).Elem()
}

func (o MetricPtrOutput) ToMetricPtrOutput() MetricPtrOutput {
	return o
}

func (o MetricPtrOutput) ToMetricPtrOutputWithContext(ctx context.Context) MetricPtrOutput {
	return o
}

func (o MetricPtrOutput) Elem() MetricOutput {
	return o.ApplyT(func(v *Metric) Metric { return *v }).(MetricOutput)
}

// The set of label values that uniquely identify this metric. All labels listed in the MetricDescriptor must be assigned values.
func (o MetricPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Metric) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// An existing metric type, see google.api.MetricDescriptor. For example, custom.googleapis.com/invoice/paid/amount.
func (o MetricPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Metric) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// A condition type that checks that monitored resources are reporting data. The configuration defines a metric and a set of monitored resources. The predicate is considered in violation when a time series for the specified metric of a monitored resource does not include any data in the specified duration.
type MetricAbsence struct {
	// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resrouces). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
	Aggregations []Aggregation `pulumi:"aggregations"`
	// The amount of time that a time series must fail to report new data to be considered failing. Currently, only values that are a multiple of a minute--e.g. 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. The Duration.nanos field is ignored.
	Duration *string `pulumi:"duration"`
	// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
	Filter *string `pulumi:"filter"`
	// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations.
	Trigger *Trigger `pulumi:"trigger"`
}

// MetricAbsenceInput is an input type that accepts MetricAbsenceArgs and MetricAbsenceOutput values.
// You can construct a concrete instance of `MetricAbsenceInput` via:
//
//          MetricAbsenceArgs{...}
type MetricAbsenceInput interface {
	pulumi.Input

	ToMetricAbsenceOutput() MetricAbsenceOutput
	ToMetricAbsenceOutputWithContext(context.Context) MetricAbsenceOutput
}

// A condition type that checks that monitored resources are reporting data. The configuration defines a metric and a set of monitored resources. The predicate is considered in violation when a time series for the specified metric of a monitored resource does not include any data in the specified duration.
type MetricAbsenceArgs struct {
	// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resrouces). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
	Aggregations AggregationArrayInput `pulumi:"aggregations"`
	// The amount of time that a time series must fail to report new data to be considered failing. Currently, only values that are a multiple of a minute--e.g. 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. The Duration.nanos field is ignored.
	Duration pulumi.StringPtrInput `pulumi:"duration"`
	// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
	Filter pulumi.StringPtrInput `pulumi:"filter"`
	// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations.
	Trigger TriggerPtrInput `pulumi:"trigger"`
}

func (MetricAbsenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricAbsence)(nil)).Elem()
}

func (i MetricAbsenceArgs) ToMetricAbsenceOutput() MetricAbsenceOutput {
	return i.ToMetricAbsenceOutputWithContext(context.Background())
}

func (i MetricAbsenceArgs) ToMetricAbsenceOutputWithContext(ctx context.Context) MetricAbsenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricAbsenceOutput)
}

func (i MetricAbsenceArgs) ToMetricAbsencePtrOutput() MetricAbsencePtrOutput {
	return i.ToMetricAbsencePtrOutputWithContext(context.Background())
}

func (i MetricAbsenceArgs) ToMetricAbsencePtrOutputWithContext(ctx context.Context) MetricAbsencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricAbsenceOutput).ToMetricAbsencePtrOutputWithContext(ctx)
}

// MetricAbsencePtrInput is an input type that accepts MetricAbsenceArgs, MetricAbsencePtr and MetricAbsencePtrOutput values.
// You can construct a concrete instance of `MetricAbsencePtrInput` via:
//
//          MetricAbsenceArgs{...}
//
//  or:
//
//          nil
type MetricAbsencePtrInput interface {
	pulumi.Input

	ToMetricAbsencePtrOutput() MetricAbsencePtrOutput
	ToMetricAbsencePtrOutputWithContext(context.Context) MetricAbsencePtrOutput
}

type metricAbsencePtrType MetricAbsenceArgs

func MetricAbsencePtr(v *MetricAbsenceArgs) MetricAbsencePtrInput {
	return (*metricAbsencePtrType)(v)
}

func (*metricAbsencePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricAbsence)(nil)).Elem()
}

func (i *metricAbsencePtrType) ToMetricAbsencePtrOutput() MetricAbsencePtrOutput {
	return i.ToMetricAbsencePtrOutputWithContext(context.Background())
}

func (i *metricAbsencePtrType) ToMetricAbsencePtrOutputWithContext(ctx context.Context) MetricAbsencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricAbsencePtrOutput)
}

// A condition type that checks that monitored resources are reporting data. The configuration defines a metric and a set of monitored resources. The predicate is considered in violation when a time series for the specified metric of a monitored resource does not include any data in the specified duration.
type MetricAbsenceOutput struct{ *pulumi.OutputState }

func (MetricAbsenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricAbsence)(nil)).Elem()
}

func (o MetricAbsenceOutput) ToMetricAbsenceOutput() MetricAbsenceOutput {
	return o
}

func (o MetricAbsenceOutput) ToMetricAbsenceOutputWithContext(ctx context.Context) MetricAbsenceOutput {
	return o
}

func (o MetricAbsenceOutput) ToMetricAbsencePtrOutput() MetricAbsencePtrOutput {
	return o.ToMetricAbsencePtrOutputWithContext(context.Background())
}

func (o MetricAbsenceOutput) ToMetricAbsencePtrOutputWithContext(ctx context.Context) MetricAbsencePtrOutput {
	return o.ApplyT(func(v MetricAbsence) *MetricAbsence {
		return &v
	}).(MetricAbsencePtrOutput)
}

// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resrouces). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
func (o MetricAbsenceOutput) Aggregations() AggregationArrayOutput {
	return o.ApplyT(func(v MetricAbsence) []Aggregation { return v.Aggregations }).(AggregationArrayOutput)
}

// The amount of time that a time series must fail to report new data to be considered failing. Currently, only values that are a multiple of a minute--e.g. 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. The Duration.nanos field is ignored.
func (o MetricAbsenceOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricAbsence) *string { return v.Duration }).(pulumi.StringPtrOutput)
}

// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
func (o MetricAbsenceOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricAbsence) *string { return v.Filter }).(pulumi.StringPtrOutput)
}

// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations.
func (o MetricAbsenceOutput) Trigger() TriggerPtrOutput {
	return o.ApplyT(func(v MetricAbsence) *Trigger { return v.Trigger }).(TriggerPtrOutput)
}

type MetricAbsencePtrOutput struct{ *pulumi.OutputState }

func (MetricAbsencePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricAbsence)(nil)).Elem()
}

func (o MetricAbsencePtrOutput) ToMetricAbsencePtrOutput() MetricAbsencePtrOutput {
	return o
}

func (o MetricAbsencePtrOutput) ToMetricAbsencePtrOutputWithContext(ctx context.Context) MetricAbsencePtrOutput {
	return o
}

func (o MetricAbsencePtrOutput) Elem() MetricAbsenceOutput {
	return o.ApplyT(func(v *MetricAbsence) MetricAbsence { return *v }).(MetricAbsenceOutput)
}

// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resrouces). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
func (o MetricAbsencePtrOutput) Aggregations() AggregationArrayOutput {
	return o.ApplyT(func(v *MetricAbsence) []Aggregation {
		if v == nil {
			return nil
		}
		return v.Aggregations
	}).(AggregationArrayOutput)
}

// The amount of time that a time series must fail to report new data to be considered failing. Currently, only values that are a multiple of a minute--e.g. 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. The Duration.nanos field is ignored.
func (o MetricAbsencePtrOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricAbsence) *string {
		if v == nil {
			return nil
		}
		return v.Duration
	}).(pulumi.StringPtrOutput)
}

// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
func (o MetricAbsencePtrOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricAbsence) *string {
		if v == nil {
			return nil
		}
		return v.Filter
	}).(pulumi.StringPtrOutput)
}

// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations.
func (o MetricAbsencePtrOutput) Trigger() TriggerPtrOutput {
	return o.ApplyT(func(v *MetricAbsence) *Trigger {
		if v == nil {
			return nil
		}
		return v.Trigger
	}).(TriggerPtrOutput)
}

// Additional annotations that can be used to guide the usage of a metric.
type MetricDescriptorMetadata struct {
	// The delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors.
	IngestDelay *string `pulumi:"ingestDelay"`
	// Deprecated. Must use the MetricDescriptor.launch_stage instead.
	LaunchStage *string `pulumi:"launchStage"`
	// The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period.
	SamplePeriod *string `pulumi:"samplePeriod"`
}

// MetricDescriptorMetadataInput is an input type that accepts MetricDescriptorMetadataArgs and MetricDescriptorMetadataOutput values.
// You can construct a concrete instance of `MetricDescriptorMetadataInput` via:
//
//          MetricDescriptorMetadataArgs{...}
type MetricDescriptorMetadataInput interface {
	pulumi.Input

	ToMetricDescriptorMetadataOutput() MetricDescriptorMetadataOutput
	ToMetricDescriptorMetadataOutputWithContext(context.Context) MetricDescriptorMetadataOutput
}

// Additional annotations that can be used to guide the usage of a metric.
type MetricDescriptorMetadataArgs struct {
	// The delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors.
	IngestDelay pulumi.StringPtrInput `pulumi:"ingestDelay"`
	// Deprecated. Must use the MetricDescriptor.launch_stage instead.
	LaunchStage pulumi.StringPtrInput `pulumi:"launchStage"`
	// The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period.
	SamplePeriod pulumi.StringPtrInput `pulumi:"samplePeriod"`
}

func (MetricDescriptorMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricDescriptorMetadata)(nil)).Elem()
}

func (i MetricDescriptorMetadataArgs) ToMetricDescriptorMetadataOutput() MetricDescriptorMetadataOutput {
	return i.ToMetricDescriptorMetadataOutputWithContext(context.Background())
}

func (i MetricDescriptorMetadataArgs) ToMetricDescriptorMetadataOutputWithContext(ctx context.Context) MetricDescriptorMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricDescriptorMetadataOutput)
}

func (i MetricDescriptorMetadataArgs) ToMetricDescriptorMetadataPtrOutput() MetricDescriptorMetadataPtrOutput {
	return i.ToMetricDescriptorMetadataPtrOutputWithContext(context.Background())
}

func (i MetricDescriptorMetadataArgs) ToMetricDescriptorMetadataPtrOutputWithContext(ctx context.Context) MetricDescriptorMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricDescriptorMetadataOutput).ToMetricDescriptorMetadataPtrOutputWithContext(ctx)
}

// MetricDescriptorMetadataPtrInput is an input type that accepts MetricDescriptorMetadataArgs, MetricDescriptorMetadataPtr and MetricDescriptorMetadataPtrOutput values.
// You can construct a concrete instance of `MetricDescriptorMetadataPtrInput` via:
//
//          MetricDescriptorMetadataArgs{...}
//
//  or:
//
//          nil
type MetricDescriptorMetadataPtrInput interface {
	pulumi.Input

	ToMetricDescriptorMetadataPtrOutput() MetricDescriptorMetadataPtrOutput
	ToMetricDescriptorMetadataPtrOutputWithContext(context.Context) MetricDescriptorMetadataPtrOutput
}

type metricDescriptorMetadataPtrType MetricDescriptorMetadataArgs

func MetricDescriptorMetadataPtr(v *MetricDescriptorMetadataArgs) MetricDescriptorMetadataPtrInput {
	return (*metricDescriptorMetadataPtrType)(v)
}

func (*metricDescriptorMetadataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricDescriptorMetadata)(nil)).Elem()
}

func (i *metricDescriptorMetadataPtrType) ToMetricDescriptorMetadataPtrOutput() MetricDescriptorMetadataPtrOutput {
	return i.ToMetricDescriptorMetadataPtrOutputWithContext(context.Background())
}

func (i *metricDescriptorMetadataPtrType) ToMetricDescriptorMetadataPtrOutputWithContext(ctx context.Context) MetricDescriptorMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricDescriptorMetadataPtrOutput)
}

// Additional annotations that can be used to guide the usage of a metric.
type MetricDescriptorMetadataOutput struct{ *pulumi.OutputState }

func (MetricDescriptorMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricDescriptorMetadata)(nil)).Elem()
}

func (o MetricDescriptorMetadataOutput) ToMetricDescriptorMetadataOutput() MetricDescriptorMetadataOutput {
	return o
}

func (o MetricDescriptorMetadataOutput) ToMetricDescriptorMetadataOutputWithContext(ctx context.Context) MetricDescriptorMetadataOutput {
	return o
}

func (o MetricDescriptorMetadataOutput) ToMetricDescriptorMetadataPtrOutput() MetricDescriptorMetadataPtrOutput {
	return o.ToMetricDescriptorMetadataPtrOutputWithContext(context.Background())
}

func (o MetricDescriptorMetadataOutput) ToMetricDescriptorMetadataPtrOutputWithContext(ctx context.Context) MetricDescriptorMetadataPtrOutput {
	return o.ApplyT(func(v MetricDescriptorMetadata) *MetricDescriptorMetadata {
		return &v
	}).(MetricDescriptorMetadataPtrOutput)
}

// The delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors.
func (o MetricDescriptorMetadataOutput) IngestDelay() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricDescriptorMetadata) *string { return v.IngestDelay }).(pulumi.StringPtrOutput)
}

// Deprecated. Must use the MetricDescriptor.launch_stage instead.
func (o MetricDescriptorMetadataOutput) LaunchStage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricDescriptorMetadata) *string { return v.LaunchStage }).(pulumi.StringPtrOutput)
}

// The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period.
func (o MetricDescriptorMetadataOutput) SamplePeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricDescriptorMetadata) *string { return v.SamplePeriod }).(pulumi.StringPtrOutput)
}

type MetricDescriptorMetadataPtrOutput struct{ *pulumi.OutputState }

func (MetricDescriptorMetadataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricDescriptorMetadata)(nil)).Elem()
}

func (o MetricDescriptorMetadataPtrOutput) ToMetricDescriptorMetadataPtrOutput() MetricDescriptorMetadataPtrOutput {
	return o
}

func (o MetricDescriptorMetadataPtrOutput) ToMetricDescriptorMetadataPtrOutputWithContext(ctx context.Context) MetricDescriptorMetadataPtrOutput {
	return o
}

func (o MetricDescriptorMetadataPtrOutput) Elem() MetricDescriptorMetadataOutput {
	return o.ApplyT(func(v *MetricDescriptorMetadata) MetricDescriptorMetadata { return *v }).(MetricDescriptorMetadataOutput)
}

// The delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors.
func (o MetricDescriptorMetadataPtrOutput) IngestDelay() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricDescriptorMetadata) *string {
		if v == nil {
			return nil
		}
		return v.IngestDelay
	}).(pulumi.StringPtrOutput)
}

// Deprecated. Must use the MetricDescriptor.launch_stage instead.
func (o MetricDescriptorMetadataPtrOutput) LaunchStage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricDescriptorMetadata) *string {
		if v == nil {
			return nil
		}
		return v.LaunchStage
	}).(pulumi.StringPtrOutput)
}

// The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period.
func (o MetricDescriptorMetadataPtrOutput) SamplePeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricDescriptorMetadata) *string {
		if v == nil {
			return nil
		}
		return v.SamplePeriod
	}).(pulumi.StringPtrOutput)
}

// A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min <= x < range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE.
type MetricRange struct {
	// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
	Range *GoogleMonitoringV3Range `pulumi:"range"`
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
	TimeSeries *string `pulumi:"timeSeries"`
}

// MetricRangeInput is an input type that accepts MetricRangeArgs and MetricRangeOutput values.
// You can construct a concrete instance of `MetricRangeInput` via:
//
//          MetricRangeArgs{...}
type MetricRangeInput interface {
	pulumi.Input

	ToMetricRangeOutput() MetricRangeOutput
	ToMetricRangeOutputWithContext(context.Context) MetricRangeOutput
}

// A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min <= x < range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE.
type MetricRangeArgs struct {
	// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
	Range GoogleMonitoringV3RangePtrInput `pulumi:"range"`
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
	TimeSeries pulumi.StringPtrInput `pulumi:"timeSeries"`
}

func (MetricRangeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricRange)(nil)).Elem()
}

func (i MetricRangeArgs) ToMetricRangeOutput() MetricRangeOutput {
	return i.ToMetricRangeOutputWithContext(context.Background())
}

func (i MetricRangeArgs) ToMetricRangeOutputWithContext(ctx context.Context) MetricRangeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricRangeOutput)
}

func (i MetricRangeArgs) ToMetricRangePtrOutput() MetricRangePtrOutput {
	return i.ToMetricRangePtrOutputWithContext(context.Background())
}

func (i MetricRangeArgs) ToMetricRangePtrOutputWithContext(ctx context.Context) MetricRangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricRangeOutput).ToMetricRangePtrOutputWithContext(ctx)
}

// MetricRangePtrInput is an input type that accepts MetricRangeArgs, MetricRangePtr and MetricRangePtrOutput values.
// You can construct a concrete instance of `MetricRangePtrInput` via:
//
//          MetricRangeArgs{...}
//
//  or:
//
//          nil
type MetricRangePtrInput interface {
	pulumi.Input

	ToMetricRangePtrOutput() MetricRangePtrOutput
	ToMetricRangePtrOutputWithContext(context.Context) MetricRangePtrOutput
}

type metricRangePtrType MetricRangeArgs

func MetricRangePtr(v *MetricRangeArgs) MetricRangePtrInput {
	return (*metricRangePtrType)(v)
}

func (*metricRangePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricRange)(nil)).Elem()
}

func (i *metricRangePtrType) ToMetricRangePtrOutput() MetricRangePtrOutput {
	return i.ToMetricRangePtrOutputWithContext(context.Background())
}

func (i *metricRangePtrType) ToMetricRangePtrOutputWithContext(ctx context.Context) MetricRangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricRangePtrOutput)
}

// A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min <= x < range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE.
type MetricRangeOutput struct{ *pulumi.OutputState }

func (MetricRangeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricRange)(nil)).Elem()
}

func (o MetricRangeOutput) ToMetricRangeOutput() MetricRangeOutput {
	return o
}

func (o MetricRangeOutput) ToMetricRangeOutputWithContext(ctx context.Context) MetricRangeOutput {
	return o
}

func (o MetricRangeOutput) ToMetricRangePtrOutput() MetricRangePtrOutput {
	return o.ToMetricRangePtrOutputWithContext(context.Background())
}

func (o MetricRangeOutput) ToMetricRangePtrOutputWithContext(ctx context.Context) MetricRangePtrOutput {
	return o.ApplyT(func(v MetricRange) *MetricRange {
		return &v
	}).(MetricRangePtrOutput)
}

// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
func (o MetricRangeOutput) Range() GoogleMonitoringV3RangePtrOutput {
	return o.ApplyT(func(v MetricRange) *GoogleMonitoringV3Range { return v.Range }).(GoogleMonitoringV3RangePtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
func (o MetricRangeOutput) TimeSeries() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricRange) *string { return v.TimeSeries }).(pulumi.StringPtrOutput)
}

type MetricRangePtrOutput struct{ *pulumi.OutputState }

func (MetricRangePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricRange)(nil)).Elem()
}

func (o MetricRangePtrOutput) ToMetricRangePtrOutput() MetricRangePtrOutput {
	return o
}

func (o MetricRangePtrOutput) ToMetricRangePtrOutputWithContext(ctx context.Context) MetricRangePtrOutput {
	return o
}

func (o MetricRangePtrOutput) Elem() MetricRangeOutput {
	return o.ApplyT(func(v *MetricRange) MetricRange { return *v }).(MetricRangeOutput)
}

// Range of values considered "good." For a one-sided range, set one bound to an infinite value.
func (o MetricRangePtrOutput) Range() GoogleMonitoringV3RangePtrOutput {
	return o.ApplyT(func(v *MetricRange) *GoogleMonitoringV3Range {
		if v == nil {
			return nil
		}
		return v.Range
	}).(GoogleMonitoringV3RangePtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
func (o MetricRangePtrOutput) TimeSeries() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricRange) *string {
		if v == nil {
			return nil
		}
		return v.TimeSeries
	}).(pulumi.StringPtrOutput)
}

// A condition type that compares a collection of time series against a threshold.
type MetricThreshold struct {
	// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resrouces). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
	Aggregations []Aggregation `pulumi:"aggregations"`
	// The comparison to apply between the time series (indicated by filter and aggregation) and the threshold (indicated by threshold_value). The comparison is applied on each time series, with the time series on the left-hand side and the threshold on the right-hand side.Only COMPARISON_LT and COMPARISON_GT are supported currently.
	Comparison *string `pulumi:"comparison"`
	// Specifies the alignment of data points in individual time series selected by denominatorFilter as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources).When computing ratios, the aggregations and denominator_aggregations fields must use the same alignment period and produce time series that have the same periodicity and labels.
	DenominatorAggregations []Aggregation `pulumi:"denominatorAggregations"`
	// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies a time series that should be used as the denominator of a ratio that will be compared with the threshold. If a denominator_filter is specified, the time series specified by the filter field will be used as the numerator.The filter must specify the metric type and optionally may contain restrictions on resource type, resource labels, and metric labels. This field may not exceed 2048 Unicode characters in length.
	DenominatorFilter *string `pulumi:"denominatorFilter"`
	// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
	Duration *string `pulumi:"duration"`
	// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
	Filter *string `pulumi:"filter"`
	// A value against which to compare the time series.
	ThresholdValue *float64 `pulumi:"thresholdValue"`
	// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
	Trigger *Trigger `pulumi:"trigger"`
}

// MetricThresholdInput is an input type that accepts MetricThresholdArgs and MetricThresholdOutput values.
// You can construct a concrete instance of `MetricThresholdInput` via:
//
//          MetricThresholdArgs{...}
type MetricThresholdInput interface {
	pulumi.Input

	ToMetricThresholdOutput() MetricThresholdOutput
	ToMetricThresholdOutputWithContext(context.Context) MetricThresholdOutput
}

// A condition type that compares a collection of time series against a threshold.
type MetricThresholdArgs struct {
	// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resrouces). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
	Aggregations AggregationArrayInput `pulumi:"aggregations"`
	// The comparison to apply between the time series (indicated by filter and aggregation) and the threshold (indicated by threshold_value). The comparison is applied on each time series, with the time series on the left-hand side and the threshold on the right-hand side.Only COMPARISON_LT and COMPARISON_GT are supported currently.
	Comparison pulumi.StringPtrInput `pulumi:"comparison"`
	// Specifies the alignment of data points in individual time series selected by denominatorFilter as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources).When computing ratios, the aggregations and denominator_aggregations fields must use the same alignment period and produce time series that have the same periodicity and labels.
	DenominatorAggregations AggregationArrayInput `pulumi:"denominatorAggregations"`
	// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies a time series that should be used as the denominator of a ratio that will be compared with the threshold. If a denominator_filter is specified, the time series specified by the filter field will be used as the numerator.The filter must specify the metric type and optionally may contain restrictions on resource type, resource labels, and metric labels. This field may not exceed 2048 Unicode characters in length.
	DenominatorFilter pulumi.StringPtrInput `pulumi:"denominatorFilter"`
	// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
	Duration pulumi.StringPtrInput `pulumi:"duration"`
	// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
	Filter pulumi.StringPtrInput `pulumi:"filter"`
	// A value against which to compare the time series.
	ThresholdValue pulumi.Float64PtrInput `pulumi:"thresholdValue"`
	// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
	Trigger TriggerPtrInput `pulumi:"trigger"`
}

func (MetricThresholdArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricThreshold)(nil)).Elem()
}

func (i MetricThresholdArgs) ToMetricThresholdOutput() MetricThresholdOutput {
	return i.ToMetricThresholdOutputWithContext(context.Background())
}

func (i MetricThresholdArgs) ToMetricThresholdOutputWithContext(ctx context.Context) MetricThresholdOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricThresholdOutput)
}

func (i MetricThresholdArgs) ToMetricThresholdPtrOutput() MetricThresholdPtrOutput {
	return i.ToMetricThresholdPtrOutputWithContext(context.Background())
}

func (i MetricThresholdArgs) ToMetricThresholdPtrOutputWithContext(ctx context.Context) MetricThresholdPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricThresholdOutput).ToMetricThresholdPtrOutputWithContext(ctx)
}

// MetricThresholdPtrInput is an input type that accepts MetricThresholdArgs, MetricThresholdPtr and MetricThresholdPtrOutput values.
// You can construct a concrete instance of `MetricThresholdPtrInput` via:
//
//          MetricThresholdArgs{...}
//
//  or:
//
//          nil
type MetricThresholdPtrInput interface {
	pulumi.Input

	ToMetricThresholdPtrOutput() MetricThresholdPtrOutput
	ToMetricThresholdPtrOutputWithContext(context.Context) MetricThresholdPtrOutput
}

type metricThresholdPtrType MetricThresholdArgs

func MetricThresholdPtr(v *MetricThresholdArgs) MetricThresholdPtrInput {
	return (*metricThresholdPtrType)(v)
}

func (*metricThresholdPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricThreshold)(nil)).Elem()
}

func (i *metricThresholdPtrType) ToMetricThresholdPtrOutput() MetricThresholdPtrOutput {
	return i.ToMetricThresholdPtrOutputWithContext(context.Background())
}

func (i *metricThresholdPtrType) ToMetricThresholdPtrOutputWithContext(ctx context.Context) MetricThresholdPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetricThresholdPtrOutput)
}

// A condition type that compares a collection of time series against a threshold.
type MetricThresholdOutput struct{ *pulumi.OutputState }

func (MetricThresholdOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MetricThreshold)(nil)).Elem()
}

func (o MetricThresholdOutput) ToMetricThresholdOutput() MetricThresholdOutput {
	return o
}

func (o MetricThresholdOutput) ToMetricThresholdOutputWithContext(ctx context.Context) MetricThresholdOutput {
	return o
}

func (o MetricThresholdOutput) ToMetricThresholdPtrOutput() MetricThresholdPtrOutput {
	return o.ToMetricThresholdPtrOutputWithContext(context.Background())
}

func (o MetricThresholdOutput) ToMetricThresholdPtrOutputWithContext(ctx context.Context) MetricThresholdPtrOutput {
	return o.ApplyT(func(v MetricThreshold) *MetricThreshold {
		return &v
	}).(MetricThresholdPtrOutput)
}

// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resrouces). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
func (o MetricThresholdOutput) Aggregations() AggregationArrayOutput {
	return o.ApplyT(func(v MetricThreshold) []Aggregation { return v.Aggregations }).(AggregationArrayOutput)
}

// The comparison to apply between the time series (indicated by filter and aggregation) and the threshold (indicated by threshold_value). The comparison is applied on each time series, with the time series on the left-hand side and the threshold on the right-hand side.Only COMPARISON_LT and COMPARISON_GT are supported currently.
func (o MetricThresholdOutput) Comparison() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricThreshold) *string { return v.Comparison }).(pulumi.StringPtrOutput)
}

// Specifies the alignment of data points in individual time series selected by denominatorFilter as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources).When computing ratios, the aggregations and denominator_aggregations fields must use the same alignment period and produce time series that have the same periodicity and labels.
func (o MetricThresholdOutput) DenominatorAggregations() AggregationArrayOutput {
	return o.ApplyT(func(v MetricThreshold) []Aggregation { return v.DenominatorAggregations }).(AggregationArrayOutput)
}

// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies a time series that should be used as the denominator of a ratio that will be compared with the threshold. If a denominator_filter is specified, the time series specified by the filter field will be used as the numerator.The filter must specify the metric type and optionally may contain restrictions on resource type, resource labels, and metric labels. This field may not exceed 2048 Unicode characters in length.
func (o MetricThresholdOutput) DenominatorFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricThreshold) *string { return v.DenominatorFilter }).(pulumi.StringPtrOutput)
}

// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
func (o MetricThresholdOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricThreshold) *string { return v.Duration }).(pulumi.StringPtrOutput)
}

// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
func (o MetricThresholdOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MetricThreshold) *string { return v.Filter }).(pulumi.StringPtrOutput)
}

// A value against which to compare the time series.
func (o MetricThresholdOutput) ThresholdValue() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v MetricThreshold) *float64 { return v.ThresholdValue }).(pulumi.Float64PtrOutput)
}

// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
func (o MetricThresholdOutput) Trigger() TriggerPtrOutput {
	return o.ApplyT(func(v MetricThreshold) *Trigger { return v.Trigger }).(TriggerPtrOutput)
}

type MetricThresholdPtrOutput struct{ *pulumi.OutputState }

func (MetricThresholdPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MetricThreshold)(nil)).Elem()
}

func (o MetricThresholdPtrOutput) ToMetricThresholdPtrOutput() MetricThresholdPtrOutput {
	return o
}

func (o MetricThresholdPtrOutput) ToMetricThresholdPtrOutputWithContext(ctx context.Context) MetricThresholdPtrOutput {
	return o
}

func (o MetricThresholdPtrOutput) Elem() MetricThresholdOutput {
	return o.ApplyT(func(v *MetricThreshold) MetricThreshold { return *v }).(MetricThresholdOutput)
}

// Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resrouces). Multiple aggregations are applied in the order specified.This field is similar to the one in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list). It is advisable to use the ListTimeSeries method when debugging this field.
func (o MetricThresholdPtrOutput) Aggregations() AggregationArrayOutput {
	return o.ApplyT(func(v *MetricThreshold) []Aggregation {
		if v == nil {
			return nil
		}
		return v.Aggregations
	}).(AggregationArrayOutput)
}

// The comparison to apply between the time series (indicated by filter and aggregation) and the threshold (indicated by threshold_value). The comparison is applied on each time series, with the time series on the left-hand side and the threshold on the right-hand side.Only COMPARISON_LT and COMPARISON_GT are supported currently.
func (o MetricThresholdPtrOutput) Comparison() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricThreshold) *string {
		if v == nil {
			return nil
		}
		return v.Comparison
	}).(pulumi.StringPtrOutput)
}

// Specifies the alignment of data points in individual time series selected by denominatorFilter as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources).When computing ratios, the aggregations and denominator_aggregations fields must use the same alignment period and produce time series that have the same periodicity and labels.
func (o MetricThresholdPtrOutput) DenominatorAggregations() AggregationArrayOutput {
	return o.ApplyT(func(v *MetricThreshold) []Aggregation {
		if v == nil {
			return nil
		}
		return v.DenominatorAggregations
	}).(AggregationArrayOutput)
}

// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies a time series that should be used as the denominator of a ratio that will be compared with the threshold. If a denominator_filter is specified, the time series specified by the filter field will be used as the numerator.The filter must specify the metric type and optionally may contain restrictions on resource type, resource labels, and metric labels. This field may not exceed 2048 Unicode characters in length.
func (o MetricThresholdPtrOutput) DenominatorFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricThreshold) *string {
		if v == nil {
			return nil
		}
		return v.DenominatorFilter
	}).(pulumi.StringPtrOutput)
}

// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
func (o MetricThresholdPtrOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricThreshold) *string {
		if v == nil {
			return nil
		}
		return v.Duration
	}).(pulumi.StringPtrOutput)
}

// A filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the ListTimeSeries request (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) (that call is useful to verify the time series that will be retrieved / processed). The filter must specify the metric type and the resource type. Optionally, it can specify resource labels and metric labels. This field must not exceed 2048 Unicode characters in length.
func (o MetricThresholdPtrOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetricThreshold) *string {
		if v == nil {
			return nil
		}
		return v.Filter
	}).(pulumi.StringPtrOutput)
}

// A value against which to compare the time series.
func (o MetricThresholdPtrOutput) ThresholdValue() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *MetricThreshold) *float64 {
		if v == nil {
			return nil
		}
		return v.ThresholdValue
	}).(pulumi.Float64PtrOutput)
}

// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
func (o MetricThresholdPtrOutput) Trigger() TriggerPtrOutput {
	return o.ApplyT(func(v *MetricThreshold) *Trigger {
		if v == nil {
			return nil
		}
		return v.Trigger
	}).(TriggerPtrOutput)
}

// An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource's schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for "gce_instance" has labels "instance_id" and "zone": { "type": "gce_instance", "labels": { "instance_id": "12345678901234", "zone": "us-central1-a" }}
type MonitoredResource struct {
	// Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
	Labels map[string]string `pulumi:"labels"`
	// Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types and Logging resource types.
	Type *string `pulumi:"type"`
}

// MonitoredResourceInput is an input type that accepts MonitoredResourceArgs and MonitoredResourceOutput values.
// You can construct a concrete instance of `MonitoredResourceInput` via:
//
//          MonitoredResourceArgs{...}
type MonitoredResourceInput interface {
	pulumi.Input

	ToMonitoredResourceOutput() MonitoredResourceOutput
	ToMonitoredResourceOutputWithContext(context.Context) MonitoredResourceOutput
}

// An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource's schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for "gce_instance" has labels "instance_id" and "zone": { "type": "gce_instance", "labels": { "instance_id": "12345678901234", "zone": "us-central1-a" }}
type MonitoredResourceArgs struct {
	// Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
	Labels pulumi.StringMapInput `pulumi:"labels"`
	// Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types and Logging resource types.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (MonitoredResourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoredResource)(nil)).Elem()
}

func (i MonitoredResourceArgs) ToMonitoredResourceOutput() MonitoredResourceOutput {
	return i.ToMonitoredResourceOutputWithContext(context.Background())
}

func (i MonitoredResourceArgs) ToMonitoredResourceOutputWithContext(ctx context.Context) MonitoredResourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoredResourceOutput)
}

func (i MonitoredResourceArgs) ToMonitoredResourcePtrOutput() MonitoredResourcePtrOutput {
	return i.ToMonitoredResourcePtrOutputWithContext(context.Background())
}

func (i MonitoredResourceArgs) ToMonitoredResourcePtrOutputWithContext(ctx context.Context) MonitoredResourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoredResourceOutput).ToMonitoredResourcePtrOutputWithContext(ctx)
}

// MonitoredResourcePtrInput is an input type that accepts MonitoredResourceArgs, MonitoredResourcePtr and MonitoredResourcePtrOutput values.
// You can construct a concrete instance of `MonitoredResourcePtrInput` via:
//
//          MonitoredResourceArgs{...}
//
//  or:
//
//          nil
type MonitoredResourcePtrInput interface {
	pulumi.Input

	ToMonitoredResourcePtrOutput() MonitoredResourcePtrOutput
	ToMonitoredResourcePtrOutputWithContext(context.Context) MonitoredResourcePtrOutput
}

type monitoredResourcePtrType MonitoredResourceArgs

func MonitoredResourcePtr(v *MonitoredResourceArgs) MonitoredResourcePtrInput {
	return (*monitoredResourcePtrType)(v)
}

func (*monitoredResourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MonitoredResource)(nil)).Elem()
}

func (i *monitoredResourcePtrType) ToMonitoredResourcePtrOutput() MonitoredResourcePtrOutput {
	return i.ToMonitoredResourcePtrOutputWithContext(context.Background())
}

func (i *monitoredResourcePtrType) ToMonitoredResourcePtrOutputWithContext(ctx context.Context) MonitoredResourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoredResourcePtrOutput)
}

// An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource's schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for "gce_instance" has labels "instance_id" and "zone": { "type": "gce_instance", "labels": { "instance_id": "12345678901234", "zone": "us-central1-a" }}
type MonitoredResourceOutput struct{ *pulumi.OutputState }

func (MonitoredResourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoredResource)(nil)).Elem()
}

func (o MonitoredResourceOutput) ToMonitoredResourceOutput() MonitoredResourceOutput {
	return o
}

func (o MonitoredResourceOutput) ToMonitoredResourceOutputWithContext(ctx context.Context) MonitoredResourceOutput {
	return o
}

func (o MonitoredResourceOutput) ToMonitoredResourcePtrOutput() MonitoredResourcePtrOutput {
	return o.ToMonitoredResourcePtrOutputWithContext(context.Background())
}

func (o MonitoredResourceOutput) ToMonitoredResourcePtrOutputWithContext(ctx context.Context) MonitoredResourcePtrOutput {
	return o.ApplyT(func(v MonitoredResource) *MonitoredResource {
		return &v
	}).(MonitoredResourcePtrOutput)
}

// Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
func (o MonitoredResourceOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v MonitoredResource) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types and Logging resource types.
func (o MonitoredResourceOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MonitoredResource) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type MonitoredResourcePtrOutput struct{ *pulumi.OutputState }

func (MonitoredResourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MonitoredResource)(nil)).Elem()
}

func (o MonitoredResourcePtrOutput) ToMonitoredResourcePtrOutput() MonitoredResourcePtrOutput {
	return o
}

func (o MonitoredResourcePtrOutput) ToMonitoredResourcePtrOutputWithContext(ctx context.Context) MonitoredResourcePtrOutput {
	return o
}

func (o MonitoredResourcePtrOutput) Elem() MonitoredResourceOutput {
	return o.ApplyT(func(v *MonitoredResource) MonitoredResource { return *v }).(MonitoredResourceOutput)
}

// Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
func (o MonitoredResourcePtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *MonitoredResource) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types and Logging resource types.
func (o MonitoredResourcePtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MonitoredResource) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// Auxiliary metadata for a MonitoredResource object. MonitoredResource objects contain the minimum set of information to uniquely identify a monitored resource instance. There is some other useful auxiliary metadata. Monitoring and Logging use an ingestion pipeline to extract metadata for cloud resources of all types, and store the metadata in this message.
type MonitoredResourceMetadata struct {
	// Output only. Values for predefined system metadata labels. System labels are a kind of metadata extracted by Google, including "machine_image", "vpc", "subnet_id", "security_group", "name", etc. System label values can be only strings, Boolean values, or a list of strings. For example: { "name": "my-test-instance", "security_group": ["a", "b", "c"], "spot_instance": false }
	SystemLabels map[string]string `pulumi:"systemLabels"`
	// Output only. A map of user-defined metadata labels.
	UserLabels map[string]string `pulumi:"userLabels"`
}

// MonitoredResourceMetadataInput is an input type that accepts MonitoredResourceMetadataArgs and MonitoredResourceMetadataOutput values.
// You can construct a concrete instance of `MonitoredResourceMetadataInput` via:
//
//          MonitoredResourceMetadataArgs{...}
type MonitoredResourceMetadataInput interface {
	pulumi.Input

	ToMonitoredResourceMetadataOutput() MonitoredResourceMetadataOutput
	ToMonitoredResourceMetadataOutputWithContext(context.Context) MonitoredResourceMetadataOutput
}

// Auxiliary metadata for a MonitoredResource object. MonitoredResource objects contain the minimum set of information to uniquely identify a monitored resource instance. There is some other useful auxiliary metadata. Monitoring and Logging use an ingestion pipeline to extract metadata for cloud resources of all types, and store the metadata in this message.
type MonitoredResourceMetadataArgs struct {
	// Output only. Values for predefined system metadata labels. System labels are a kind of metadata extracted by Google, including "machine_image", "vpc", "subnet_id", "security_group", "name", etc. System label values can be only strings, Boolean values, or a list of strings. For example: { "name": "my-test-instance", "security_group": ["a", "b", "c"], "spot_instance": false }
	SystemLabels pulumi.StringMapInput `pulumi:"systemLabels"`
	// Output only. A map of user-defined metadata labels.
	UserLabels pulumi.StringMapInput `pulumi:"userLabels"`
}

func (MonitoredResourceMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoredResourceMetadata)(nil)).Elem()
}

func (i MonitoredResourceMetadataArgs) ToMonitoredResourceMetadataOutput() MonitoredResourceMetadataOutput {
	return i.ToMonitoredResourceMetadataOutputWithContext(context.Background())
}

func (i MonitoredResourceMetadataArgs) ToMonitoredResourceMetadataOutputWithContext(ctx context.Context) MonitoredResourceMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoredResourceMetadataOutput)
}

func (i MonitoredResourceMetadataArgs) ToMonitoredResourceMetadataPtrOutput() MonitoredResourceMetadataPtrOutput {
	return i.ToMonitoredResourceMetadataPtrOutputWithContext(context.Background())
}

func (i MonitoredResourceMetadataArgs) ToMonitoredResourceMetadataPtrOutputWithContext(ctx context.Context) MonitoredResourceMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoredResourceMetadataOutput).ToMonitoredResourceMetadataPtrOutputWithContext(ctx)
}

// MonitoredResourceMetadataPtrInput is an input type that accepts MonitoredResourceMetadataArgs, MonitoredResourceMetadataPtr and MonitoredResourceMetadataPtrOutput values.
// You can construct a concrete instance of `MonitoredResourceMetadataPtrInput` via:
//
//          MonitoredResourceMetadataArgs{...}
//
//  or:
//
//          nil
type MonitoredResourceMetadataPtrInput interface {
	pulumi.Input

	ToMonitoredResourceMetadataPtrOutput() MonitoredResourceMetadataPtrOutput
	ToMonitoredResourceMetadataPtrOutputWithContext(context.Context) MonitoredResourceMetadataPtrOutput
}

type monitoredResourceMetadataPtrType MonitoredResourceMetadataArgs

func MonitoredResourceMetadataPtr(v *MonitoredResourceMetadataArgs) MonitoredResourceMetadataPtrInput {
	return (*monitoredResourceMetadataPtrType)(v)
}

func (*monitoredResourceMetadataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MonitoredResourceMetadata)(nil)).Elem()
}

func (i *monitoredResourceMetadataPtrType) ToMonitoredResourceMetadataPtrOutput() MonitoredResourceMetadataPtrOutput {
	return i.ToMonitoredResourceMetadataPtrOutputWithContext(context.Background())
}

func (i *monitoredResourceMetadataPtrType) ToMonitoredResourceMetadataPtrOutputWithContext(ctx context.Context) MonitoredResourceMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoredResourceMetadataPtrOutput)
}

// Auxiliary metadata for a MonitoredResource object. MonitoredResource objects contain the minimum set of information to uniquely identify a monitored resource instance. There is some other useful auxiliary metadata. Monitoring and Logging use an ingestion pipeline to extract metadata for cloud resources of all types, and store the metadata in this message.
type MonitoredResourceMetadataOutput struct{ *pulumi.OutputState }

func (MonitoredResourceMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoredResourceMetadata)(nil)).Elem()
}

func (o MonitoredResourceMetadataOutput) ToMonitoredResourceMetadataOutput() MonitoredResourceMetadataOutput {
	return o
}

func (o MonitoredResourceMetadataOutput) ToMonitoredResourceMetadataOutputWithContext(ctx context.Context) MonitoredResourceMetadataOutput {
	return o
}

func (o MonitoredResourceMetadataOutput) ToMonitoredResourceMetadataPtrOutput() MonitoredResourceMetadataPtrOutput {
	return o.ToMonitoredResourceMetadataPtrOutputWithContext(context.Background())
}

func (o MonitoredResourceMetadataOutput) ToMonitoredResourceMetadataPtrOutputWithContext(ctx context.Context) MonitoredResourceMetadataPtrOutput {
	return o.ApplyT(func(v MonitoredResourceMetadata) *MonitoredResourceMetadata {
		return &v
	}).(MonitoredResourceMetadataPtrOutput)
}

// Output only. Values for predefined system metadata labels. System labels are a kind of metadata extracted by Google, including "machine_image", "vpc", "subnet_id", "security_group", "name", etc. System label values can be only strings, Boolean values, or a list of strings. For example: { "name": "my-test-instance", "security_group": ["a", "b", "c"], "spot_instance": false }
func (o MonitoredResourceMetadataOutput) SystemLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v MonitoredResourceMetadata) map[string]string { return v.SystemLabels }).(pulumi.StringMapOutput)
}

// Output only. A map of user-defined metadata labels.
func (o MonitoredResourceMetadataOutput) UserLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v MonitoredResourceMetadata) map[string]string { return v.UserLabels }).(pulumi.StringMapOutput)
}

type MonitoredResourceMetadataPtrOutput struct{ *pulumi.OutputState }

func (MonitoredResourceMetadataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MonitoredResourceMetadata)(nil)).Elem()
}

func (o MonitoredResourceMetadataPtrOutput) ToMonitoredResourceMetadataPtrOutput() MonitoredResourceMetadataPtrOutput {
	return o
}

func (o MonitoredResourceMetadataPtrOutput) ToMonitoredResourceMetadataPtrOutputWithContext(ctx context.Context) MonitoredResourceMetadataPtrOutput {
	return o
}

func (o MonitoredResourceMetadataPtrOutput) Elem() MonitoredResourceMetadataOutput {
	return o.ApplyT(func(v *MonitoredResourceMetadata) MonitoredResourceMetadata { return *v }).(MonitoredResourceMetadataOutput)
}

// Output only. Values for predefined system metadata labels. System labels are a kind of metadata extracted by Google, including "machine_image", "vpc", "subnet_id", "security_group", "name", etc. System label values can be only strings, Boolean values, or a list of strings. For example: { "name": "my-test-instance", "security_group": ["a", "b", "c"], "spot_instance": false }
func (o MonitoredResourceMetadataPtrOutput) SystemLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *MonitoredResourceMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.SystemLabels
	}).(pulumi.StringMapOutput)
}

// Output only. A map of user-defined metadata labels.
func (o MonitoredResourceMetadataPtrOutput) UserLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *MonitoredResourceMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.UserLabels
	}).(pulumi.StringMapOutput)
}

// A condition type that allows alert policies to be defined using Monitoring Query Language (https://cloud.google.com/monitoring/mql).
type MonitoringQueryLanguageCondition struct {
	// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
	Duration *string `pulumi:"duration"`
	// Monitoring Query Language (https://cloud.google.com/monitoring/mql) query that outputs a boolean stream.
	Query *string `pulumi:"query"`
	// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
	Trigger *Trigger `pulumi:"trigger"`
}

// MonitoringQueryLanguageConditionInput is an input type that accepts MonitoringQueryLanguageConditionArgs and MonitoringQueryLanguageConditionOutput values.
// You can construct a concrete instance of `MonitoringQueryLanguageConditionInput` via:
//
//          MonitoringQueryLanguageConditionArgs{...}
type MonitoringQueryLanguageConditionInput interface {
	pulumi.Input

	ToMonitoringQueryLanguageConditionOutput() MonitoringQueryLanguageConditionOutput
	ToMonitoringQueryLanguageConditionOutputWithContext(context.Context) MonitoringQueryLanguageConditionOutput
}

// A condition type that allows alert policies to be defined using Monitoring Query Language (https://cloud.google.com/monitoring/mql).
type MonitoringQueryLanguageConditionArgs struct {
	// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
	Duration pulumi.StringPtrInput `pulumi:"duration"`
	// Monitoring Query Language (https://cloud.google.com/monitoring/mql) query that outputs a boolean stream.
	Query pulumi.StringPtrInput `pulumi:"query"`
	// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
	Trigger TriggerPtrInput `pulumi:"trigger"`
}

func (MonitoringQueryLanguageConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoringQueryLanguageCondition)(nil)).Elem()
}

func (i MonitoringQueryLanguageConditionArgs) ToMonitoringQueryLanguageConditionOutput() MonitoringQueryLanguageConditionOutput {
	return i.ToMonitoringQueryLanguageConditionOutputWithContext(context.Background())
}

func (i MonitoringQueryLanguageConditionArgs) ToMonitoringQueryLanguageConditionOutputWithContext(ctx context.Context) MonitoringQueryLanguageConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoringQueryLanguageConditionOutput)
}

func (i MonitoringQueryLanguageConditionArgs) ToMonitoringQueryLanguageConditionPtrOutput() MonitoringQueryLanguageConditionPtrOutput {
	return i.ToMonitoringQueryLanguageConditionPtrOutputWithContext(context.Background())
}

func (i MonitoringQueryLanguageConditionArgs) ToMonitoringQueryLanguageConditionPtrOutputWithContext(ctx context.Context) MonitoringQueryLanguageConditionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoringQueryLanguageConditionOutput).ToMonitoringQueryLanguageConditionPtrOutputWithContext(ctx)
}

// MonitoringQueryLanguageConditionPtrInput is an input type that accepts MonitoringQueryLanguageConditionArgs, MonitoringQueryLanguageConditionPtr and MonitoringQueryLanguageConditionPtrOutput values.
// You can construct a concrete instance of `MonitoringQueryLanguageConditionPtrInput` via:
//
//          MonitoringQueryLanguageConditionArgs{...}
//
//  or:
//
//          nil
type MonitoringQueryLanguageConditionPtrInput interface {
	pulumi.Input

	ToMonitoringQueryLanguageConditionPtrOutput() MonitoringQueryLanguageConditionPtrOutput
	ToMonitoringQueryLanguageConditionPtrOutputWithContext(context.Context) MonitoringQueryLanguageConditionPtrOutput
}

type monitoringQueryLanguageConditionPtrType MonitoringQueryLanguageConditionArgs

func MonitoringQueryLanguageConditionPtr(v *MonitoringQueryLanguageConditionArgs) MonitoringQueryLanguageConditionPtrInput {
	return (*monitoringQueryLanguageConditionPtrType)(v)
}

func (*monitoringQueryLanguageConditionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MonitoringQueryLanguageCondition)(nil)).Elem()
}

func (i *monitoringQueryLanguageConditionPtrType) ToMonitoringQueryLanguageConditionPtrOutput() MonitoringQueryLanguageConditionPtrOutput {
	return i.ToMonitoringQueryLanguageConditionPtrOutputWithContext(context.Background())
}

func (i *monitoringQueryLanguageConditionPtrType) ToMonitoringQueryLanguageConditionPtrOutputWithContext(ctx context.Context) MonitoringQueryLanguageConditionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MonitoringQueryLanguageConditionPtrOutput)
}

// A condition type that allows alert policies to be defined using Monitoring Query Language (https://cloud.google.com/monitoring/mql).
type MonitoringQueryLanguageConditionOutput struct{ *pulumi.OutputState }

func (MonitoringQueryLanguageConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MonitoringQueryLanguageCondition)(nil)).Elem()
}

func (o MonitoringQueryLanguageConditionOutput) ToMonitoringQueryLanguageConditionOutput() MonitoringQueryLanguageConditionOutput {
	return o
}

func (o MonitoringQueryLanguageConditionOutput) ToMonitoringQueryLanguageConditionOutputWithContext(ctx context.Context) MonitoringQueryLanguageConditionOutput {
	return o
}

func (o MonitoringQueryLanguageConditionOutput) ToMonitoringQueryLanguageConditionPtrOutput() MonitoringQueryLanguageConditionPtrOutput {
	return o.ToMonitoringQueryLanguageConditionPtrOutputWithContext(context.Background())
}

func (o MonitoringQueryLanguageConditionOutput) ToMonitoringQueryLanguageConditionPtrOutputWithContext(ctx context.Context) MonitoringQueryLanguageConditionPtrOutput {
	return o.ApplyT(func(v MonitoringQueryLanguageCondition) *MonitoringQueryLanguageCondition {
		return &v
	}).(MonitoringQueryLanguageConditionPtrOutput)
}

// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
func (o MonitoringQueryLanguageConditionOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MonitoringQueryLanguageCondition) *string { return v.Duration }).(pulumi.StringPtrOutput)
}

// Monitoring Query Language (https://cloud.google.com/monitoring/mql) query that outputs a boolean stream.
func (o MonitoringQueryLanguageConditionOutput) Query() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MonitoringQueryLanguageCondition) *string { return v.Query }).(pulumi.StringPtrOutput)
}

// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
func (o MonitoringQueryLanguageConditionOutput) Trigger() TriggerPtrOutput {
	return o.ApplyT(func(v MonitoringQueryLanguageCondition) *Trigger { return v.Trigger }).(TriggerPtrOutput)
}

type MonitoringQueryLanguageConditionPtrOutput struct{ *pulumi.OutputState }

func (MonitoringQueryLanguageConditionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MonitoringQueryLanguageCondition)(nil)).Elem()
}

func (o MonitoringQueryLanguageConditionPtrOutput) ToMonitoringQueryLanguageConditionPtrOutput() MonitoringQueryLanguageConditionPtrOutput {
	return o
}

func (o MonitoringQueryLanguageConditionPtrOutput) ToMonitoringQueryLanguageConditionPtrOutputWithContext(ctx context.Context) MonitoringQueryLanguageConditionPtrOutput {
	return o
}

func (o MonitoringQueryLanguageConditionPtrOutput) Elem() MonitoringQueryLanguageConditionOutput {
	return o.ApplyT(func(v *MonitoringQueryLanguageCondition) MonitoringQueryLanguageCondition { return *v }).(MonitoringQueryLanguageConditionOutput)
}

// The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
func (o MonitoringQueryLanguageConditionPtrOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MonitoringQueryLanguageCondition) *string {
		if v == nil {
			return nil
		}
		return v.Duration
	}).(pulumi.StringPtrOutput)
}

// Monitoring Query Language (https://cloud.google.com/monitoring/mql) query that outputs a boolean stream.
func (o MonitoringQueryLanguageConditionPtrOutput) Query() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MonitoringQueryLanguageCondition) *string {
		if v == nil {
			return nil
		}
		return v.Query
	}).(pulumi.StringPtrOutput)
}

// The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified.
func (o MonitoringQueryLanguageConditionPtrOutput) Trigger() TriggerPtrOutput {
	return o.ApplyT(func(v *MonitoringQueryLanguageCondition) *Trigger {
		if v == nil {
			return nil
		}
		return v.Trigger
	}).(TriggerPtrOutput)
}

// Describes a change made to a configuration.
type MutationRecord struct {
	// When the change occurred.
	MutateTime *string `pulumi:"mutateTime"`
	// The email address of the user making the change.
	MutatedBy *string `pulumi:"mutatedBy"`
}

// MutationRecordInput is an input type that accepts MutationRecordArgs and MutationRecordOutput values.
// You can construct a concrete instance of `MutationRecordInput` via:
//
//          MutationRecordArgs{...}
type MutationRecordInput interface {
	pulumi.Input

	ToMutationRecordOutput() MutationRecordOutput
	ToMutationRecordOutputWithContext(context.Context) MutationRecordOutput
}

// Describes a change made to a configuration.
type MutationRecordArgs struct {
	// When the change occurred.
	MutateTime pulumi.StringPtrInput `pulumi:"mutateTime"`
	// The email address of the user making the change.
	MutatedBy pulumi.StringPtrInput `pulumi:"mutatedBy"`
}

func (MutationRecordArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MutationRecord)(nil)).Elem()
}

func (i MutationRecordArgs) ToMutationRecordOutput() MutationRecordOutput {
	return i.ToMutationRecordOutputWithContext(context.Background())
}

func (i MutationRecordArgs) ToMutationRecordOutputWithContext(ctx context.Context) MutationRecordOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MutationRecordOutput)
}

func (i MutationRecordArgs) ToMutationRecordPtrOutput() MutationRecordPtrOutput {
	return i.ToMutationRecordPtrOutputWithContext(context.Background())
}

func (i MutationRecordArgs) ToMutationRecordPtrOutputWithContext(ctx context.Context) MutationRecordPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MutationRecordOutput).ToMutationRecordPtrOutputWithContext(ctx)
}

// MutationRecordPtrInput is an input type that accepts MutationRecordArgs, MutationRecordPtr and MutationRecordPtrOutput values.
// You can construct a concrete instance of `MutationRecordPtrInput` via:
//
//          MutationRecordArgs{...}
//
//  or:
//
//          nil
type MutationRecordPtrInput interface {
	pulumi.Input

	ToMutationRecordPtrOutput() MutationRecordPtrOutput
	ToMutationRecordPtrOutputWithContext(context.Context) MutationRecordPtrOutput
}

type mutationRecordPtrType MutationRecordArgs

func MutationRecordPtr(v *MutationRecordArgs) MutationRecordPtrInput {
	return (*mutationRecordPtrType)(v)
}

func (*mutationRecordPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MutationRecord)(nil)).Elem()
}

func (i *mutationRecordPtrType) ToMutationRecordPtrOutput() MutationRecordPtrOutput {
	return i.ToMutationRecordPtrOutputWithContext(context.Background())
}

func (i *mutationRecordPtrType) ToMutationRecordPtrOutputWithContext(ctx context.Context) MutationRecordPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MutationRecordPtrOutput)
}

// Describes a change made to a configuration.
type MutationRecordOutput struct{ *pulumi.OutputState }

func (MutationRecordOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MutationRecord)(nil)).Elem()
}

func (o MutationRecordOutput) ToMutationRecordOutput() MutationRecordOutput {
	return o
}

func (o MutationRecordOutput) ToMutationRecordOutputWithContext(ctx context.Context) MutationRecordOutput {
	return o
}

func (o MutationRecordOutput) ToMutationRecordPtrOutput() MutationRecordPtrOutput {
	return o.ToMutationRecordPtrOutputWithContext(context.Background())
}

func (o MutationRecordOutput) ToMutationRecordPtrOutputWithContext(ctx context.Context) MutationRecordPtrOutput {
	return o.ApplyT(func(v MutationRecord) *MutationRecord {
		return &v
	}).(MutationRecordPtrOutput)
}

// When the change occurred.
func (o MutationRecordOutput) MutateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MutationRecord) *string { return v.MutateTime }).(pulumi.StringPtrOutput)
}

// The email address of the user making the change.
func (o MutationRecordOutput) MutatedBy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v MutationRecord) *string { return v.MutatedBy }).(pulumi.StringPtrOutput)
}

type MutationRecordPtrOutput struct{ *pulumi.OutputState }

func (MutationRecordPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MutationRecord)(nil)).Elem()
}

func (o MutationRecordPtrOutput) ToMutationRecordPtrOutput() MutationRecordPtrOutput {
	return o
}

func (o MutationRecordPtrOutput) ToMutationRecordPtrOutputWithContext(ctx context.Context) MutationRecordPtrOutput {
	return o
}

func (o MutationRecordPtrOutput) Elem() MutationRecordOutput {
	return o.ApplyT(func(v *MutationRecord) MutationRecord { return *v }).(MutationRecordOutput)
}

// When the change occurred.
func (o MutationRecordPtrOutput) MutateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MutationRecord) *string {
		if v == nil {
			return nil
		}
		return v.MutateTime
	}).(pulumi.StringPtrOutput)
}

// The email address of the user making the change.
func (o MutationRecordPtrOutput) MutatedBy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MutationRecord) *string {
		if v == nil {
			return nil
		}
		return v.MutatedBy
	}).(pulumi.StringPtrOutput)
}

// A PerformanceThreshold is used when each window is good when that window has a sufficiently high performance.
type PerformanceThreshold struct {
	// BasicSli to evaluate to judge window quality.
	BasicSliPerformance *BasicSli `pulumi:"basicSliPerformance"`
	// RequestBasedSli to evaluate to judge window quality.
	Performance *RequestBasedSli `pulumi:"performance"`
	// If window performance >= threshold, the window is counted as good.
	Threshold *float64 `pulumi:"threshold"`
}

// PerformanceThresholdInput is an input type that accepts PerformanceThresholdArgs and PerformanceThresholdOutput values.
// You can construct a concrete instance of `PerformanceThresholdInput` via:
//
//          PerformanceThresholdArgs{...}
type PerformanceThresholdInput interface {
	pulumi.Input

	ToPerformanceThresholdOutput() PerformanceThresholdOutput
	ToPerformanceThresholdOutputWithContext(context.Context) PerformanceThresholdOutput
}

// A PerformanceThreshold is used when each window is good when that window has a sufficiently high performance.
type PerformanceThresholdArgs struct {
	// BasicSli to evaluate to judge window quality.
	BasicSliPerformance BasicSliPtrInput `pulumi:"basicSliPerformance"`
	// RequestBasedSli to evaluate to judge window quality.
	Performance RequestBasedSliPtrInput `pulumi:"performance"`
	// If window performance >= threshold, the window is counted as good.
	Threshold pulumi.Float64PtrInput `pulumi:"threshold"`
}

func (PerformanceThresholdArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PerformanceThreshold)(nil)).Elem()
}

func (i PerformanceThresholdArgs) ToPerformanceThresholdOutput() PerformanceThresholdOutput {
	return i.ToPerformanceThresholdOutputWithContext(context.Background())
}

func (i PerformanceThresholdArgs) ToPerformanceThresholdOutputWithContext(ctx context.Context) PerformanceThresholdOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PerformanceThresholdOutput)
}

func (i PerformanceThresholdArgs) ToPerformanceThresholdPtrOutput() PerformanceThresholdPtrOutput {
	return i.ToPerformanceThresholdPtrOutputWithContext(context.Background())
}

func (i PerformanceThresholdArgs) ToPerformanceThresholdPtrOutputWithContext(ctx context.Context) PerformanceThresholdPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PerformanceThresholdOutput).ToPerformanceThresholdPtrOutputWithContext(ctx)
}

// PerformanceThresholdPtrInput is an input type that accepts PerformanceThresholdArgs, PerformanceThresholdPtr and PerformanceThresholdPtrOutput values.
// You can construct a concrete instance of `PerformanceThresholdPtrInput` via:
//
//          PerformanceThresholdArgs{...}
//
//  or:
//
//          nil
type PerformanceThresholdPtrInput interface {
	pulumi.Input

	ToPerformanceThresholdPtrOutput() PerformanceThresholdPtrOutput
	ToPerformanceThresholdPtrOutputWithContext(context.Context) PerformanceThresholdPtrOutput
}

type performanceThresholdPtrType PerformanceThresholdArgs

func PerformanceThresholdPtr(v *PerformanceThresholdArgs) PerformanceThresholdPtrInput {
	return (*performanceThresholdPtrType)(v)
}

func (*performanceThresholdPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PerformanceThreshold)(nil)).Elem()
}

func (i *performanceThresholdPtrType) ToPerformanceThresholdPtrOutput() PerformanceThresholdPtrOutput {
	return i.ToPerformanceThresholdPtrOutputWithContext(context.Background())
}

func (i *performanceThresholdPtrType) ToPerformanceThresholdPtrOutputWithContext(ctx context.Context) PerformanceThresholdPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PerformanceThresholdPtrOutput)
}

// A PerformanceThreshold is used when each window is good when that window has a sufficiently high performance.
type PerformanceThresholdOutput struct{ *pulumi.OutputState }

func (PerformanceThresholdOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PerformanceThreshold)(nil)).Elem()
}

func (o PerformanceThresholdOutput) ToPerformanceThresholdOutput() PerformanceThresholdOutput {
	return o
}

func (o PerformanceThresholdOutput) ToPerformanceThresholdOutputWithContext(ctx context.Context) PerformanceThresholdOutput {
	return o
}

func (o PerformanceThresholdOutput) ToPerformanceThresholdPtrOutput() PerformanceThresholdPtrOutput {
	return o.ToPerformanceThresholdPtrOutputWithContext(context.Background())
}

func (o PerformanceThresholdOutput) ToPerformanceThresholdPtrOutputWithContext(ctx context.Context) PerformanceThresholdPtrOutput {
	return o.ApplyT(func(v PerformanceThreshold) *PerformanceThreshold {
		return &v
	}).(PerformanceThresholdPtrOutput)
}

// BasicSli to evaluate to judge window quality.
func (o PerformanceThresholdOutput) BasicSliPerformance() BasicSliPtrOutput {
	return o.ApplyT(func(v PerformanceThreshold) *BasicSli { return v.BasicSliPerformance }).(BasicSliPtrOutput)
}

// RequestBasedSli to evaluate to judge window quality.
func (o PerformanceThresholdOutput) Performance() RequestBasedSliPtrOutput {
	return o.ApplyT(func(v PerformanceThreshold) *RequestBasedSli { return v.Performance }).(RequestBasedSliPtrOutput)
}

// If window performance >= threshold, the window is counted as good.
func (o PerformanceThresholdOutput) Threshold() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v PerformanceThreshold) *float64 { return v.Threshold }).(pulumi.Float64PtrOutput)
}

type PerformanceThresholdPtrOutput struct{ *pulumi.OutputState }

func (PerformanceThresholdPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PerformanceThreshold)(nil)).Elem()
}

func (o PerformanceThresholdPtrOutput) ToPerformanceThresholdPtrOutput() PerformanceThresholdPtrOutput {
	return o
}

func (o PerformanceThresholdPtrOutput) ToPerformanceThresholdPtrOutputWithContext(ctx context.Context) PerformanceThresholdPtrOutput {
	return o
}

func (o PerformanceThresholdPtrOutput) Elem() PerformanceThresholdOutput {
	return o.ApplyT(func(v *PerformanceThreshold) PerformanceThreshold { return *v }).(PerformanceThresholdOutput)
}

// BasicSli to evaluate to judge window quality.
func (o PerformanceThresholdPtrOutput) BasicSliPerformance() BasicSliPtrOutput {
	return o.ApplyT(func(v *PerformanceThreshold) *BasicSli {
		if v == nil {
			return nil
		}
		return v.BasicSliPerformance
	}).(BasicSliPtrOutput)
}

// RequestBasedSli to evaluate to judge window quality.
func (o PerformanceThresholdPtrOutput) Performance() RequestBasedSliPtrOutput {
	return o.ApplyT(func(v *PerformanceThreshold) *RequestBasedSli {
		if v == nil {
			return nil
		}
		return v.Performance
	}).(RequestBasedSliPtrOutput)
}

// If window performance >= threshold, the window is counted as good.
func (o PerformanceThresholdPtrOutput) Threshold() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *PerformanceThreshold) *float64 {
		if v == nil {
			return nil
		}
		return v.Threshold
	}).(pulumi.Float64PtrOutput)
}

// A single data point in a time series.
type Point struct {
	// The time interval to which the data point applies. For GAUGE metrics, the start time is optional, but if it is supplied, it must equal the end time. For DELTA metrics, the start and end time should specify a non-zero interval, with subsequent points specifying contiguous and non-overlapping intervals. For CUMULATIVE metrics, the start and end time should specify a non-zero interval, with subsequent points specifying the same start time and increasing end times, until an event resets the cumulative value to zero and sets a new start time for the following points.
	Interval *TimeInterval `pulumi:"interval"`
	// The value of the data point.
	Value *TypedValue `pulumi:"value"`
}

// PointInput is an input type that accepts PointArgs and PointOutput values.
// You can construct a concrete instance of `PointInput` via:
//
//          PointArgs{...}
type PointInput interface {
	pulumi.Input

	ToPointOutput() PointOutput
	ToPointOutputWithContext(context.Context) PointOutput
}

// A single data point in a time series.
type PointArgs struct {
	// The time interval to which the data point applies. For GAUGE metrics, the start time is optional, but if it is supplied, it must equal the end time. For DELTA metrics, the start and end time should specify a non-zero interval, with subsequent points specifying contiguous and non-overlapping intervals. For CUMULATIVE metrics, the start and end time should specify a non-zero interval, with subsequent points specifying the same start time and increasing end times, until an event resets the cumulative value to zero and sets a new start time for the following points.
	Interval TimeIntervalPtrInput `pulumi:"interval"`
	// The value of the data point.
	Value TypedValuePtrInput `pulumi:"value"`
}

func (PointArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Point)(nil)).Elem()
}

func (i PointArgs) ToPointOutput() PointOutput {
	return i.ToPointOutputWithContext(context.Background())
}

func (i PointArgs) ToPointOutputWithContext(ctx context.Context) PointOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PointOutput)
}

// PointArrayInput is an input type that accepts PointArray and PointArrayOutput values.
// You can construct a concrete instance of `PointArrayInput` via:
//
//          PointArray{ PointArgs{...} }
type PointArrayInput interface {
	pulumi.Input

	ToPointArrayOutput() PointArrayOutput
	ToPointArrayOutputWithContext(context.Context) PointArrayOutput
}

type PointArray []PointInput

func (PointArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Point)(nil)).Elem()
}

func (i PointArray) ToPointArrayOutput() PointArrayOutput {
	return i.ToPointArrayOutputWithContext(context.Background())
}

func (i PointArray) ToPointArrayOutputWithContext(ctx context.Context) PointArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PointArrayOutput)
}

// A single data point in a time series.
type PointOutput struct{ *pulumi.OutputState }

func (PointOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Point)(nil)).Elem()
}

func (o PointOutput) ToPointOutput() PointOutput {
	return o
}

func (o PointOutput) ToPointOutputWithContext(ctx context.Context) PointOutput {
	return o
}

// The time interval to which the data point applies. For GAUGE metrics, the start time is optional, but if it is supplied, it must equal the end time. For DELTA metrics, the start and end time should specify a non-zero interval, with subsequent points specifying contiguous and non-overlapping intervals. For CUMULATIVE metrics, the start and end time should specify a non-zero interval, with subsequent points specifying the same start time and increasing end times, until an event resets the cumulative value to zero and sets a new start time for the following points.
func (o PointOutput) Interval() TimeIntervalPtrOutput {
	return o.ApplyT(func(v Point) *TimeInterval { return v.Interval }).(TimeIntervalPtrOutput)
}

// The value of the data point.
func (o PointOutput) Value() TypedValuePtrOutput {
	return o.ApplyT(func(v Point) *TypedValue { return v.Value }).(TypedValuePtrOutput)
}

type PointArrayOutput struct{ *pulumi.OutputState }

func (PointArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Point)(nil)).Elem()
}

func (o PointArrayOutput) ToPointArrayOutput() PointArrayOutput {
	return o
}

func (o PointArrayOutput) ToPointArrayOutputWithContext(ctx context.Context) PointArrayOutput {
	return o
}

func (o PointArrayOutput) Index(i pulumi.IntInput) PointOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Point {
		return vs[0].([]Point)[vs[1].(int)]
	}).(PointOutput)
}

// The range of the population values.
type Range struct {
	// The maximum of the population values.
	Max *float64 `pulumi:"max"`
	// The minimum of the population values.
	Min *float64 `pulumi:"min"`
}

// RangeInput is an input type that accepts RangeArgs and RangeOutput values.
// You can construct a concrete instance of `RangeInput` via:
//
//          RangeArgs{...}
type RangeInput interface {
	pulumi.Input

	ToRangeOutput() RangeOutput
	ToRangeOutputWithContext(context.Context) RangeOutput
}

// The range of the population values.
type RangeArgs struct {
	// The maximum of the population values.
	Max pulumi.Float64PtrInput `pulumi:"max"`
	// The minimum of the population values.
	Min pulumi.Float64PtrInput `pulumi:"min"`
}

func (RangeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Range)(nil)).Elem()
}

func (i RangeArgs) ToRangeOutput() RangeOutput {
	return i.ToRangeOutputWithContext(context.Background())
}

func (i RangeArgs) ToRangeOutputWithContext(ctx context.Context) RangeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RangeOutput)
}

func (i RangeArgs) ToRangePtrOutput() RangePtrOutput {
	return i.ToRangePtrOutputWithContext(context.Background())
}

func (i RangeArgs) ToRangePtrOutputWithContext(ctx context.Context) RangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RangeOutput).ToRangePtrOutputWithContext(ctx)
}

// RangePtrInput is an input type that accepts RangeArgs, RangePtr and RangePtrOutput values.
// You can construct a concrete instance of `RangePtrInput` via:
//
//          RangeArgs{...}
//
//  or:
//
//          nil
type RangePtrInput interface {
	pulumi.Input

	ToRangePtrOutput() RangePtrOutput
	ToRangePtrOutputWithContext(context.Context) RangePtrOutput
}

type rangePtrType RangeArgs

func RangePtr(v *RangeArgs) RangePtrInput {
	return (*rangePtrType)(v)
}

func (*rangePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Range)(nil)).Elem()
}

func (i *rangePtrType) ToRangePtrOutput() RangePtrOutput {
	return i.ToRangePtrOutputWithContext(context.Background())
}

func (i *rangePtrType) ToRangePtrOutputWithContext(ctx context.Context) RangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RangePtrOutput)
}

// The range of the population values.
type RangeOutput struct{ *pulumi.OutputState }

func (RangeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Range)(nil)).Elem()
}

func (o RangeOutput) ToRangeOutput() RangeOutput {
	return o
}

func (o RangeOutput) ToRangeOutputWithContext(ctx context.Context) RangeOutput {
	return o
}

func (o RangeOutput) ToRangePtrOutput() RangePtrOutput {
	return o.ToRangePtrOutputWithContext(context.Background())
}

func (o RangeOutput) ToRangePtrOutputWithContext(ctx context.Context) RangePtrOutput {
	return o.ApplyT(func(v Range) *Range {
		return &v
	}).(RangePtrOutput)
}

// The maximum of the population values.
func (o RangeOutput) Max() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Range) *float64 { return v.Max }).(pulumi.Float64PtrOutput)
}

// The minimum of the population values.
func (o RangeOutput) Min() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Range) *float64 { return v.Min }).(pulumi.Float64PtrOutput)
}

type RangePtrOutput struct{ *pulumi.OutputState }

func (RangePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Range)(nil)).Elem()
}

func (o RangePtrOutput) ToRangePtrOutput() RangePtrOutput {
	return o
}

func (o RangePtrOutput) ToRangePtrOutputWithContext(ctx context.Context) RangePtrOutput {
	return o
}

func (o RangePtrOutput) Elem() RangeOutput {
	return o.ApplyT(func(v *Range) Range { return *v }).(RangeOutput)
}

// The maximum of the population values.
func (o RangePtrOutput) Max() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *Range) *float64 {
		if v == nil {
			return nil
		}
		return v.Max
	}).(pulumi.Float64PtrOutput)
}

// The minimum of the population values.
func (o RangePtrOutput) Min() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *Range) *float64 {
		if v == nil {
			return nil
		}
		return v.Min
	}).(pulumi.Float64PtrOutput)
}

// Service Level Indicators for which atomic units of service are counted directly.
type RequestBasedSli struct {
	// distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
	DistributionCut *DistributionCut `pulumi:"distributionCut"`
	// good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
	GoodTotalRatio *TimeSeriesRatio `pulumi:"goodTotalRatio"`
}

// RequestBasedSliInput is an input type that accepts RequestBasedSliArgs and RequestBasedSliOutput values.
// You can construct a concrete instance of `RequestBasedSliInput` via:
//
//          RequestBasedSliArgs{...}
type RequestBasedSliInput interface {
	pulumi.Input

	ToRequestBasedSliOutput() RequestBasedSliOutput
	ToRequestBasedSliOutputWithContext(context.Context) RequestBasedSliOutput
}

// Service Level Indicators for which atomic units of service are counted directly.
type RequestBasedSliArgs struct {
	// distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
	DistributionCut DistributionCutPtrInput `pulumi:"distributionCut"`
	// good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
	GoodTotalRatio TimeSeriesRatioPtrInput `pulumi:"goodTotalRatio"`
}

func (RequestBasedSliArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RequestBasedSli)(nil)).Elem()
}

func (i RequestBasedSliArgs) ToRequestBasedSliOutput() RequestBasedSliOutput {
	return i.ToRequestBasedSliOutputWithContext(context.Background())
}

func (i RequestBasedSliArgs) ToRequestBasedSliOutputWithContext(ctx context.Context) RequestBasedSliOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RequestBasedSliOutput)
}

func (i RequestBasedSliArgs) ToRequestBasedSliPtrOutput() RequestBasedSliPtrOutput {
	return i.ToRequestBasedSliPtrOutputWithContext(context.Background())
}

func (i RequestBasedSliArgs) ToRequestBasedSliPtrOutputWithContext(ctx context.Context) RequestBasedSliPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RequestBasedSliOutput).ToRequestBasedSliPtrOutputWithContext(ctx)
}

// RequestBasedSliPtrInput is an input type that accepts RequestBasedSliArgs, RequestBasedSliPtr and RequestBasedSliPtrOutput values.
// You can construct a concrete instance of `RequestBasedSliPtrInput` via:
//
//          RequestBasedSliArgs{...}
//
//  or:
//
//          nil
type RequestBasedSliPtrInput interface {
	pulumi.Input

	ToRequestBasedSliPtrOutput() RequestBasedSliPtrOutput
	ToRequestBasedSliPtrOutputWithContext(context.Context) RequestBasedSliPtrOutput
}

type requestBasedSliPtrType RequestBasedSliArgs

func RequestBasedSliPtr(v *RequestBasedSliArgs) RequestBasedSliPtrInput {
	return (*requestBasedSliPtrType)(v)
}

func (*requestBasedSliPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RequestBasedSli)(nil)).Elem()
}

func (i *requestBasedSliPtrType) ToRequestBasedSliPtrOutput() RequestBasedSliPtrOutput {
	return i.ToRequestBasedSliPtrOutputWithContext(context.Background())
}

func (i *requestBasedSliPtrType) ToRequestBasedSliPtrOutputWithContext(ctx context.Context) RequestBasedSliPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RequestBasedSliPtrOutput)
}

// Service Level Indicators for which atomic units of service are counted directly.
type RequestBasedSliOutput struct{ *pulumi.OutputState }

func (RequestBasedSliOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RequestBasedSli)(nil)).Elem()
}

func (o RequestBasedSliOutput) ToRequestBasedSliOutput() RequestBasedSliOutput {
	return o
}

func (o RequestBasedSliOutput) ToRequestBasedSliOutputWithContext(ctx context.Context) RequestBasedSliOutput {
	return o
}

func (o RequestBasedSliOutput) ToRequestBasedSliPtrOutput() RequestBasedSliPtrOutput {
	return o.ToRequestBasedSliPtrOutputWithContext(context.Background())
}

func (o RequestBasedSliOutput) ToRequestBasedSliPtrOutputWithContext(ctx context.Context) RequestBasedSliPtrOutput {
	return o.ApplyT(func(v RequestBasedSli) *RequestBasedSli {
		return &v
	}).(RequestBasedSliPtrOutput)
}

// distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
func (o RequestBasedSliOutput) DistributionCut() DistributionCutPtrOutput {
	return o.ApplyT(func(v RequestBasedSli) *DistributionCut { return v.DistributionCut }).(DistributionCutPtrOutput)
}

// good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
func (o RequestBasedSliOutput) GoodTotalRatio() TimeSeriesRatioPtrOutput {
	return o.ApplyT(func(v RequestBasedSli) *TimeSeriesRatio { return v.GoodTotalRatio }).(TimeSeriesRatioPtrOutput)
}

type RequestBasedSliPtrOutput struct{ *pulumi.OutputState }

func (RequestBasedSliPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RequestBasedSli)(nil)).Elem()
}

func (o RequestBasedSliPtrOutput) ToRequestBasedSliPtrOutput() RequestBasedSliPtrOutput {
	return o
}

func (o RequestBasedSliPtrOutput) ToRequestBasedSliPtrOutputWithContext(ctx context.Context) RequestBasedSliPtrOutput {
	return o
}

func (o RequestBasedSliPtrOutput) Elem() RequestBasedSliOutput {
	return o.ApplyT(func(v *RequestBasedSli) RequestBasedSli { return *v }).(RequestBasedSliOutput)
}

// distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
func (o RequestBasedSliPtrOutput) DistributionCut() DistributionCutPtrOutput {
	return o.ApplyT(func(v *RequestBasedSli) *DistributionCut {
		if v == nil {
			return nil
		}
		return v.DistributionCut
	}).(DistributionCutPtrOutput)
}

// good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
func (o RequestBasedSliPtrOutput) GoodTotalRatio() TimeSeriesRatioPtrOutput {
	return o.ApplyT(func(v *RequestBasedSli) *TimeSeriesRatio {
		if v == nil {
			return nil
		}
		return v.GoodTotalRatio
	}).(TimeSeriesRatioPtrOutput)
}

// The resource submessage for group checks. It can be used instead of a monitored resource, when multiple resources are being monitored.
type ResourceGroup struct {
	// The group of resources being monitored. Should be only the [GROUP_ID], and not the full-path projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID].
	GroupId *string `pulumi:"groupId"`
	// The resource type of the group members.
	ResourceType *string `pulumi:"resourceType"`
}

// ResourceGroupInput is an input type that accepts ResourceGroupArgs and ResourceGroupOutput values.
// You can construct a concrete instance of `ResourceGroupInput` via:
//
//          ResourceGroupArgs{...}
type ResourceGroupInput interface {
	pulumi.Input

	ToResourceGroupOutput() ResourceGroupOutput
	ToResourceGroupOutputWithContext(context.Context) ResourceGroupOutput
}

// The resource submessage for group checks. It can be used instead of a monitored resource, when multiple resources are being monitored.
type ResourceGroupArgs struct {
	// The group of resources being monitored. Should be only the [GROUP_ID], and not the full-path projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID].
	GroupId pulumi.StringPtrInput `pulumi:"groupId"`
	// The resource type of the group members.
	ResourceType pulumi.StringPtrInput `pulumi:"resourceType"`
}

func (ResourceGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceGroup)(nil)).Elem()
}

func (i ResourceGroupArgs) ToResourceGroupOutput() ResourceGroupOutput {
	return i.ToResourceGroupOutputWithContext(context.Background())
}

func (i ResourceGroupArgs) ToResourceGroupOutputWithContext(ctx context.Context) ResourceGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceGroupOutput)
}

func (i ResourceGroupArgs) ToResourceGroupPtrOutput() ResourceGroupPtrOutput {
	return i.ToResourceGroupPtrOutputWithContext(context.Background())
}

func (i ResourceGroupArgs) ToResourceGroupPtrOutputWithContext(ctx context.Context) ResourceGroupPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceGroupOutput).ToResourceGroupPtrOutputWithContext(ctx)
}

// ResourceGroupPtrInput is an input type that accepts ResourceGroupArgs, ResourceGroupPtr and ResourceGroupPtrOutput values.
// You can construct a concrete instance of `ResourceGroupPtrInput` via:
//
//          ResourceGroupArgs{...}
//
//  or:
//
//          nil
type ResourceGroupPtrInput interface {
	pulumi.Input

	ToResourceGroupPtrOutput() ResourceGroupPtrOutput
	ToResourceGroupPtrOutputWithContext(context.Context) ResourceGroupPtrOutput
}

type resourceGroupPtrType ResourceGroupArgs

func ResourceGroupPtr(v *ResourceGroupArgs) ResourceGroupPtrInput {
	return (*resourceGroupPtrType)(v)
}

func (*resourceGroupPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceGroup)(nil)).Elem()
}

func (i *resourceGroupPtrType) ToResourceGroupPtrOutput() ResourceGroupPtrOutput {
	return i.ToResourceGroupPtrOutputWithContext(context.Background())
}

func (i *resourceGroupPtrType) ToResourceGroupPtrOutputWithContext(ctx context.Context) ResourceGroupPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceGroupPtrOutput)
}

// The resource submessage for group checks. It can be used instead of a monitored resource, when multiple resources are being monitored.
type ResourceGroupOutput struct{ *pulumi.OutputState }

func (ResourceGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ResourceGroup)(nil)).Elem()
}

func (o ResourceGroupOutput) ToResourceGroupOutput() ResourceGroupOutput {
	return o
}

func (o ResourceGroupOutput) ToResourceGroupOutputWithContext(ctx context.Context) ResourceGroupOutput {
	return o
}

func (o ResourceGroupOutput) ToResourceGroupPtrOutput() ResourceGroupPtrOutput {
	return o.ToResourceGroupPtrOutputWithContext(context.Background())
}

func (o ResourceGroupOutput) ToResourceGroupPtrOutputWithContext(ctx context.Context) ResourceGroupPtrOutput {
	return o.ApplyT(func(v ResourceGroup) *ResourceGroup {
		return &v
	}).(ResourceGroupPtrOutput)
}

// The group of resources being monitored. Should be only the [GROUP_ID], and not the full-path projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID].
func (o ResourceGroupOutput) GroupId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceGroup) *string { return v.GroupId }).(pulumi.StringPtrOutput)
}

// The resource type of the group members.
func (o ResourceGroupOutput) ResourceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ResourceGroup) *string { return v.ResourceType }).(pulumi.StringPtrOutput)
}

type ResourceGroupPtrOutput struct{ *pulumi.OutputState }

func (ResourceGroupPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceGroup)(nil)).Elem()
}

func (o ResourceGroupPtrOutput) ToResourceGroupPtrOutput() ResourceGroupPtrOutput {
	return o
}

func (o ResourceGroupPtrOutput) ToResourceGroupPtrOutputWithContext(ctx context.Context) ResourceGroupPtrOutput {
	return o
}

func (o ResourceGroupPtrOutput) Elem() ResourceGroupOutput {
	return o.ApplyT(func(v *ResourceGroup) ResourceGroup { return *v }).(ResourceGroupOutput)
}

// The group of resources being monitored. Should be only the [GROUP_ID], and not the full-path projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID].
func (o ResourceGroupPtrOutput) GroupId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourceGroup) *string {
		if v == nil {
			return nil
		}
		return v.GroupId
	}).(pulumi.StringPtrOutput)
}

// The resource type of the group members.
func (o ResourceGroupPtrOutput) ResourceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourceGroup) *string {
		if v == nil {
			return nil
		}
		return v.ResourceType
	}).(pulumi.StringPtrOutput)
}

// A Service-Level Indicator (SLI) describes the "performance" of a service. For some services, the SLI is well-defined. In such cases, the SLI can be described easily by referencing the well-known SLI and providing the needed parameters. Alternatively, a "custom" SLI can be defined with a query to the underlying metric store. An SLI is defined to be good_service / total_service over any queried time interval. The value of performance always falls into the range 0 <= performance <= 1. A custom SLI describes how to compute this ratio, whether this is by dividing values from a pair of time series, cutting a Distribution into good and bad counts, or counting time windows in which the service complies with a criterion. For separation of concerns, a single Service-Level Indicator measures performance for only one aspect of service quality, such as fraction of successful queries or fast-enough queries.
type ServiceLevelIndicator struct {
	// Basic SLI on a well-known service type.
	BasicSli *BasicSli `pulumi:"basicSli"`
	// Request-based SLIs
	RequestBased *RequestBasedSli `pulumi:"requestBased"`
	// Windows-based SLIs
	WindowsBased *WindowsBasedSli `pulumi:"windowsBased"`
}

// ServiceLevelIndicatorInput is an input type that accepts ServiceLevelIndicatorArgs and ServiceLevelIndicatorOutput values.
// You can construct a concrete instance of `ServiceLevelIndicatorInput` via:
//
//          ServiceLevelIndicatorArgs{...}
type ServiceLevelIndicatorInput interface {
	pulumi.Input

	ToServiceLevelIndicatorOutput() ServiceLevelIndicatorOutput
	ToServiceLevelIndicatorOutputWithContext(context.Context) ServiceLevelIndicatorOutput
}

// A Service-Level Indicator (SLI) describes the "performance" of a service. For some services, the SLI is well-defined. In such cases, the SLI can be described easily by referencing the well-known SLI and providing the needed parameters. Alternatively, a "custom" SLI can be defined with a query to the underlying metric store. An SLI is defined to be good_service / total_service over any queried time interval. The value of performance always falls into the range 0 <= performance <= 1. A custom SLI describes how to compute this ratio, whether this is by dividing values from a pair of time series, cutting a Distribution into good and bad counts, or counting time windows in which the service complies with a criterion. For separation of concerns, a single Service-Level Indicator measures performance for only one aspect of service quality, such as fraction of successful queries or fast-enough queries.
type ServiceLevelIndicatorArgs struct {
	// Basic SLI on a well-known service type.
	BasicSli BasicSliPtrInput `pulumi:"basicSli"`
	// Request-based SLIs
	RequestBased RequestBasedSliPtrInput `pulumi:"requestBased"`
	// Windows-based SLIs
	WindowsBased WindowsBasedSliPtrInput `pulumi:"windowsBased"`
}

func (ServiceLevelIndicatorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceLevelIndicator)(nil)).Elem()
}

func (i ServiceLevelIndicatorArgs) ToServiceLevelIndicatorOutput() ServiceLevelIndicatorOutput {
	return i.ToServiceLevelIndicatorOutputWithContext(context.Background())
}

func (i ServiceLevelIndicatorArgs) ToServiceLevelIndicatorOutputWithContext(ctx context.Context) ServiceLevelIndicatorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceLevelIndicatorOutput)
}

func (i ServiceLevelIndicatorArgs) ToServiceLevelIndicatorPtrOutput() ServiceLevelIndicatorPtrOutput {
	return i.ToServiceLevelIndicatorPtrOutputWithContext(context.Background())
}

func (i ServiceLevelIndicatorArgs) ToServiceLevelIndicatorPtrOutputWithContext(ctx context.Context) ServiceLevelIndicatorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceLevelIndicatorOutput).ToServiceLevelIndicatorPtrOutputWithContext(ctx)
}

// ServiceLevelIndicatorPtrInput is an input type that accepts ServiceLevelIndicatorArgs, ServiceLevelIndicatorPtr and ServiceLevelIndicatorPtrOutput values.
// You can construct a concrete instance of `ServiceLevelIndicatorPtrInput` via:
//
//          ServiceLevelIndicatorArgs{...}
//
//  or:
//
//          nil
type ServiceLevelIndicatorPtrInput interface {
	pulumi.Input

	ToServiceLevelIndicatorPtrOutput() ServiceLevelIndicatorPtrOutput
	ToServiceLevelIndicatorPtrOutputWithContext(context.Context) ServiceLevelIndicatorPtrOutput
}

type serviceLevelIndicatorPtrType ServiceLevelIndicatorArgs

func ServiceLevelIndicatorPtr(v *ServiceLevelIndicatorArgs) ServiceLevelIndicatorPtrInput {
	return (*serviceLevelIndicatorPtrType)(v)
}

func (*serviceLevelIndicatorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceLevelIndicator)(nil)).Elem()
}

func (i *serviceLevelIndicatorPtrType) ToServiceLevelIndicatorPtrOutput() ServiceLevelIndicatorPtrOutput {
	return i.ToServiceLevelIndicatorPtrOutputWithContext(context.Background())
}

func (i *serviceLevelIndicatorPtrType) ToServiceLevelIndicatorPtrOutputWithContext(ctx context.Context) ServiceLevelIndicatorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceLevelIndicatorPtrOutput)
}

// A Service-Level Indicator (SLI) describes the "performance" of a service. For some services, the SLI is well-defined. In such cases, the SLI can be described easily by referencing the well-known SLI and providing the needed parameters. Alternatively, a "custom" SLI can be defined with a query to the underlying metric store. An SLI is defined to be good_service / total_service over any queried time interval. The value of performance always falls into the range 0 <= performance <= 1. A custom SLI describes how to compute this ratio, whether this is by dividing values from a pair of time series, cutting a Distribution into good and bad counts, or counting time windows in which the service complies with a criterion. For separation of concerns, a single Service-Level Indicator measures performance for only one aspect of service quality, such as fraction of successful queries or fast-enough queries.
type ServiceLevelIndicatorOutput struct{ *pulumi.OutputState }

func (ServiceLevelIndicatorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceLevelIndicator)(nil)).Elem()
}

func (o ServiceLevelIndicatorOutput) ToServiceLevelIndicatorOutput() ServiceLevelIndicatorOutput {
	return o
}

func (o ServiceLevelIndicatorOutput) ToServiceLevelIndicatorOutputWithContext(ctx context.Context) ServiceLevelIndicatorOutput {
	return o
}

func (o ServiceLevelIndicatorOutput) ToServiceLevelIndicatorPtrOutput() ServiceLevelIndicatorPtrOutput {
	return o.ToServiceLevelIndicatorPtrOutputWithContext(context.Background())
}

func (o ServiceLevelIndicatorOutput) ToServiceLevelIndicatorPtrOutputWithContext(ctx context.Context) ServiceLevelIndicatorPtrOutput {
	return o.ApplyT(func(v ServiceLevelIndicator) *ServiceLevelIndicator {
		return &v
	}).(ServiceLevelIndicatorPtrOutput)
}

// Basic SLI on a well-known service type.
func (o ServiceLevelIndicatorOutput) BasicSli() BasicSliPtrOutput {
	return o.ApplyT(func(v ServiceLevelIndicator) *BasicSli { return v.BasicSli }).(BasicSliPtrOutput)
}

// Request-based SLIs
func (o ServiceLevelIndicatorOutput) RequestBased() RequestBasedSliPtrOutput {
	return o.ApplyT(func(v ServiceLevelIndicator) *RequestBasedSli { return v.RequestBased }).(RequestBasedSliPtrOutput)
}

// Windows-based SLIs
func (o ServiceLevelIndicatorOutput) WindowsBased() WindowsBasedSliPtrOutput {
	return o.ApplyT(func(v ServiceLevelIndicator) *WindowsBasedSli { return v.WindowsBased }).(WindowsBasedSliPtrOutput)
}

type ServiceLevelIndicatorPtrOutput struct{ *pulumi.OutputState }

func (ServiceLevelIndicatorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceLevelIndicator)(nil)).Elem()
}

func (o ServiceLevelIndicatorPtrOutput) ToServiceLevelIndicatorPtrOutput() ServiceLevelIndicatorPtrOutput {
	return o
}

func (o ServiceLevelIndicatorPtrOutput) ToServiceLevelIndicatorPtrOutputWithContext(ctx context.Context) ServiceLevelIndicatorPtrOutput {
	return o
}

func (o ServiceLevelIndicatorPtrOutput) Elem() ServiceLevelIndicatorOutput {
	return o.ApplyT(func(v *ServiceLevelIndicator) ServiceLevelIndicator { return *v }).(ServiceLevelIndicatorOutput)
}

// Basic SLI on a well-known service type.
func (o ServiceLevelIndicatorPtrOutput) BasicSli() BasicSliPtrOutput {
	return o.ApplyT(func(v *ServiceLevelIndicator) *BasicSli {
		if v == nil {
			return nil
		}
		return v.BasicSli
	}).(BasicSliPtrOutput)
}

// Request-based SLIs
func (o ServiceLevelIndicatorPtrOutput) RequestBased() RequestBasedSliPtrOutput {
	return o.ApplyT(func(v *ServiceLevelIndicator) *RequestBasedSli {
		if v == nil {
			return nil
		}
		return v.RequestBased
	}).(RequestBasedSliPtrOutput)
}

// Windows-based SLIs
func (o ServiceLevelIndicatorPtrOutput) WindowsBased() WindowsBasedSliPtrOutput {
	return o.ApplyT(func(v *ServiceLevelIndicator) *WindowsBasedSli {
		if v == nil {
			return nil
		}
		return v.WindowsBased
	}).(WindowsBasedSliPtrOutput)
}

// The Status type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by gRPC (https://github.com/grpc). Each Status message contains three pieces of data: error code, error message, and error details.You can find out more about this error model and how to work with it in the API Design Guide (https://cloud.google.com/apis/design/errors).
type Status struct {
	// The status code, which should be an enum value of google.rpc.Code.
	Code *int `pulumi:"code"`
	// A list of messages that carry the error details. There is a common set of message types for APIs to use.
	Details []map[string]string `pulumi:"details"`
	// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
	Message *string `pulumi:"message"`
}

// StatusInput is an input type that accepts StatusArgs and StatusOutput values.
// You can construct a concrete instance of `StatusInput` via:
//
//          StatusArgs{...}
type StatusInput interface {
	pulumi.Input

	ToStatusOutput() StatusOutput
	ToStatusOutputWithContext(context.Context) StatusOutput
}

// The Status type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by gRPC (https://github.com/grpc). Each Status message contains three pieces of data: error code, error message, and error details.You can find out more about this error model and how to work with it in the API Design Guide (https://cloud.google.com/apis/design/errors).
type StatusArgs struct {
	// The status code, which should be an enum value of google.rpc.Code.
	Code pulumi.IntPtrInput `pulumi:"code"`
	// A list of messages that carry the error details. There is a common set of message types for APIs to use.
	Details pulumi.StringMapArrayInput `pulumi:"details"`
	// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
	Message pulumi.StringPtrInput `pulumi:"message"`
}

func (StatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Status)(nil)).Elem()
}

func (i StatusArgs) ToStatusOutput() StatusOutput {
	return i.ToStatusOutputWithContext(context.Background())
}

func (i StatusArgs) ToStatusOutputWithContext(ctx context.Context) StatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatusOutput)
}

func (i StatusArgs) ToStatusPtrOutput() StatusPtrOutput {
	return i.ToStatusPtrOutputWithContext(context.Background())
}

func (i StatusArgs) ToStatusPtrOutputWithContext(ctx context.Context) StatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatusOutput).ToStatusPtrOutputWithContext(ctx)
}

// StatusPtrInput is an input type that accepts StatusArgs, StatusPtr and StatusPtrOutput values.
// You can construct a concrete instance of `StatusPtrInput` via:
//
//          StatusArgs{...}
//
//  or:
//
//          nil
type StatusPtrInput interface {
	pulumi.Input

	ToStatusPtrOutput() StatusPtrOutput
	ToStatusPtrOutputWithContext(context.Context) StatusPtrOutput
}

type statusPtrType StatusArgs

func StatusPtr(v *StatusArgs) StatusPtrInput {
	return (*statusPtrType)(v)
}

func (*statusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Status)(nil)).Elem()
}

func (i *statusPtrType) ToStatusPtrOutput() StatusPtrOutput {
	return i.ToStatusPtrOutputWithContext(context.Background())
}

func (i *statusPtrType) ToStatusPtrOutputWithContext(ctx context.Context) StatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatusPtrOutput)
}

// The Status type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by gRPC (https://github.com/grpc). Each Status message contains three pieces of data: error code, error message, and error details.You can find out more about this error model and how to work with it in the API Design Guide (https://cloud.google.com/apis/design/errors).
type StatusOutput struct{ *pulumi.OutputState }

func (StatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Status)(nil)).Elem()
}

func (o StatusOutput) ToStatusOutput() StatusOutput {
	return o
}

func (o StatusOutput) ToStatusOutputWithContext(ctx context.Context) StatusOutput {
	return o
}

func (o StatusOutput) ToStatusPtrOutput() StatusPtrOutput {
	return o.ToStatusPtrOutputWithContext(context.Background())
}

func (o StatusOutput) ToStatusPtrOutputWithContext(ctx context.Context) StatusPtrOutput {
	return o.ApplyT(func(v Status) *Status {
		return &v
	}).(StatusPtrOutput)
}

// The status code, which should be an enum value of google.rpc.Code.
func (o StatusOutput) Code() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Status) *int { return v.Code }).(pulumi.IntPtrOutput)
}

// A list of messages that carry the error details. There is a common set of message types for APIs to use.
func (o StatusOutput) Details() pulumi.StringMapArrayOutput {
	return o.ApplyT(func(v Status) []map[string]string { return v.Details }).(pulumi.StringMapArrayOutput)
}

// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
func (o StatusOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Status) *string { return v.Message }).(pulumi.StringPtrOutput)
}

type StatusPtrOutput struct{ *pulumi.OutputState }

func (StatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Status)(nil)).Elem()
}

func (o StatusPtrOutput) ToStatusPtrOutput() StatusPtrOutput {
	return o
}

func (o StatusPtrOutput) ToStatusPtrOutputWithContext(ctx context.Context) StatusPtrOutput {
	return o
}

func (o StatusPtrOutput) Elem() StatusOutput {
	return o.ApplyT(func(v *Status) Status { return *v }).(StatusOutput)
}

// The status code, which should be an enum value of google.rpc.Code.
func (o StatusPtrOutput) Code() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Status) *int {
		if v == nil {
			return nil
		}
		return v.Code
	}).(pulumi.IntPtrOutput)
}

// A list of messages that carry the error details. There is a common set of message types for APIs to use.
func (o StatusPtrOutput) Details() pulumi.StringMapArrayOutput {
	return o.ApplyT(func(v *Status) []map[string]string {
		if v == nil {
			return nil
		}
		return v.Details
	}).(pulumi.StringMapArrayOutput)
}

// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
func (o StatusPtrOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Status) *string {
		if v == nil {
			return nil
		}
		return v.Message
	}).(pulumi.StringPtrOutput)
}

// Information required for a TCP Uptime check request.
type TcpCheck struct {
	// The TCP port on the server against which to run the check. Will be combined with host (specified within the monitored_resource) to construct the full URL. Required.
	Port *int `pulumi:"port"`
}

// TcpCheckInput is an input type that accepts TcpCheckArgs and TcpCheckOutput values.
// You can construct a concrete instance of `TcpCheckInput` via:
//
//          TcpCheckArgs{...}
type TcpCheckInput interface {
	pulumi.Input

	ToTcpCheckOutput() TcpCheckOutput
	ToTcpCheckOutputWithContext(context.Context) TcpCheckOutput
}

// Information required for a TCP Uptime check request.
type TcpCheckArgs struct {
	// The TCP port on the server against which to run the check. Will be combined with host (specified within the monitored_resource) to construct the full URL. Required.
	Port pulumi.IntPtrInput `pulumi:"port"`
}

func (TcpCheckArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TcpCheck)(nil)).Elem()
}

func (i TcpCheckArgs) ToTcpCheckOutput() TcpCheckOutput {
	return i.ToTcpCheckOutputWithContext(context.Background())
}

func (i TcpCheckArgs) ToTcpCheckOutputWithContext(ctx context.Context) TcpCheckOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TcpCheckOutput)
}

func (i TcpCheckArgs) ToTcpCheckPtrOutput() TcpCheckPtrOutput {
	return i.ToTcpCheckPtrOutputWithContext(context.Background())
}

func (i TcpCheckArgs) ToTcpCheckPtrOutputWithContext(ctx context.Context) TcpCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TcpCheckOutput).ToTcpCheckPtrOutputWithContext(ctx)
}

// TcpCheckPtrInput is an input type that accepts TcpCheckArgs, TcpCheckPtr and TcpCheckPtrOutput values.
// You can construct a concrete instance of `TcpCheckPtrInput` via:
//
//          TcpCheckArgs{...}
//
//  or:
//
//          nil
type TcpCheckPtrInput interface {
	pulumi.Input

	ToTcpCheckPtrOutput() TcpCheckPtrOutput
	ToTcpCheckPtrOutputWithContext(context.Context) TcpCheckPtrOutput
}

type tcpCheckPtrType TcpCheckArgs

func TcpCheckPtr(v *TcpCheckArgs) TcpCheckPtrInput {
	return (*tcpCheckPtrType)(v)
}

func (*tcpCheckPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TcpCheck)(nil)).Elem()
}

func (i *tcpCheckPtrType) ToTcpCheckPtrOutput() TcpCheckPtrOutput {
	return i.ToTcpCheckPtrOutputWithContext(context.Background())
}

func (i *tcpCheckPtrType) ToTcpCheckPtrOutputWithContext(ctx context.Context) TcpCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TcpCheckPtrOutput)
}

// Information required for a TCP Uptime check request.
type TcpCheckOutput struct{ *pulumi.OutputState }

func (TcpCheckOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TcpCheck)(nil)).Elem()
}

func (o TcpCheckOutput) ToTcpCheckOutput() TcpCheckOutput {
	return o
}

func (o TcpCheckOutput) ToTcpCheckOutputWithContext(ctx context.Context) TcpCheckOutput {
	return o
}

func (o TcpCheckOutput) ToTcpCheckPtrOutput() TcpCheckPtrOutput {
	return o.ToTcpCheckPtrOutputWithContext(context.Background())
}

func (o TcpCheckOutput) ToTcpCheckPtrOutputWithContext(ctx context.Context) TcpCheckPtrOutput {
	return o.ApplyT(func(v TcpCheck) *TcpCheck {
		return &v
	}).(TcpCheckPtrOutput)
}

// The TCP port on the server against which to run the check. Will be combined with host (specified within the monitored_resource) to construct the full URL. Required.
func (o TcpCheckOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TcpCheck) *int { return v.Port }).(pulumi.IntPtrOutput)
}

type TcpCheckPtrOutput struct{ *pulumi.OutputState }

func (TcpCheckPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TcpCheck)(nil)).Elem()
}

func (o TcpCheckPtrOutput) ToTcpCheckPtrOutput() TcpCheckPtrOutput {
	return o
}

func (o TcpCheckPtrOutput) ToTcpCheckPtrOutputWithContext(ctx context.Context) TcpCheckPtrOutput {
	return o
}

func (o TcpCheckPtrOutput) Elem() TcpCheckOutput {
	return o.ApplyT(func(v *TcpCheck) TcpCheck { return *v }).(TcpCheckOutput)
}

// The TCP port on the server against which to run the check. Will be combined with host (specified within the monitored_resource) to construct the full URL. Required.
func (o TcpCheckPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *TcpCheck) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// Configuration for how to query telemetry on a Service.
type Telemetry struct {
	// The full name of the resource that defines this service. Formatted as described in https://cloud.google.com/apis/design/resource_names.
	ResourceName *string `pulumi:"resourceName"`
}

// TelemetryInput is an input type that accepts TelemetryArgs and TelemetryOutput values.
// You can construct a concrete instance of `TelemetryInput` via:
//
//          TelemetryArgs{...}
type TelemetryInput interface {
	pulumi.Input

	ToTelemetryOutput() TelemetryOutput
	ToTelemetryOutputWithContext(context.Context) TelemetryOutput
}

// Configuration for how to query telemetry on a Service.
type TelemetryArgs struct {
	// The full name of the resource that defines this service. Formatted as described in https://cloud.google.com/apis/design/resource_names.
	ResourceName pulumi.StringPtrInput `pulumi:"resourceName"`
}

func (TelemetryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Telemetry)(nil)).Elem()
}

func (i TelemetryArgs) ToTelemetryOutput() TelemetryOutput {
	return i.ToTelemetryOutputWithContext(context.Background())
}

func (i TelemetryArgs) ToTelemetryOutputWithContext(ctx context.Context) TelemetryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TelemetryOutput)
}

func (i TelemetryArgs) ToTelemetryPtrOutput() TelemetryPtrOutput {
	return i.ToTelemetryPtrOutputWithContext(context.Background())
}

func (i TelemetryArgs) ToTelemetryPtrOutputWithContext(ctx context.Context) TelemetryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TelemetryOutput).ToTelemetryPtrOutputWithContext(ctx)
}

// TelemetryPtrInput is an input type that accepts TelemetryArgs, TelemetryPtr and TelemetryPtrOutput values.
// You can construct a concrete instance of `TelemetryPtrInput` via:
//
//          TelemetryArgs{...}
//
//  or:
//
//          nil
type TelemetryPtrInput interface {
	pulumi.Input

	ToTelemetryPtrOutput() TelemetryPtrOutput
	ToTelemetryPtrOutputWithContext(context.Context) TelemetryPtrOutput
}

type telemetryPtrType TelemetryArgs

func TelemetryPtr(v *TelemetryArgs) TelemetryPtrInput {
	return (*telemetryPtrType)(v)
}

func (*telemetryPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Telemetry)(nil)).Elem()
}

func (i *telemetryPtrType) ToTelemetryPtrOutput() TelemetryPtrOutput {
	return i.ToTelemetryPtrOutputWithContext(context.Background())
}

func (i *telemetryPtrType) ToTelemetryPtrOutputWithContext(ctx context.Context) TelemetryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TelemetryPtrOutput)
}

// Configuration for how to query telemetry on a Service.
type TelemetryOutput struct{ *pulumi.OutputState }

func (TelemetryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Telemetry)(nil)).Elem()
}

func (o TelemetryOutput) ToTelemetryOutput() TelemetryOutput {
	return o
}

func (o TelemetryOutput) ToTelemetryOutputWithContext(ctx context.Context) TelemetryOutput {
	return o
}

func (o TelemetryOutput) ToTelemetryPtrOutput() TelemetryPtrOutput {
	return o.ToTelemetryPtrOutputWithContext(context.Background())
}

func (o TelemetryOutput) ToTelemetryPtrOutputWithContext(ctx context.Context) TelemetryPtrOutput {
	return o.ApplyT(func(v Telemetry) *Telemetry {
		return &v
	}).(TelemetryPtrOutput)
}

// The full name of the resource that defines this service. Formatted as described in https://cloud.google.com/apis/design/resource_names.
func (o TelemetryOutput) ResourceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Telemetry) *string { return v.ResourceName }).(pulumi.StringPtrOutput)
}

type TelemetryPtrOutput struct{ *pulumi.OutputState }

func (TelemetryPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Telemetry)(nil)).Elem()
}

func (o TelemetryPtrOutput) ToTelemetryPtrOutput() TelemetryPtrOutput {
	return o
}

func (o TelemetryPtrOutput) ToTelemetryPtrOutputWithContext(ctx context.Context) TelemetryPtrOutput {
	return o
}

func (o TelemetryPtrOutput) Elem() TelemetryOutput {
	return o.ApplyT(func(v *Telemetry) Telemetry { return *v }).(TelemetryOutput)
}

// The full name of the resource that defines this service. Formatted as described in https://cloud.google.com/apis/design/resource_names.
func (o TelemetryPtrOutput) ResourceName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Telemetry) *string {
		if v == nil {
			return nil
		}
		return v.ResourceName
	}).(pulumi.StringPtrOutput)
}

// A closed time interval. It extends from the start time to the end time, and includes both: [startTime, endTime]. Valid time intervals depend on the MetricKind of the metric value. The end time must not be earlier than the start time. When writing data points, the start time must not be more than 25 hours in the past and the end time must not be more than five minutes in the future. For GAUGE metrics, the startTime value is technically optional; if no value is specified, the start time defaults to the value of the end time, and the interval represents a single point in time. If both start and end times are specified, they must be identical. Such an interval is valid only for GAUGE metrics, which are point-in-time measurements. The end time of a new interval must be at least a millisecond after the end time of the previous interval. For DELTA metrics, the start time and end time must specify a non-zero interval, with subsequent points specifying contiguous and non-overlapping intervals. For DELTA metrics, the start time of the next interval must be at least a millisecond after the end time of the previous interval. For CUMULATIVE metrics, the start time and end time must specify a a non-zero interval, with subsequent points specifying the same start time and increasing end times, until an event resets the cumulative value to zero and sets a new start time for the following points. The new start time must be at least a millisecond after the end time of the previous interval. The start time of a new interval must be at least a millisecond after the end time of the previous interval because intervals are closed. If the start time of a new interval is the same as the end time of the previous interval, then data written at the new start time could overwrite data written at the previous end time.
type TimeInterval struct {
	// Required. The end of the time interval.
	EndTime *string `pulumi:"endTime"`
	// Optional. The beginning of the time interval. The default value for the start time is the end time. The start time must not be later than the end time.
	StartTime *string `pulumi:"startTime"`
}

// TimeIntervalInput is an input type that accepts TimeIntervalArgs and TimeIntervalOutput values.
// You can construct a concrete instance of `TimeIntervalInput` via:
//
//          TimeIntervalArgs{...}
type TimeIntervalInput interface {
	pulumi.Input

	ToTimeIntervalOutput() TimeIntervalOutput
	ToTimeIntervalOutputWithContext(context.Context) TimeIntervalOutput
}

// A closed time interval. It extends from the start time to the end time, and includes both: [startTime, endTime]. Valid time intervals depend on the MetricKind of the metric value. The end time must not be earlier than the start time. When writing data points, the start time must not be more than 25 hours in the past and the end time must not be more than five minutes in the future. For GAUGE metrics, the startTime value is technically optional; if no value is specified, the start time defaults to the value of the end time, and the interval represents a single point in time. If both start and end times are specified, they must be identical. Such an interval is valid only for GAUGE metrics, which are point-in-time measurements. The end time of a new interval must be at least a millisecond after the end time of the previous interval. For DELTA metrics, the start time and end time must specify a non-zero interval, with subsequent points specifying contiguous and non-overlapping intervals. For DELTA metrics, the start time of the next interval must be at least a millisecond after the end time of the previous interval. For CUMULATIVE metrics, the start time and end time must specify a a non-zero interval, with subsequent points specifying the same start time and increasing end times, until an event resets the cumulative value to zero and sets a new start time for the following points. The new start time must be at least a millisecond after the end time of the previous interval. The start time of a new interval must be at least a millisecond after the end time of the previous interval because intervals are closed. If the start time of a new interval is the same as the end time of the previous interval, then data written at the new start time could overwrite data written at the previous end time.
type TimeIntervalArgs struct {
	// Required. The end of the time interval.
	EndTime pulumi.StringPtrInput `pulumi:"endTime"`
	// Optional. The beginning of the time interval. The default value for the start time is the end time. The start time must not be later than the end time.
	StartTime pulumi.StringPtrInput `pulumi:"startTime"`
}

func (TimeIntervalArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeInterval)(nil)).Elem()
}

func (i TimeIntervalArgs) ToTimeIntervalOutput() TimeIntervalOutput {
	return i.ToTimeIntervalOutputWithContext(context.Background())
}

func (i TimeIntervalArgs) ToTimeIntervalOutputWithContext(ctx context.Context) TimeIntervalOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeIntervalOutput)
}

func (i TimeIntervalArgs) ToTimeIntervalPtrOutput() TimeIntervalPtrOutput {
	return i.ToTimeIntervalPtrOutputWithContext(context.Background())
}

func (i TimeIntervalArgs) ToTimeIntervalPtrOutputWithContext(ctx context.Context) TimeIntervalPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeIntervalOutput).ToTimeIntervalPtrOutputWithContext(ctx)
}

// TimeIntervalPtrInput is an input type that accepts TimeIntervalArgs, TimeIntervalPtr and TimeIntervalPtrOutput values.
// You can construct a concrete instance of `TimeIntervalPtrInput` via:
//
//          TimeIntervalArgs{...}
//
//  or:
//
//          nil
type TimeIntervalPtrInput interface {
	pulumi.Input

	ToTimeIntervalPtrOutput() TimeIntervalPtrOutput
	ToTimeIntervalPtrOutputWithContext(context.Context) TimeIntervalPtrOutput
}

type timeIntervalPtrType TimeIntervalArgs

func TimeIntervalPtr(v *TimeIntervalArgs) TimeIntervalPtrInput {
	return (*timeIntervalPtrType)(v)
}

func (*timeIntervalPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeInterval)(nil)).Elem()
}

func (i *timeIntervalPtrType) ToTimeIntervalPtrOutput() TimeIntervalPtrOutput {
	return i.ToTimeIntervalPtrOutputWithContext(context.Background())
}

func (i *timeIntervalPtrType) ToTimeIntervalPtrOutputWithContext(ctx context.Context) TimeIntervalPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeIntervalPtrOutput)
}

// A closed time interval. It extends from the start time to the end time, and includes both: [startTime, endTime]. Valid time intervals depend on the MetricKind of the metric value. The end time must not be earlier than the start time. When writing data points, the start time must not be more than 25 hours in the past and the end time must not be more than five minutes in the future. For GAUGE metrics, the startTime value is technically optional; if no value is specified, the start time defaults to the value of the end time, and the interval represents a single point in time. If both start and end times are specified, they must be identical. Such an interval is valid only for GAUGE metrics, which are point-in-time measurements. The end time of a new interval must be at least a millisecond after the end time of the previous interval. For DELTA metrics, the start time and end time must specify a non-zero interval, with subsequent points specifying contiguous and non-overlapping intervals. For DELTA metrics, the start time of the next interval must be at least a millisecond after the end time of the previous interval. For CUMULATIVE metrics, the start time and end time must specify a a non-zero interval, with subsequent points specifying the same start time and increasing end times, until an event resets the cumulative value to zero and sets a new start time for the following points. The new start time must be at least a millisecond after the end time of the previous interval. The start time of a new interval must be at least a millisecond after the end time of the previous interval because intervals are closed. If the start time of a new interval is the same as the end time of the previous interval, then data written at the new start time could overwrite data written at the previous end time.
type TimeIntervalOutput struct{ *pulumi.OutputState }

func (TimeIntervalOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeInterval)(nil)).Elem()
}

func (o TimeIntervalOutput) ToTimeIntervalOutput() TimeIntervalOutput {
	return o
}

func (o TimeIntervalOutput) ToTimeIntervalOutputWithContext(ctx context.Context) TimeIntervalOutput {
	return o
}

func (o TimeIntervalOutput) ToTimeIntervalPtrOutput() TimeIntervalPtrOutput {
	return o.ToTimeIntervalPtrOutputWithContext(context.Background())
}

func (o TimeIntervalOutput) ToTimeIntervalPtrOutputWithContext(ctx context.Context) TimeIntervalPtrOutput {
	return o.ApplyT(func(v TimeInterval) *TimeInterval {
		return &v
	}).(TimeIntervalPtrOutput)
}

// Required. The end of the time interval.
func (o TimeIntervalOutput) EndTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeInterval) *string { return v.EndTime }).(pulumi.StringPtrOutput)
}

// Optional. The beginning of the time interval. The default value for the start time is the end time. The start time must not be later than the end time.
func (o TimeIntervalOutput) StartTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeInterval) *string { return v.StartTime }).(pulumi.StringPtrOutput)
}

type TimeIntervalPtrOutput struct{ *pulumi.OutputState }

func (TimeIntervalPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeInterval)(nil)).Elem()
}

func (o TimeIntervalPtrOutput) ToTimeIntervalPtrOutput() TimeIntervalPtrOutput {
	return o
}

func (o TimeIntervalPtrOutput) ToTimeIntervalPtrOutputWithContext(ctx context.Context) TimeIntervalPtrOutput {
	return o
}

func (o TimeIntervalPtrOutput) Elem() TimeIntervalOutput {
	return o.ApplyT(func(v *TimeInterval) TimeInterval { return *v }).(TimeIntervalOutput)
}

// Required. The end of the time interval.
func (o TimeIntervalPtrOutput) EndTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeInterval) *string {
		if v == nil {
			return nil
		}
		return v.EndTime
	}).(pulumi.StringPtrOutput)
}

// Optional. The beginning of the time interval. The default value for the start time is the end time. The start time must not be later than the end time.
func (o TimeIntervalPtrOutput) StartTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeInterval) *string {
		if v == nil {
			return nil
		}
		return v.StartTime
	}).(pulumi.StringPtrOutput)
}

// A collection of data points that describes the time-varying values of a metric. A time series is identified by a combination of a fully-specified monitored resource and a fully-specified metric. This type is used for both listing and creating time series.
type TimeSeries struct {
	// Output only. The associated monitored resource metadata. When reading a time series, this field will include metadata labels that are explicitly named in the reduction. When creating a time series, this field is ignored.
	Metadata *MonitoredResourceMetadata `pulumi:"metadata"`
	// The associated metric. A fully-specified metric used to identify the time series.
	Metric *Metric `pulumi:"metric"`
	// The metric kind of the time series. When listing time series, this metric kind might be different from the metric kind of the associated metric if this time series is an alignment or reduction of other time series.When creating a time series, this field is optional. If present, it must be the same as the metric kind of the associated metric. If the associated metric's descriptor must be auto-created, then this field specifies the metric kind of the new descriptor and must be either GAUGE (the default) or CUMULATIVE.
	MetricKind *string `pulumi:"metricKind"`
	// The data points of this time series. When listing time series, points are returned in reverse time order.When creating a time series, this field must contain exactly one point and the point's type must be the same as the value type of the associated metric. If the associated metric's descriptor must be auto-created, then the value type of the descriptor is determined by the point's type, which must be BOOL, INT64, DOUBLE, or DISTRIBUTION.
	Points []Point `pulumi:"points"`
	// The associated monitored resource. Custom metrics can use only certain monitored resource types in their time series data.
	Resource *MonitoredResource `pulumi:"resource"`
	// The units in which the metric value is reported. It is only applicable if the value_type is INT64, DOUBLE, or DISTRIBUTION. The unit defines the representation of the stored metric values.
	Unit *string `pulumi:"unit"`
	// The value type of the time series. When listing time series, this value type might be different from the value type of the associated metric if this time series is an alignment or reduction of other time series.When creating a time series, this field is optional. If present, it must be the same as the type of the data in the points field.
	ValueType *string `pulumi:"valueType"`
}

// TimeSeriesInput is an input type that accepts TimeSeriesArgs and TimeSeriesOutput values.
// You can construct a concrete instance of `TimeSeriesInput` via:
//
//          TimeSeriesArgs{...}
type TimeSeriesInput interface {
	pulumi.Input

	ToTimeSeriesOutput() TimeSeriesOutput
	ToTimeSeriesOutputWithContext(context.Context) TimeSeriesOutput
}

// A collection of data points that describes the time-varying values of a metric. A time series is identified by a combination of a fully-specified monitored resource and a fully-specified metric. This type is used for both listing and creating time series.
type TimeSeriesArgs struct {
	// Output only. The associated monitored resource metadata. When reading a time series, this field will include metadata labels that are explicitly named in the reduction. When creating a time series, this field is ignored.
	Metadata MonitoredResourceMetadataPtrInput `pulumi:"metadata"`
	// The associated metric. A fully-specified metric used to identify the time series.
	Metric MetricPtrInput `pulumi:"metric"`
	// The metric kind of the time series. When listing time series, this metric kind might be different from the metric kind of the associated metric if this time series is an alignment or reduction of other time series.When creating a time series, this field is optional. If present, it must be the same as the metric kind of the associated metric. If the associated metric's descriptor must be auto-created, then this field specifies the metric kind of the new descriptor and must be either GAUGE (the default) or CUMULATIVE.
	MetricKind pulumi.StringPtrInput `pulumi:"metricKind"`
	// The data points of this time series. When listing time series, points are returned in reverse time order.When creating a time series, this field must contain exactly one point and the point's type must be the same as the value type of the associated metric. If the associated metric's descriptor must be auto-created, then the value type of the descriptor is determined by the point's type, which must be BOOL, INT64, DOUBLE, or DISTRIBUTION.
	Points PointArrayInput `pulumi:"points"`
	// The associated monitored resource. Custom metrics can use only certain monitored resource types in their time series data.
	Resource MonitoredResourcePtrInput `pulumi:"resource"`
	// The units in which the metric value is reported. It is only applicable if the value_type is INT64, DOUBLE, or DISTRIBUTION. The unit defines the representation of the stored metric values.
	Unit pulumi.StringPtrInput `pulumi:"unit"`
	// The value type of the time series. When listing time series, this value type might be different from the value type of the associated metric if this time series is an alignment or reduction of other time series.When creating a time series, this field is optional. If present, it must be the same as the type of the data in the points field.
	ValueType pulumi.StringPtrInput `pulumi:"valueType"`
}

func (TimeSeriesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeries)(nil)).Elem()
}

func (i TimeSeriesArgs) ToTimeSeriesOutput() TimeSeriesOutput {
	return i.ToTimeSeriesOutputWithContext(context.Background())
}

func (i TimeSeriesArgs) ToTimeSeriesOutputWithContext(ctx context.Context) TimeSeriesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesOutput)
}

// TimeSeriesArrayInput is an input type that accepts TimeSeriesArray and TimeSeriesArrayOutput values.
// You can construct a concrete instance of `TimeSeriesArrayInput` via:
//
//          TimeSeriesArray{ TimeSeriesArgs{...} }
type TimeSeriesArrayInput interface {
	pulumi.Input

	ToTimeSeriesArrayOutput() TimeSeriesArrayOutput
	ToTimeSeriesArrayOutputWithContext(context.Context) TimeSeriesArrayOutput
}

type TimeSeriesArray []TimeSeriesInput

func (TimeSeriesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TimeSeries)(nil)).Elem()
}

func (i TimeSeriesArray) ToTimeSeriesArrayOutput() TimeSeriesArrayOutput {
	return i.ToTimeSeriesArrayOutputWithContext(context.Background())
}

func (i TimeSeriesArray) ToTimeSeriesArrayOutputWithContext(ctx context.Context) TimeSeriesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesArrayOutput)
}

// A collection of data points that describes the time-varying values of a metric. A time series is identified by a combination of a fully-specified monitored resource and a fully-specified metric. This type is used for both listing and creating time series.
type TimeSeriesOutput struct{ *pulumi.OutputState }

func (TimeSeriesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeries)(nil)).Elem()
}

func (o TimeSeriesOutput) ToTimeSeriesOutput() TimeSeriesOutput {
	return o
}

func (o TimeSeriesOutput) ToTimeSeriesOutputWithContext(ctx context.Context) TimeSeriesOutput {
	return o
}

// Output only. The associated monitored resource metadata. When reading a time series, this field will include metadata labels that are explicitly named in the reduction. When creating a time series, this field is ignored.
func (o TimeSeriesOutput) Metadata() MonitoredResourceMetadataPtrOutput {
	return o.ApplyT(func(v TimeSeries) *MonitoredResourceMetadata { return v.Metadata }).(MonitoredResourceMetadataPtrOutput)
}

// The associated metric. A fully-specified metric used to identify the time series.
func (o TimeSeriesOutput) Metric() MetricPtrOutput {
	return o.ApplyT(func(v TimeSeries) *Metric { return v.Metric }).(MetricPtrOutput)
}

// The metric kind of the time series. When listing time series, this metric kind might be different from the metric kind of the associated metric if this time series is an alignment or reduction of other time series.When creating a time series, this field is optional. If present, it must be the same as the metric kind of the associated metric. If the associated metric's descriptor must be auto-created, then this field specifies the metric kind of the new descriptor and must be either GAUGE (the default) or CUMULATIVE.
func (o TimeSeriesOutput) MetricKind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeSeries) *string { return v.MetricKind }).(pulumi.StringPtrOutput)
}

// The data points of this time series. When listing time series, points are returned in reverse time order.When creating a time series, this field must contain exactly one point and the point's type must be the same as the value type of the associated metric. If the associated metric's descriptor must be auto-created, then the value type of the descriptor is determined by the point's type, which must be BOOL, INT64, DOUBLE, or DISTRIBUTION.
func (o TimeSeriesOutput) Points() PointArrayOutput {
	return o.ApplyT(func(v TimeSeries) []Point { return v.Points }).(PointArrayOutput)
}

// The associated monitored resource. Custom metrics can use only certain monitored resource types in their time series data.
func (o TimeSeriesOutput) Resource() MonitoredResourcePtrOutput {
	return o.ApplyT(func(v TimeSeries) *MonitoredResource { return v.Resource }).(MonitoredResourcePtrOutput)
}

// The units in which the metric value is reported. It is only applicable if the value_type is INT64, DOUBLE, or DISTRIBUTION. The unit defines the representation of the stored metric values.
func (o TimeSeriesOutput) Unit() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeSeries) *string { return v.Unit }).(pulumi.StringPtrOutput)
}

// The value type of the time series. When listing time series, this value type might be different from the value type of the associated metric if this time series is an alignment or reduction of other time series.When creating a time series, this field is optional. If present, it must be the same as the type of the data in the points field.
func (o TimeSeriesOutput) ValueType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeSeries) *string { return v.ValueType }).(pulumi.StringPtrOutput)
}

type TimeSeriesArrayOutput struct{ *pulumi.OutputState }

func (TimeSeriesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TimeSeries)(nil)).Elem()
}

func (o TimeSeriesArrayOutput) ToTimeSeriesArrayOutput() TimeSeriesArrayOutput {
	return o
}

func (o TimeSeriesArrayOutput) ToTimeSeriesArrayOutputWithContext(ctx context.Context) TimeSeriesArrayOutput {
	return o
}

func (o TimeSeriesArrayOutput) Index(i pulumi.IntInput) TimeSeriesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TimeSeries {
		return vs[0].([]TimeSeries)[vs[1].(int)]
	}).(TimeSeriesOutput)
}

// A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed.
type TimeSeriesRatio struct {
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	BadServiceFilter *string `pulumi:"badServiceFilter"`
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	GoodServiceFilter *string `pulumi:"goodServiceFilter"`
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	TotalServiceFilter *string `pulumi:"totalServiceFilter"`
}

// TimeSeriesRatioInput is an input type that accepts TimeSeriesRatioArgs and TimeSeriesRatioOutput values.
// You can construct a concrete instance of `TimeSeriesRatioInput` via:
//
//          TimeSeriesRatioArgs{...}
type TimeSeriesRatioInput interface {
	pulumi.Input

	ToTimeSeriesRatioOutput() TimeSeriesRatioOutput
	ToTimeSeriesRatioOutputWithContext(context.Context) TimeSeriesRatioOutput
}

// A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed.
type TimeSeriesRatioArgs struct {
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	BadServiceFilter pulumi.StringPtrInput `pulumi:"badServiceFilter"`
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	GoodServiceFilter pulumi.StringPtrInput `pulumi:"goodServiceFilter"`
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	TotalServiceFilter pulumi.StringPtrInput `pulumi:"totalServiceFilter"`
}

func (TimeSeriesRatioArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesRatio)(nil)).Elem()
}

func (i TimeSeriesRatioArgs) ToTimeSeriesRatioOutput() TimeSeriesRatioOutput {
	return i.ToTimeSeriesRatioOutputWithContext(context.Background())
}

func (i TimeSeriesRatioArgs) ToTimeSeriesRatioOutputWithContext(ctx context.Context) TimeSeriesRatioOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesRatioOutput)
}

func (i TimeSeriesRatioArgs) ToTimeSeriesRatioPtrOutput() TimeSeriesRatioPtrOutput {
	return i.ToTimeSeriesRatioPtrOutputWithContext(context.Background())
}

func (i TimeSeriesRatioArgs) ToTimeSeriesRatioPtrOutputWithContext(ctx context.Context) TimeSeriesRatioPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesRatioOutput).ToTimeSeriesRatioPtrOutputWithContext(ctx)
}

// TimeSeriesRatioPtrInput is an input type that accepts TimeSeriesRatioArgs, TimeSeriesRatioPtr and TimeSeriesRatioPtrOutput values.
// You can construct a concrete instance of `TimeSeriesRatioPtrInput` via:
//
//          TimeSeriesRatioArgs{...}
//
//  or:
//
//          nil
type TimeSeriesRatioPtrInput interface {
	pulumi.Input

	ToTimeSeriesRatioPtrOutput() TimeSeriesRatioPtrOutput
	ToTimeSeriesRatioPtrOutputWithContext(context.Context) TimeSeriesRatioPtrOutput
}

type timeSeriesRatioPtrType TimeSeriesRatioArgs

func TimeSeriesRatioPtr(v *TimeSeriesRatioArgs) TimeSeriesRatioPtrInput {
	return (*timeSeriesRatioPtrType)(v)
}

func (*timeSeriesRatioPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeSeriesRatio)(nil)).Elem()
}

func (i *timeSeriesRatioPtrType) ToTimeSeriesRatioPtrOutput() TimeSeriesRatioPtrOutput {
	return i.ToTimeSeriesRatioPtrOutputWithContext(context.Background())
}

func (i *timeSeriesRatioPtrType) ToTimeSeriesRatioPtrOutputWithContext(ctx context.Context) TimeSeriesRatioPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TimeSeriesRatioPtrOutput)
}

// A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed.
type TimeSeriesRatioOutput struct{ *pulumi.OutputState }

func (TimeSeriesRatioOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimeSeriesRatio)(nil)).Elem()
}

func (o TimeSeriesRatioOutput) ToTimeSeriesRatioOutput() TimeSeriesRatioOutput {
	return o
}

func (o TimeSeriesRatioOutput) ToTimeSeriesRatioOutputWithContext(ctx context.Context) TimeSeriesRatioOutput {
	return o
}

func (o TimeSeriesRatioOutput) ToTimeSeriesRatioPtrOutput() TimeSeriesRatioPtrOutput {
	return o.ToTimeSeriesRatioPtrOutputWithContext(context.Background())
}

func (o TimeSeriesRatioOutput) ToTimeSeriesRatioPtrOutputWithContext(ctx context.Context) TimeSeriesRatioPtrOutput {
	return o.ApplyT(func(v TimeSeriesRatio) *TimeSeriesRatio {
		return &v
	}).(TimeSeriesRatioPtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o TimeSeriesRatioOutput) BadServiceFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeSeriesRatio) *string { return v.BadServiceFilter }).(pulumi.StringPtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o TimeSeriesRatioOutput) GoodServiceFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeSeriesRatio) *string { return v.GoodServiceFilter }).(pulumi.StringPtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o TimeSeriesRatioOutput) TotalServiceFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TimeSeriesRatio) *string { return v.TotalServiceFilter }).(pulumi.StringPtrOutput)
}

type TimeSeriesRatioPtrOutput struct{ *pulumi.OutputState }

func (TimeSeriesRatioPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TimeSeriesRatio)(nil)).Elem()
}

func (o TimeSeriesRatioPtrOutput) ToTimeSeriesRatioPtrOutput() TimeSeriesRatioPtrOutput {
	return o
}

func (o TimeSeriesRatioPtrOutput) ToTimeSeriesRatioPtrOutputWithContext(ctx context.Context) TimeSeriesRatioPtrOutput {
	return o
}

func (o TimeSeriesRatioPtrOutput) Elem() TimeSeriesRatioOutput {
	return o.ApplyT(func(v *TimeSeriesRatio) TimeSeriesRatio { return *v }).(TimeSeriesRatioOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o TimeSeriesRatioPtrOutput) BadServiceFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeSeriesRatio) *string {
		if v == nil {
			return nil
		}
		return v.BadServiceFilter
	}).(pulumi.StringPtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o TimeSeriesRatioPtrOutput) GoodServiceFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeSeriesRatio) *string {
		if v == nil {
			return nil
		}
		return v.GoodServiceFilter
	}).(pulumi.StringPtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
func (o TimeSeriesRatioPtrOutput) TotalServiceFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TimeSeriesRatio) *string {
		if v == nil {
			return nil
		}
		return v.TotalServiceFilter
	}).(pulumi.StringPtrOutput)
}

// Specifies how many time series must fail a predicate to trigger a condition. If not specified, then a {count: 1} trigger is used.
type Trigger struct {
	// The absolute number of time series that must fail the predicate for the condition to be triggered.
	Count *int `pulumi:"count"`
	// The percentage of time series that must fail the predicate for the condition to be triggered.
	Percent *float64 `pulumi:"percent"`
}

// TriggerInput is an input type that accepts TriggerArgs and TriggerOutput values.
// You can construct a concrete instance of `TriggerInput` via:
//
//          TriggerArgs{...}
type TriggerInput interface {
	pulumi.Input

	ToTriggerOutput() TriggerOutput
	ToTriggerOutputWithContext(context.Context) TriggerOutput
}

// Specifies how many time series must fail a predicate to trigger a condition. If not specified, then a {count: 1} trigger is used.
type TriggerArgs struct {
	// The absolute number of time series that must fail the predicate for the condition to be triggered.
	Count pulumi.IntPtrInput `pulumi:"count"`
	// The percentage of time series that must fail the predicate for the condition to be triggered.
	Percent pulumi.Float64PtrInput `pulumi:"percent"`
}

func (TriggerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Trigger)(nil)).Elem()
}

func (i TriggerArgs) ToTriggerOutput() TriggerOutput {
	return i.ToTriggerOutputWithContext(context.Background())
}

func (i TriggerArgs) ToTriggerOutputWithContext(ctx context.Context) TriggerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TriggerOutput)
}

func (i TriggerArgs) ToTriggerPtrOutput() TriggerPtrOutput {
	return i.ToTriggerPtrOutputWithContext(context.Background())
}

func (i TriggerArgs) ToTriggerPtrOutputWithContext(ctx context.Context) TriggerPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TriggerOutput).ToTriggerPtrOutputWithContext(ctx)
}

// TriggerPtrInput is an input type that accepts TriggerArgs, TriggerPtr and TriggerPtrOutput values.
// You can construct a concrete instance of `TriggerPtrInput` via:
//
//          TriggerArgs{...}
//
//  or:
//
//          nil
type TriggerPtrInput interface {
	pulumi.Input

	ToTriggerPtrOutput() TriggerPtrOutput
	ToTriggerPtrOutputWithContext(context.Context) TriggerPtrOutput
}

type triggerPtrType TriggerArgs

func TriggerPtr(v *TriggerArgs) TriggerPtrInput {
	return (*triggerPtrType)(v)
}

func (*triggerPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Trigger)(nil)).Elem()
}

func (i *triggerPtrType) ToTriggerPtrOutput() TriggerPtrOutput {
	return i.ToTriggerPtrOutputWithContext(context.Background())
}

func (i *triggerPtrType) ToTriggerPtrOutputWithContext(ctx context.Context) TriggerPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TriggerPtrOutput)
}

// Specifies how many time series must fail a predicate to trigger a condition. If not specified, then a {count: 1} trigger is used.
type TriggerOutput struct{ *pulumi.OutputState }

func (TriggerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Trigger)(nil)).Elem()
}

func (o TriggerOutput) ToTriggerOutput() TriggerOutput {
	return o
}

func (o TriggerOutput) ToTriggerOutputWithContext(ctx context.Context) TriggerOutput {
	return o
}

func (o TriggerOutput) ToTriggerPtrOutput() TriggerPtrOutput {
	return o.ToTriggerPtrOutputWithContext(context.Background())
}

func (o TriggerOutput) ToTriggerPtrOutputWithContext(ctx context.Context) TriggerPtrOutput {
	return o.ApplyT(func(v Trigger) *Trigger {
		return &v
	}).(TriggerPtrOutput)
}

// The absolute number of time series that must fail the predicate for the condition to be triggered.
func (o TriggerOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Trigger) *int { return v.Count }).(pulumi.IntPtrOutput)
}

// The percentage of time series that must fail the predicate for the condition to be triggered.
func (o TriggerOutput) Percent() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Trigger) *float64 { return v.Percent }).(pulumi.Float64PtrOutput)
}

type TriggerPtrOutput struct{ *pulumi.OutputState }

func (TriggerPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Trigger)(nil)).Elem()
}

func (o TriggerPtrOutput) ToTriggerPtrOutput() TriggerPtrOutput {
	return o
}

func (o TriggerPtrOutput) ToTriggerPtrOutputWithContext(ctx context.Context) TriggerPtrOutput {
	return o
}

func (o TriggerPtrOutput) Elem() TriggerOutput {
	return o.ApplyT(func(v *Trigger) Trigger { return *v }).(TriggerOutput)
}

// The absolute number of time series that must fail the predicate for the condition to be triggered.
func (o TriggerPtrOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Trigger) *int {
		if v == nil {
			return nil
		}
		return v.Count
	}).(pulumi.IntPtrOutput)
}

// The percentage of time series that must fail the predicate for the condition to be triggered.
func (o TriggerPtrOutput) Percent() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *Trigger) *float64 {
		if v == nil {
			return nil
		}
		return v.Percent
	}).(pulumi.Float64PtrOutput)
}

// A single strongly-typed value.
type TypedValue struct {
	// A Boolean value: true or false.
	BoolValue *bool `pulumi:"boolValue"`
	// A distribution value.
	DistributionValue *Distribution `pulumi:"distributionValue"`
	// A 64-bit double-precision floating-point number. Its magnitude is approximately 10300 and it has 16 significant digits of precision.
	DoubleValue *float64 `pulumi:"doubleValue"`
	// A 64-bit integer. Its range is approximately 9.2x1018.
	Int64Value *string `pulumi:"int64Value"`
	// A variable-length string value.
	StringValue *string `pulumi:"stringValue"`
}

// TypedValueInput is an input type that accepts TypedValueArgs and TypedValueOutput values.
// You can construct a concrete instance of `TypedValueInput` via:
//
//          TypedValueArgs{...}
type TypedValueInput interface {
	pulumi.Input

	ToTypedValueOutput() TypedValueOutput
	ToTypedValueOutputWithContext(context.Context) TypedValueOutput
}

// A single strongly-typed value.
type TypedValueArgs struct {
	// A Boolean value: true or false.
	BoolValue pulumi.BoolPtrInput `pulumi:"boolValue"`
	// A distribution value.
	DistributionValue DistributionPtrInput `pulumi:"distributionValue"`
	// A 64-bit double-precision floating-point number. Its magnitude is approximately 10300 and it has 16 significant digits of precision.
	DoubleValue pulumi.Float64PtrInput `pulumi:"doubleValue"`
	// A 64-bit integer. Its range is approximately 9.2x1018.
	Int64Value pulumi.StringPtrInput `pulumi:"int64Value"`
	// A variable-length string value.
	StringValue pulumi.StringPtrInput `pulumi:"stringValue"`
}

func (TypedValueArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TypedValue)(nil)).Elem()
}

func (i TypedValueArgs) ToTypedValueOutput() TypedValueOutput {
	return i.ToTypedValueOutputWithContext(context.Background())
}

func (i TypedValueArgs) ToTypedValueOutputWithContext(ctx context.Context) TypedValueOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TypedValueOutput)
}

func (i TypedValueArgs) ToTypedValuePtrOutput() TypedValuePtrOutput {
	return i.ToTypedValuePtrOutputWithContext(context.Background())
}

func (i TypedValueArgs) ToTypedValuePtrOutputWithContext(ctx context.Context) TypedValuePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TypedValueOutput).ToTypedValuePtrOutputWithContext(ctx)
}

// TypedValuePtrInput is an input type that accepts TypedValueArgs, TypedValuePtr and TypedValuePtrOutput values.
// You can construct a concrete instance of `TypedValuePtrInput` via:
//
//          TypedValueArgs{...}
//
//  or:
//
//          nil
type TypedValuePtrInput interface {
	pulumi.Input

	ToTypedValuePtrOutput() TypedValuePtrOutput
	ToTypedValuePtrOutputWithContext(context.Context) TypedValuePtrOutput
}

type typedValuePtrType TypedValueArgs

func TypedValuePtr(v *TypedValueArgs) TypedValuePtrInput {
	return (*typedValuePtrType)(v)
}

func (*typedValuePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TypedValue)(nil)).Elem()
}

func (i *typedValuePtrType) ToTypedValuePtrOutput() TypedValuePtrOutput {
	return i.ToTypedValuePtrOutputWithContext(context.Background())
}

func (i *typedValuePtrType) ToTypedValuePtrOutputWithContext(ctx context.Context) TypedValuePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TypedValuePtrOutput)
}

// A single strongly-typed value.
type TypedValueOutput struct{ *pulumi.OutputState }

func (TypedValueOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TypedValue)(nil)).Elem()
}

func (o TypedValueOutput) ToTypedValueOutput() TypedValueOutput {
	return o
}

func (o TypedValueOutput) ToTypedValueOutputWithContext(ctx context.Context) TypedValueOutput {
	return o
}

func (o TypedValueOutput) ToTypedValuePtrOutput() TypedValuePtrOutput {
	return o.ToTypedValuePtrOutputWithContext(context.Background())
}

func (o TypedValueOutput) ToTypedValuePtrOutputWithContext(ctx context.Context) TypedValuePtrOutput {
	return o.ApplyT(func(v TypedValue) *TypedValue {
		return &v
	}).(TypedValuePtrOutput)
}

// A Boolean value: true or false.
func (o TypedValueOutput) BoolValue() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v TypedValue) *bool { return v.BoolValue }).(pulumi.BoolPtrOutput)
}

// A distribution value.
func (o TypedValueOutput) DistributionValue() DistributionPtrOutput {
	return o.ApplyT(func(v TypedValue) *Distribution { return v.DistributionValue }).(DistributionPtrOutput)
}

// A 64-bit double-precision floating-point number. Its magnitude is approximately 10300 and it has 16 significant digits of precision.
func (o TypedValueOutput) DoubleValue() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v TypedValue) *float64 { return v.DoubleValue }).(pulumi.Float64PtrOutput)
}

// A 64-bit integer. Its range is approximately 9.2x1018.
func (o TypedValueOutput) Int64Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TypedValue) *string { return v.Int64Value }).(pulumi.StringPtrOutput)
}

// A variable-length string value.
func (o TypedValueOutput) StringValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TypedValue) *string { return v.StringValue }).(pulumi.StringPtrOutput)
}

type TypedValuePtrOutput struct{ *pulumi.OutputState }

func (TypedValuePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TypedValue)(nil)).Elem()
}

func (o TypedValuePtrOutput) ToTypedValuePtrOutput() TypedValuePtrOutput {
	return o
}

func (o TypedValuePtrOutput) ToTypedValuePtrOutputWithContext(ctx context.Context) TypedValuePtrOutput {
	return o
}

func (o TypedValuePtrOutput) Elem() TypedValueOutput {
	return o.ApplyT(func(v *TypedValue) TypedValue { return *v }).(TypedValueOutput)
}

// A Boolean value: true or false.
func (o TypedValuePtrOutput) BoolValue() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *TypedValue) *bool {
		if v == nil {
			return nil
		}
		return v.BoolValue
	}).(pulumi.BoolPtrOutput)
}

// A distribution value.
func (o TypedValuePtrOutput) DistributionValue() DistributionPtrOutput {
	return o.ApplyT(func(v *TypedValue) *Distribution {
		if v == nil {
			return nil
		}
		return v.DistributionValue
	}).(DistributionPtrOutput)
}

// A 64-bit double-precision floating-point number. Its magnitude is approximately 10300 and it has 16 significant digits of precision.
func (o TypedValuePtrOutput) DoubleValue() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *TypedValue) *float64 {
		if v == nil {
			return nil
		}
		return v.DoubleValue
	}).(pulumi.Float64PtrOutput)
}

// A 64-bit integer. Its range is approximately 9.2x1018.
func (o TypedValuePtrOutput) Int64Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TypedValue) *string {
		if v == nil {
			return nil
		}
		return v.Int64Value
	}).(pulumi.StringPtrOutput)
}

// A variable-length string value.
func (o TypedValuePtrOutput) StringValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TypedValue) *string {
		if v == nil {
			return nil
		}
		return v.StringValue
	}).(pulumi.StringPtrOutput)
}

// A WindowsBasedSli defines good_service as the count of time windows for which the provided service was of good quality. Criteria for determining if service was good are embedded in the window_criterion.
type WindowsBasedSli struct {
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries with ValueType = BOOL. The window is good if any true values appear in the window.
	GoodBadMetricFilter *string `pulumi:"goodBadMetricFilter"`
	// A window is good if its performance is high enough.
	GoodTotalRatioThreshold *PerformanceThreshold `pulumi:"goodTotalRatioThreshold"`
	// A window is good if the metric's value is in a good range, averaged across returned streams.
	MetricMeanInRange *MetricRange `pulumi:"metricMeanInRange"`
	// A window is good if the metric's value is in a good range, summed across returned streams.
	MetricSumInRange *MetricRange `pulumi:"metricSumInRange"`
	// Duration over which window quality is evaluated. Must be an integer fraction of a day and at least 60s.
	WindowPeriod *string `pulumi:"windowPeriod"`
}

// WindowsBasedSliInput is an input type that accepts WindowsBasedSliArgs and WindowsBasedSliOutput values.
// You can construct a concrete instance of `WindowsBasedSliInput` via:
//
//          WindowsBasedSliArgs{...}
type WindowsBasedSliInput interface {
	pulumi.Input

	ToWindowsBasedSliOutput() WindowsBasedSliOutput
	ToWindowsBasedSliOutputWithContext(context.Context) WindowsBasedSliOutput
}

// A WindowsBasedSli defines good_service as the count of time windows for which the provided service was of good quality. Criteria for determining if service was good are embedded in the window_criterion.
type WindowsBasedSliArgs struct {
	// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries with ValueType = BOOL. The window is good if any true values appear in the window.
	GoodBadMetricFilter pulumi.StringPtrInput `pulumi:"goodBadMetricFilter"`
	// A window is good if its performance is high enough.
	GoodTotalRatioThreshold PerformanceThresholdPtrInput `pulumi:"goodTotalRatioThreshold"`
	// A window is good if the metric's value is in a good range, averaged across returned streams.
	MetricMeanInRange MetricRangePtrInput `pulumi:"metricMeanInRange"`
	// A window is good if the metric's value is in a good range, summed across returned streams.
	MetricSumInRange MetricRangePtrInput `pulumi:"metricSumInRange"`
	// Duration over which window quality is evaluated. Must be an integer fraction of a day and at least 60s.
	WindowPeriod pulumi.StringPtrInput `pulumi:"windowPeriod"`
}

func (WindowsBasedSliArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WindowsBasedSli)(nil)).Elem()
}

func (i WindowsBasedSliArgs) ToWindowsBasedSliOutput() WindowsBasedSliOutput {
	return i.ToWindowsBasedSliOutputWithContext(context.Background())
}

func (i WindowsBasedSliArgs) ToWindowsBasedSliOutputWithContext(ctx context.Context) WindowsBasedSliOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WindowsBasedSliOutput)
}

func (i WindowsBasedSliArgs) ToWindowsBasedSliPtrOutput() WindowsBasedSliPtrOutput {
	return i.ToWindowsBasedSliPtrOutputWithContext(context.Background())
}

func (i WindowsBasedSliArgs) ToWindowsBasedSliPtrOutputWithContext(ctx context.Context) WindowsBasedSliPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WindowsBasedSliOutput).ToWindowsBasedSliPtrOutputWithContext(ctx)
}

// WindowsBasedSliPtrInput is an input type that accepts WindowsBasedSliArgs, WindowsBasedSliPtr and WindowsBasedSliPtrOutput values.
// You can construct a concrete instance of `WindowsBasedSliPtrInput` via:
//
//          WindowsBasedSliArgs{...}
//
//  or:
//
//          nil
type WindowsBasedSliPtrInput interface {
	pulumi.Input

	ToWindowsBasedSliPtrOutput() WindowsBasedSliPtrOutput
	ToWindowsBasedSliPtrOutputWithContext(context.Context) WindowsBasedSliPtrOutput
}

type windowsBasedSliPtrType WindowsBasedSliArgs

func WindowsBasedSliPtr(v *WindowsBasedSliArgs) WindowsBasedSliPtrInput {
	return (*windowsBasedSliPtrType)(v)
}

func (*windowsBasedSliPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WindowsBasedSli)(nil)).Elem()
}

func (i *windowsBasedSliPtrType) ToWindowsBasedSliPtrOutput() WindowsBasedSliPtrOutput {
	return i.ToWindowsBasedSliPtrOutputWithContext(context.Background())
}

func (i *windowsBasedSliPtrType) ToWindowsBasedSliPtrOutputWithContext(ctx context.Context) WindowsBasedSliPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WindowsBasedSliPtrOutput)
}

// A WindowsBasedSli defines good_service as the count of time windows for which the provided service was of good quality. Criteria for determining if service was good are embedded in the window_criterion.
type WindowsBasedSliOutput struct{ *pulumi.OutputState }

func (WindowsBasedSliOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WindowsBasedSli)(nil)).Elem()
}

func (o WindowsBasedSliOutput) ToWindowsBasedSliOutput() WindowsBasedSliOutput {
	return o
}

func (o WindowsBasedSliOutput) ToWindowsBasedSliOutputWithContext(ctx context.Context) WindowsBasedSliOutput {
	return o
}

func (o WindowsBasedSliOutput) ToWindowsBasedSliPtrOutput() WindowsBasedSliPtrOutput {
	return o.ToWindowsBasedSliPtrOutputWithContext(context.Background())
}

func (o WindowsBasedSliOutput) ToWindowsBasedSliPtrOutputWithContext(ctx context.Context) WindowsBasedSliPtrOutput {
	return o.ApplyT(func(v WindowsBasedSli) *WindowsBasedSli {
		return &v
	}).(WindowsBasedSliPtrOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries with ValueType = BOOL. The window is good if any true values appear in the window.
func (o WindowsBasedSliOutput) GoodBadMetricFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v WindowsBasedSli) *string { return v.GoodBadMetricFilter }).(pulumi.StringPtrOutput)
}

// A window is good if its performance is high enough.
func (o WindowsBasedSliOutput) GoodTotalRatioThreshold() PerformanceThresholdPtrOutput {
	return o.ApplyT(func(v WindowsBasedSli) *PerformanceThreshold { return v.GoodTotalRatioThreshold }).(PerformanceThresholdPtrOutput)
}

// A window is good if the metric's value is in a good range, averaged across returned streams.
func (o WindowsBasedSliOutput) MetricMeanInRange() MetricRangePtrOutput {
	return o.ApplyT(func(v WindowsBasedSli) *MetricRange { return v.MetricMeanInRange }).(MetricRangePtrOutput)
}

// A window is good if the metric's value is in a good range, summed across returned streams.
func (o WindowsBasedSliOutput) MetricSumInRange() MetricRangePtrOutput {
	return o.ApplyT(func(v WindowsBasedSli) *MetricRange { return v.MetricSumInRange }).(MetricRangePtrOutput)
}

// Duration over which window quality is evaluated. Must be an integer fraction of a day and at least 60s.
func (o WindowsBasedSliOutput) WindowPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v WindowsBasedSli) *string { return v.WindowPeriod }).(pulumi.StringPtrOutput)
}

type WindowsBasedSliPtrOutput struct{ *pulumi.OutputState }

func (WindowsBasedSliPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WindowsBasedSli)(nil)).Elem()
}

func (o WindowsBasedSliPtrOutput) ToWindowsBasedSliPtrOutput() WindowsBasedSliPtrOutput {
	return o
}

func (o WindowsBasedSliPtrOutput) ToWindowsBasedSliPtrOutputWithContext(ctx context.Context) WindowsBasedSliPtrOutput {
	return o
}

func (o WindowsBasedSliPtrOutput) Elem() WindowsBasedSliOutput {
	return o.ApplyT(func(v *WindowsBasedSli) WindowsBasedSli { return *v }).(WindowsBasedSliOutput)
}

// A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries with ValueType = BOOL. The window is good if any true values appear in the window.
func (o WindowsBasedSliPtrOutput) GoodBadMetricFilter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WindowsBasedSli) *string {
		if v == nil {
			return nil
		}
		return v.GoodBadMetricFilter
	}).(pulumi.StringPtrOutput)
}

// A window is good if its performance is high enough.
func (o WindowsBasedSliPtrOutput) GoodTotalRatioThreshold() PerformanceThresholdPtrOutput {
	return o.ApplyT(func(v *WindowsBasedSli) *PerformanceThreshold {
		if v == nil {
			return nil
		}
		return v.GoodTotalRatioThreshold
	}).(PerformanceThresholdPtrOutput)
}

// A window is good if the metric's value is in a good range, averaged across returned streams.
func (o WindowsBasedSliPtrOutput) MetricMeanInRange() MetricRangePtrOutput {
	return o.ApplyT(func(v *WindowsBasedSli) *MetricRange {
		if v == nil {
			return nil
		}
		return v.MetricMeanInRange
	}).(MetricRangePtrOutput)
}

// A window is good if the metric's value is in a good range, summed across returned streams.
func (o WindowsBasedSliPtrOutput) MetricSumInRange() MetricRangePtrOutput {
	return o.ApplyT(func(v *WindowsBasedSli) *MetricRange {
		if v == nil {
			return nil
		}
		return v.MetricSumInRange
	}).(MetricRangePtrOutput)
}

// Duration over which window quality is evaluated. Must be an integer fraction of a day and at least 60s.
func (o WindowsBasedSliPtrOutput) WindowPeriod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WindowsBasedSli) *string {
		if v == nil {
			return nil
		}
		return v.WindowPeriod
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterOutputType(AggregationOutput{})
	pulumi.RegisterOutputType(AggregationArrayOutput{})
	pulumi.RegisterOutputType(AppEngineOutput{})
	pulumi.RegisterOutputType(AppEnginePtrOutput{})
	pulumi.RegisterOutputType(AvailabilityCriteriaOutput{})
	pulumi.RegisterOutputType(AvailabilityCriteriaPtrOutput{})
	pulumi.RegisterOutputType(BasicAuthenticationOutput{})
	pulumi.RegisterOutputType(BasicAuthenticationPtrOutput{})
	pulumi.RegisterOutputType(BasicSliOutput{})
	pulumi.RegisterOutputType(BasicSliPtrOutput{})
	pulumi.RegisterOutputType(BucketOptionsOutput{})
	pulumi.RegisterOutputType(BucketOptionsPtrOutput{})
	pulumi.RegisterOutputType(CloudEndpointsOutput{})
	pulumi.RegisterOutputType(CloudEndpointsPtrOutput{})
	pulumi.RegisterOutputType(ClusterIstioOutput{})
	pulumi.RegisterOutputType(ClusterIstioPtrOutput{})
	pulumi.RegisterOutputType(CollectdPayloadOutput{})
	pulumi.RegisterOutputType(CollectdPayloadArrayOutput{})
	pulumi.RegisterOutputType(CollectdValueOutput{})
	pulumi.RegisterOutputType(CollectdValueArrayOutput{})
	pulumi.RegisterOutputType(ConditionOutput{})
	pulumi.RegisterOutputType(ConditionArrayOutput{})
	pulumi.RegisterOutputType(ContentMatcherOutput{})
	pulumi.RegisterOutputType(ContentMatcherArrayOutput{})
	pulumi.RegisterOutputType(CustomOutput{})
	pulumi.RegisterOutputType(CustomPtrOutput{})
	pulumi.RegisterOutputType(DistributionOutput{})
	pulumi.RegisterOutputType(DistributionPtrOutput{})
	pulumi.RegisterOutputType(DistributionCutOutput{})
	pulumi.RegisterOutputType(DistributionCutPtrOutput{})
	pulumi.RegisterOutputType(DocumentationOutput{})
	pulumi.RegisterOutputType(DocumentationPtrOutput{})
	pulumi.RegisterOutputType(ExemplarOutput{})
	pulumi.RegisterOutputType(ExemplarArrayOutput{})
	pulumi.RegisterOutputType(ExplicitOutput{})
	pulumi.RegisterOutputType(ExplicitPtrOutput{})
	pulumi.RegisterOutputType(ExponentialOutput{})
	pulumi.RegisterOutputType(ExponentialPtrOutput{})
	pulumi.RegisterOutputType(GoogleMonitoringV3RangeOutput{})
	pulumi.RegisterOutputType(GoogleMonitoringV3RangePtrOutput{})
	pulumi.RegisterOutputType(HttpCheckOutput{})
	pulumi.RegisterOutputType(HttpCheckPtrOutput{})
	pulumi.RegisterOutputType(InternalCheckerOutput{})
	pulumi.RegisterOutputType(InternalCheckerArrayOutput{})
	pulumi.RegisterOutputType(LabelDescriptorOutput{})
	pulumi.RegisterOutputType(LabelDescriptorArrayOutput{})
	pulumi.RegisterOutputType(LatencyCriteriaOutput{})
	pulumi.RegisterOutputType(LatencyCriteriaPtrOutput{})
	pulumi.RegisterOutputType(LinearOutput{})
	pulumi.RegisterOutputType(LinearPtrOutput{})
	pulumi.RegisterOutputType(MeshIstioOutput{})
	pulumi.RegisterOutputType(MeshIstioPtrOutput{})
	pulumi.RegisterOutputType(MetricOutput{})
	pulumi.RegisterOutputType(MetricPtrOutput{})
	pulumi.RegisterOutputType(MetricAbsenceOutput{})
	pulumi.RegisterOutputType(MetricAbsencePtrOutput{})
	pulumi.RegisterOutputType(MetricDescriptorMetadataOutput{})
	pulumi.RegisterOutputType(MetricDescriptorMetadataPtrOutput{})
	pulumi.RegisterOutputType(MetricRangeOutput{})
	pulumi.RegisterOutputType(MetricRangePtrOutput{})
	pulumi.RegisterOutputType(MetricThresholdOutput{})
	pulumi.RegisterOutputType(MetricThresholdPtrOutput{})
	pulumi.RegisterOutputType(MonitoredResourceOutput{})
	pulumi.RegisterOutputType(MonitoredResourcePtrOutput{})
	pulumi.RegisterOutputType(MonitoredResourceMetadataOutput{})
	pulumi.RegisterOutputType(MonitoredResourceMetadataPtrOutput{})
	pulumi.RegisterOutputType(MonitoringQueryLanguageConditionOutput{})
	pulumi.RegisterOutputType(MonitoringQueryLanguageConditionPtrOutput{})
	pulumi.RegisterOutputType(MutationRecordOutput{})
	pulumi.RegisterOutputType(MutationRecordPtrOutput{})
	pulumi.RegisterOutputType(PerformanceThresholdOutput{})
	pulumi.RegisterOutputType(PerformanceThresholdPtrOutput{})
	pulumi.RegisterOutputType(PointOutput{})
	pulumi.RegisterOutputType(PointArrayOutput{})
	pulumi.RegisterOutputType(RangeOutput{})
	pulumi.RegisterOutputType(RangePtrOutput{})
	pulumi.RegisterOutputType(RequestBasedSliOutput{})
	pulumi.RegisterOutputType(RequestBasedSliPtrOutput{})
	pulumi.RegisterOutputType(ResourceGroupOutput{})
	pulumi.RegisterOutputType(ResourceGroupPtrOutput{})
	pulumi.RegisterOutputType(ServiceLevelIndicatorOutput{})
	pulumi.RegisterOutputType(ServiceLevelIndicatorPtrOutput{})
	pulumi.RegisterOutputType(StatusOutput{})
	pulumi.RegisterOutputType(StatusPtrOutput{})
	pulumi.RegisterOutputType(TcpCheckOutput{})
	pulumi.RegisterOutputType(TcpCheckPtrOutput{})
	pulumi.RegisterOutputType(TelemetryOutput{})
	pulumi.RegisterOutputType(TelemetryPtrOutput{})
	pulumi.RegisterOutputType(TimeIntervalOutput{})
	pulumi.RegisterOutputType(TimeIntervalPtrOutput{})
	pulumi.RegisterOutputType(TimeSeriesOutput{})
	pulumi.RegisterOutputType(TimeSeriesArrayOutput{})
	pulumi.RegisterOutputType(TimeSeriesRatioOutput{})
	pulumi.RegisterOutputType(TimeSeriesRatioPtrOutput{})
	pulumi.RegisterOutputType(TriggerOutput{})
	pulumi.RegisterOutputType(TriggerPtrOutput{})
	pulumi.RegisterOutputType(TypedValueOutput{})
	pulumi.RegisterOutputType(TypedValuePtrOutput{})
	pulumi.RegisterOutputType(WindowsBasedSliOutput{})
	pulumi.RegisterOutputType(WindowsBasedSliPtrOutput{})
}
