// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v3

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

// The Google Cloud Storage location for the input content.
type GcsSource struct {
	// Required. Source data URI. For example, `gs://my_bucket/my_object`.
	InputUri *string `pulumi:"inputUri"`
}

// GcsSourceInput is an input type that accepts GcsSourceArgs and GcsSourceOutput values.
// You can construct a concrete instance of `GcsSourceInput` via:
//
//          GcsSourceArgs{...}
type GcsSourceInput interface {
	pulumi.Input

	ToGcsSourceOutput() GcsSourceOutput
	ToGcsSourceOutputWithContext(context.Context) GcsSourceOutput
}

// The Google Cloud Storage location for the input content.
type GcsSourceArgs struct {
	// Required. Source data URI. For example, `gs://my_bucket/my_object`.
	InputUri pulumi.StringPtrInput `pulumi:"inputUri"`
}

func (GcsSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GcsSource)(nil)).Elem()
}

func (i GcsSourceArgs) ToGcsSourceOutput() GcsSourceOutput {
	return i.ToGcsSourceOutputWithContext(context.Background())
}

func (i GcsSourceArgs) ToGcsSourceOutputWithContext(ctx context.Context) GcsSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GcsSourceOutput)
}

func (i GcsSourceArgs) ToGcsSourcePtrOutput() GcsSourcePtrOutput {
	return i.ToGcsSourcePtrOutputWithContext(context.Background())
}

func (i GcsSourceArgs) ToGcsSourcePtrOutputWithContext(ctx context.Context) GcsSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GcsSourceOutput).ToGcsSourcePtrOutputWithContext(ctx)
}

// GcsSourcePtrInput is an input type that accepts GcsSourceArgs, GcsSourcePtr and GcsSourcePtrOutput values.
// You can construct a concrete instance of `GcsSourcePtrInput` via:
//
//          GcsSourceArgs{...}
//
//  or:
//
//          nil
type GcsSourcePtrInput interface {
	pulumi.Input

	ToGcsSourcePtrOutput() GcsSourcePtrOutput
	ToGcsSourcePtrOutputWithContext(context.Context) GcsSourcePtrOutput
}

type gcsSourcePtrType GcsSourceArgs

func GcsSourcePtr(v *GcsSourceArgs) GcsSourcePtrInput {
	return (*gcsSourcePtrType)(v)
}

func (*gcsSourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GcsSource)(nil)).Elem()
}

func (i *gcsSourcePtrType) ToGcsSourcePtrOutput() GcsSourcePtrOutput {
	return i.ToGcsSourcePtrOutputWithContext(context.Background())
}

func (i *gcsSourcePtrType) ToGcsSourcePtrOutputWithContext(ctx context.Context) GcsSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GcsSourcePtrOutput)
}

// The Google Cloud Storage location for the input content.
type GcsSourceOutput struct{ *pulumi.OutputState }

func (GcsSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GcsSource)(nil)).Elem()
}

func (o GcsSourceOutput) ToGcsSourceOutput() GcsSourceOutput {
	return o
}

func (o GcsSourceOutput) ToGcsSourceOutputWithContext(ctx context.Context) GcsSourceOutput {
	return o
}

func (o GcsSourceOutput) ToGcsSourcePtrOutput() GcsSourcePtrOutput {
	return o.ToGcsSourcePtrOutputWithContext(context.Background())
}

func (o GcsSourceOutput) ToGcsSourcePtrOutputWithContext(ctx context.Context) GcsSourcePtrOutput {
	return o.ApplyT(func(v GcsSource) *GcsSource {
		return &v
	}).(GcsSourcePtrOutput)
}

// Required. Source data URI. For example, `gs://my_bucket/my_object`.
func (o GcsSourceOutput) InputUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GcsSource) *string { return v.InputUri }).(pulumi.StringPtrOutput)
}

type GcsSourcePtrOutput struct{ *pulumi.OutputState }

func (GcsSourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GcsSource)(nil)).Elem()
}

func (o GcsSourcePtrOutput) ToGcsSourcePtrOutput() GcsSourcePtrOutput {
	return o
}

func (o GcsSourcePtrOutput) ToGcsSourcePtrOutputWithContext(ctx context.Context) GcsSourcePtrOutput {
	return o
}

func (o GcsSourcePtrOutput) Elem() GcsSourceOutput {
	return o.ApplyT(func(v *GcsSource) GcsSource { return *v }).(GcsSourceOutput)
}

// Required. Source data URI. For example, `gs://my_bucket/my_object`.
func (o GcsSourcePtrOutput) InputUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GcsSource) *string {
		if v == nil {
			return nil
		}
		return v.InputUri
	}).(pulumi.StringPtrOutput)
}

// Input configuration for glossaries.
type GlossaryInputConfig struct {
	// Required. Google Cloud Storage location of glossary data. File format is determined based on the filename extension. API returns [google.rpc.Code.INVALID_ARGUMENT] for unsupported URI-s and file formats. Wildcards are not allowed. This must be a single file in one of the following formats: For unidirectional glossaries: - TSV/CSV (`.tsv`/`.csv`): 2 column file, tab- or comma-separated. The first column is source text. The second column is target text. The file must not contain headers. That is, the first row is data, not column names. - TMX (`.tmx`): TMX file with parallel data defining source/target term pairs. For equivalent term sets glossaries: - CSV (`.csv`): Multi-column CSV file defining equivalent glossary terms in multiple languages. See documentation for more information - [glossaries](https://cloud.google.com/translate/docs/advanced/glossary).
	GcsSource *GcsSource `pulumi:"gcsSource"`
}

// GlossaryInputConfigInput is an input type that accepts GlossaryInputConfigArgs and GlossaryInputConfigOutput values.
// You can construct a concrete instance of `GlossaryInputConfigInput` via:
//
//          GlossaryInputConfigArgs{...}
type GlossaryInputConfigInput interface {
	pulumi.Input

	ToGlossaryInputConfigOutput() GlossaryInputConfigOutput
	ToGlossaryInputConfigOutputWithContext(context.Context) GlossaryInputConfigOutput
}

// Input configuration for glossaries.
type GlossaryInputConfigArgs struct {
	// Required. Google Cloud Storage location of glossary data. File format is determined based on the filename extension. API returns [google.rpc.Code.INVALID_ARGUMENT] for unsupported URI-s and file formats. Wildcards are not allowed. This must be a single file in one of the following formats: For unidirectional glossaries: - TSV/CSV (`.tsv`/`.csv`): 2 column file, tab- or comma-separated. The first column is source text. The second column is target text. The file must not contain headers. That is, the first row is data, not column names. - TMX (`.tmx`): TMX file with parallel data defining source/target term pairs. For equivalent term sets glossaries: - CSV (`.csv`): Multi-column CSV file defining equivalent glossary terms in multiple languages. See documentation for more information - [glossaries](https://cloud.google.com/translate/docs/advanced/glossary).
	GcsSource GcsSourcePtrInput `pulumi:"gcsSource"`
}

func (GlossaryInputConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GlossaryInputConfig)(nil)).Elem()
}

func (i GlossaryInputConfigArgs) ToGlossaryInputConfigOutput() GlossaryInputConfigOutput {
	return i.ToGlossaryInputConfigOutputWithContext(context.Background())
}

func (i GlossaryInputConfigArgs) ToGlossaryInputConfigOutputWithContext(ctx context.Context) GlossaryInputConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GlossaryInputConfigOutput)
}

func (i GlossaryInputConfigArgs) ToGlossaryInputConfigPtrOutput() GlossaryInputConfigPtrOutput {
	return i.ToGlossaryInputConfigPtrOutputWithContext(context.Background())
}

func (i GlossaryInputConfigArgs) ToGlossaryInputConfigPtrOutputWithContext(ctx context.Context) GlossaryInputConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GlossaryInputConfigOutput).ToGlossaryInputConfigPtrOutputWithContext(ctx)
}

// GlossaryInputConfigPtrInput is an input type that accepts GlossaryInputConfigArgs, GlossaryInputConfigPtr and GlossaryInputConfigPtrOutput values.
// You can construct a concrete instance of `GlossaryInputConfigPtrInput` via:
//
//          GlossaryInputConfigArgs{...}
//
//  or:
//
//          nil
type GlossaryInputConfigPtrInput interface {
	pulumi.Input

	ToGlossaryInputConfigPtrOutput() GlossaryInputConfigPtrOutput
	ToGlossaryInputConfigPtrOutputWithContext(context.Context) GlossaryInputConfigPtrOutput
}

type glossaryInputConfigPtrType GlossaryInputConfigArgs

func GlossaryInputConfigPtr(v *GlossaryInputConfigArgs) GlossaryInputConfigPtrInput {
	return (*glossaryInputConfigPtrType)(v)
}

func (*glossaryInputConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GlossaryInputConfig)(nil)).Elem()
}

func (i *glossaryInputConfigPtrType) ToGlossaryInputConfigPtrOutput() GlossaryInputConfigPtrOutput {
	return i.ToGlossaryInputConfigPtrOutputWithContext(context.Background())
}

func (i *glossaryInputConfigPtrType) ToGlossaryInputConfigPtrOutputWithContext(ctx context.Context) GlossaryInputConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GlossaryInputConfigPtrOutput)
}

// Input configuration for glossaries.
type GlossaryInputConfigOutput struct{ *pulumi.OutputState }

func (GlossaryInputConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GlossaryInputConfig)(nil)).Elem()
}

func (o GlossaryInputConfigOutput) ToGlossaryInputConfigOutput() GlossaryInputConfigOutput {
	return o
}

func (o GlossaryInputConfigOutput) ToGlossaryInputConfigOutputWithContext(ctx context.Context) GlossaryInputConfigOutput {
	return o
}

func (o GlossaryInputConfigOutput) ToGlossaryInputConfigPtrOutput() GlossaryInputConfigPtrOutput {
	return o.ToGlossaryInputConfigPtrOutputWithContext(context.Background())
}

func (o GlossaryInputConfigOutput) ToGlossaryInputConfigPtrOutputWithContext(ctx context.Context) GlossaryInputConfigPtrOutput {
	return o.ApplyT(func(v GlossaryInputConfig) *GlossaryInputConfig {
		return &v
	}).(GlossaryInputConfigPtrOutput)
}

// Required. Google Cloud Storage location of glossary data. File format is determined based on the filename extension. API returns [google.rpc.Code.INVALID_ARGUMENT] for unsupported URI-s and file formats. Wildcards are not allowed. This must be a single file in one of the following formats: For unidirectional glossaries: - TSV/CSV (`.tsv`/`.csv`): 2 column file, tab- or comma-separated. The first column is source text. The second column is target text. The file must not contain headers. That is, the first row is data, not column names. - TMX (`.tmx`): TMX file with parallel data defining source/target term pairs. For equivalent term sets glossaries: - CSV (`.csv`): Multi-column CSV file defining equivalent glossary terms in multiple languages. See documentation for more information - [glossaries](https://cloud.google.com/translate/docs/advanced/glossary).
func (o GlossaryInputConfigOutput) GcsSource() GcsSourcePtrOutput {
	return o.ApplyT(func(v GlossaryInputConfig) *GcsSource { return v.GcsSource }).(GcsSourcePtrOutput)
}

type GlossaryInputConfigPtrOutput struct{ *pulumi.OutputState }

func (GlossaryInputConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GlossaryInputConfig)(nil)).Elem()
}

func (o GlossaryInputConfigPtrOutput) ToGlossaryInputConfigPtrOutput() GlossaryInputConfigPtrOutput {
	return o
}

func (o GlossaryInputConfigPtrOutput) ToGlossaryInputConfigPtrOutputWithContext(ctx context.Context) GlossaryInputConfigPtrOutput {
	return o
}

func (o GlossaryInputConfigPtrOutput) Elem() GlossaryInputConfigOutput {
	return o.ApplyT(func(v *GlossaryInputConfig) GlossaryInputConfig { return *v }).(GlossaryInputConfigOutput)
}

// Required. Google Cloud Storage location of glossary data. File format is determined based on the filename extension. API returns [google.rpc.Code.INVALID_ARGUMENT] for unsupported URI-s and file formats. Wildcards are not allowed. This must be a single file in one of the following formats: For unidirectional glossaries: - TSV/CSV (`.tsv`/`.csv`): 2 column file, tab- or comma-separated. The first column is source text. The second column is target text. The file must not contain headers. That is, the first row is data, not column names. - TMX (`.tmx`): TMX file with parallel data defining source/target term pairs. For equivalent term sets glossaries: - CSV (`.csv`): Multi-column CSV file defining equivalent glossary terms in multiple languages. See documentation for more information - [glossaries](https://cloud.google.com/translate/docs/advanced/glossary).
func (o GlossaryInputConfigPtrOutput) GcsSource() GcsSourcePtrOutput {
	return o.ApplyT(func(v *GlossaryInputConfig) *GcsSource {
		if v == nil {
			return nil
		}
		return v.GcsSource
	}).(GcsSourcePtrOutput)
}

// Used with unidirectional glossaries.
type LanguageCodePair struct {
	// Required. The BCP-47 language code of the input text, for example, "en-US". Expected to be an exact match for GlossaryTerm.language_code.
	SourceLanguageCode *string `pulumi:"sourceLanguageCode"`
	// Required. The BCP-47 language code for translation output, for example, "zh-CN". Expected to be an exact match for GlossaryTerm.language_code.
	TargetLanguageCode *string `pulumi:"targetLanguageCode"`
}

// LanguageCodePairInput is an input type that accepts LanguageCodePairArgs and LanguageCodePairOutput values.
// You can construct a concrete instance of `LanguageCodePairInput` via:
//
//          LanguageCodePairArgs{...}
type LanguageCodePairInput interface {
	pulumi.Input

	ToLanguageCodePairOutput() LanguageCodePairOutput
	ToLanguageCodePairOutputWithContext(context.Context) LanguageCodePairOutput
}

// Used with unidirectional glossaries.
type LanguageCodePairArgs struct {
	// Required. The BCP-47 language code of the input text, for example, "en-US". Expected to be an exact match for GlossaryTerm.language_code.
	SourceLanguageCode pulumi.StringPtrInput `pulumi:"sourceLanguageCode"`
	// Required. The BCP-47 language code for translation output, for example, "zh-CN". Expected to be an exact match for GlossaryTerm.language_code.
	TargetLanguageCode pulumi.StringPtrInput `pulumi:"targetLanguageCode"`
}

func (LanguageCodePairArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LanguageCodePair)(nil)).Elem()
}

func (i LanguageCodePairArgs) ToLanguageCodePairOutput() LanguageCodePairOutput {
	return i.ToLanguageCodePairOutputWithContext(context.Background())
}

func (i LanguageCodePairArgs) ToLanguageCodePairOutputWithContext(ctx context.Context) LanguageCodePairOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LanguageCodePairOutput)
}

func (i LanguageCodePairArgs) ToLanguageCodePairPtrOutput() LanguageCodePairPtrOutput {
	return i.ToLanguageCodePairPtrOutputWithContext(context.Background())
}

func (i LanguageCodePairArgs) ToLanguageCodePairPtrOutputWithContext(ctx context.Context) LanguageCodePairPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LanguageCodePairOutput).ToLanguageCodePairPtrOutputWithContext(ctx)
}

// LanguageCodePairPtrInput is an input type that accepts LanguageCodePairArgs, LanguageCodePairPtr and LanguageCodePairPtrOutput values.
// You can construct a concrete instance of `LanguageCodePairPtrInput` via:
//
//          LanguageCodePairArgs{...}
//
//  or:
//
//          nil
type LanguageCodePairPtrInput interface {
	pulumi.Input

	ToLanguageCodePairPtrOutput() LanguageCodePairPtrOutput
	ToLanguageCodePairPtrOutputWithContext(context.Context) LanguageCodePairPtrOutput
}

type languageCodePairPtrType LanguageCodePairArgs

func LanguageCodePairPtr(v *LanguageCodePairArgs) LanguageCodePairPtrInput {
	return (*languageCodePairPtrType)(v)
}

func (*languageCodePairPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LanguageCodePair)(nil)).Elem()
}

func (i *languageCodePairPtrType) ToLanguageCodePairPtrOutput() LanguageCodePairPtrOutput {
	return i.ToLanguageCodePairPtrOutputWithContext(context.Background())
}

func (i *languageCodePairPtrType) ToLanguageCodePairPtrOutputWithContext(ctx context.Context) LanguageCodePairPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LanguageCodePairPtrOutput)
}

// Used with unidirectional glossaries.
type LanguageCodePairOutput struct{ *pulumi.OutputState }

func (LanguageCodePairOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LanguageCodePair)(nil)).Elem()
}

func (o LanguageCodePairOutput) ToLanguageCodePairOutput() LanguageCodePairOutput {
	return o
}

func (o LanguageCodePairOutput) ToLanguageCodePairOutputWithContext(ctx context.Context) LanguageCodePairOutput {
	return o
}

func (o LanguageCodePairOutput) ToLanguageCodePairPtrOutput() LanguageCodePairPtrOutput {
	return o.ToLanguageCodePairPtrOutputWithContext(context.Background())
}

func (o LanguageCodePairOutput) ToLanguageCodePairPtrOutputWithContext(ctx context.Context) LanguageCodePairPtrOutput {
	return o.ApplyT(func(v LanguageCodePair) *LanguageCodePair {
		return &v
	}).(LanguageCodePairPtrOutput)
}

// Required. The BCP-47 language code of the input text, for example, "en-US". Expected to be an exact match for GlossaryTerm.language_code.
func (o LanguageCodePairOutput) SourceLanguageCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LanguageCodePair) *string { return v.SourceLanguageCode }).(pulumi.StringPtrOutput)
}

// Required. The BCP-47 language code for translation output, for example, "zh-CN". Expected to be an exact match for GlossaryTerm.language_code.
func (o LanguageCodePairOutput) TargetLanguageCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LanguageCodePair) *string { return v.TargetLanguageCode }).(pulumi.StringPtrOutput)
}

type LanguageCodePairPtrOutput struct{ *pulumi.OutputState }

func (LanguageCodePairPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LanguageCodePair)(nil)).Elem()
}

func (o LanguageCodePairPtrOutput) ToLanguageCodePairPtrOutput() LanguageCodePairPtrOutput {
	return o
}

func (o LanguageCodePairPtrOutput) ToLanguageCodePairPtrOutputWithContext(ctx context.Context) LanguageCodePairPtrOutput {
	return o
}

func (o LanguageCodePairPtrOutput) Elem() LanguageCodePairOutput {
	return o.ApplyT(func(v *LanguageCodePair) LanguageCodePair { return *v }).(LanguageCodePairOutput)
}

// Required. The BCP-47 language code of the input text, for example, "en-US". Expected to be an exact match for GlossaryTerm.language_code.
func (o LanguageCodePairPtrOutput) SourceLanguageCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LanguageCodePair) *string {
		if v == nil {
			return nil
		}
		return v.SourceLanguageCode
	}).(pulumi.StringPtrOutput)
}

// Required. The BCP-47 language code for translation output, for example, "zh-CN". Expected to be an exact match for GlossaryTerm.language_code.
func (o LanguageCodePairPtrOutput) TargetLanguageCode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LanguageCodePair) *string {
		if v == nil {
			return nil
		}
		return v.TargetLanguageCode
	}).(pulumi.StringPtrOutput)
}

// Used with equivalent term set glossaries.
type LanguageCodesSet struct {
	// The BCP-47 language code(s) for terms defined in the glossary. All entries are unique. The list contains at least two entries. Expected to be an exact match for GlossaryTerm.language_code.
	LanguageCodes []string `pulumi:"languageCodes"`
}

// LanguageCodesSetInput is an input type that accepts LanguageCodesSetArgs and LanguageCodesSetOutput values.
// You can construct a concrete instance of `LanguageCodesSetInput` via:
//
//          LanguageCodesSetArgs{...}
type LanguageCodesSetInput interface {
	pulumi.Input

	ToLanguageCodesSetOutput() LanguageCodesSetOutput
	ToLanguageCodesSetOutputWithContext(context.Context) LanguageCodesSetOutput
}

// Used with equivalent term set glossaries.
type LanguageCodesSetArgs struct {
	// The BCP-47 language code(s) for terms defined in the glossary. All entries are unique. The list contains at least two entries. Expected to be an exact match for GlossaryTerm.language_code.
	LanguageCodes pulumi.StringArrayInput `pulumi:"languageCodes"`
}

func (LanguageCodesSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LanguageCodesSet)(nil)).Elem()
}

func (i LanguageCodesSetArgs) ToLanguageCodesSetOutput() LanguageCodesSetOutput {
	return i.ToLanguageCodesSetOutputWithContext(context.Background())
}

func (i LanguageCodesSetArgs) ToLanguageCodesSetOutputWithContext(ctx context.Context) LanguageCodesSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LanguageCodesSetOutput)
}

func (i LanguageCodesSetArgs) ToLanguageCodesSetPtrOutput() LanguageCodesSetPtrOutput {
	return i.ToLanguageCodesSetPtrOutputWithContext(context.Background())
}

func (i LanguageCodesSetArgs) ToLanguageCodesSetPtrOutputWithContext(ctx context.Context) LanguageCodesSetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LanguageCodesSetOutput).ToLanguageCodesSetPtrOutputWithContext(ctx)
}

// LanguageCodesSetPtrInput is an input type that accepts LanguageCodesSetArgs, LanguageCodesSetPtr and LanguageCodesSetPtrOutput values.
// You can construct a concrete instance of `LanguageCodesSetPtrInput` via:
//
//          LanguageCodesSetArgs{...}
//
//  or:
//
//          nil
type LanguageCodesSetPtrInput interface {
	pulumi.Input

	ToLanguageCodesSetPtrOutput() LanguageCodesSetPtrOutput
	ToLanguageCodesSetPtrOutputWithContext(context.Context) LanguageCodesSetPtrOutput
}

type languageCodesSetPtrType LanguageCodesSetArgs

func LanguageCodesSetPtr(v *LanguageCodesSetArgs) LanguageCodesSetPtrInput {
	return (*languageCodesSetPtrType)(v)
}

func (*languageCodesSetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LanguageCodesSet)(nil)).Elem()
}

func (i *languageCodesSetPtrType) ToLanguageCodesSetPtrOutput() LanguageCodesSetPtrOutput {
	return i.ToLanguageCodesSetPtrOutputWithContext(context.Background())
}

func (i *languageCodesSetPtrType) ToLanguageCodesSetPtrOutputWithContext(ctx context.Context) LanguageCodesSetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LanguageCodesSetPtrOutput)
}

// Used with equivalent term set glossaries.
type LanguageCodesSetOutput struct{ *pulumi.OutputState }

func (LanguageCodesSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LanguageCodesSet)(nil)).Elem()
}

func (o LanguageCodesSetOutput) ToLanguageCodesSetOutput() LanguageCodesSetOutput {
	return o
}

func (o LanguageCodesSetOutput) ToLanguageCodesSetOutputWithContext(ctx context.Context) LanguageCodesSetOutput {
	return o
}

func (o LanguageCodesSetOutput) ToLanguageCodesSetPtrOutput() LanguageCodesSetPtrOutput {
	return o.ToLanguageCodesSetPtrOutputWithContext(context.Background())
}

func (o LanguageCodesSetOutput) ToLanguageCodesSetPtrOutputWithContext(ctx context.Context) LanguageCodesSetPtrOutput {
	return o.ApplyT(func(v LanguageCodesSet) *LanguageCodesSet {
		return &v
	}).(LanguageCodesSetPtrOutput)
}

// The BCP-47 language code(s) for terms defined in the glossary. All entries are unique. The list contains at least two entries. Expected to be an exact match for GlossaryTerm.language_code.
func (o LanguageCodesSetOutput) LanguageCodes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LanguageCodesSet) []string { return v.LanguageCodes }).(pulumi.StringArrayOutput)
}

type LanguageCodesSetPtrOutput struct{ *pulumi.OutputState }

func (LanguageCodesSetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LanguageCodesSet)(nil)).Elem()
}

func (o LanguageCodesSetPtrOutput) ToLanguageCodesSetPtrOutput() LanguageCodesSetPtrOutput {
	return o
}

func (o LanguageCodesSetPtrOutput) ToLanguageCodesSetPtrOutputWithContext(ctx context.Context) LanguageCodesSetPtrOutput {
	return o
}

func (o LanguageCodesSetPtrOutput) Elem() LanguageCodesSetOutput {
	return o.ApplyT(func(v *LanguageCodesSet) LanguageCodesSet { return *v }).(LanguageCodesSetOutput)
}

// The BCP-47 language code(s) for terms defined in the glossary. All entries are unique. The list contains at least two entries. Expected to be an exact match for GlossaryTerm.language_code.
func (o LanguageCodesSetPtrOutput) LanguageCodes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LanguageCodesSet) []string {
		if v == nil {
			return nil
		}
		return v.LanguageCodes
	}).(pulumi.StringArrayOutput)
}

func init() {
	pulumi.RegisterOutputType(GcsSourceOutput{})
	pulumi.RegisterOutputType(GcsSourcePtrOutput{})
	pulumi.RegisterOutputType(GlossaryInputConfigOutput{})
	pulumi.RegisterOutputType(GlossaryInputConfigPtrOutput{})
	pulumi.RegisterOutputType(LanguageCodePairOutput{})
	pulumi.RegisterOutputType(LanguageCodePairPtrOutput{})
	pulumi.RegisterOutputType(LanguageCodesSetOutput{})
	pulumi.RegisterOutputType(LanguageCodesSetPtrOutput{})
}
