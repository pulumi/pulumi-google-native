// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.googlenative.bigquery.v2.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.googlenative.bigquery.v2.outputs.CloneDefinitionResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.ClusteringResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.EncryptionConfigurationResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.ExternalDataConfigurationResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.MaterializedViewDefinitionResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.ModelDefinitionResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.RangePartitioningResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.SnapshotDefinitionResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.StreamingbufferResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.TableReferenceResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.TableSchemaResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.TimePartitioningResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.ViewDefinitionResponse;
import java.lang.Boolean;
import java.lang.String;
import java.util.Map;
import java.util.Objects;

@CustomType
public final class GetTableResult {
    /**
     * @return Clone definition.
     * 
     */
    private CloneDefinitionResponse cloneDefinition;
    /**
     * @return [Beta] Clustering specification for the table. Must be specified with partitioning, data in the table will be first partitioned and subsequently clustered.
     * 
     */
    private ClusteringResponse clustering;
    /**
     * @return The time when this table was created, in milliseconds since the epoch.
     * 
     */
    private String creationTime;
    /**
     * @return The default collation of the table.
     * 
     */
    private String defaultCollation;
    /**
     * @return [Optional] A user-friendly description of this table.
     * 
     */
    private String description;
    /**
     * @return Custom encryption configuration (e.g., Cloud KMS keys).
     * 
     */
    private EncryptionConfigurationResponse encryptionConfiguration;
    /**
     * @return A hash of the table metadata. Used to ensure there were no concurrent modifications to the resource when attempting an update. Not guaranteed to change when the table contents or the fields numRows, numBytes, numLongTermBytes or lastModifiedTime change.
     * 
     */
    private String etag;
    /**
     * @return [Optional] The time when this table expires, in milliseconds since the epoch. If not present, the table will persist indefinitely. Expired tables will be deleted and their storage reclaimed. The defaultTableExpirationMs property of the encapsulating dataset can be used to set a default expirationTime on newly created tables.
     * 
     */
    private String expirationTime;
    /**
     * @return [Optional] Describes the data format, location, and other properties of a table stored outside of BigQuery. By defining these properties, the data source can then be queried as if it were a standard BigQuery table.
     * 
     */
    private ExternalDataConfigurationResponse externalDataConfiguration;
    /**
     * @return [Optional] A descriptive name for this table.
     * 
     */
    private String friendlyName;
    /**
     * @return The type of the resource.
     * 
     */
    private String kind;
    /**
     * @return The labels associated with this table. You can use these to organize and group your tables. Label keys and values can be no longer than 63 characters, can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. Label values are optional. Label keys must start with a letter and each label in the list must have a different key.
     * 
     */
    private Map<String,String> labels;
    /**
     * @return The time when this table was last modified, in milliseconds since the epoch.
     * 
     */
    private String lastModifiedTime;
    /**
     * @return The geographic location where the table resides. This value is inherited from the dataset.
     * 
     */
    private String location;
    /**
     * @return [Optional] Materialized view definition.
     * 
     */
    private MaterializedViewDefinitionResponse materializedView;
    /**
     * @return [Optional] Max staleness of data that could be returned when table or materialized view is queried (formatted as Google SQL Interval type).
     * 
     */
    private String maxStaleness;
    /**
     * @return [Output-only, Beta] Present iff this table represents a ML model. Describes the training information for the model, and it is required to run &#39;PREDICT&#39; queries.
     * 
     */
    private ModelDefinitionResponse model;
    /**
     * @return Number of logical bytes that are less than 90 days old.
     * 
     */
    private String numActiveLogicalBytes;
    /**
     * @return Number of physical bytes less than 90 days old. This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
     * 
     */
    private String numActivePhysicalBytes;
    /**
     * @return The size of this table in bytes, excluding any data in the streaming buffer.
     * 
     */
    private String numBytes;
    /**
     * @return The number of bytes in the table that are considered &#34;long-term storage&#34;.
     * 
     */
    private String numLongTermBytes;
    /**
     * @return Number of logical bytes that are more than 90 days old.
     * 
     */
    private String numLongTermLogicalBytes;
    /**
     * @return Number of physical bytes more than 90 days old. This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
     * 
     */
    private String numLongTermPhysicalBytes;
    /**
     * @return The number of partitions present in the table or materialized view. This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
     * 
     */
    private String numPartitions;
    /**
     * @return [TrustedTester] The physical size of this table in bytes, excluding any data in the streaming buffer. This includes compression and storage used for time travel.
     * 
     */
    private String numPhysicalBytes;
    /**
     * @return The number of rows of data in this table, excluding any data in the streaming buffer.
     * 
     */
    private String numRows;
    /**
     * @return Number of physical bytes used by time travel storage (deleted or changed data). This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
     * 
     */
    private String numTimeTravelPhysicalBytes;
    /**
     * @return Total number of logical bytes in the table or materialized view.
     * 
     */
    private String numTotalLogicalBytes;
    /**
     * @return The physical size of this table in bytes. This also includes storage used for time travel. This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
     * 
     */
    private String numTotalPhysicalBytes;
    /**
     * @return [TrustedTester] Range partitioning specification for this table. Only one of timePartitioning and rangePartitioning should be specified.
     * 
     */
    private RangePartitioningResponse rangePartitioning;
    /**
     * @return [Optional] If set to true, queries over this table require a partition filter that can be used for partition elimination to be specified.
     * 
     */
    private Boolean requirePartitionFilter;
    /**
     * @return [Optional] Describes the schema of this table.
     * 
     */
    private TableSchemaResponse schema;
    /**
     * @return A URL that can be used to access this resource again.
     * 
     */
    private String selfLink;
    /**
     * @return Snapshot definition.
     * 
     */
    private SnapshotDefinitionResponse snapshotDefinition;
    /**
     * @return Contains information regarding this table&#39;s streaming buffer, if one is present. This field will be absent if the table is not being streamed to or if there is no data in the streaming buffer.
     * 
     */
    private StreamingbufferResponse streamingBuffer;
    /**
     * @return [Required] Reference describing the ID of this table.
     * 
     */
    private TableReferenceResponse tableReference;
    /**
     * @return Time-based partitioning specification for this table. Only one of timePartitioning and rangePartitioning should be specified.
     * 
     */
    private TimePartitioningResponse timePartitioning;
    /**
     * @return Describes the table type. The following values are supported: TABLE: A normal BigQuery table. VIEW: A virtual table defined by a SQL query. SNAPSHOT: An immutable, read-only table that is a copy of another table. [TrustedTester] MATERIALIZED_VIEW: SQL query whose result is persisted. EXTERNAL: A table that references data stored in an external storage system, such as Google Cloud Storage. The default value is TABLE.
     * 
     */
    private String type;
    /**
     * @return [Optional] The view definition.
     * 
     */
    private ViewDefinitionResponse view;

    private GetTableResult() {}
    /**
     * @return Clone definition.
     * 
     */
    public CloneDefinitionResponse cloneDefinition() {
        return this.cloneDefinition;
    }
    /**
     * @return [Beta] Clustering specification for the table. Must be specified with partitioning, data in the table will be first partitioned and subsequently clustered.
     * 
     */
    public ClusteringResponse clustering() {
        return this.clustering;
    }
    /**
     * @return The time when this table was created, in milliseconds since the epoch.
     * 
     */
    public String creationTime() {
        return this.creationTime;
    }
    /**
     * @return The default collation of the table.
     * 
     */
    public String defaultCollation() {
        return this.defaultCollation;
    }
    /**
     * @return [Optional] A user-friendly description of this table.
     * 
     */
    public String description() {
        return this.description;
    }
    /**
     * @return Custom encryption configuration (e.g., Cloud KMS keys).
     * 
     */
    public EncryptionConfigurationResponse encryptionConfiguration() {
        return this.encryptionConfiguration;
    }
    /**
     * @return A hash of the table metadata. Used to ensure there were no concurrent modifications to the resource when attempting an update. Not guaranteed to change when the table contents or the fields numRows, numBytes, numLongTermBytes or lastModifiedTime change.
     * 
     */
    public String etag() {
        return this.etag;
    }
    /**
     * @return [Optional] The time when this table expires, in milliseconds since the epoch. If not present, the table will persist indefinitely. Expired tables will be deleted and their storage reclaimed. The defaultTableExpirationMs property of the encapsulating dataset can be used to set a default expirationTime on newly created tables.
     * 
     */
    public String expirationTime() {
        return this.expirationTime;
    }
    /**
     * @return [Optional] Describes the data format, location, and other properties of a table stored outside of BigQuery. By defining these properties, the data source can then be queried as if it were a standard BigQuery table.
     * 
     */
    public ExternalDataConfigurationResponse externalDataConfiguration() {
        return this.externalDataConfiguration;
    }
    /**
     * @return [Optional] A descriptive name for this table.
     * 
     */
    public String friendlyName() {
        return this.friendlyName;
    }
    /**
     * @return The type of the resource.
     * 
     */
    public String kind() {
        return this.kind;
    }
    /**
     * @return The labels associated with this table. You can use these to organize and group your tables. Label keys and values can be no longer than 63 characters, can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. Label values are optional. Label keys must start with a letter and each label in the list must have a different key.
     * 
     */
    public Map<String,String> labels() {
        return this.labels;
    }
    /**
     * @return The time when this table was last modified, in milliseconds since the epoch.
     * 
     */
    public String lastModifiedTime() {
        return this.lastModifiedTime;
    }
    /**
     * @return The geographic location where the table resides. This value is inherited from the dataset.
     * 
     */
    public String location() {
        return this.location;
    }
    /**
     * @return [Optional] Materialized view definition.
     * 
     */
    public MaterializedViewDefinitionResponse materializedView() {
        return this.materializedView;
    }
    /**
     * @return [Optional] Max staleness of data that could be returned when table or materialized view is queried (formatted as Google SQL Interval type).
     * 
     */
    public String maxStaleness() {
        return this.maxStaleness;
    }
    /**
     * @return [Output-only, Beta] Present iff this table represents a ML model. Describes the training information for the model, and it is required to run &#39;PREDICT&#39; queries.
     * 
     */
    public ModelDefinitionResponse model() {
        return this.model;
    }
    /**
     * @return Number of logical bytes that are less than 90 days old.
     * 
     */
    public String numActiveLogicalBytes() {
        return this.numActiveLogicalBytes;
    }
    /**
     * @return Number of physical bytes less than 90 days old. This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
     * 
     */
    public String numActivePhysicalBytes() {
        return this.numActivePhysicalBytes;
    }
    /**
     * @return The size of this table in bytes, excluding any data in the streaming buffer.
     * 
     */
    public String numBytes() {
        return this.numBytes;
    }
    /**
     * @return The number of bytes in the table that are considered &#34;long-term storage&#34;.
     * 
     */
    public String numLongTermBytes() {
        return this.numLongTermBytes;
    }
    /**
     * @return Number of logical bytes that are more than 90 days old.
     * 
     */
    public String numLongTermLogicalBytes() {
        return this.numLongTermLogicalBytes;
    }
    /**
     * @return Number of physical bytes more than 90 days old. This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
     * 
     */
    public String numLongTermPhysicalBytes() {
        return this.numLongTermPhysicalBytes;
    }
    /**
     * @return The number of partitions present in the table or materialized view. This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
     * 
     */
    public String numPartitions() {
        return this.numPartitions;
    }
    /**
     * @return [TrustedTester] The physical size of this table in bytes, excluding any data in the streaming buffer. This includes compression and storage used for time travel.
     * 
     */
    public String numPhysicalBytes() {
        return this.numPhysicalBytes;
    }
    /**
     * @return The number of rows of data in this table, excluding any data in the streaming buffer.
     * 
     */
    public String numRows() {
        return this.numRows;
    }
    /**
     * @return Number of physical bytes used by time travel storage (deleted or changed data). This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
     * 
     */
    public String numTimeTravelPhysicalBytes() {
        return this.numTimeTravelPhysicalBytes;
    }
    /**
     * @return Total number of logical bytes in the table or materialized view.
     * 
     */
    public String numTotalLogicalBytes() {
        return this.numTotalLogicalBytes;
    }
    /**
     * @return The physical size of this table in bytes. This also includes storage used for time travel. This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
     * 
     */
    public String numTotalPhysicalBytes() {
        return this.numTotalPhysicalBytes;
    }
    /**
     * @return [TrustedTester] Range partitioning specification for this table. Only one of timePartitioning and rangePartitioning should be specified.
     * 
     */
    public RangePartitioningResponse rangePartitioning() {
        return this.rangePartitioning;
    }
    /**
     * @return [Optional] If set to true, queries over this table require a partition filter that can be used for partition elimination to be specified.
     * 
     */
    public Boolean requirePartitionFilter() {
        return this.requirePartitionFilter;
    }
    /**
     * @return [Optional] Describes the schema of this table.
     * 
     */
    public TableSchemaResponse schema() {
        return this.schema;
    }
    /**
     * @return A URL that can be used to access this resource again.
     * 
     */
    public String selfLink() {
        return this.selfLink;
    }
    /**
     * @return Snapshot definition.
     * 
     */
    public SnapshotDefinitionResponse snapshotDefinition() {
        return this.snapshotDefinition;
    }
    /**
     * @return Contains information regarding this table&#39;s streaming buffer, if one is present. This field will be absent if the table is not being streamed to or if there is no data in the streaming buffer.
     * 
     */
    public StreamingbufferResponse streamingBuffer() {
        return this.streamingBuffer;
    }
    /**
     * @return [Required] Reference describing the ID of this table.
     * 
     */
    public TableReferenceResponse tableReference() {
        return this.tableReference;
    }
    /**
     * @return Time-based partitioning specification for this table. Only one of timePartitioning and rangePartitioning should be specified.
     * 
     */
    public TimePartitioningResponse timePartitioning() {
        return this.timePartitioning;
    }
    /**
     * @return Describes the table type. The following values are supported: TABLE: A normal BigQuery table. VIEW: A virtual table defined by a SQL query. SNAPSHOT: An immutable, read-only table that is a copy of another table. [TrustedTester] MATERIALIZED_VIEW: SQL query whose result is persisted. EXTERNAL: A table that references data stored in an external storage system, such as Google Cloud Storage. The default value is TABLE.
     * 
     */
    public String type() {
        return this.type;
    }
    /**
     * @return [Optional] The view definition.
     * 
     */
    public ViewDefinitionResponse view() {
        return this.view;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetTableResult defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private CloneDefinitionResponse cloneDefinition;
        private ClusteringResponse clustering;
        private String creationTime;
        private String defaultCollation;
        private String description;
        private EncryptionConfigurationResponse encryptionConfiguration;
        private String etag;
        private String expirationTime;
        private ExternalDataConfigurationResponse externalDataConfiguration;
        private String friendlyName;
        private String kind;
        private Map<String,String> labels;
        private String lastModifiedTime;
        private String location;
        private MaterializedViewDefinitionResponse materializedView;
        private String maxStaleness;
        private ModelDefinitionResponse model;
        private String numActiveLogicalBytes;
        private String numActivePhysicalBytes;
        private String numBytes;
        private String numLongTermBytes;
        private String numLongTermLogicalBytes;
        private String numLongTermPhysicalBytes;
        private String numPartitions;
        private String numPhysicalBytes;
        private String numRows;
        private String numTimeTravelPhysicalBytes;
        private String numTotalLogicalBytes;
        private String numTotalPhysicalBytes;
        private RangePartitioningResponse rangePartitioning;
        private Boolean requirePartitionFilter;
        private TableSchemaResponse schema;
        private String selfLink;
        private SnapshotDefinitionResponse snapshotDefinition;
        private StreamingbufferResponse streamingBuffer;
        private TableReferenceResponse tableReference;
        private TimePartitioningResponse timePartitioning;
        private String type;
        private ViewDefinitionResponse view;
        public Builder() {}
        public Builder(GetTableResult defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.cloneDefinition = defaults.cloneDefinition;
    	      this.clustering = defaults.clustering;
    	      this.creationTime = defaults.creationTime;
    	      this.defaultCollation = defaults.defaultCollation;
    	      this.description = defaults.description;
    	      this.encryptionConfiguration = defaults.encryptionConfiguration;
    	      this.etag = defaults.etag;
    	      this.expirationTime = defaults.expirationTime;
    	      this.externalDataConfiguration = defaults.externalDataConfiguration;
    	      this.friendlyName = defaults.friendlyName;
    	      this.kind = defaults.kind;
    	      this.labels = defaults.labels;
    	      this.lastModifiedTime = defaults.lastModifiedTime;
    	      this.location = defaults.location;
    	      this.materializedView = defaults.materializedView;
    	      this.maxStaleness = defaults.maxStaleness;
    	      this.model = defaults.model;
    	      this.numActiveLogicalBytes = defaults.numActiveLogicalBytes;
    	      this.numActivePhysicalBytes = defaults.numActivePhysicalBytes;
    	      this.numBytes = defaults.numBytes;
    	      this.numLongTermBytes = defaults.numLongTermBytes;
    	      this.numLongTermLogicalBytes = defaults.numLongTermLogicalBytes;
    	      this.numLongTermPhysicalBytes = defaults.numLongTermPhysicalBytes;
    	      this.numPartitions = defaults.numPartitions;
    	      this.numPhysicalBytes = defaults.numPhysicalBytes;
    	      this.numRows = defaults.numRows;
    	      this.numTimeTravelPhysicalBytes = defaults.numTimeTravelPhysicalBytes;
    	      this.numTotalLogicalBytes = defaults.numTotalLogicalBytes;
    	      this.numTotalPhysicalBytes = defaults.numTotalPhysicalBytes;
    	      this.rangePartitioning = defaults.rangePartitioning;
    	      this.requirePartitionFilter = defaults.requirePartitionFilter;
    	      this.schema = defaults.schema;
    	      this.selfLink = defaults.selfLink;
    	      this.snapshotDefinition = defaults.snapshotDefinition;
    	      this.streamingBuffer = defaults.streamingBuffer;
    	      this.tableReference = defaults.tableReference;
    	      this.timePartitioning = defaults.timePartitioning;
    	      this.type = defaults.type;
    	      this.view = defaults.view;
        }

        @CustomType.Setter
        public Builder cloneDefinition(CloneDefinitionResponse cloneDefinition) {
            this.cloneDefinition = Objects.requireNonNull(cloneDefinition);
            return this;
        }
        @CustomType.Setter
        public Builder clustering(ClusteringResponse clustering) {
            this.clustering = Objects.requireNonNull(clustering);
            return this;
        }
        @CustomType.Setter
        public Builder creationTime(String creationTime) {
            this.creationTime = Objects.requireNonNull(creationTime);
            return this;
        }
        @CustomType.Setter
        public Builder defaultCollation(String defaultCollation) {
            this.defaultCollation = Objects.requireNonNull(defaultCollation);
            return this;
        }
        @CustomType.Setter
        public Builder description(String description) {
            this.description = Objects.requireNonNull(description);
            return this;
        }
        @CustomType.Setter
        public Builder encryptionConfiguration(EncryptionConfigurationResponse encryptionConfiguration) {
            this.encryptionConfiguration = Objects.requireNonNull(encryptionConfiguration);
            return this;
        }
        @CustomType.Setter
        public Builder etag(String etag) {
            this.etag = Objects.requireNonNull(etag);
            return this;
        }
        @CustomType.Setter
        public Builder expirationTime(String expirationTime) {
            this.expirationTime = Objects.requireNonNull(expirationTime);
            return this;
        }
        @CustomType.Setter
        public Builder externalDataConfiguration(ExternalDataConfigurationResponse externalDataConfiguration) {
            this.externalDataConfiguration = Objects.requireNonNull(externalDataConfiguration);
            return this;
        }
        @CustomType.Setter
        public Builder friendlyName(String friendlyName) {
            this.friendlyName = Objects.requireNonNull(friendlyName);
            return this;
        }
        @CustomType.Setter
        public Builder kind(String kind) {
            this.kind = Objects.requireNonNull(kind);
            return this;
        }
        @CustomType.Setter
        public Builder labels(Map<String,String> labels) {
            this.labels = Objects.requireNonNull(labels);
            return this;
        }
        @CustomType.Setter
        public Builder lastModifiedTime(String lastModifiedTime) {
            this.lastModifiedTime = Objects.requireNonNull(lastModifiedTime);
            return this;
        }
        @CustomType.Setter
        public Builder location(String location) {
            this.location = Objects.requireNonNull(location);
            return this;
        }
        @CustomType.Setter
        public Builder materializedView(MaterializedViewDefinitionResponse materializedView) {
            this.materializedView = Objects.requireNonNull(materializedView);
            return this;
        }
        @CustomType.Setter
        public Builder maxStaleness(String maxStaleness) {
            this.maxStaleness = Objects.requireNonNull(maxStaleness);
            return this;
        }
        @CustomType.Setter
        public Builder model(ModelDefinitionResponse model) {
            this.model = Objects.requireNonNull(model);
            return this;
        }
        @CustomType.Setter
        public Builder numActiveLogicalBytes(String numActiveLogicalBytes) {
            this.numActiveLogicalBytes = Objects.requireNonNull(numActiveLogicalBytes);
            return this;
        }
        @CustomType.Setter
        public Builder numActivePhysicalBytes(String numActivePhysicalBytes) {
            this.numActivePhysicalBytes = Objects.requireNonNull(numActivePhysicalBytes);
            return this;
        }
        @CustomType.Setter
        public Builder numBytes(String numBytes) {
            this.numBytes = Objects.requireNonNull(numBytes);
            return this;
        }
        @CustomType.Setter
        public Builder numLongTermBytes(String numLongTermBytes) {
            this.numLongTermBytes = Objects.requireNonNull(numLongTermBytes);
            return this;
        }
        @CustomType.Setter
        public Builder numLongTermLogicalBytes(String numLongTermLogicalBytes) {
            this.numLongTermLogicalBytes = Objects.requireNonNull(numLongTermLogicalBytes);
            return this;
        }
        @CustomType.Setter
        public Builder numLongTermPhysicalBytes(String numLongTermPhysicalBytes) {
            this.numLongTermPhysicalBytes = Objects.requireNonNull(numLongTermPhysicalBytes);
            return this;
        }
        @CustomType.Setter
        public Builder numPartitions(String numPartitions) {
            this.numPartitions = Objects.requireNonNull(numPartitions);
            return this;
        }
        @CustomType.Setter
        public Builder numPhysicalBytes(String numPhysicalBytes) {
            this.numPhysicalBytes = Objects.requireNonNull(numPhysicalBytes);
            return this;
        }
        @CustomType.Setter
        public Builder numRows(String numRows) {
            this.numRows = Objects.requireNonNull(numRows);
            return this;
        }
        @CustomType.Setter
        public Builder numTimeTravelPhysicalBytes(String numTimeTravelPhysicalBytes) {
            this.numTimeTravelPhysicalBytes = Objects.requireNonNull(numTimeTravelPhysicalBytes);
            return this;
        }
        @CustomType.Setter
        public Builder numTotalLogicalBytes(String numTotalLogicalBytes) {
            this.numTotalLogicalBytes = Objects.requireNonNull(numTotalLogicalBytes);
            return this;
        }
        @CustomType.Setter
        public Builder numTotalPhysicalBytes(String numTotalPhysicalBytes) {
            this.numTotalPhysicalBytes = Objects.requireNonNull(numTotalPhysicalBytes);
            return this;
        }
        @CustomType.Setter
        public Builder rangePartitioning(RangePartitioningResponse rangePartitioning) {
            this.rangePartitioning = Objects.requireNonNull(rangePartitioning);
            return this;
        }
        @CustomType.Setter
        public Builder requirePartitionFilter(Boolean requirePartitionFilter) {
            this.requirePartitionFilter = Objects.requireNonNull(requirePartitionFilter);
            return this;
        }
        @CustomType.Setter
        public Builder schema(TableSchemaResponse schema) {
            this.schema = Objects.requireNonNull(schema);
            return this;
        }
        @CustomType.Setter
        public Builder selfLink(String selfLink) {
            this.selfLink = Objects.requireNonNull(selfLink);
            return this;
        }
        @CustomType.Setter
        public Builder snapshotDefinition(SnapshotDefinitionResponse snapshotDefinition) {
            this.snapshotDefinition = Objects.requireNonNull(snapshotDefinition);
            return this;
        }
        @CustomType.Setter
        public Builder streamingBuffer(StreamingbufferResponse streamingBuffer) {
            this.streamingBuffer = Objects.requireNonNull(streamingBuffer);
            return this;
        }
        @CustomType.Setter
        public Builder tableReference(TableReferenceResponse tableReference) {
            this.tableReference = Objects.requireNonNull(tableReference);
            return this;
        }
        @CustomType.Setter
        public Builder timePartitioning(TimePartitioningResponse timePartitioning) {
            this.timePartitioning = Objects.requireNonNull(timePartitioning);
            return this;
        }
        @CustomType.Setter
        public Builder type(String type) {
            this.type = Objects.requireNonNull(type);
            return this;
        }
        @CustomType.Setter
        public Builder view(ViewDefinitionResponse view) {
            this.view = Objects.requireNonNull(view);
            return this;
        }
        public GetTableResult build() {
            final var o = new GetTableResult();
            o.cloneDefinition = cloneDefinition;
            o.clustering = clustering;
            o.creationTime = creationTime;
            o.defaultCollation = defaultCollation;
            o.description = description;
            o.encryptionConfiguration = encryptionConfiguration;
            o.etag = etag;
            o.expirationTime = expirationTime;
            o.externalDataConfiguration = externalDataConfiguration;
            o.friendlyName = friendlyName;
            o.kind = kind;
            o.labels = labels;
            o.lastModifiedTime = lastModifiedTime;
            o.location = location;
            o.materializedView = materializedView;
            o.maxStaleness = maxStaleness;
            o.model = model;
            o.numActiveLogicalBytes = numActiveLogicalBytes;
            o.numActivePhysicalBytes = numActivePhysicalBytes;
            o.numBytes = numBytes;
            o.numLongTermBytes = numLongTermBytes;
            o.numLongTermLogicalBytes = numLongTermLogicalBytes;
            o.numLongTermPhysicalBytes = numLongTermPhysicalBytes;
            o.numPartitions = numPartitions;
            o.numPhysicalBytes = numPhysicalBytes;
            o.numRows = numRows;
            o.numTimeTravelPhysicalBytes = numTimeTravelPhysicalBytes;
            o.numTotalLogicalBytes = numTotalLogicalBytes;
            o.numTotalPhysicalBytes = numTotalPhysicalBytes;
            o.rangePartitioning = rangePartitioning;
            o.requirePartitionFilter = requirePartitionFilter;
            o.schema = schema;
            o.selfLink = selfLink;
            o.snapshotDefinition = snapshotDefinition;
            o.streamingBuffer = streamingBuffer;
            o.tableReference = tableReference;
            o.timePartitioning = timePartitioning;
            o.type = type;
            o.view = view;
            return o;
        }
    }
}
