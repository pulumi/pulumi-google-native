// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.googlenative.cloudbuild.v1.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.googlenative.cloudbuild.v1.outputs.ArtifactsResponse;
import com.pulumi.googlenative.cloudbuild.v1.outputs.BuildApprovalResponse;
import com.pulumi.googlenative.cloudbuild.v1.outputs.BuildOptionsResponse;
import com.pulumi.googlenative.cloudbuild.v1.outputs.BuildStepResponse;
import com.pulumi.googlenative.cloudbuild.v1.outputs.FailureInfoResponse;
import com.pulumi.googlenative.cloudbuild.v1.outputs.ResultsResponse;
import com.pulumi.googlenative.cloudbuild.v1.outputs.SecretResponse;
import com.pulumi.googlenative.cloudbuild.v1.outputs.SecretsResponse;
import com.pulumi.googlenative.cloudbuild.v1.outputs.SourceProvenanceResponse;
import com.pulumi.googlenative.cloudbuild.v1.outputs.SourceResponse;
import com.pulumi.googlenative.cloudbuild.v1.outputs.WarningResponse;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@CustomType
public final class BuildResponse {
    /**
     * @return Describes this build&#39;s approval configuration, status, and result.
     * 
     */
    private BuildApprovalResponse approval;
    /**
     * @return Artifacts produced by the build that should be uploaded upon successful completion of all build steps.
     * 
     */
    private ArtifactsResponse artifacts;
    /**
     * @return Secrets and secret environment variables.
     * 
     */
    private SecretsResponse availableSecrets;
    /**
     * @return The ID of the `BuildTrigger` that triggered this build, if it was triggered automatically.
     * 
     */
    private String buildTriggerId;
    /**
     * @return Time at which the request to create the build was received.
     * 
     */
    private String createTime;
    /**
     * @return Contains information about the build when status=FAILURE.
     * 
     */
    private FailureInfoResponse failureInfo;
    /**
     * @return Time at which execution of the build was finished. The difference between finish_time and start_time is the duration of the build&#39;s execution.
     * 
     */
    private String finishTime;
    /**
     * @return A list of images to be pushed upon the successful completion of all build steps. The images are pushed using the builder service account&#39;s credentials. The digests of the pushed images will be stored in the `Build` resource&#39;s results field. If any of the images fail to be pushed, the build status is marked `FAILURE`.
     * 
     */
    private List<String> images;
    /**
     * @return URL to logs for this build in Google Cloud Console.
     * 
     */
    private String logUrl;
    /**
     * @return Google Cloud Storage bucket where logs should be written (see [Bucket Name Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)). Logs file names will be of the format `${logs_bucket}/log-${build_id}.txt`.
     * 
     */
    private String logsBucket;
    /**
     * @return The &#39;Build&#39; name with format: `projects/{project}/locations/{location}/builds/{build}`, where {build} is a unique identifier generated by the service.
     * 
     */
    private String name;
    /**
     * @return Special options for this build.
     * 
     */
    private BuildOptionsResponse options;
    /**
     * @return ID of the project.
     * 
     */
    private String project;
    /**
     * @return TTL in queue for this build. If provided and the build is enqueued longer than this value, the build will expire and the build status will be `EXPIRED`. The TTL starts ticking from create_time.
     * 
     */
    private String queueTtl;
    /**
     * @return Results of the build.
     * 
     */
    private ResultsResponse results;
    /**
     * @return Secrets to decrypt using Cloud Key Management Service. Note: Secret Manager is the recommended technique for managing sensitive data with Cloud Build. Use `available_secrets` to configure builds to access secrets from Secret Manager. For instructions, see: https://cloud.google.com/cloud-build/docs/securing-builds/use-secrets
     * 
     */
    private List<SecretResponse> secrets;
    /**
     * @return IAM service account whose credentials will be used at build runtime. Must be of the format `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}`. ACCOUNT can be email address or uniqueId of the service account.
     * 
     */
    private String serviceAccount;
    /**
     * @return The location of the source files to build.
     * 
     */
    private SourceResponse source;
    /**
     * @return A permanent fixed identifier for source.
     * 
     */
    private SourceProvenanceResponse sourceProvenance;
    /**
     * @return Time at which execution of the build was started.
     * 
     */
    private String startTime;
    /**
     * @return Status of the build.
     * 
     */
    private String status;
    /**
     * @return Customer-readable message about the current status.
     * 
     */
    private String statusDetail;
    /**
     * @return The operations to be performed on the workspace.
     * 
     */
    private List<BuildStepResponse> steps;
    /**
     * @return Substitutions data for `Build` resource.
     * 
     */
    private Map<String,String> substitutions;
    /**
     * @return Tags for annotation of a `Build`. These are not docker tags.
     * 
     */
    private List<String> tags;
    /**
     * @return Amount of time that this build should be allowed to run, to second granularity. If this amount of time elapses, work on the build will cease and the build status will be `TIMEOUT`. `timeout` starts ticking from `startTime`. Default time is ten minutes.
     * 
     */
    private String timeout;
    /**
     * @return Stores timing information for phases of the build. Valid keys are: * BUILD: time to execute all build steps. * PUSH: time to push all specified images. * FETCHSOURCE: time to fetch source. * SETUPBUILD: time to set up build. If the build does not specify source or images, these keys will not be included.
     * 
     */
    private Map<String,String> timing;
    /**
     * @return Non-fatal problems encountered during the execution of the build.
     * 
     */
    private List<WarningResponse> warnings;

    private BuildResponse() {}
    /**
     * @return Describes this build&#39;s approval configuration, status, and result.
     * 
     */
    public BuildApprovalResponse approval() {
        return this.approval;
    }
    /**
     * @return Artifacts produced by the build that should be uploaded upon successful completion of all build steps.
     * 
     */
    public ArtifactsResponse artifacts() {
        return this.artifacts;
    }
    /**
     * @return Secrets and secret environment variables.
     * 
     */
    public SecretsResponse availableSecrets() {
        return this.availableSecrets;
    }
    /**
     * @return The ID of the `BuildTrigger` that triggered this build, if it was triggered automatically.
     * 
     */
    public String buildTriggerId() {
        return this.buildTriggerId;
    }
    /**
     * @return Time at which the request to create the build was received.
     * 
     */
    public String createTime() {
        return this.createTime;
    }
    /**
     * @return Contains information about the build when status=FAILURE.
     * 
     */
    public FailureInfoResponse failureInfo() {
        return this.failureInfo;
    }
    /**
     * @return Time at which execution of the build was finished. The difference between finish_time and start_time is the duration of the build&#39;s execution.
     * 
     */
    public String finishTime() {
        return this.finishTime;
    }
    /**
     * @return A list of images to be pushed upon the successful completion of all build steps. The images are pushed using the builder service account&#39;s credentials. The digests of the pushed images will be stored in the `Build` resource&#39;s results field. If any of the images fail to be pushed, the build status is marked `FAILURE`.
     * 
     */
    public List<String> images() {
        return this.images;
    }
    /**
     * @return URL to logs for this build in Google Cloud Console.
     * 
     */
    public String logUrl() {
        return this.logUrl;
    }
    /**
     * @return Google Cloud Storage bucket where logs should be written (see [Bucket Name Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)). Logs file names will be of the format `${logs_bucket}/log-${build_id}.txt`.
     * 
     */
    public String logsBucket() {
        return this.logsBucket;
    }
    /**
     * @return The &#39;Build&#39; name with format: `projects/{project}/locations/{location}/builds/{build}`, where {build} is a unique identifier generated by the service.
     * 
     */
    public String name() {
        return this.name;
    }
    /**
     * @return Special options for this build.
     * 
     */
    public BuildOptionsResponse options() {
        return this.options;
    }
    /**
     * @return ID of the project.
     * 
     */
    public String project() {
        return this.project;
    }
    /**
     * @return TTL in queue for this build. If provided and the build is enqueued longer than this value, the build will expire and the build status will be `EXPIRED`. The TTL starts ticking from create_time.
     * 
     */
    public String queueTtl() {
        return this.queueTtl;
    }
    /**
     * @return Results of the build.
     * 
     */
    public ResultsResponse results() {
        return this.results;
    }
    /**
     * @return Secrets to decrypt using Cloud Key Management Service. Note: Secret Manager is the recommended technique for managing sensitive data with Cloud Build. Use `available_secrets` to configure builds to access secrets from Secret Manager. For instructions, see: https://cloud.google.com/cloud-build/docs/securing-builds/use-secrets
     * 
     */
    public List<SecretResponse> secrets() {
        return this.secrets;
    }
    /**
     * @return IAM service account whose credentials will be used at build runtime. Must be of the format `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}`. ACCOUNT can be email address or uniqueId of the service account.
     * 
     */
    public String serviceAccount() {
        return this.serviceAccount;
    }
    /**
     * @return The location of the source files to build.
     * 
     */
    public SourceResponse source() {
        return this.source;
    }
    /**
     * @return A permanent fixed identifier for source.
     * 
     */
    public SourceProvenanceResponse sourceProvenance() {
        return this.sourceProvenance;
    }
    /**
     * @return Time at which execution of the build was started.
     * 
     */
    public String startTime() {
        return this.startTime;
    }
    /**
     * @return Status of the build.
     * 
     */
    public String status() {
        return this.status;
    }
    /**
     * @return Customer-readable message about the current status.
     * 
     */
    public String statusDetail() {
        return this.statusDetail;
    }
    /**
     * @return The operations to be performed on the workspace.
     * 
     */
    public List<BuildStepResponse> steps() {
        return this.steps;
    }
    /**
     * @return Substitutions data for `Build` resource.
     * 
     */
    public Map<String,String> substitutions() {
        return this.substitutions;
    }
    /**
     * @return Tags for annotation of a `Build`. These are not docker tags.
     * 
     */
    public List<String> tags() {
        return this.tags;
    }
    /**
     * @return Amount of time that this build should be allowed to run, to second granularity. If this amount of time elapses, work on the build will cease and the build status will be `TIMEOUT`. `timeout` starts ticking from `startTime`. Default time is ten minutes.
     * 
     */
    public String timeout() {
        return this.timeout;
    }
    /**
     * @return Stores timing information for phases of the build. Valid keys are: * BUILD: time to execute all build steps. * PUSH: time to push all specified images. * FETCHSOURCE: time to fetch source. * SETUPBUILD: time to set up build. If the build does not specify source or images, these keys will not be included.
     * 
     */
    public Map<String,String> timing() {
        return this.timing;
    }
    /**
     * @return Non-fatal problems encountered during the execution of the build.
     * 
     */
    public List<WarningResponse> warnings() {
        return this.warnings;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(BuildResponse defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private BuildApprovalResponse approval;
        private ArtifactsResponse artifacts;
        private SecretsResponse availableSecrets;
        private String buildTriggerId;
        private String createTime;
        private FailureInfoResponse failureInfo;
        private String finishTime;
        private List<String> images;
        private String logUrl;
        private String logsBucket;
        private String name;
        private BuildOptionsResponse options;
        private String project;
        private String queueTtl;
        private ResultsResponse results;
        private List<SecretResponse> secrets;
        private String serviceAccount;
        private SourceResponse source;
        private SourceProvenanceResponse sourceProvenance;
        private String startTime;
        private String status;
        private String statusDetail;
        private List<BuildStepResponse> steps;
        private Map<String,String> substitutions;
        private List<String> tags;
        private String timeout;
        private Map<String,String> timing;
        private List<WarningResponse> warnings;
        public Builder() {}
        public Builder(BuildResponse defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.approval = defaults.approval;
    	      this.artifacts = defaults.artifacts;
    	      this.availableSecrets = defaults.availableSecrets;
    	      this.buildTriggerId = defaults.buildTriggerId;
    	      this.createTime = defaults.createTime;
    	      this.failureInfo = defaults.failureInfo;
    	      this.finishTime = defaults.finishTime;
    	      this.images = defaults.images;
    	      this.logUrl = defaults.logUrl;
    	      this.logsBucket = defaults.logsBucket;
    	      this.name = defaults.name;
    	      this.options = defaults.options;
    	      this.project = defaults.project;
    	      this.queueTtl = defaults.queueTtl;
    	      this.results = defaults.results;
    	      this.secrets = defaults.secrets;
    	      this.serviceAccount = defaults.serviceAccount;
    	      this.source = defaults.source;
    	      this.sourceProvenance = defaults.sourceProvenance;
    	      this.startTime = defaults.startTime;
    	      this.status = defaults.status;
    	      this.statusDetail = defaults.statusDetail;
    	      this.steps = defaults.steps;
    	      this.substitutions = defaults.substitutions;
    	      this.tags = defaults.tags;
    	      this.timeout = defaults.timeout;
    	      this.timing = defaults.timing;
    	      this.warnings = defaults.warnings;
        }

        @CustomType.Setter
        public Builder approval(BuildApprovalResponse approval) {
            this.approval = Objects.requireNonNull(approval);
            return this;
        }
        @CustomType.Setter
        public Builder artifacts(ArtifactsResponse artifacts) {
            this.artifacts = Objects.requireNonNull(artifacts);
            return this;
        }
        @CustomType.Setter
        public Builder availableSecrets(SecretsResponse availableSecrets) {
            this.availableSecrets = Objects.requireNonNull(availableSecrets);
            return this;
        }
        @CustomType.Setter
        public Builder buildTriggerId(String buildTriggerId) {
            this.buildTriggerId = Objects.requireNonNull(buildTriggerId);
            return this;
        }
        @CustomType.Setter
        public Builder createTime(String createTime) {
            this.createTime = Objects.requireNonNull(createTime);
            return this;
        }
        @CustomType.Setter
        public Builder failureInfo(FailureInfoResponse failureInfo) {
            this.failureInfo = Objects.requireNonNull(failureInfo);
            return this;
        }
        @CustomType.Setter
        public Builder finishTime(String finishTime) {
            this.finishTime = Objects.requireNonNull(finishTime);
            return this;
        }
        @CustomType.Setter
        public Builder images(List<String> images) {
            this.images = Objects.requireNonNull(images);
            return this;
        }
        public Builder images(String... images) {
            return images(List.of(images));
        }
        @CustomType.Setter
        public Builder logUrl(String logUrl) {
            this.logUrl = Objects.requireNonNull(logUrl);
            return this;
        }
        @CustomType.Setter
        public Builder logsBucket(String logsBucket) {
            this.logsBucket = Objects.requireNonNull(logsBucket);
            return this;
        }
        @CustomType.Setter
        public Builder name(String name) {
            this.name = Objects.requireNonNull(name);
            return this;
        }
        @CustomType.Setter
        public Builder options(BuildOptionsResponse options) {
            this.options = Objects.requireNonNull(options);
            return this;
        }
        @CustomType.Setter
        public Builder project(String project) {
            this.project = Objects.requireNonNull(project);
            return this;
        }
        @CustomType.Setter
        public Builder queueTtl(String queueTtl) {
            this.queueTtl = Objects.requireNonNull(queueTtl);
            return this;
        }
        @CustomType.Setter
        public Builder results(ResultsResponse results) {
            this.results = Objects.requireNonNull(results);
            return this;
        }
        @CustomType.Setter
        public Builder secrets(List<SecretResponse> secrets) {
            this.secrets = Objects.requireNonNull(secrets);
            return this;
        }
        public Builder secrets(SecretResponse... secrets) {
            return secrets(List.of(secrets));
        }
        @CustomType.Setter
        public Builder serviceAccount(String serviceAccount) {
            this.serviceAccount = Objects.requireNonNull(serviceAccount);
            return this;
        }
        @CustomType.Setter
        public Builder source(SourceResponse source) {
            this.source = Objects.requireNonNull(source);
            return this;
        }
        @CustomType.Setter
        public Builder sourceProvenance(SourceProvenanceResponse sourceProvenance) {
            this.sourceProvenance = Objects.requireNonNull(sourceProvenance);
            return this;
        }
        @CustomType.Setter
        public Builder startTime(String startTime) {
            this.startTime = Objects.requireNonNull(startTime);
            return this;
        }
        @CustomType.Setter
        public Builder status(String status) {
            this.status = Objects.requireNonNull(status);
            return this;
        }
        @CustomType.Setter
        public Builder statusDetail(String statusDetail) {
            this.statusDetail = Objects.requireNonNull(statusDetail);
            return this;
        }
        @CustomType.Setter
        public Builder steps(List<BuildStepResponse> steps) {
            this.steps = Objects.requireNonNull(steps);
            return this;
        }
        public Builder steps(BuildStepResponse... steps) {
            return steps(List.of(steps));
        }
        @CustomType.Setter
        public Builder substitutions(Map<String,String> substitutions) {
            this.substitutions = Objects.requireNonNull(substitutions);
            return this;
        }
        @CustomType.Setter
        public Builder tags(List<String> tags) {
            this.tags = Objects.requireNonNull(tags);
            return this;
        }
        public Builder tags(String... tags) {
            return tags(List.of(tags));
        }
        @CustomType.Setter
        public Builder timeout(String timeout) {
            this.timeout = Objects.requireNonNull(timeout);
            return this;
        }
        @CustomType.Setter
        public Builder timing(Map<String,String> timing) {
            this.timing = Objects.requireNonNull(timing);
            return this;
        }
        @CustomType.Setter
        public Builder warnings(List<WarningResponse> warnings) {
            this.warnings = Objects.requireNonNull(warnings);
            return this;
        }
        public Builder warnings(WarningResponse... warnings) {
            return warnings(List.of(warnings));
        }
        public BuildResponse build() {
            final var o = new BuildResponse();
            o.approval = approval;
            o.artifacts = artifacts;
            o.availableSecrets = availableSecrets;
            o.buildTriggerId = buildTriggerId;
            o.createTime = createTime;
            o.failureInfo = failureInfo;
            o.finishTime = finishTime;
            o.images = images;
            o.logUrl = logUrl;
            o.logsBucket = logsBucket;
            o.name = name;
            o.options = options;
            o.project = project;
            o.queueTtl = queueTtl;
            o.results = results;
            o.secrets = secrets;
            o.serviceAccount = serviceAccount;
            o.source = source;
            o.sourceProvenance = sourceProvenance;
            o.startTime = startTime;
            o.status = status;
            o.statusDetail = statusDetail;
            o.steps = steps;
            o.substitutions = substitutions;
            o.tags = tags;
            o.timeout = timeout;
            o.timing = timing;
            o.warnings = warnings;
            return o;
        }
    }
}
