# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from ._enums import *

__all__ = [
    'GoogleCloudContentwarehouseV1AccessControlActionArgs',
    'GoogleCloudContentwarehouseV1ActionArgs',
    'GoogleCloudContentwarehouseV1AddToFolderActionArgs',
    'GoogleCloudContentwarehouseV1CloudAIDocumentOptionArgs',
    'GoogleCloudContentwarehouseV1DataUpdateActionArgs',
    'GoogleCloudContentwarehouseV1DataValidationActionArgs',
    'GoogleCloudContentwarehouseV1DateTimeArrayArgs',
    'GoogleCloudContentwarehouseV1DateTimeTypeOptionsArgs',
    'GoogleCloudContentwarehouseV1DeleteDocumentActionArgs',
    'GoogleCloudContentwarehouseV1EnumArrayArgs',
    'GoogleCloudContentwarehouseV1EnumTypeOptionsArgs',
    'GoogleCloudContentwarehouseV1EnumValueArgs',
    'GoogleCloudContentwarehouseV1FloatArrayArgs',
    'GoogleCloudContentwarehouseV1FloatTypeOptionsArgs',
    'GoogleCloudContentwarehouseV1IntegerArrayArgs',
    'GoogleCloudContentwarehouseV1IntegerTypeOptionsArgs',
    'GoogleCloudContentwarehouseV1MapPropertyArgs',
    'GoogleCloudContentwarehouseV1MapTypeOptionsArgs',
    'GoogleCloudContentwarehouseV1PropertyArrayArgs',
    'GoogleCloudContentwarehouseV1PropertyDefinitionSchemaSourceArgs',
    'GoogleCloudContentwarehouseV1PropertyDefinitionArgs',
    'GoogleCloudContentwarehouseV1PropertyTypeOptionsArgs',
    'GoogleCloudContentwarehouseV1PropertyArgs',
    'GoogleCloudContentwarehouseV1PublishActionArgs',
    'GoogleCloudContentwarehouseV1RemoveFromFolderActionArgs',
    'GoogleCloudContentwarehouseV1RequestMetadataArgs',
    'GoogleCloudContentwarehouseV1RuleArgs',
    'GoogleCloudContentwarehouseV1SynonymSetSynonymArgs',
    'GoogleCloudContentwarehouseV1TextArrayArgs',
    'GoogleCloudContentwarehouseV1TextTypeOptionsArgs',
    'GoogleCloudContentwarehouseV1TimestampArrayArgs',
    'GoogleCloudContentwarehouseV1TimestampTypeOptionsArgs',
    'GoogleCloudContentwarehouseV1TimestampValueArgs',
    'GoogleCloudContentwarehouseV1UserInfoArgs',
    'GoogleCloudContentwarehouseV1ValueArgs',
    'GoogleCloudDocumentaiV1BarcodeArgs',
    'GoogleCloudDocumentaiV1BoundingPolyArgs',
    'GoogleCloudDocumentaiV1DocumentEntityNormalizedValueArgs',
    'GoogleCloudDocumentaiV1DocumentEntityRelationArgs',
    'GoogleCloudDocumentaiV1DocumentEntityArgs',
    'GoogleCloudDocumentaiV1DocumentPageAnchorPageRefArgs',
    'GoogleCloudDocumentaiV1DocumentPageAnchorArgs',
    'GoogleCloudDocumentaiV1DocumentPageBlockArgs',
    'GoogleCloudDocumentaiV1DocumentPageDetectedBarcodeArgs',
    'GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs',
    'GoogleCloudDocumentaiV1DocumentPageDimensionArgs',
    'GoogleCloudDocumentaiV1DocumentPageFormFieldArgs',
    'GoogleCloudDocumentaiV1DocumentPageImageQualityScoresDetectedDefectArgs',
    'GoogleCloudDocumentaiV1DocumentPageImageQualityScoresArgs',
    'GoogleCloudDocumentaiV1DocumentPageImageArgs',
    'GoogleCloudDocumentaiV1DocumentPageLayoutArgs',
    'GoogleCloudDocumentaiV1DocumentPageLineArgs',
    'GoogleCloudDocumentaiV1DocumentPageMatrixArgs',
    'GoogleCloudDocumentaiV1DocumentPageParagraphArgs',
    'GoogleCloudDocumentaiV1DocumentPageSymbolArgs',
    'GoogleCloudDocumentaiV1DocumentPageTableTableCellArgs',
    'GoogleCloudDocumentaiV1DocumentPageTableTableRowArgs',
    'GoogleCloudDocumentaiV1DocumentPageTableArgs',
    'GoogleCloudDocumentaiV1DocumentPageTokenDetectedBreakArgs',
    'GoogleCloudDocumentaiV1DocumentPageTokenStyleInfoArgs',
    'GoogleCloudDocumentaiV1DocumentPageTokenArgs',
    'GoogleCloudDocumentaiV1DocumentPageVisualElementArgs',
    'GoogleCloudDocumentaiV1DocumentPageArgs',
    'GoogleCloudDocumentaiV1DocumentProvenanceParentArgs',
    'GoogleCloudDocumentaiV1DocumentProvenanceArgs',
    'GoogleCloudDocumentaiV1DocumentRevisionHumanReviewArgs',
    'GoogleCloudDocumentaiV1DocumentRevisionArgs',
    'GoogleCloudDocumentaiV1DocumentShardInfoArgs',
    'GoogleCloudDocumentaiV1DocumentStyleFontSizeArgs',
    'GoogleCloudDocumentaiV1DocumentStyleArgs',
    'GoogleCloudDocumentaiV1DocumentTextAnchorTextSegmentArgs',
    'GoogleCloudDocumentaiV1DocumentTextAnchorArgs',
    'GoogleCloudDocumentaiV1DocumentTextChangeArgs',
    'GoogleCloudDocumentaiV1DocumentArgs',
    'GoogleCloudDocumentaiV1NormalizedVertexArgs',
    'GoogleCloudDocumentaiV1VertexArgs',
    'GoogleIamV1AuditConfigArgs',
    'GoogleIamV1AuditLogConfigArgs',
    'GoogleIamV1BindingArgs',
    'GoogleIamV1PolicyArgs',
    'GoogleRpcStatusArgs',
    'GoogleTypeColorArgs',
    'GoogleTypeDateTimeArgs',
    'GoogleTypeDateArgs',
    'GoogleTypeExprArgs',
    'GoogleTypeMoneyArgs',
    'GoogleTypePostalAddressArgs',
    'GoogleTypeTimeZoneArgs',
]

@pulumi.input_type
class GoogleCloudContentwarehouseV1AccessControlActionArgs:
    def __init__(__self__, *,
                 operation_type: Optional[pulumi.Input['GoogleCloudContentwarehouseV1AccessControlActionOperationType']] = None,
                 policy: Optional[pulumi.Input['GoogleIamV1PolicyArgs']] = None):
        """
        Represents the action responsible for access control list management operations.
        :param pulumi.Input['GoogleCloudContentwarehouseV1AccessControlActionOperationType'] operation_type: Identifies the type of operation.
        :param pulumi.Input['GoogleIamV1PolicyArgs'] policy: Represents the new policy from which bindings are added, removed or replaced based on the type of the operation. the policy is limited to a few 10s of KB.
        """
        if operation_type is not None:
            pulumi.set(__self__, "operation_type", operation_type)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter(name="operationType")
    def operation_type(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1AccessControlActionOperationType']]:
        """
        Identifies the type of operation.
        """
        return pulumi.get(self, "operation_type")

    @operation_type.setter
    def operation_type(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1AccessControlActionOperationType']]):
        pulumi.set(self, "operation_type", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['GoogleIamV1PolicyArgs']]:
        """
        Represents the new policy from which bindings are added, removed or replaced based on the type of the operation. the policy is limited to a few 10s of KB.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['GoogleIamV1PolicyArgs']]):
        pulumi.set(self, "policy", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1ActionArgs:
    def __init__(__self__, *,
                 access_control: Optional[pulumi.Input['GoogleCloudContentwarehouseV1AccessControlActionArgs']] = None,
                 action_id: Optional[pulumi.Input[str]] = None,
                 add_to_folder: Optional[pulumi.Input['GoogleCloudContentwarehouseV1AddToFolderActionArgs']] = None,
                 data_update: Optional[pulumi.Input['GoogleCloudContentwarehouseV1DataUpdateActionArgs']] = None,
                 data_validation: Optional[pulumi.Input['GoogleCloudContentwarehouseV1DataValidationActionArgs']] = None,
                 delete_document_action: Optional[pulumi.Input['GoogleCloudContentwarehouseV1DeleteDocumentActionArgs']] = None,
                 publish_to_pub_sub: Optional[pulumi.Input['GoogleCloudContentwarehouseV1PublishActionArgs']] = None,
                 remove_from_folder_action: Optional[pulumi.Input['GoogleCloudContentwarehouseV1RemoveFromFolderActionArgs']] = None):
        """
        Represents the action triggered by Rule Engine when the rule is true.
        :param pulumi.Input['GoogleCloudContentwarehouseV1AccessControlActionArgs'] access_control: Action triggering access control operations.
        :param pulumi.Input[str] action_id: ID of the action. Managed internally.
        :param pulumi.Input['GoogleCloudContentwarehouseV1AddToFolderActionArgs'] add_to_folder: Action triggering create document link operation.
        :param pulumi.Input['GoogleCloudContentwarehouseV1DataUpdateActionArgs'] data_update: Action triggering data update operations.
        :param pulumi.Input['GoogleCloudContentwarehouseV1DataValidationActionArgs'] data_validation: Action triggering data validation operations.
        :param pulumi.Input['GoogleCloudContentwarehouseV1DeleteDocumentActionArgs'] delete_document_action: Action deleting the document.
        :param pulumi.Input['GoogleCloudContentwarehouseV1PublishActionArgs'] publish_to_pub_sub: Action publish to Pub/Sub operation.
        :param pulumi.Input['GoogleCloudContentwarehouseV1RemoveFromFolderActionArgs'] remove_from_folder_action: Action removing a document from a folder.
        """
        if access_control is not None:
            pulumi.set(__self__, "access_control", access_control)
        if action_id is not None:
            pulumi.set(__self__, "action_id", action_id)
        if add_to_folder is not None:
            pulumi.set(__self__, "add_to_folder", add_to_folder)
        if data_update is not None:
            pulumi.set(__self__, "data_update", data_update)
        if data_validation is not None:
            pulumi.set(__self__, "data_validation", data_validation)
        if delete_document_action is not None:
            pulumi.set(__self__, "delete_document_action", delete_document_action)
        if publish_to_pub_sub is not None:
            pulumi.set(__self__, "publish_to_pub_sub", publish_to_pub_sub)
        if remove_from_folder_action is not None:
            pulumi.set(__self__, "remove_from_folder_action", remove_from_folder_action)

    @property
    @pulumi.getter(name="accessControl")
    def access_control(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1AccessControlActionArgs']]:
        """
        Action triggering access control operations.
        """
        return pulumi.get(self, "access_control")

    @access_control.setter
    def access_control(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1AccessControlActionArgs']]):
        pulumi.set(self, "access_control", value)

    @property
    @pulumi.getter(name="actionId")
    def action_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the action. Managed internally.
        """
        return pulumi.get(self, "action_id")

    @action_id.setter
    def action_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action_id", value)

    @property
    @pulumi.getter(name="addToFolder")
    def add_to_folder(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1AddToFolderActionArgs']]:
        """
        Action triggering create document link operation.
        """
        return pulumi.get(self, "add_to_folder")

    @add_to_folder.setter
    def add_to_folder(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1AddToFolderActionArgs']]):
        pulumi.set(self, "add_to_folder", value)

    @property
    @pulumi.getter(name="dataUpdate")
    def data_update(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1DataUpdateActionArgs']]:
        """
        Action triggering data update operations.
        """
        return pulumi.get(self, "data_update")

    @data_update.setter
    def data_update(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1DataUpdateActionArgs']]):
        pulumi.set(self, "data_update", value)

    @property
    @pulumi.getter(name="dataValidation")
    def data_validation(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1DataValidationActionArgs']]:
        """
        Action triggering data validation operations.
        """
        return pulumi.get(self, "data_validation")

    @data_validation.setter
    def data_validation(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1DataValidationActionArgs']]):
        pulumi.set(self, "data_validation", value)

    @property
    @pulumi.getter(name="deleteDocumentAction")
    def delete_document_action(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1DeleteDocumentActionArgs']]:
        """
        Action deleting the document.
        """
        return pulumi.get(self, "delete_document_action")

    @delete_document_action.setter
    def delete_document_action(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1DeleteDocumentActionArgs']]):
        pulumi.set(self, "delete_document_action", value)

    @property
    @pulumi.getter(name="publishToPubSub")
    def publish_to_pub_sub(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1PublishActionArgs']]:
        """
        Action publish to Pub/Sub operation.
        """
        return pulumi.get(self, "publish_to_pub_sub")

    @publish_to_pub_sub.setter
    def publish_to_pub_sub(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1PublishActionArgs']]):
        pulumi.set(self, "publish_to_pub_sub", value)

    @property
    @pulumi.getter(name="removeFromFolderAction")
    def remove_from_folder_action(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1RemoveFromFolderActionArgs']]:
        """
        Action removing a document from a folder.
        """
        return pulumi.get(self, "remove_from_folder_action")

    @remove_from_folder_action.setter
    def remove_from_folder_action(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1RemoveFromFolderActionArgs']]):
        pulumi.set(self, "remove_from_folder_action", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1AddToFolderActionArgs:
    def __init__(__self__, *,
                 folders: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Represents the action responsible for adding document under a folder.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] folders: Names of the folder under which new document is to be added. Format: projects/{project_number}/locations/{location}/documents/{document_id}.
        """
        if folders is not None:
            pulumi.set(__self__, "folders", folders)

    @property
    @pulumi.getter
    def folders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Names of the folder under which new document is to be added. Format: projects/{project_number}/locations/{location}/documents/{document_id}.
        """
        return pulumi.get(self, "folders")

    @folders.setter
    def folders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "folders", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1CloudAIDocumentOptionArgs:
    def __init__(__self__, *,
                 customized_entities_properties_conversions: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 enable_entities_conversions: Optional[pulumi.Input[bool]] = None):
        """
        Request Option for processing Cloud AI Document in CW Document.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] customized_entities_properties_conversions: If set, only selected entities will be converted to properties.
        :param pulumi.Input[bool] enable_entities_conversions: Whether to convert all the entities to properties.
        """
        if customized_entities_properties_conversions is not None:
            pulumi.set(__self__, "customized_entities_properties_conversions", customized_entities_properties_conversions)
        if enable_entities_conversions is not None:
            pulumi.set(__self__, "enable_entities_conversions", enable_entities_conversions)

    @property
    @pulumi.getter(name="customizedEntitiesPropertiesConversions")
    def customized_entities_properties_conversions(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        If set, only selected entities will be converted to properties.
        """
        return pulumi.get(self, "customized_entities_properties_conversions")

    @customized_entities_properties_conversions.setter
    def customized_entities_properties_conversions(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "customized_entities_properties_conversions", value)

    @property
    @pulumi.getter(name="enableEntitiesConversions")
    def enable_entities_conversions(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to convert all the entities to properties.
        """
        return pulumi.get(self, "enable_entities_conversions")

    @enable_entities_conversions.setter
    def enable_entities_conversions(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_entities_conversions", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1DataUpdateActionArgs:
    def __init__(__self__, *,
                 entries: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Represents the action responsible for properties update operations.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] entries: Map of (K, V) -> (valid name of the field, new value of the field) E.g., ("age", "60") entry triggers update of field age with a value of 60. If the field is not present then new entry is added. During update action execution, value strings will be casted to appropriate types.
        """
        if entries is not None:
            pulumi.set(__self__, "entries", entries)

    @property
    @pulumi.getter
    def entries(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Map of (K, V) -> (valid name of the field, new value of the field) E.g., ("age", "60") entry triggers update of field age with a value of 60. If the field is not present then new entry is added. During update action execution, value strings will be casted to appropriate types.
        """
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "entries", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1DataValidationActionArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Represents the action responsible for data validation operations.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] conditions: Map of (K, V) -> (field, string condition to be evaluated on the field) E.g., ("age", "age > 18 && age < 60") entry triggers validation of field age with the given condition. Map entries will be ANDed during validation.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Map of (K, V) -> (field, string condition to be evaluated on the field) E.g., ("age", "age > 18 && age < 60") entry triggers validation of field age with the given condition. Map entries will be ANDed during validation.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "conditions", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1DateTimeArrayArgs:
    def __init__(__self__, *,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleTypeDateTimeArgs']]]] = None):
        """
        DateTime values.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleTypeDateTimeArgs']]] values: List of datetime values. Both OffsetDateTime and ZonedDateTime are supported.
        """
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleTypeDateTimeArgs']]]]:
        """
        List of datetime values. Both OffsetDateTime and ZonedDateTime are supported.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleTypeDateTimeArgs']]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1DateTimeTypeOptionsArgs:
    def __init__(__self__):
        """
        Configurations for a date time property.
        """
        pass


@pulumi.input_type
class GoogleCloudContentwarehouseV1DeleteDocumentActionArgs:
    def __init__(__self__, *,
                 enable_hard_delete: Optional[pulumi.Input[bool]] = None):
        """
        Represents the action responsible for deleting the document.
        :param pulumi.Input[bool] enable_hard_delete: Boolean field to select between hard vs soft delete options. Set 'true' for 'hard delete' and 'false' for 'soft delete'.
        """
        if enable_hard_delete is not None:
            pulumi.set(__self__, "enable_hard_delete", enable_hard_delete)

    @property
    @pulumi.getter(name="enableHardDelete")
    def enable_hard_delete(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean field to select between hard vs soft delete options. Set 'true' for 'hard delete' and 'false' for 'soft delete'.
        """
        return pulumi.get(self, "enable_hard_delete")

    @enable_hard_delete.setter
    def enable_hard_delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_hard_delete", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1EnumArrayArgs:
    def __init__(__self__, *,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Enum values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of enum values.
        """
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of enum values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1EnumTypeOptionsArgs:
    def __init__(__self__, *,
                 possible_values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 validation_check_disabled: Optional[pulumi.Input[bool]] = None):
        """
        Configurations for an enum/categorical property.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] possible_values: List of possible enum values.
        :param pulumi.Input[bool] validation_check_disabled: Make sure the Enum property value provided in the document is in the possile value list during document creation. The validation check runs by default.
        """
        pulumi.set(__self__, "possible_values", possible_values)
        if validation_check_disabled is not None:
            pulumi.set(__self__, "validation_check_disabled", validation_check_disabled)

    @property
    @pulumi.getter(name="possibleValues")
    def possible_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of possible enum values.
        """
        return pulumi.get(self, "possible_values")

    @possible_values.setter
    def possible_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "possible_values", value)

    @property
    @pulumi.getter(name="validationCheckDisabled")
    def validation_check_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Make sure the Enum property value provided in the document is in the possile value list during document creation. The validation check runs by default.
        """
        return pulumi.get(self, "validation_check_disabled")

    @validation_check_disabled.setter
    def validation_check_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "validation_check_disabled", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1EnumValueArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        Represents the string value of the enum field.
        :param pulumi.Input[str] value: String value of the enum field. This must match defined set of enums in document schema using EnumTypeOptions.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        String value of the enum field. This must match defined set of enums in document schema using EnumTypeOptions.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1FloatArrayArgs:
    def __init__(__self__, *,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[float]]]] = None):
        """
        Float values.
        :param pulumi.Input[Sequence[pulumi.Input[float]]] values: List of float values.
        """
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[float]]]]:
        """
        List of float values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[float]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1FloatTypeOptionsArgs:
    def __init__(__self__):
        """
        Configurations for a float property.
        """
        pass


@pulumi.input_type
class GoogleCloudContentwarehouseV1IntegerArrayArgs:
    def __init__(__self__, *,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        Integer values.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] values: List of integer values.
        """
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        List of integer values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1IntegerTypeOptionsArgs:
    def __init__(__self__):
        """
        Configurations for an integer property.
        """
        pass


@pulumi.input_type
class GoogleCloudContentwarehouseV1MapPropertyArgs:
    def __init__(__self__, *,
                 fields: Optional[pulumi.Input[Mapping[str, pulumi.Input['GoogleCloudContentwarehouseV1ValueArgs']]]] = None):
        """
        Map property value. Represents a structured entries of key value pairs, consisting of field names which map to dynamically typed values.
        :param pulumi.Input[Mapping[str, pulumi.Input['GoogleCloudContentwarehouseV1ValueArgs']]] fields: Unordered map of dynamically typed values.
        """
        if fields is not None:
            pulumi.set(__self__, "fields", fields)

    @property
    @pulumi.getter
    def fields(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['GoogleCloudContentwarehouseV1ValueArgs']]]]:
        """
        Unordered map of dynamically typed values.
        """
        return pulumi.get(self, "fields")

    @fields.setter
    def fields(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['GoogleCloudContentwarehouseV1ValueArgs']]]]):
        pulumi.set(self, "fields", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1MapTypeOptionsArgs:
    def __init__(__self__):
        """
        Configurations for a Map property.
        """
        pass


@pulumi.input_type
class GoogleCloudContentwarehouseV1PropertyArrayArgs:
    def __init__(__self__, *,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudContentwarehouseV1PropertyArgs']]]] = None):
        """
        Property values.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudContentwarehouseV1PropertyArgs']]] properties: List of property values.
        """
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudContentwarehouseV1PropertyArgs']]]]:
        """
        List of property values.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudContentwarehouseV1PropertyArgs']]]]):
        pulumi.set(self, "properties", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1PropertyDefinitionSchemaSourceArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 processor_type: Optional[pulumi.Input[str]] = None):
        """
        The schema source information.
        :param pulumi.Input[str] name: The schema name in the source.
        :param pulumi.Input[str] processor_type: The Doc AI processor type name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if processor_type is not None:
            pulumi.set(__self__, "processor_type", processor_type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The schema name in the source.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="processorType")
    def processor_type(self) -> Optional[pulumi.Input[str]]:
        """
        The Doc AI processor type name.
        """
        return pulumi.get(self, "processor_type")

    @processor_type.setter
    def processor_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "processor_type", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1PropertyDefinitionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 date_time_type_options: Optional[pulumi.Input['GoogleCloudContentwarehouseV1DateTimeTypeOptionsArgs']] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 enum_type_options: Optional[pulumi.Input['GoogleCloudContentwarehouseV1EnumTypeOptionsArgs']] = None,
                 float_type_options: Optional[pulumi.Input['GoogleCloudContentwarehouseV1FloatTypeOptionsArgs']] = None,
                 integer_type_options: Optional[pulumi.Input['GoogleCloudContentwarehouseV1IntegerTypeOptionsArgs']] = None,
                 is_filterable: Optional[pulumi.Input[bool]] = None,
                 is_metadata: Optional[pulumi.Input[bool]] = None,
                 is_repeatable: Optional[pulumi.Input[bool]] = None,
                 is_required: Optional[pulumi.Input[bool]] = None,
                 is_searchable: Optional[pulumi.Input[bool]] = None,
                 map_type_options: Optional[pulumi.Input['GoogleCloudContentwarehouseV1MapTypeOptionsArgs']] = None,
                 property_type_options: Optional[pulumi.Input['GoogleCloudContentwarehouseV1PropertyTypeOptionsArgs']] = None,
                 retrieval_importance: Optional[pulumi.Input['GoogleCloudContentwarehouseV1PropertyDefinitionRetrievalImportance']] = None,
                 schema_sources: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudContentwarehouseV1PropertyDefinitionSchemaSourceArgs']]]] = None,
                 text_type_options: Optional[pulumi.Input['GoogleCloudContentwarehouseV1TextTypeOptionsArgs']] = None,
                 timestamp_type_options: Optional[pulumi.Input['GoogleCloudContentwarehouseV1TimestampTypeOptionsArgs']] = None):
        """
        Defines the metadata for a schema property.
        :param pulumi.Input[str] name: The name of the metadata property. Must be unique within a document schema and is case insensitive. Names must be non-blank, start with a letter, and can contain alphanumeric characters and: /, :, -, _, and .
        :param pulumi.Input['GoogleCloudContentwarehouseV1DateTimeTypeOptionsArgs'] date_time_type_options: Date time property. It is not supported by CMEK compliant deployment.
        :param pulumi.Input[str] display_name: The display-name for the property, used for front-end.
        :param pulumi.Input['GoogleCloudContentwarehouseV1EnumTypeOptionsArgs'] enum_type_options: Enum/categorical property.
        :param pulumi.Input['GoogleCloudContentwarehouseV1FloatTypeOptionsArgs'] float_type_options: Float property.
        :param pulumi.Input['GoogleCloudContentwarehouseV1IntegerTypeOptionsArgs'] integer_type_options: Integer property.
        :param pulumi.Input[bool] is_filterable: Whether the property can be filtered. If this is a sub-property, all the parent properties must be marked filterable.
        :param pulumi.Input[bool] is_metadata: Whether the property is user supplied metadata. This out-of-the box placeholder setting can be used to tag derived properties. Its value and interpretation logic should be implemented by API user.
        :param pulumi.Input[bool] is_repeatable: Whether the property can have multiple values.
        :param pulumi.Input[bool] is_required: Whether the property is mandatory. Default is 'false', i.e. populating property value can be skipped. If 'true' then user must populate the value for this property.
        :param pulumi.Input[bool] is_searchable: Indicates that the property should be included in a global search.
        :param pulumi.Input['GoogleCloudContentwarehouseV1MapTypeOptionsArgs'] map_type_options: Map property.
        :param pulumi.Input['GoogleCloudContentwarehouseV1PropertyTypeOptionsArgs'] property_type_options: Nested structured data property.
        :param pulumi.Input['GoogleCloudContentwarehouseV1PropertyDefinitionRetrievalImportance'] retrieval_importance: The retrieval importance of the property during search.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudContentwarehouseV1PropertyDefinitionSchemaSourceArgs']]] schema_sources: The mapping information between this property to another schema source.
        :param pulumi.Input['GoogleCloudContentwarehouseV1TextTypeOptionsArgs'] text_type_options: Text/string property.
        :param pulumi.Input['GoogleCloudContentwarehouseV1TimestampTypeOptionsArgs'] timestamp_type_options: Timestamp property. It is not supported by CMEK compliant deployment.
        """
        pulumi.set(__self__, "name", name)
        if date_time_type_options is not None:
            pulumi.set(__self__, "date_time_type_options", date_time_type_options)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if enum_type_options is not None:
            pulumi.set(__self__, "enum_type_options", enum_type_options)
        if float_type_options is not None:
            pulumi.set(__self__, "float_type_options", float_type_options)
        if integer_type_options is not None:
            pulumi.set(__self__, "integer_type_options", integer_type_options)
        if is_filterable is not None:
            pulumi.set(__self__, "is_filterable", is_filterable)
        if is_metadata is not None:
            pulumi.set(__self__, "is_metadata", is_metadata)
        if is_repeatable is not None:
            pulumi.set(__self__, "is_repeatable", is_repeatable)
        if is_required is not None:
            pulumi.set(__self__, "is_required", is_required)
        if is_searchable is not None:
            pulumi.set(__self__, "is_searchable", is_searchable)
        if map_type_options is not None:
            pulumi.set(__self__, "map_type_options", map_type_options)
        if property_type_options is not None:
            pulumi.set(__self__, "property_type_options", property_type_options)
        if retrieval_importance is not None:
            pulumi.set(__self__, "retrieval_importance", retrieval_importance)
        if schema_sources is not None:
            pulumi.set(__self__, "schema_sources", schema_sources)
        if text_type_options is not None:
            pulumi.set(__self__, "text_type_options", text_type_options)
        if timestamp_type_options is not None:
            pulumi.set(__self__, "timestamp_type_options", timestamp_type_options)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the metadata property. Must be unique within a document schema and is case insensitive. Names must be non-blank, start with a letter, and can contain alphanumeric characters and: /, :, -, _, and .
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="dateTimeTypeOptions")
    def date_time_type_options(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1DateTimeTypeOptionsArgs']]:
        """
        Date time property. It is not supported by CMEK compliant deployment.
        """
        return pulumi.get(self, "date_time_type_options")

    @date_time_type_options.setter
    def date_time_type_options(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1DateTimeTypeOptionsArgs']]):
        pulumi.set(self, "date_time_type_options", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        The display-name for the property, used for front-end.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="enumTypeOptions")
    def enum_type_options(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1EnumTypeOptionsArgs']]:
        """
        Enum/categorical property.
        """
        return pulumi.get(self, "enum_type_options")

    @enum_type_options.setter
    def enum_type_options(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1EnumTypeOptionsArgs']]):
        pulumi.set(self, "enum_type_options", value)

    @property
    @pulumi.getter(name="floatTypeOptions")
    def float_type_options(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1FloatTypeOptionsArgs']]:
        """
        Float property.
        """
        return pulumi.get(self, "float_type_options")

    @float_type_options.setter
    def float_type_options(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1FloatTypeOptionsArgs']]):
        pulumi.set(self, "float_type_options", value)

    @property
    @pulumi.getter(name="integerTypeOptions")
    def integer_type_options(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1IntegerTypeOptionsArgs']]:
        """
        Integer property.
        """
        return pulumi.get(self, "integer_type_options")

    @integer_type_options.setter
    def integer_type_options(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1IntegerTypeOptionsArgs']]):
        pulumi.set(self, "integer_type_options", value)

    @property
    @pulumi.getter(name="isFilterable")
    def is_filterable(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the property can be filtered. If this is a sub-property, all the parent properties must be marked filterable.
        """
        return pulumi.get(self, "is_filterable")

    @is_filterable.setter
    def is_filterable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_filterable", value)

    @property
    @pulumi.getter(name="isMetadata")
    def is_metadata(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the property is user supplied metadata. This out-of-the box placeholder setting can be used to tag derived properties. Its value and interpretation logic should be implemented by API user.
        """
        return pulumi.get(self, "is_metadata")

    @is_metadata.setter
    def is_metadata(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_metadata", value)

    @property
    @pulumi.getter(name="isRepeatable")
    def is_repeatable(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the property can have multiple values.
        """
        return pulumi.get(self, "is_repeatable")

    @is_repeatable.setter
    def is_repeatable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_repeatable", value)

    @property
    @pulumi.getter(name="isRequired")
    def is_required(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the property is mandatory. Default is 'false', i.e. populating property value can be skipped. If 'true' then user must populate the value for this property.
        """
        return pulumi.get(self, "is_required")

    @is_required.setter
    def is_required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_required", value)

    @property
    @pulumi.getter(name="isSearchable")
    def is_searchable(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates that the property should be included in a global search.
        """
        return pulumi.get(self, "is_searchable")

    @is_searchable.setter
    def is_searchable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_searchable", value)

    @property
    @pulumi.getter(name="mapTypeOptions")
    def map_type_options(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1MapTypeOptionsArgs']]:
        """
        Map property.
        """
        return pulumi.get(self, "map_type_options")

    @map_type_options.setter
    def map_type_options(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1MapTypeOptionsArgs']]):
        pulumi.set(self, "map_type_options", value)

    @property
    @pulumi.getter(name="propertyTypeOptions")
    def property_type_options(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1PropertyTypeOptionsArgs']]:
        """
        Nested structured data property.
        """
        return pulumi.get(self, "property_type_options")

    @property_type_options.setter
    def property_type_options(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1PropertyTypeOptionsArgs']]):
        pulumi.set(self, "property_type_options", value)

    @property
    @pulumi.getter(name="retrievalImportance")
    def retrieval_importance(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1PropertyDefinitionRetrievalImportance']]:
        """
        The retrieval importance of the property during search.
        """
        return pulumi.get(self, "retrieval_importance")

    @retrieval_importance.setter
    def retrieval_importance(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1PropertyDefinitionRetrievalImportance']]):
        pulumi.set(self, "retrieval_importance", value)

    @property
    @pulumi.getter(name="schemaSources")
    def schema_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudContentwarehouseV1PropertyDefinitionSchemaSourceArgs']]]]:
        """
        The mapping information between this property to another schema source.
        """
        return pulumi.get(self, "schema_sources")

    @schema_sources.setter
    def schema_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudContentwarehouseV1PropertyDefinitionSchemaSourceArgs']]]]):
        pulumi.set(self, "schema_sources", value)

    @property
    @pulumi.getter(name="textTypeOptions")
    def text_type_options(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1TextTypeOptionsArgs']]:
        """
        Text/string property.
        """
        return pulumi.get(self, "text_type_options")

    @text_type_options.setter
    def text_type_options(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1TextTypeOptionsArgs']]):
        pulumi.set(self, "text_type_options", value)

    @property
    @pulumi.getter(name="timestampTypeOptions")
    def timestamp_type_options(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1TimestampTypeOptionsArgs']]:
        """
        Timestamp property. It is not supported by CMEK compliant deployment.
        """
        return pulumi.get(self, "timestamp_type_options")

    @timestamp_type_options.setter
    def timestamp_type_options(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1TimestampTypeOptionsArgs']]):
        pulumi.set(self, "timestamp_type_options", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1PropertyTypeOptionsArgs:
    def __init__(__self__, *,
                 property_definitions: pulumi.Input[Sequence[pulumi.Input['GoogleCloudContentwarehouseV1PropertyDefinitionArgs']]]):
        """
        Configurations for a nested structured data property.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudContentwarehouseV1PropertyDefinitionArgs']]] property_definitions: List of property definitions.
        """
        pulumi.set(__self__, "property_definitions", property_definitions)

    @property
    @pulumi.getter(name="propertyDefinitions")
    def property_definitions(self) -> pulumi.Input[Sequence[pulumi.Input['GoogleCloudContentwarehouseV1PropertyDefinitionArgs']]]:
        """
        List of property definitions.
        """
        return pulumi.get(self, "property_definitions")

    @property_definitions.setter
    def property_definitions(self, value: pulumi.Input[Sequence[pulumi.Input['GoogleCloudContentwarehouseV1PropertyDefinitionArgs']]]):
        pulumi.set(self, "property_definitions", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1PropertyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 date_time_values: Optional[pulumi.Input['GoogleCloudContentwarehouseV1DateTimeArrayArgs']] = None,
                 enum_values: Optional[pulumi.Input['GoogleCloudContentwarehouseV1EnumArrayArgs']] = None,
                 float_values: Optional[pulumi.Input['GoogleCloudContentwarehouseV1FloatArrayArgs']] = None,
                 integer_values: Optional[pulumi.Input['GoogleCloudContentwarehouseV1IntegerArrayArgs']] = None,
                 map_property: Optional[pulumi.Input['GoogleCloudContentwarehouseV1MapPropertyArgs']] = None,
                 property_values: Optional[pulumi.Input['GoogleCloudContentwarehouseV1PropertyArrayArgs']] = None,
                 text_values: Optional[pulumi.Input['GoogleCloudContentwarehouseV1TextArrayArgs']] = None,
                 timestamp_values: Optional[pulumi.Input['GoogleCloudContentwarehouseV1TimestampArrayArgs']] = None):
        """
        Property of a document.
        :param pulumi.Input[str] name: Must match the name of a PropertyDefinition in the DocumentSchema.
        :param pulumi.Input['GoogleCloudContentwarehouseV1DateTimeArrayArgs'] date_time_values: Date time property values. It is not supported by CMEK compliant deployment.
        :param pulumi.Input['GoogleCloudContentwarehouseV1EnumArrayArgs'] enum_values: Enum property values.
        :param pulumi.Input['GoogleCloudContentwarehouseV1FloatArrayArgs'] float_values: Float property values.
        :param pulumi.Input['GoogleCloudContentwarehouseV1IntegerArrayArgs'] integer_values: Integer property values.
        :param pulumi.Input['GoogleCloudContentwarehouseV1MapPropertyArgs'] map_property: Map property values.
        :param pulumi.Input['GoogleCloudContentwarehouseV1PropertyArrayArgs'] property_values: Nested structured data property values.
        :param pulumi.Input['GoogleCloudContentwarehouseV1TextArrayArgs'] text_values: String/text property values.
        :param pulumi.Input['GoogleCloudContentwarehouseV1TimestampArrayArgs'] timestamp_values: Timestamp property values. It is not supported by CMEK compliant deployment.
        """
        pulumi.set(__self__, "name", name)
        if date_time_values is not None:
            pulumi.set(__self__, "date_time_values", date_time_values)
        if enum_values is not None:
            pulumi.set(__self__, "enum_values", enum_values)
        if float_values is not None:
            pulumi.set(__self__, "float_values", float_values)
        if integer_values is not None:
            pulumi.set(__self__, "integer_values", integer_values)
        if map_property is not None:
            pulumi.set(__self__, "map_property", map_property)
        if property_values is not None:
            pulumi.set(__self__, "property_values", property_values)
        if text_values is not None:
            pulumi.set(__self__, "text_values", text_values)
        if timestamp_values is not None:
            pulumi.set(__self__, "timestamp_values", timestamp_values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Must match the name of a PropertyDefinition in the DocumentSchema.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="dateTimeValues")
    def date_time_values(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1DateTimeArrayArgs']]:
        """
        Date time property values. It is not supported by CMEK compliant deployment.
        """
        return pulumi.get(self, "date_time_values")

    @date_time_values.setter
    def date_time_values(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1DateTimeArrayArgs']]):
        pulumi.set(self, "date_time_values", value)

    @property
    @pulumi.getter(name="enumValues")
    def enum_values(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1EnumArrayArgs']]:
        """
        Enum property values.
        """
        return pulumi.get(self, "enum_values")

    @enum_values.setter
    def enum_values(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1EnumArrayArgs']]):
        pulumi.set(self, "enum_values", value)

    @property
    @pulumi.getter(name="floatValues")
    def float_values(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1FloatArrayArgs']]:
        """
        Float property values.
        """
        return pulumi.get(self, "float_values")

    @float_values.setter
    def float_values(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1FloatArrayArgs']]):
        pulumi.set(self, "float_values", value)

    @property
    @pulumi.getter(name="integerValues")
    def integer_values(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1IntegerArrayArgs']]:
        """
        Integer property values.
        """
        return pulumi.get(self, "integer_values")

    @integer_values.setter
    def integer_values(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1IntegerArrayArgs']]):
        pulumi.set(self, "integer_values", value)

    @property
    @pulumi.getter(name="mapProperty")
    def map_property(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1MapPropertyArgs']]:
        """
        Map property values.
        """
        return pulumi.get(self, "map_property")

    @map_property.setter
    def map_property(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1MapPropertyArgs']]):
        pulumi.set(self, "map_property", value)

    @property
    @pulumi.getter(name="propertyValues")
    def property_values(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1PropertyArrayArgs']]:
        """
        Nested structured data property values.
        """
        return pulumi.get(self, "property_values")

    @property_values.setter
    def property_values(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1PropertyArrayArgs']]):
        pulumi.set(self, "property_values", value)

    @property
    @pulumi.getter(name="textValues")
    def text_values(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1TextArrayArgs']]:
        """
        String/text property values.
        """
        return pulumi.get(self, "text_values")

    @text_values.setter
    def text_values(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1TextArrayArgs']]):
        pulumi.set(self, "text_values", value)

    @property
    @pulumi.getter(name="timestampValues")
    def timestamp_values(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1TimestampArrayArgs']]:
        """
        Timestamp property values. It is not supported by CMEK compliant deployment.
        """
        return pulumi.get(self, "timestamp_values")

    @timestamp_values.setter
    def timestamp_values(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1TimestampArrayArgs']]):
        pulumi.set(self, "timestamp_values", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1PublishActionArgs:
    def __init__(__self__, *,
                 messages: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topic_id: Optional[pulumi.Input[str]] = None):
        """
        Represents the action responsible for publishing messages to a Pub/Sub topic.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] messages: Messages to be published.
        :param pulumi.Input[str] topic_id: The topic id in the Pub/Sub service for which messages will be published to.
        """
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if topic_id is not None:
            pulumi.set(__self__, "topic_id", topic_id)

    @property
    @pulumi.getter
    def messages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Messages to be published.
        """
        return pulumi.get(self, "messages")

    @messages.setter
    def messages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "messages", value)

    @property
    @pulumi.getter(name="topicId")
    def topic_id(self) -> Optional[pulumi.Input[str]]:
        """
        The topic id in the Pub/Sub service for which messages will be published to.
        """
        return pulumi.get(self, "topic_id")

    @topic_id.setter
    def topic_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topic_id", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1RemoveFromFolderActionArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input[str]] = None):
        """
        Represents the action responsible for remove a document from a specific folder.
        :param pulumi.Input[str] condition: Condition of the action to be executed.
        :param pulumi.Input[str] folder: Name of the folder under which new document is to be added. Format: projects/{project_number}/locations/{location}/documents/{document_id}.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        Condition of the action to be executed.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the folder under which new document is to be added. Format: projects/{project_number}/locations/{location}/documents/{document_id}.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "folder", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1RequestMetadataArgs:
    def __init__(__self__, *,
                 user_info: Optional[pulumi.Input['GoogleCloudContentwarehouseV1UserInfoArgs']] = None):
        """
        Meta information is used to improve the performance of the service.
        :param pulumi.Input['GoogleCloudContentwarehouseV1UserInfoArgs'] user_info: Provides user unique identification and groups information.
        """
        if user_info is not None:
            pulumi.set(__self__, "user_info", user_info)

    @property
    @pulumi.getter(name="userInfo")
    def user_info(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1UserInfoArgs']]:
        """
        Provides user unique identification and groups information.
        """
        return pulumi.get(self, "user_info")

    @user_info.setter
    def user_info(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1UserInfoArgs']]):
        pulumi.set(self, "user_info", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1RuleArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudContentwarehouseV1ActionArgs']]]] = None,
                 condition: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 rule_id: Optional[pulumi.Input[str]] = None,
                 trigger_type: Optional[pulumi.Input['GoogleCloudContentwarehouseV1RuleTriggerType']] = None):
        """
        Represents the rule for a content warehouse trigger.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudContentwarehouseV1ActionArgs']]] actions: List of actions that are executed when the rule is satisfied.
        :param pulumi.Input[str] condition: Represents the conditional expression to be evaluated. Expression should evaluate to a boolean result. When the condition is true actions are executed. Example: user_role = "hsbc_role_1" AND doc.salary > 20000
        :param pulumi.Input[str] description: Short description of the rule and its context.
        :param pulumi.Input[str] rule_id: ID of the rule. It has to be unique across all the examples. This is managed internally.
        :param pulumi.Input['GoogleCloudContentwarehouseV1RuleTriggerType'] trigger_type: Identifies the trigger type for running the policy.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)
        if trigger_type is not None:
            pulumi.set(__self__, "trigger_type", trigger_type)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudContentwarehouseV1ActionArgs']]]]:
        """
        List of actions that are executed when the rule is satisfied.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudContentwarehouseV1ActionArgs']]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        Represents the conditional expression to be evaluated. Expression should evaluate to a boolean result. When the condition is true actions are executed. Example: user_role = "hsbc_role_1" AND doc.salary > 20000
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Short description of the rule and its context.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the rule. It has to be unique across all the examples. This is managed internally.
        """
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rule_id", value)

    @property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1RuleTriggerType']]:
        """
        Identifies the trigger type for running the policy.
        """
        return pulumi.get(self, "trigger_type")

    @trigger_type.setter
    def trigger_type(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1RuleTriggerType']]):
        pulumi.set(self, "trigger_type", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1SynonymSetSynonymArgs:
    def __init__(__self__, *,
                 words: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Represents a list of words given by the customer All these words are synonyms of each other.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] words: For example: sale, invoice, bill, order
        """
        if words is not None:
            pulumi.set(__self__, "words", words)

    @property
    @pulumi.getter
    def words(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        For example: sale, invoice, bill, order
        """
        return pulumi.get(self, "words")

    @words.setter
    def words(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "words", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1TextArrayArgs:
    def __init__(__self__, *,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        String/text values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of text values.
        """
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of text values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1TextTypeOptionsArgs:
    def __init__(__self__):
        """
        Configurations for a text property.
        """
        pass


@pulumi.input_type
class GoogleCloudContentwarehouseV1TimestampArrayArgs:
    def __init__(__self__, *,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudContentwarehouseV1TimestampValueArgs']]]] = None):
        """
        Timestamp values.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudContentwarehouseV1TimestampValueArgs']]] values: List of timestamp values.
        """
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudContentwarehouseV1TimestampValueArgs']]]]:
        """
        List of timestamp values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudContentwarehouseV1TimestampValueArgs']]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1TimestampTypeOptionsArgs:
    def __init__(__self__):
        """
        Configurations for a timestamp property.
        """
        pass


@pulumi.input_type
class GoogleCloudContentwarehouseV1TimestampValueArgs:
    def __init__(__self__, *,
                 text_value: Optional[pulumi.Input[str]] = None,
                 timestamp_value: Optional[pulumi.Input[str]] = None):
        """
        Timestamp value type.
        :param pulumi.Input[str] text_value: The string must represent a valid instant in UTC and is parsed using java.time.format.DateTimeFormatter.ISO_INSTANT. e.g. "2013-09-29T18:46:19Z"
        :param pulumi.Input[str] timestamp_value: Timestamp value
        """
        if text_value is not None:
            pulumi.set(__self__, "text_value", text_value)
        if timestamp_value is not None:
            pulumi.set(__self__, "timestamp_value", timestamp_value)

    @property
    @pulumi.getter(name="textValue")
    def text_value(self) -> Optional[pulumi.Input[str]]:
        """
        The string must represent a valid instant in UTC and is parsed using java.time.format.DateTimeFormatter.ISO_INSTANT. e.g. "2013-09-29T18:46:19Z"
        """
        return pulumi.get(self, "text_value")

    @text_value.setter
    def text_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_value", value)

    @property
    @pulumi.getter(name="timestampValue")
    def timestamp_value(self) -> Optional[pulumi.Input[str]]:
        """
        Timestamp value
        """
        return pulumi.get(self, "timestamp_value")

    @timestamp_value.setter
    def timestamp_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timestamp_value", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1UserInfoArgs:
    def __init__(__self__, *,
                 group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        The user information.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_ids: The unique group identifications which the user is belong to. The format is "group:yyyy@example.com";
        :param pulumi.Input[str] id: A unique user identification string, as determined by the client. The maximum number of allowed characters is 255. Allowed characters include numbers 0 to 9, uppercase and lowercase letters, and restricted special symbols (:, @, +, -, _, ~) The format is "user:xxxx@example.com";
        """
        if group_ids is not None:
            pulumi.set(__self__, "group_ids", group_ids)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The unique group identifications which the user is belong to. The format is "group:yyyy@example.com";
        """
        return pulumi.get(self, "group_ids")

    @group_ids.setter
    def group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_ids", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        A unique user identification string, as determined by the client. The maximum number of allowed characters is 255. Allowed characters include numbers 0 to 9, uppercase and lowercase letters, and restricted special symbols (:, @, +, -, _, ~) The format is "user:xxxx@example.com";
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class GoogleCloudContentwarehouseV1ValueArgs:
    def __init__(__self__, *,
                 boolean_value: Optional[pulumi.Input[bool]] = None,
                 datetime_value: Optional[pulumi.Input['GoogleTypeDateTimeArgs']] = None,
                 enum_value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1EnumValueArgs']] = None,
                 float_value: Optional[pulumi.Input[float]] = None,
                 int_value: Optional[pulumi.Input[int]] = None,
                 string_value: Optional[pulumi.Input[str]] = None,
                 timestamp_value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1TimestampValueArgs']] = None):
        """
        `Value` represents a dynamically typed value which can be either be a float, a integer, a string, or a datetime value. A producer of value is expected to set one of these variants. Absence of any variant indicates an error.
        :param pulumi.Input[bool] boolean_value: Represents a boolean value.
        :param pulumi.Input['GoogleTypeDateTimeArgs'] datetime_value: Represents a datetime value.
        :param pulumi.Input['GoogleCloudContentwarehouseV1EnumValueArgs'] enum_value: Represents an enum value.
        :param pulumi.Input[float] float_value: Represents a float value.
        :param pulumi.Input[int] int_value: Represents a integer value.
        :param pulumi.Input[str] string_value: Represents a string value.
        :param pulumi.Input['GoogleCloudContentwarehouseV1TimestampValueArgs'] timestamp_value: Represents a timestamp value.
        """
        if boolean_value is not None:
            pulumi.set(__self__, "boolean_value", boolean_value)
        if datetime_value is not None:
            pulumi.set(__self__, "datetime_value", datetime_value)
        if enum_value is not None:
            pulumi.set(__self__, "enum_value", enum_value)
        if float_value is not None:
            pulumi.set(__self__, "float_value", float_value)
        if int_value is not None:
            pulumi.set(__self__, "int_value", int_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)
        if timestamp_value is not None:
            pulumi.set(__self__, "timestamp_value", timestamp_value)

    @property
    @pulumi.getter(name="booleanValue")
    def boolean_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Represents a boolean value.
        """
        return pulumi.get(self, "boolean_value")

    @boolean_value.setter
    def boolean_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boolean_value", value)

    @property
    @pulumi.getter(name="datetimeValue")
    def datetime_value(self) -> Optional[pulumi.Input['GoogleTypeDateTimeArgs']]:
        """
        Represents a datetime value.
        """
        return pulumi.get(self, "datetime_value")

    @datetime_value.setter
    def datetime_value(self, value: Optional[pulumi.Input['GoogleTypeDateTimeArgs']]):
        pulumi.set(self, "datetime_value", value)

    @property
    @pulumi.getter(name="enumValue")
    def enum_value(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1EnumValueArgs']]:
        """
        Represents an enum value.
        """
        return pulumi.get(self, "enum_value")

    @enum_value.setter
    def enum_value(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1EnumValueArgs']]):
        pulumi.set(self, "enum_value", value)

    @property
    @pulumi.getter(name="floatValue")
    def float_value(self) -> Optional[pulumi.Input[float]]:
        """
        Represents a float value.
        """
        return pulumi.get(self, "float_value")

    @float_value.setter
    def float_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "float_value", value)

    @property
    @pulumi.getter(name="intValue")
    def int_value(self) -> Optional[pulumi.Input[int]]:
        """
        Represents a integer value.
        """
        return pulumi.get(self, "int_value")

    @int_value.setter
    def int_value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "int_value", value)

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[pulumi.Input[str]]:
        """
        Represents a string value.
        """
        return pulumi.get(self, "string_value")

    @string_value.setter
    def string_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string_value", value)

    @property
    @pulumi.getter(name="timestampValue")
    def timestamp_value(self) -> Optional[pulumi.Input['GoogleCloudContentwarehouseV1TimestampValueArgs']]:
        """
        Represents a timestamp value.
        """
        return pulumi.get(self, "timestamp_value")

    @timestamp_value.setter
    def timestamp_value(self, value: Optional[pulumi.Input['GoogleCloudContentwarehouseV1TimestampValueArgs']]):
        pulumi.set(self, "timestamp_value", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1BarcodeArgs:
    def __init__(__self__, *,
                 format: Optional[pulumi.Input[str]] = None,
                 raw_value: Optional[pulumi.Input[str]] = None,
                 value_format: Optional[pulumi.Input[str]] = None):
        """
        Encodes the detailed information of a barcode.
        :param pulumi.Input[str] format: Format of a barcode. The supported formats are: - `CODE_128`: Code 128 type. - `CODE_39`: Code 39 type. - `CODE_93`: Code 93 type. - `CODABAR`: Codabar type. - `DATA_MATRIX`: 2D Data Matrix type. - `ITF`: ITF type. - `EAN_13`: EAN-13 type. - `EAN_8`: EAN-8 type. - `QR_CODE`: 2D QR code type. - `UPC_A`: UPC-A type. - `UPC_E`: UPC-E type. - `PDF417`: PDF417 type. - `AZTEC`: 2D Aztec code type. - `DATABAR`: GS1 DataBar code type.
        :param pulumi.Input[str] raw_value: Raw value encoded in the barcode. For example: `'MEBKM:TITLE:Google;URL:https://www.google.com;;'`.
        :param pulumi.Input[str] value_format: Value format describes the format of the value that a barcode encodes. The supported formats are: - `CONTACT_INFO`: Contact information. - `EMAIL`: Email address. - `ISBN`: ISBN identifier. - `PHONE`: Phone number. - `PRODUCT`: Product. - `SMS`: SMS message. - `TEXT`: Text string. - `URL`: URL address. - `WIFI`: Wifi information. - `GEO`: Geo-localization. - `CALENDAR_EVENT`: Calendar event. - `DRIVER_LICENSE`: Driver's license.
        """
        if format is not None:
            pulumi.set(__self__, "format", format)
        if raw_value is not None:
            pulumi.set(__self__, "raw_value", raw_value)
        if value_format is not None:
            pulumi.set(__self__, "value_format", value_format)

    @property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[str]]:
        """
        Format of a barcode. The supported formats are: - `CODE_128`: Code 128 type. - `CODE_39`: Code 39 type. - `CODE_93`: Code 93 type. - `CODABAR`: Codabar type. - `DATA_MATRIX`: 2D Data Matrix type. - `ITF`: ITF type. - `EAN_13`: EAN-13 type. - `EAN_8`: EAN-8 type. - `QR_CODE`: 2D QR code type. - `UPC_A`: UPC-A type. - `UPC_E`: UPC-E type. - `PDF417`: PDF417 type. - `AZTEC`: 2D Aztec code type. - `DATABAR`: GS1 DataBar code type.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter(name="rawValue")
    def raw_value(self) -> Optional[pulumi.Input[str]]:
        """
        Raw value encoded in the barcode. For example: `'MEBKM:TITLE:Google;URL:https://www.google.com;;'`.
        """
        return pulumi.get(self, "raw_value")

    @raw_value.setter
    def raw_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raw_value", value)

    @property
    @pulumi.getter(name="valueFormat")
    def value_format(self) -> Optional[pulumi.Input[str]]:
        """
        Value format describes the format of the value that a barcode encodes. The supported formats are: - `CONTACT_INFO`: Contact information. - `EMAIL`: Email address. - `ISBN`: ISBN identifier. - `PHONE`: Phone number. - `PRODUCT`: Product. - `SMS`: SMS message. - `TEXT`: Text string. - `URL`: URL address. - `WIFI`: Wifi information. - `GEO`: Geo-localization. - `CALENDAR_EVENT`: Calendar event. - `DRIVER_LICENSE`: Driver's license.
        """
        return pulumi.get(self, "value_format")

    @value_format.setter
    def value_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_format", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1BoundingPolyArgs:
    def __init__(__self__, *,
                 normalized_vertices: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1NormalizedVertexArgs']]]] = None,
                 vertices: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1VertexArgs']]]] = None):
        """
        A bounding polygon for the detected image annotation.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1NormalizedVertexArgs']]] normalized_vertices: The bounding polygon normalized vertices.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1VertexArgs']]] vertices: The bounding polygon vertices.
        """
        if normalized_vertices is not None:
            pulumi.set(__self__, "normalized_vertices", normalized_vertices)
        if vertices is not None:
            pulumi.set(__self__, "vertices", vertices)

    @property
    @pulumi.getter(name="normalizedVertices")
    def normalized_vertices(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1NormalizedVertexArgs']]]]:
        """
        The bounding polygon normalized vertices.
        """
        return pulumi.get(self, "normalized_vertices")

    @normalized_vertices.setter
    def normalized_vertices(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1NormalizedVertexArgs']]]]):
        pulumi.set(self, "normalized_vertices", value)

    @property
    @pulumi.getter
    def vertices(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1VertexArgs']]]]:
        """
        The bounding polygon vertices.
        """
        return pulumi.get(self, "vertices")

    @vertices.setter
    def vertices(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1VertexArgs']]]]):
        pulumi.set(self, "vertices", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentEntityNormalizedValueArgs:
    def __init__(__self__, *,
                 address_value: Optional[pulumi.Input['GoogleTypePostalAddressArgs']] = None,
                 boolean_value: Optional[pulumi.Input[bool]] = None,
                 date_value: Optional[pulumi.Input['GoogleTypeDateArgs']] = None,
                 datetime_value: Optional[pulumi.Input['GoogleTypeDateTimeArgs']] = None,
                 float_value: Optional[pulumi.Input[float]] = None,
                 integer_value: Optional[pulumi.Input[int]] = None,
                 money_value: Optional[pulumi.Input['GoogleTypeMoneyArgs']] = None,
                 text: Optional[pulumi.Input[str]] = None):
        """
        Parsed and normalized entity value.
        :param pulumi.Input['GoogleTypePostalAddressArgs'] address_value: Postal address. See also: https://github.com/googleapis/googleapis/blob/master/google/type/postal_address.proto
        :param pulumi.Input[bool] boolean_value: Boolean value. Can be used for entities with binary values, or for checkboxes.
        :param pulumi.Input['GoogleTypeDateArgs'] date_value: Date value. Includes year, month, day. See also: https://github.com/googleapis/googleapis/blob/master/google/type/date.proto
        :param pulumi.Input['GoogleTypeDateTimeArgs'] datetime_value: DateTime value. Includes date, time, and timezone. See also: https://github.com/googleapis/googleapis/blob/master/google/type/datetime.proto
        :param pulumi.Input[float] float_value: Float value.
        :param pulumi.Input[int] integer_value: Integer value.
        :param pulumi.Input['GoogleTypeMoneyArgs'] money_value: Money value. See also: https://github.com/googleapis/googleapis/blob/master/google/type/money.proto
        :param pulumi.Input[str] text: Optional. An optional field to store a normalized string. For some entity types, one of respective `structured_value` fields may also be populated. Also not all the types of `structured_value` will be normalized. For example, some processors may not generate `float` or `integer` normalized text by default. Below are sample formats mapped to structured values. - Money/Currency type (`money_value`) is in the ISO 4217 text format. - Date type (`date_value`) is in the ISO 8601 text format. - Datetime type (`datetime_value`) is in the ISO 8601 text format.
        """
        if address_value is not None:
            pulumi.set(__self__, "address_value", address_value)
        if boolean_value is not None:
            pulumi.set(__self__, "boolean_value", boolean_value)
        if date_value is not None:
            pulumi.set(__self__, "date_value", date_value)
        if datetime_value is not None:
            pulumi.set(__self__, "datetime_value", datetime_value)
        if float_value is not None:
            pulumi.set(__self__, "float_value", float_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)
        if money_value is not None:
            pulumi.set(__self__, "money_value", money_value)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter(name="addressValue")
    def address_value(self) -> Optional[pulumi.Input['GoogleTypePostalAddressArgs']]:
        """
        Postal address. See also: https://github.com/googleapis/googleapis/blob/master/google/type/postal_address.proto
        """
        return pulumi.get(self, "address_value")

    @address_value.setter
    def address_value(self, value: Optional[pulumi.Input['GoogleTypePostalAddressArgs']]):
        pulumi.set(self, "address_value", value)

    @property
    @pulumi.getter(name="booleanValue")
    def boolean_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean value. Can be used for entities with binary values, or for checkboxes.
        """
        return pulumi.get(self, "boolean_value")

    @boolean_value.setter
    def boolean_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boolean_value", value)

    @property
    @pulumi.getter(name="dateValue")
    def date_value(self) -> Optional[pulumi.Input['GoogleTypeDateArgs']]:
        """
        Date value. Includes year, month, day. See also: https://github.com/googleapis/googleapis/blob/master/google/type/date.proto
        """
        return pulumi.get(self, "date_value")

    @date_value.setter
    def date_value(self, value: Optional[pulumi.Input['GoogleTypeDateArgs']]):
        pulumi.set(self, "date_value", value)

    @property
    @pulumi.getter(name="datetimeValue")
    def datetime_value(self) -> Optional[pulumi.Input['GoogleTypeDateTimeArgs']]:
        """
        DateTime value. Includes date, time, and timezone. See also: https://github.com/googleapis/googleapis/blob/master/google/type/datetime.proto
        """
        return pulumi.get(self, "datetime_value")

    @datetime_value.setter
    def datetime_value(self, value: Optional[pulumi.Input['GoogleTypeDateTimeArgs']]):
        pulumi.set(self, "datetime_value", value)

    @property
    @pulumi.getter(name="floatValue")
    def float_value(self) -> Optional[pulumi.Input[float]]:
        """
        Float value.
        """
        return pulumi.get(self, "float_value")

    @float_value.setter
    def float_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "float_value", value)

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[pulumi.Input[int]]:
        """
        Integer value.
        """
        return pulumi.get(self, "integer_value")

    @integer_value.setter
    def integer_value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "integer_value", value)

    @property
    @pulumi.getter(name="moneyValue")
    def money_value(self) -> Optional[pulumi.Input['GoogleTypeMoneyArgs']]:
        """
        Money value. See also: https://github.com/googleapis/googleapis/blob/master/google/type/money.proto
        """
        return pulumi.get(self, "money_value")

    @money_value.setter
    def money_value(self, value: Optional[pulumi.Input['GoogleTypeMoneyArgs']]):
        pulumi.set(self, "money_value", value)

    @property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. An optional field to store a normalized string. For some entity types, one of respective `structured_value` fields may also be populated. Also not all the types of `structured_value` will be normalized. For example, some processors may not generate `float` or `integer` normalized text by default. Below are sample formats mapped to structured values. - Money/Currency type (`money_value`) is in the ISO 4217 text format. - Date type (`date_value`) is in the ISO 8601 text format. - Datetime type (`datetime_value`) is in the ISO 8601 text format.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentEntityRelationArgs:
    def __init__(__self__, *,
                 object_id: Optional[pulumi.Input[str]] = None,
                 relation: Optional[pulumi.Input[str]] = None,
                 subject_id: Optional[pulumi.Input[str]] = None):
        """
        Relationship between Entities.
        :param pulumi.Input[str] object_id: Object entity id.
        :param pulumi.Input[str] relation: Relationship description.
        :param pulumi.Input[str] subject_id: Subject entity id.
        """
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if relation is not None:
            pulumi.set(__self__, "relation", relation)
        if subject_id is not None:
            pulumi.set(__self__, "subject_id", subject_id)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[pulumi.Input[str]]:
        """
        Object entity id.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_id", value)

    @property
    @pulumi.getter
    def relation(self) -> Optional[pulumi.Input[str]]:
        """
        Relationship description.
        """
        return pulumi.get(self, "relation")

    @relation.setter
    def relation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "relation", value)

    @property
    @pulumi.getter(name="subjectId")
    def subject_id(self) -> Optional[pulumi.Input[str]]:
        """
        Subject entity id.
        """
        return pulumi.get(self, "subject_id")

    @subject_id.setter
    def subject_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject_id", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentEntityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 confidence: Optional[pulumi.Input[float]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 mention_id: Optional[pulumi.Input[str]] = None,
                 mention_text: Optional[pulumi.Input[str]] = None,
                 normalized_value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentEntityNormalizedValueArgs']] = None,
                 page_anchor: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageAnchorArgs']] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentEntityArgs']]]] = None,
                 provenance: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']] = None,
                 redacted: Optional[pulumi.Input[bool]] = None,
                 text_anchor: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentTextAnchorArgs']] = None):
        """
        An entity that could be a phrase in the text or a property that belongs to the document. It is a known entity type, such as a person, an organization, or location.
        :param pulumi.Input[str] type: Entity type from a schema e.g. `Address`.
        :param pulumi.Input[float] confidence: Optional. Confidence of detected Schema entity. Range `[0, 1]`.
        :param pulumi.Input[str] id: Optional. Canonical id. This will be a unique value in the entity list for this document.
        :param pulumi.Input[str] mention_id: Optional. Deprecated. Use `id` field instead.
        :param pulumi.Input[str] mention_text: Optional. Text value of the entity e.g. `1600 Amphitheatre Pkwy`.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentEntityNormalizedValueArgs'] normalized_value: Optional. Normalized entity value. Absent if the extracted value could not be converted or the type (e.g. address) is not supported for certain parsers. This field is also only populated for certain supported document types.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentPageAnchorArgs'] page_anchor: Optional. Represents the provenance of this entity wrt. the location on the page where it was found.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentEntityArgs']]] properties: Optional. Entities can be nested to form a hierarchical data structure representing the content in the document.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs'] provenance: Optional. The history of this annotation.
        :param pulumi.Input[bool] redacted: Optional. Whether the entity will be redacted for de-identification purposes.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentTextAnchorArgs'] text_anchor: Optional. Provenance of the entity. Text anchor indexing into the Document.text.
        """
        pulumi.set(__self__, "type", type)
        if confidence is not None:
            pulumi.set(__self__, "confidence", confidence)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mention_id is not None:
            warnings.warn("""Optional. Deprecated. Use `id` field instead.""", DeprecationWarning)
            pulumi.log.warn("""mention_id is deprecated: Optional. Deprecated. Use `id` field instead.""")
        if mention_id is not None:
            pulumi.set(__self__, "mention_id", mention_id)
        if mention_text is not None:
            pulumi.set(__self__, "mention_text", mention_text)
        if normalized_value is not None:
            pulumi.set(__self__, "normalized_value", normalized_value)
        if page_anchor is not None:
            pulumi.set(__self__, "page_anchor", page_anchor)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if provenance is not None:
            pulumi.set(__self__, "provenance", provenance)
        if redacted is not None:
            pulumi.set(__self__, "redacted", redacted)
        if text_anchor is not None:
            pulumi.set(__self__, "text_anchor", text_anchor)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Entity type from a schema e.g. `Address`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def confidence(self) -> Optional[pulumi.Input[float]]:
        """
        Optional. Confidence of detected Schema entity. Range `[0, 1]`.
        """
        return pulumi.get(self, "confidence")

    @confidence.setter
    def confidence(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "confidence", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Canonical id. This will be a unique value in the entity list for this document.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="mentionId")
    @_utilities.deprecated("""Optional. Deprecated. Use `id` field instead.""")
    def mention_id(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Deprecated. Use `id` field instead.
        """
        return pulumi.get(self, "mention_id")

    @mention_id.setter
    def mention_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mention_id", value)

    @property
    @pulumi.getter(name="mentionText")
    def mention_text(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Text value of the entity e.g. `1600 Amphitheatre Pkwy`.
        """
        return pulumi.get(self, "mention_text")

    @mention_text.setter
    def mention_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mention_text", value)

    @property
    @pulumi.getter(name="normalizedValue")
    def normalized_value(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentEntityNormalizedValueArgs']]:
        """
        Optional. Normalized entity value. Absent if the extracted value could not be converted or the type (e.g. address) is not supported for certain parsers. This field is also only populated for certain supported document types.
        """
        return pulumi.get(self, "normalized_value")

    @normalized_value.setter
    def normalized_value(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentEntityNormalizedValueArgs']]):
        pulumi.set(self, "normalized_value", value)

    @property
    @pulumi.getter(name="pageAnchor")
    def page_anchor(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageAnchorArgs']]:
        """
        Optional. Represents the provenance of this entity wrt. the location on the page where it was found.
        """
        return pulumi.get(self, "page_anchor")

    @page_anchor.setter
    def page_anchor(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageAnchorArgs']]):
        pulumi.set(self, "page_anchor", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentEntityArgs']]]]:
        """
        Optional. Entities can be nested to form a hierarchical data structure representing the content in the document.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentEntityArgs']]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter
    def provenance(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']]:
        """
        Optional. The history of this annotation.
        """
        return pulumi.get(self, "provenance")

    @provenance.setter
    def provenance(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']]):
        pulumi.set(self, "provenance", value)

    @property
    @pulumi.getter
    def redacted(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional. Whether the entity will be redacted for de-identification purposes.
        """
        return pulumi.get(self, "redacted")

    @redacted.setter
    def redacted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "redacted", value)

    @property
    @pulumi.getter(name="textAnchor")
    def text_anchor(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentTextAnchorArgs']]:
        """
        Optional. Provenance of the entity. Text anchor indexing into the Document.text.
        """
        return pulumi.get(self, "text_anchor")

    @text_anchor.setter
    def text_anchor(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentTextAnchorArgs']]):
        pulumi.set(self, "text_anchor", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentPageAnchorPageRefArgs:
    def __init__(__self__, *,
                 page: pulumi.Input[str],
                 bounding_poly: Optional[pulumi.Input['GoogleCloudDocumentaiV1BoundingPolyArgs']] = None,
                 confidence: Optional[pulumi.Input[float]] = None,
                 layout_id: Optional[pulumi.Input[str]] = None,
                 layout_type: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageAnchorPageRefLayoutType']] = None):
        """
        Represents a weak reference to a page element within a document.
        :param pulumi.Input[str] page: Index into the Document.pages element, for example using `Document.pages` to locate the related page element. This field is skipped when its value is the default `0`. See https://developers.google.com/protocol-buffers/docs/proto3#json.
        :param pulumi.Input['GoogleCloudDocumentaiV1BoundingPolyArgs'] bounding_poly: Optional. Identifies the bounding polygon of a layout element on the page.
        :param pulumi.Input[float] confidence: Optional. Confidence of detected page element, if applicable. Range `[0, 1]`.
        :param pulumi.Input[str] layout_id: Optional. Deprecated. Use PageRef.bounding_poly instead.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentPageAnchorPageRefLayoutType'] layout_type: Optional. The type of the layout element that is being referenced if any.
        """
        pulumi.set(__self__, "page", page)
        if bounding_poly is not None:
            pulumi.set(__self__, "bounding_poly", bounding_poly)
        if confidence is not None:
            pulumi.set(__self__, "confidence", confidence)
        if layout_id is not None:
            warnings.warn("""Optional. Deprecated. Use PageRef.bounding_poly instead.""", DeprecationWarning)
            pulumi.log.warn("""layout_id is deprecated: Optional. Deprecated. Use PageRef.bounding_poly instead.""")
        if layout_id is not None:
            pulumi.set(__self__, "layout_id", layout_id)
        if layout_type is not None:
            pulumi.set(__self__, "layout_type", layout_type)

    @property
    @pulumi.getter
    def page(self) -> pulumi.Input[str]:
        """
        Index into the Document.pages element, for example using `Document.pages` to locate the related page element. This field is skipped when its value is the default `0`. See https://developers.google.com/protocol-buffers/docs/proto3#json.
        """
        return pulumi.get(self, "page")

    @page.setter
    def page(self, value: pulumi.Input[str]):
        pulumi.set(self, "page", value)

    @property
    @pulumi.getter(name="boundingPoly")
    def bounding_poly(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1BoundingPolyArgs']]:
        """
        Optional. Identifies the bounding polygon of a layout element on the page.
        """
        return pulumi.get(self, "bounding_poly")

    @bounding_poly.setter
    def bounding_poly(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1BoundingPolyArgs']]):
        pulumi.set(self, "bounding_poly", value)

    @property
    @pulumi.getter
    def confidence(self) -> Optional[pulumi.Input[float]]:
        """
        Optional. Confidence of detected page element, if applicable. Range `[0, 1]`.
        """
        return pulumi.get(self, "confidence")

    @confidence.setter
    def confidence(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "confidence", value)

    @property
    @pulumi.getter(name="layoutId")
    @_utilities.deprecated("""Optional. Deprecated. Use PageRef.bounding_poly instead.""")
    def layout_id(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Deprecated. Use PageRef.bounding_poly instead.
        """
        return pulumi.get(self, "layout_id")

    @layout_id.setter
    def layout_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "layout_id", value)

    @property
    @pulumi.getter(name="layoutType")
    def layout_type(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageAnchorPageRefLayoutType']]:
        """
        Optional. The type of the layout element that is being referenced if any.
        """
        return pulumi.get(self, "layout_type")

    @layout_type.setter
    def layout_type(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageAnchorPageRefLayoutType']]):
        pulumi.set(self, "layout_type", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentPageAnchorArgs:
    def __init__(__self__, *,
                 page_refs: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageAnchorPageRefArgs']]]] = None):
        """
        Referencing the visual context of the entity in the Document.pages. Page anchors can be cross-page, consist of multiple bounding polygons and optionally reference specific layout element types.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageAnchorPageRefArgs']]] page_refs: One or more references to visual page elements
        """
        if page_refs is not None:
            pulumi.set(__self__, "page_refs", page_refs)

    @property
    @pulumi.getter(name="pageRefs")
    def page_refs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageAnchorPageRefArgs']]]]:
        """
        One or more references to visual page elements
        """
        return pulumi.get(self, "page_refs")

    @page_refs.setter
    def page_refs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageAnchorPageRefArgs']]]]):
        pulumi.set(self, "page_refs", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentPageBlockArgs:
    def __init__(__self__, *,
                 detected_languages: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]] = None,
                 layout: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']] = None,
                 provenance: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']] = None):
        """
        A block has a set of lines (collected into paragraphs) that have a common line-spacing and orientation.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]] detected_languages: A list of detected languages together with confidence.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs'] layout: Layout for Block.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs'] provenance: The history of this annotation.
        """
        if detected_languages is not None:
            pulumi.set(__self__, "detected_languages", detected_languages)
        if layout is not None:
            pulumi.set(__self__, "layout", layout)
        if provenance is not None:
            pulumi.set(__self__, "provenance", provenance)

    @property
    @pulumi.getter(name="detectedLanguages")
    def detected_languages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]]:
        """
        A list of detected languages together with confidence.
        """
        return pulumi.get(self, "detected_languages")

    @detected_languages.setter
    def detected_languages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]]):
        pulumi.set(self, "detected_languages", value)

    @property
    @pulumi.getter
    def layout(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']]:
        """
        Layout for Block.
        """
        return pulumi.get(self, "layout")

    @layout.setter
    def layout(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']]):
        pulumi.set(self, "layout", value)

    @property
    @pulumi.getter
    def provenance(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']]:
        """
        The history of this annotation.
        """
        return pulumi.get(self, "provenance")

    @provenance.setter
    def provenance(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']]):
        pulumi.set(self, "provenance", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentPageDetectedBarcodeArgs:
    def __init__(__self__, *,
                 barcode: Optional[pulumi.Input['GoogleCloudDocumentaiV1BarcodeArgs']] = None,
                 layout: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']] = None):
        """
        A detected barcode.
        :param pulumi.Input['GoogleCloudDocumentaiV1BarcodeArgs'] barcode: Detailed barcode information of the DetectedBarcode.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs'] layout: Layout for DetectedBarcode.
        """
        if barcode is not None:
            pulumi.set(__self__, "barcode", barcode)
        if layout is not None:
            pulumi.set(__self__, "layout", layout)

    @property
    @pulumi.getter
    def barcode(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1BarcodeArgs']]:
        """
        Detailed barcode information of the DetectedBarcode.
        """
        return pulumi.get(self, "barcode")

    @barcode.setter
    def barcode(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1BarcodeArgs']]):
        pulumi.set(self, "barcode", value)

    @property
    @pulumi.getter
    def layout(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']]:
        """
        Layout for DetectedBarcode.
        """
        return pulumi.get(self, "layout")

    @layout.setter
    def layout(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']]):
        pulumi.set(self, "layout", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs:
    def __init__(__self__, *,
                 confidence: Optional[pulumi.Input[float]] = None,
                 language_code: Optional[pulumi.Input[str]] = None):
        """
        Detected language for a structural component.
        :param pulumi.Input[float] confidence: Confidence of detected language. Range `[0, 1]`.
        :param pulumi.Input[str] language_code: The [BCP-47 language code](https://www.unicode.org/reports/tr35/#Unicode_locale_identifier), such as `en-US` or `sr-Latn`.
        """
        if confidence is not None:
            pulumi.set(__self__, "confidence", confidence)
        if language_code is not None:
            pulumi.set(__self__, "language_code", language_code)

    @property
    @pulumi.getter
    def confidence(self) -> Optional[pulumi.Input[float]]:
        """
        Confidence of detected language. Range `[0, 1]`.
        """
        return pulumi.get(self, "confidence")

    @confidence.setter
    def confidence(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "confidence", value)

    @property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> Optional[pulumi.Input[str]]:
        """
        The [BCP-47 language code](https://www.unicode.org/reports/tr35/#Unicode_locale_identifier), such as `en-US` or `sr-Latn`.
        """
        return pulumi.get(self, "language_code")

    @language_code.setter
    def language_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "language_code", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentPageDimensionArgs:
    def __init__(__self__, *,
                 height: Optional[pulumi.Input[float]] = None,
                 unit: Optional[pulumi.Input[str]] = None,
                 width: Optional[pulumi.Input[float]] = None):
        """
        Dimension for the page.
        :param pulumi.Input[float] height: Page height.
        :param pulumi.Input[str] unit: Dimension unit.
        :param pulumi.Input[float] width: Page width.
        """
        if height is not None:
            pulumi.set(__self__, "height", height)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[float]]:
        """
        Page height.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[str]]:
        """
        Dimension unit.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[float]]:
        """
        Page width.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentPageFormFieldArgs:
    def __init__(__self__, *,
                 corrected_key_text: Optional[pulumi.Input[str]] = None,
                 corrected_value_text: Optional[pulumi.Input[str]] = None,
                 field_name: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']] = None,
                 field_value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']] = None,
                 name_detected_languages: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]] = None,
                 provenance: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']] = None,
                 value_detected_languages: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]] = None,
                 value_type: Optional[pulumi.Input[str]] = None):
        """
        A form field detected on the page.
        :param pulumi.Input[str] corrected_key_text: Created for Labeling UI to export key text. If corrections were made to the text identified by the `field_name.text_anchor`, this field will contain the correction.
        :param pulumi.Input[str] corrected_value_text: Created for Labeling UI to export value text. If corrections were made to the text identified by the `field_value.text_anchor`, this field will contain the correction.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs'] field_name: Layout for the FormField name. e.g. `Address`, `Email`, `Grand total`, `Phone number`, etc.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs'] field_value: Layout for the FormField value.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]] name_detected_languages: A list of detected languages for name together with confidence.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs'] provenance: The history of this annotation.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]] value_detected_languages: A list of detected languages for value together with confidence.
        :param pulumi.Input[str] value_type: If the value is non-textual, this field represents the type. Current valid values are: - blank (this indicates the `field_value` is normal text) - `unfilled_checkbox` - `filled_checkbox`
        """
        if corrected_key_text is not None:
            pulumi.set(__self__, "corrected_key_text", corrected_key_text)
        if corrected_value_text is not None:
            pulumi.set(__self__, "corrected_value_text", corrected_value_text)
        if field_name is not None:
            pulumi.set(__self__, "field_name", field_name)
        if field_value is not None:
            pulumi.set(__self__, "field_value", field_value)
        if name_detected_languages is not None:
            pulumi.set(__self__, "name_detected_languages", name_detected_languages)
        if provenance is not None:
            pulumi.set(__self__, "provenance", provenance)
        if value_detected_languages is not None:
            pulumi.set(__self__, "value_detected_languages", value_detected_languages)
        if value_type is not None:
            pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter(name="correctedKeyText")
    def corrected_key_text(self) -> Optional[pulumi.Input[str]]:
        """
        Created for Labeling UI to export key text. If corrections were made to the text identified by the `field_name.text_anchor`, this field will contain the correction.
        """
        return pulumi.get(self, "corrected_key_text")

    @corrected_key_text.setter
    def corrected_key_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "corrected_key_text", value)

    @property
    @pulumi.getter(name="correctedValueText")
    def corrected_value_text(self) -> Optional[pulumi.Input[str]]:
        """
        Created for Labeling UI to export value text. If corrections were made to the text identified by the `field_value.text_anchor`, this field will contain the correction.
        """
        return pulumi.get(self, "corrected_value_text")

    @corrected_value_text.setter
    def corrected_value_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "corrected_value_text", value)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']]:
        """
        Layout for the FormField name. e.g. `Address`, `Email`, `Grand total`, `Phone number`, etc.
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']]):
        pulumi.set(self, "field_name", value)

    @property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']]:
        """
        Layout for the FormField value.
        """
        return pulumi.get(self, "field_value")

    @field_value.setter
    def field_value(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']]):
        pulumi.set(self, "field_value", value)

    @property
    @pulumi.getter(name="nameDetectedLanguages")
    def name_detected_languages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]]:
        """
        A list of detected languages for name together with confidence.
        """
        return pulumi.get(self, "name_detected_languages")

    @name_detected_languages.setter
    def name_detected_languages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]]):
        pulumi.set(self, "name_detected_languages", value)

    @property
    @pulumi.getter
    def provenance(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']]:
        """
        The history of this annotation.
        """
        return pulumi.get(self, "provenance")

    @provenance.setter
    def provenance(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']]):
        pulumi.set(self, "provenance", value)

    @property
    @pulumi.getter(name="valueDetectedLanguages")
    def value_detected_languages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]]:
        """
        A list of detected languages for value together with confidence.
        """
        return pulumi.get(self, "value_detected_languages")

    @value_detected_languages.setter
    def value_detected_languages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]]):
        pulumi.set(self, "value_detected_languages", value)

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> Optional[pulumi.Input[str]]:
        """
        If the value is non-textual, this field represents the type. Current valid values are: - blank (this indicates the `field_value` is normal text) - `unfilled_checkbox` - `filled_checkbox`
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_type", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentPageImageQualityScoresDetectedDefectArgs:
    def __init__(__self__, *,
                 confidence: Optional[pulumi.Input[float]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        Image Quality Defects
        :param pulumi.Input[float] confidence: Confidence of detected defect. Range `[0, 1]` where `1` indicates strong confidence that the defect exists.
        :param pulumi.Input[str] type: Name of the defect type. Supported values are: - `quality/defect_blurry` - `quality/defect_noisy` - `quality/defect_dark` - `quality/defect_faint` - `quality/defect_text_too_small` - `quality/defect_document_cutoff` - `quality/defect_text_cutoff` - `quality/defect_glare`
        """
        if confidence is not None:
            pulumi.set(__self__, "confidence", confidence)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def confidence(self) -> Optional[pulumi.Input[float]]:
        """
        Confidence of detected defect. Range `[0, 1]` where `1` indicates strong confidence that the defect exists.
        """
        return pulumi.get(self, "confidence")

    @confidence.setter
    def confidence(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "confidence", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the defect type. Supported values are: - `quality/defect_blurry` - `quality/defect_noisy` - `quality/defect_dark` - `quality/defect_faint` - `quality/defect_text_too_small` - `quality/defect_document_cutoff` - `quality/defect_text_cutoff` - `quality/defect_glare`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentPageImageQualityScoresArgs:
    def __init__(__self__, *,
                 detected_defects: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageImageQualityScoresDetectedDefectArgs']]]] = None,
                 quality_score: Optional[pulumi.Input[float]] = None):
        """
        Image quality scores for the page image.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageImageQualityScoresDetectedDefectArgs']]] detected_defects: A list of detected defects.
        :param pulumi.Input[float] quality_score: The overall quality score. Range `[0, 1]` where `1` is perfect quality.
        """
        if detected_defects is not None:
            pulumi.set(__self__, "detected_defects", detected_defects)
        if quality_score is not None:
            pulumi.set(__self__, "quality_score", quality_score)

    @property
    @pulumi.getter(name="detectedDefects")
    def detected_defects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageImageQualityScoresDetectedDefectArgs']]]]:
        """
        A list of detected defects.
        """
        return pulumi.get(self, "detected_defects")

    @detected_defects.setter
    def detected_defects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageImageQualityScoresDetectedDefectArgs']]]]):
        pulumi.set(self, "detected_defects", value)

    @property
    @pulumi.getter(name="qualityScore")
    def quality_score(self) -> Optional[pulumi.Input[float]]:
        """
        The overall quality score. Range `[0, 1]` where `1` is perfect quality.
        """
        return pulumi.get(self, "quality_score")

    @quality_score.setter
    def quality_score(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "quality_score", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentPageImageArgs:
    def __init__(__self__, *,
                 content: Optional[pulumi.Input[str]] = None,
                 height: Optional[pulumi.Input[int]] = None,
                 mime_type: Optional[pulumi.Input[str]] = None,
                 width: Optional[pulumi.Input[int]] = None):
        """
        Rendered image contents for this page.
        :param pulumi.Input[str] content: Raw byte content of the image.
        :param pulumi.Input[int] height: Height of the image in pixels.
        :param pulumi.Input[str] mime_type: Encoding [media type (MIME type)](https://www.iana.org/assignments/media-types/media-types.xhtml) for the image.
        :param pulumi.Input[int] width: Width of the image in pixels.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if mime_type is not None:
            pulumi.set(__self__, "mime_type", mime_type)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        """
        Raw byte content of the image.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[int]]:
        """
        Height of the image in pixels.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter(name="mimeType")
    def mime_type(self) -> Optional[pulumi.Input[str]]:
        """
        Encoding [media type (MIME type)](https://www.iana.org/assignments/media-types/media-types.xhtml) for the image.
        """
        return pulumi.get(self, "mime_type")

    @mime_type.setter
    def mime_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mime_type", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[int]]:
        """
        Width of the image in pixels.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentPageLayoutArgs:
    def __init__(__self__, *,
                 bounding_poly: Optional[pulumi.Input['GoogleCloudDocumentaiV1BoundingPolyArgs']] = None,
                 confidence: Optional[pulumi.Input[float]] = None,
                 orientation: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutOrientation']] = None,
                 text_anchor: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentTextAnchorArgs']] = None):
        """
        Visual element describing a layout unit on a page.
        :param pulumi.Input['GoogleCloudDocumentaiV1BoundingPolyArgs'] bounding_poly: The bounding polygon for the Layout.
        :param pulumi.Input[float] confidence: Confidence of the current Layout within context of the object this layout is for. e.g. confidence can be for a single token, a table, a visual element, etc. depending on context. Range `[0, 1]`.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutOrientation'] orientation: Detected orientation for the Layout.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentTextAnchorArgs'] text_anchor: Text anchor indexing into the Document.text.
        """
        if bounding_poly is not None:
            pulumi.set(__self__, "bounding_poly", bounding_poly)
        if confidence is not None:
            pulumi.set(__self__, "confidence", confidence)
        if orientation is not None:
            pulumi.set(__self__, "orientation", orientation)
        if text_anchor is not None:
            pulumi.set(__self__, "text_anchor", text_anchor)

    @property
    @pulumi.getter(name="boundingPoly")
    def bounding_poly(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1BoundingPolyArgs']]:
        """
        The bounding polygon for the Layout.
        """
        return pulumi.get(self, "bounding_poly")

    @bounding_poly.setter
    def bounding_poly(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1BoundingPolyArgs']]):
        pulumi.set(self, "bounding_poly", value)

    @property
    @pulumi.getter
    def confidence(self) -> Optional[pulumi.Input[float]]:
        """
        Confidence of the current Layout within context of the object this layout is for. e.g. confidence can be for a single token, a table, a visual element, etc. depending on context. Range `[0, 1]`.
        """
        return pulumi.get(self, "confidence")

    @confidence.setter
    def confidence(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "confidence", value)

    @property
    @pulumi.getter
    def orientation(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutOrientation']]:
        """
        Detected orientation for the Layout.
        """
        return pulumi.get(self, "orientation")

    @orientation.setter
    def orientation(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutOrientation']]):
        pulumi.set(self, "orientation", value)

    @property
    @pulumi.getter(name="textAnchor")
    def text_anchor(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentTextAnchorArgs']]:
        """
        Text anchor indexing into the Document.text.
        """
        return pulumi.get(self, "text_anchor")

    @text_anchor.setter
    def text_anchor(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentTextAnchorArgs']]):
        pulumi.set(self, "text_anchor", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentPageLineArgs:
    def __init__(__self__, *,
                 detected_languages: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]] = None,
                 layout: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']] = None,
                 provenance: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']] = None):
        """
        A collection of tokens that a human would perceive as a line. Does not cross column boundaries, can be horizontal, vertical, etc.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]] detected_languages: A list of detected languages together with confidence.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs'] layout: Layout for Line.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs'] provenance: The history of this annotation.
        """
        if detected_languages is not None:
            pulumi.set(__self__, "detected_languages", detected_languages)
        if layout is not None:
            pulumi.set(__self__, "layout", layout)
        if provenance is not None:
            pulumi.set(__self__, "provenance", provenance)

    @property
    @pulumi.getter(name="detectedLanguages")
    def detected_languages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]]:
        """
        A list of detected languages together with confidence.
        """
        return pulumi.get(self, "detected_languages")

    @detected_languages.setter
    def detected_languages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]]):
        pulumi.set(self, "detected_languages", value)

    @property
    @pulumi.getter
    def layout(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']]:
        """
        Layout for Line.
        """
        return pulumi.get(self, "layout")

    @layout.setter
    def layout(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']]):
        pulumi.set(self, "layout", value)

    @property
    @pulumi.getter
    def provenance(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']]:
        """
        The history of this annotation.
        """
        return pulumi.get(self, "provenance")

    @provenance.setter
    def provenance(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']]):
        pulumi.set(self, "provenance", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentPageMatrixArgs:
    def __init__(__self__, *,
                 cols: Optional[pulumi.Input[int]] = None,
                 data: Optional[pulumi.Input[str]] = None,
                 rows: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[int]] = None):
        """
        Representation for transformation matrix, intended to be compatible and used with OpenCV format for image manipulation.
        :param pulumi.Input[int] cols: Number of columns in the matrix.
        :param pulumi.Input[str] data: The matrix data.
        :param pulumi.Input[int] rows: Number of rows in the matrix.
        :param pulumi.Input[int] type: This encodes information about what data type the matrix uses. For example, 0 (CV_8U) is an unsigned 8-bit image. For the full list of OpenCV primitive data types, please refer to https://docs.opencv.org/4.3.0/d1/d1b/group__core__hal__interface.html
        """
        if cols is not None:
            pulumi.set(__self__, "cols", cols)
        if data is not None:
            pulumi.set(__self__, "data", data)
        if rows is not None:
            pulumi.set(__self__, "rows", rows)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def cols(self) -> Optional[pulumi.Input[int]]:
        """
        Number of columns in the matrix.
        """
        return pulumi.get(self, "cols")

    @cols.setter
    def cols(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cols", value)

    @property
    @pulumi.getter
    def data(self) -> Optional[pulumi.Input[str]]:
        """
        The matrix data.
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data", value)

    @property
    @pulumi.getter
    def rows(self) -> Optional[pulumi.Input[int]]:
        """
        Number of rows in the matrix.
        """
        return pulumi.get(self, "rows")

    @rows.setter
    def rows(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rows", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[int]]:
        """
        This encodes information about what data type the matrix uses. For example, 0 (CV_8U) is an unsigned 8-bit image. For the full list of OpenCV primitive data types, please refer to https://docs.opencv.org/4.3.0/d1/d1b/group__core__hal__interface.html
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentPageParagraphArgs:
    def __init__(__self__, *,
                 detected_languages: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]] = None,
                 layout: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']] = None,
                 provenance: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']] = None):
        """
        A collection of lines that a human would perceive as a paragraph.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]] detected_languages: A list of detected languages together with confidence.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs'] layout: Layout for Paragraph.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs'] provenance: The history of this annotation.
        """
        if detected_languages is not None:
            pulumi.set(__self__, "detected_languages", detected_languages)
        if layout is not None:
            pulumi.set(__self__, "layout", layout)
        if provenance is not None:
            pulumi.set(__self__, "provenance", provenance)

    @property
    @pulumi.getter(name="detectedLanguages")
    def detected_languages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]]:
        """
        A list of detected languages together with confidence.
        """
        return pulumi.get(self, "detected_languages")

    @detected_languages.setter
    def detected_languages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]]):
        pulumi.set(self, "detected_languages", value)

    @property
    @pulumi.getter
    def layout(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']]:
        """
        Layout for Paragraph.
        """
        return pulumi.get(self, "layout")

    @layout.setter
    def layout(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']]):
        pulumi.set(self, "layout", value)

    @property
    @pulumi.getter
    def provenance(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']]:
        """
        The history of this annotation.
        """
        return pulumi.get(self, "provenance")

    @provenance.setter
    def provenance(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']]):
        pulumi.set(self, "provenance", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentPageSymbolArgs:
    def __init__(__self__, *,
                 detected_languages: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]] = None,
                 layout: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']] = None):
        """
        A detected symbol.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]] detected_languages: A list of detected languages together with confidence.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs'] layout: Layout for Symbol.
        """
        if detected_languages is not None:
            pulumi.set(__self__, "detected_languages", detected_languages)
        if layout is not None:
            pulumi.set(__self__, "layout", layout)

    @property
    @pulumi.getter(name="detectedLanguages")
    def detected_languages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]]:
        """
        A list of detected languages together with confidence.
        """
        return pulumi.get(self, "detected_languages")

    @detected_languages.setter
    def detected_languages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]]):
        pulumi.set(self, "detected_languages", value)

    @property
    @pulumi.getter
    def layout(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']]:
        """
        Layout for Symbol.
        """
        return pulumi.get(self, "layout")

    @layout.setter
    def layout(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']]):
        pulumi.set(self, "layout", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentPageTableTableCellArgs:
    def __init__(__self__, *,
                 col_span: Optional[pulumi.Input[int]] = None,
                 detected_languages: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]] = None,
                 layout: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']] = None,
                 row_span: Optional[pulumi.Input[int]] = None):
        """
        A cell representation inside the table.
        :param pulumi.Input[int] col_span: How many columns this cell spans.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]] detected_languages: A list of detected languages together with confidence.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs'] layout: Layout for TableCell.
        :param pulumi.Input[int] row_span: How many rows this cell spans.
        """
        if col_span is not None:
            pulumi.set(__self__, "col_span", col_span)
        if detected_languages is not None:
            pulumi.set(__self__, "detected_languages", detected_languages)
        if layout is not None:
            pulumi.set(__self__, "layout", layout)
        if row_span is not None:
            pulumi.set(__self__, "row_span", row_span)

    @property
    @pulumi.getter(name="colSpan")
    def col_span(self) -> Optional[pulumi.Input[int]]:
        """
        How many columns this cell spans.
        """
        return pulumi.get(self, "col_span")

    @col_span.setter
    def col_span(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "col_span", value)

    @property
    @pulumi.getter(name="detectedLanguages")
    def detected_languages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]]:
        """
        A list of detected languages together with confidence.
        """
        return pulumi.get(self, "detected_languages")

    @detected_languages.setter
    def detected_languages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]]):
        pulumi.set(self, "detected_languages", value)

    @property
    @pulumi.getter
    def layout(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']]:
        """
        Layout for TableCell.
        """
        return pulumi.get(self, "layout")

    @layout.setter
    def layout(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']]):
        pulumi.set(self, "layout", value)

    @property
    @pulumi.getter(name="rowSpan")
    def row_span(self) -> Optional[pulumi.Input[int]]:
        """
        How many rows this cell spans.
        """
        return pulumi.get(self, "row_span")

    @row_span.setter
    def row_span(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "row_span", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentPageTableTableRowArgs:
    def __init__(__self__, *,
                 cells: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTableTableCellArgs']]]] = None):
        """
        A row of table cells.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTableTableCellArgs']]] cells: Cells that make up this row.
        """
        if cells is not None:
            pulumi.set(__self__, "cells", cells)

    @property
    @pulumi.getter
    def cells(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTableTableCellArgs']]]]:
        """
        Cells that make up this row.
        """
        return pulumi.get(self, "cells")

    @cells.setter
    def cells(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTableTableCellArgs']]]]):
        pulumi.set(self, "cells", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentPageTableArgs:
    def __init__(__self__, *,
                 body_rows: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTableTableRowArgs']]]] = None,
                 detected_languages: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]] = None,
                 header_rows: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTableTableRowArgs']]]] = None,
                 layout: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']] = None,
                 provenance: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']] = None):
        """
        A table representation similar to HTML table structure.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTableTableRowArgs']]] body_rows: Body rows of the table.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]] detected_languages: A list of detected languages together with confidence.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTableTableRowArgs']]] header_rows: Header rows of the table.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs'] layout: Layout for Table.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs'] provenance: The history of this table.
        """
        if body_rows is not None:
            pulumi.set(__self__, "body_rows", body_rows)
        if detected_languages is not None:
            pulumi.set(__self__, "detected_languages", detected_languages)
        if header_rows is not None:
            pulumi.set(__self__, "header_rows", header_rows)
        if layout is not None:
            pulumi.set(__self__, "layout", layout)
        if provenance is not None:
            pulumi.set(__self__, "provenance", provenance)

    @property
    @pulumi.getter(name="bodyRows")
    def body_rows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTableTableRowArgs']]]]:
        """
        Body rows of the table.
        """
        return pulumi.get(self, "body_rows")

    @body_rows.setter
    def body_rows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTableTableRowArgs']]]]):
        pulumi.set(self, "body_rows", value)

    @property
    @pulumi.getter(name="detectedLanguages")
    def detected_languages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]]:
        """
        A list of detected languages together with confidence.
        """
        return pulumi.get(self, "detected_languages")

    @detected_languages.setter
    def detected_languages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]]):
        pulumi.set(self, "detected_languages", value)

    @property
    @pulumi.getter(name="headerRows")
    def header_rows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTableTableRowArgs']]]]:
        """
        Header rows of the table.
        """
        return pulumi.get(self, "header_rows")

    @header_rows.setter
    def header_rows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTableTableRowArgs']]]]):
        pulumi.set(self, "header_rows", value)

    @property
    @pulumi.getter
    def layout(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']]:
        """
        Layout for Table.
        """
        return pulumi.get(self, "layout")

    @layout.setter
    def layout(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']]):
        pulumi.set(self, "layout", value)

    @property
    @pulumi.getter
    def provenance(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']]:
        """
        The history of this table.
        """
        return pulumi.get(self, "provenance")

    @provenance.setter
    def provenance(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']]):
        pulumi.set(self, "provenance", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentPageTokenDetectedBreakArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTokenDetectedBreakType']] = None):
        """
        Detected break at the end of a Token.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTokenDetectedBreakType'] type: Detected break type.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTokenDetectedBreakType']]:
        """
        Detected break type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTokenDetectedBreakType']]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentPageTokenStyleInfoArgs:
    def __init__(__self__, *,
                 background_color: Optional[pulumi.Input['GoogleTypeColorArgs']] = None,
                 bold: Optional[pulumi.Input[bool]] = None,
                 font_size: Optional[pulumi.Input[int]] = None,
                 font_type: Optional[pulumi.Input[str]] = None,
                 font_weight: Optional[pulumi.Input[int]] = None,
                 handwritten: Optional[pulumi.Input[bool]] = None,
                 italic: Optional[pulumi.Input[bool]] = None,
                 letter_spacing: Optional[pulumi.Input[float]] = None,
                 pixel_font_size: Optional[pulumi.Input[float]] = None,
                 smallcaps: Optional[pulumi.Input[bool]] = None,
                 strikeout: Optional[pulumi.Input[bool]] = None,
                 subscript: Optional[pulumi.Input[bool]] = None,
                 superscript: Optional[pulumi.Input[bool]] = None,
                 text_color: Optional[pulumi.Input['GoogleTypeColorArgs']] = None,
                 underlined: Optional[pulumi.Input[bool]] = None):
        """
        Font and other text style attributes.
        :param pulumi.Input['GoogleTypeColorArgs'] background_color: Color of the background.
        :param pulumi.Input[bool] bold: Whether the text is bold (equivalent to font_weight is at least `700`).
        :param pulumi.Input[int] font_size: Font size in points (`1` point is `` inches).
        :param pulumi.Input[str] font_type: Name or style of the font.
        :param pulumi.Input[int] font_weight: TrueType weight on a scale `100` (thin) to `1000` (ultra-heavy). Normal is `400`, bold is `700`.
        :param pulumi.Input[bool] handwritten: Whether the text is handwritten.
        :param pulumi.Input[bool] italic: Whether the text is italic.
        :param pulumi.Input[float] letter_spacing: Letter spacing in points.
        :param pulumi.Input[float] pixel_font_size: Font size in pixels, equal to _unrounded font_size_ * _resolution_  `72.0`.
        :param pulumi.Input[bool] smallcaps: Whether the text is in small caps.
        :param pulumi.Input[bool] strikeout: Whether the text is strikethrough.
        :param pulumi.Input[bool] subscript: Whether the text is a subscript.
        :param pulumi.Input[bool] superscript: Whether the text is a superscript.
        :param pulumi.Input['GoogleTypeColorArgs'] text_color: Color of the text.
        :param pulumi.Input[bool] underlined: Whether the text is underlined.
        """
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if bold is not None:
            pulumi.set(__self__, "bold", bold)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if font_type is not None:
            pulumi.set(__self__, "font_type", font_type)
        if font_weight is not None:
            pulumi.set(__self__, "font_weight", font_weight)
        if handwritten is not None:
            pulumi.set(__self__, "handwritten", handwritten)
        if italic is not None:
            pulumi.set(__self__, "italic", italic)
        if letter_spacing is not None:
            pulumi.set(__self__, "letter_spacing", letter_spacing)
        if pixel_font_size is not None:
            pulumi.set(__self__, "pixel_font_size", pixel_font_size)
        if smallcaps is not None:
            pulumi.set(__self__, "smallcaps", smallcaps)
        if strikeout is not None:
            pulumi.set(__self__, "strikeout", strikeout)
        if subscript is not None:
            pulumi.set(__self__, "subscript", subscript)
        if superscript is not None:
            pulumi.set(__self__, "superscript", superscript)
        if text_color is not None:
            pulumi.set(__self__, "text_color", text_color)
        if underlined is not None:
            pulumi.set(__self__, "underlined", underlined)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[pulumi.Input['GoogleTypeColorArgs']]:
        """
        Color of the background.
        """
        return pulumi.get(self, "background_color")

    @background_color.setter
    def background_color(self, value: Optional[pulumi.Input['GoogleTypeColorArgs']]):
        pulumi.set(self, "background_color", value)

    @property
    @pulumi.getter
    def bold(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the text is bold (equivalent to font_weight is at least `700`).
        """
        return pulumi.get(self, "bold")

    @bold.setter
    def bold(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bold", value)

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[pulumi.Input[int]]:
        """
        Font size in points (`1` point is `` inches).
        """
        return pulumi.get(self, "font_size")

    @font_size.setter
    def font_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "font_size", value)

    @property
    @pulumi.getter(name="fontType")
    def font_type(self) -> Optional[pulumi.Input[str]]:
        """
        Name or style of the font.
        """
        return pulumi.get(self, "font_type")

    @font_type.setter
    def font_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "font_type", value)

    @property
    @pulumi.getter(name="fontWeight")
    def font_weight(self) -> Optional[pulumi.Input[int]]:
        """
        TrueType weight on a scale `100` (thin) to `1000` (ultra-heavy). Normal is `400`, bold is `700`.
        """
        return pulumi.get(self, "font_weight")

    @font_weight.setter
    def font_weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "font_weight", value)

    @property
    @pulumi.getter
    def handwritten(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the text is handwritten.
        """
        return pulumi.get(self, "handwritten")

    @handwritten.setter
    def handwritten(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "handwritten", value)

    @property
    @pulumi.getter
    def italic(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the text is italic.
        """
        return pulumi.get(self, "italic")

    @italic.setter
    def italic(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "italic", value)

    @property
    @pulumi.getter(name="letterSpacing")
    def letter_spacing(self) -> Optional[pulumi.Input[float]]:
        """
        Letter spacing in points.
        """
        return pulumi.get(self, "letter_spacing")

    @letter_spacing.setter
    def letter_spacing(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "letter_spacing", value)

    @property
    @pulumi.getter(name="pixelFontSize")
    def pixel_font_size(self) -> Optional[pulumi.Input[float]]:
        """
        Font size in pixels, equal to _unrounded font_size_ * _resolution_  `72.0`.
        """
        return pulumi.get(self, "pixel_font_size")

    @pixel_font_size.setter
    def pixel_font_size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "pixel_font_size", value)

    @property
    @pulumi.getter
    def smallcaps(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the text is in small caps.
        """
        return pulumi.get(self, "smallcaps")

    @smallcaps.setter
    def smallcaps(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "smallcaps", value)

    @property
    @pulumi.getter
    def strikeout(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the text is strikethrough.
        """
        return pulumi.get(self, "strikeout")

    @strikeout.setter
    def strikeout(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strikeout", value)

    @property
    @pulumi.getter
    def subscript(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the text is a subscript.
        """
        return pulumi.get(self, "subscript")

    @subscript.setter
    def subscript(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "subscript", value)

    @property
    @pulumi.getter
    def superscript(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the text is a superscript.
        """
        return pulumi.get(self, "superscript")

    @superscript.setter
    def superscript(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "superscript", value)

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional[pulumi.Input['GoogleTypeColorArgs']]:
        """
        Color of the text.
        """
        return pulumi.get(self, "text_color")

    @text_color.setter
    def text_color(self, value: Optional[pulumi.Input['GoogleTypeColorArgs']]):
        pulumi.set(self, "text_color", value)

    @property
    @pulumi.getter
    def underlined(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the text is underlined.
        """
        return pulumi.get(self, "underlined")

    @underlined.setter
    def underlined(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "underlined", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentPageTokenArgs:
    def __init__(__self__, *,
                 detected_break: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTokenDetectedBreakArgs']] = None,
                 detected_languages: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]] = None,
                 layout: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']] = None,
                 provenance: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']] = None,
                 style_info: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTokenStyleInfoArgs']] = None):
        """
        A detected token.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTokenDetectedBreakArgs'] detected_break: Detected break at the end of a Token.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]] detected_languages: A list of detected languages together with confidence.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs'] layout: Layout for Token.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs'] provenance: The history of this annotation.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTokenStyleInfoArgs'] style_info: Text style attributes.
        """
        if detected_break is not None:
            pulumi.set(__self__, "detected_break", detected_break)
        if detected_languages is not None:
            pulumi.set(__self__, "detected_languages", detected_languages)
        if layout is not None:
            pulumi.set(__self__, "layout", layout)
        if provenance is not None:
            pulumi.set(__self__, "provenance", provenance)
        if style_info is not None:
            pulumi.set(__self__, "style_info", style_info)

    @property
    @pulumi.getter(name="detectedBreak")
    def detected_break(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTokenDetectedBreakArgs']]:
        """
        Detected break at the end of a Token.
        """
        return pulumi.get(self, "detected_break")

    @detected_break.setter
    def detected_break(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTokenDetectedBreakArgs']]):
        pulumi.set(self, "detected_break", value)

    @property
    @pulumi.getter(name="detectedLanguages")
    def detected_languages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]]:
        """
        A list of detected languages together with confidence.
        """
        return pulumi.get(self, "detected_languages")

    @detected_languages.setter
    def detected_languages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]]):
        pulumi.set(self, "detected_languages", value)

    @property
    @pulumi.getter
    def layout(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']]:
        """
        Layout for Token.
        """
        return pulumi.get(self, "layout")

    @layout.setter
    def layout(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']]):
        pulumi.set(self, "layout", value)

    @property
    @pulumi.getter
    def provenance(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']]:
        """
        The history of this annotation.
        """
        return pulumi.get(self, "provenance")

    @provenance.setter
    def provenance(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']]):
        pulumi.set(self, "provenance", value)

    @property
    @pulumi.getter(name="styleInfo")
    def style_info(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTokenStyleInfoArgs']]:
        """
        Text style attributes.
        """
        return pulumi.get(self, "style_info")

    @style_info.setter
    def style_info(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTokenStyleInfoArgs']]):
        pulumi.set(self, "style_info", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentPageVisualElementArgs:
    def __init__(__self__, *,
                 detected_languages: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]] = None,
                 layout: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        Detected non-text visual elements e.g. checkbox, signature etc. on the page.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]] detected_languages: A list of detected languages together with confidence.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs'] layout: Layout for VisualElement.
        :param pulumi.Input[str] type: Type of the VisualElement.
        """
        if detected_languages is not None:
            pulumi.set(__self__, "detected_languages", detected_languages)
        if layout is not None:
            pulumi.set(__self__, "layout", layout)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="detectedLanguages")
    def detected_languages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]]:
        """
        A list of detected languages together with confidence.
        """
        return pulumi.get(self, "detected_languages")

    @detected_languages.setter
    def detected_languages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]]):
        pulumi.set(self, "detected_languages", value)

    @property
    @pulumi.getter
    def layout(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']]:
        """
        Layout for VisualElement.
        """
        return pulumi.get(self, "layout")

    @layout.setter
    def layout(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']]):
        pulumi.set(self, "layout", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the VisualElement.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentPageArgs:
    def __init__(__self__, *,
                 blocks: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageBlockArgs']]]] = None,
                 detected_barcodes: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedBarcodeArgs']]]] = None,
                 detected_languages: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]] = None,
                 dimension: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDimensionArgs']] = None,
                 form_fields: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageFormFieldArgs']]]] = None,
                 image: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageImageArgs']] = None,
                 image_quality_scores: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageImageQualityScoresArgs']] = None,
                 layout: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']] = None,
                 lines: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLineArgs']]]] = None,
                 page_number: Optional[pulumi.Input[int]] = None,
                 paragraphs: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageParagraphArgs']]]] = None,
                 provenance: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']] = None,
                 symbols: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageSymbolArgs']]]] = None,
                 tables: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTableArgs']]]] = None,
                 tokens: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTokenArgs']]]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageMatrixArgs']]]] = None,
                 visual_elements: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageVisualElementArgs']]]] = None):
        """
        A page in a Document.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageBlockArgs']]] blocks: A list of visually detected text blocks on the page. A block has a set of lines (collected into paragraphs) that have a common line-spacing and orientation.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedBarcodeArgs']]] detected_barcodes: A list of detected barcodes.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]] detected_languages: A list of detected languages together with confidence.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDimensionArgs'] dimension: Physical dimension of the page.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageFormFieldArgs']]] form_fields: A list of visually detected form fields on the page.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentPageImageArgs'] image: Rendered image for this page. This image is preprocessed to remove any skew, rotation, and distortions such that the annotation bounding boxes can be upright and axis-aligned.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentPageImageQualityScoresArgs'] image_quality_scores: Image quality scores.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs'] layout: Layout for the page.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLineArgs']]] lines: A list of visually detected text lines on the page. A collection of tokens that a human would perceive as a line.
        :param pulumi.Input[int] page_number: 1-based index for current Page in a parent Document. Useful when a page is taken out of a Document for individual processing.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageParagraphArgs']]] paragraphs: A list of visually detected text paragraphs on the page. A collection of lines that a human would perceive as a paragraph.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs'] provenance: The history of this page.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageSymbolArgs']]] symbols: A list of visually detected symbols on the page.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTableArgs']]] tables: A list of visually detected tables on the page.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTokenArgs']]] tokens: A list of visually detected tokens on the page.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageMatrixArgs']]] transforms: Transformation matrices that were applied to the original document image to produce Page.image.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageVisualElementArgs']]] visual_elements: A list of detected non-text visual elements e.g. checkbox, signature etc. on the page.
        """
        if blocks is not None:
            pulumi.set(__self__, "blocks", blocks)
        if detected_barcodes is not None:
            pulumi.set(__self__, "detected_barcodes", detected_barcodes)
        if detected_languages is not None:
            pulumi.set(__self__, "detected_languages", detected_languages)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if form_fields is not None:
            pulumi.set(__self__, "form_fields", form_fields)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if image_quality_scores is not None:
            pulumi.set(__self__, "image_quality_scores", image_quality_scores)
        if layout is not None:
            pulumi.set(__self__, "layout", layout)
        if lines is not None:
            pulumi.set(__self__, "lines", lines)
        if page_number is not None:
            pulumi.set(__self__, "page_number", page_number)
        if paragraphs is not None:
            pulumi.set(__self__, "paragraphs", paragraphs)
        if provenance is not None:
            pulumi.set(__self__, "provenance", provenance)
        if symbols is not None:
            pulumi.set(__self__, "symbols", symbols)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)
        if tokens is not None:
            pulumi.set(__self__, "tokens", tokens)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)
        if visual_elements is not None:
            pulumi.set(__self__, "visual_elements", visual_elements)

    @property
    @pulumi.getter
    def blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageBlockArgs']]]]:
        """
        A list of visually detected text blocks on the page. A block has a set of lines (collected into paragraphs) that have a common line-spacing and orientation.
        """
        return pulumi.get(self, "blocks")

    @blocks.setter
    def blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageBlockArgs']]]]):
        pulumi.set(self, "blocks", value)

    @property
    @pulumi.getter(name="detectedBarcodes")
    def detected_barcodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedBarcodeArgs']]]]:
        """
        A list of detected barcodes.
        """
        return pulumi.get(self, "detected_barcodes")

    @detected_barcodes.setter
    def detected_barcodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedBarcodeArgs']]]]):
        pulumi.set(self, "detected_barcodes", value)

    @property
    @pulumi.getter(name="detectedLanguages")
    def detected_languages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]]:
        """
        A list of detected languages together with confidence.
        """
        return pulumi.get(self, "detected_languages")

    @detected_languages.setter
    def detected_languages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDetectedLanguageArgs']]]]):
        pulumi.set(self, "detected_languages", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDimensionArgs']]:
        """
        Physical dimension of the page.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageDimensionArgs']]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter(name="formFields")
    def form_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageFormFieldArgs']]]]:
        """
        A list of visually detected form fields on the page.
        """
        return pulumi.get(self, "form_fields")

    @form_fields.setter
    def form_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageFormFieldArgs']]]]):
        pulumi.set(self, "form_fields", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageImageArgs']]:
        """
        Rendered image for this page. This image is preprocessed to remove any skew, rotation, and distortions such that the annotation bounding boxes can be upright and axis-aligned.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageImageArgs']]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="imageQualityScores")
    def image_quality_scores(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageImageQualityScoresArgs']]:
        """
        Image quality scores.
        """
        return pulumi.get(self, "image_quality_scores")

    @image_quality_scores.setter
    def image_quality_scores(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageImageQualityScoresArgs']]):
        pulumi.set(self, "image_quality_scores", value)

    @property
    @pulumi.getter
    def layout(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']]:
        """
        Layout for the page.
        """
        return pulumi.get(self, "layout")

    @layout.setter
    def layout(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLayoutArgs']]):
        pulumi.set(self, "layout", value)

    @property
    @pulumi.getter
    def lines(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLineArgs']]]]:
        """
        A list of visually detected text lines on the page. A collection of tokens that a human would perceive as a line.
        """
        return pulumi.get(self, "lines")

    @lines.setter
    def lines(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageLineArgs']]]]):
        pulumi.set(self, "lines", value)

    @property
    @pulumi.getter(name="pageNumber")
    def page_number(self) -> Optional[pulumi.Input[int]]:
        """
        1-based index for current Page in a parent Document. Useful when a page is taken out of a Document for individual processing.
        """
        return pulumi.get(self, "page_number")

    @page_number.setter
    def page_number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "page_number", value)

    @property
    @pulumi.getter
    def paragraphs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageParagraphArgs']]]]:
        """
        A list of visually detected text paragraphs on the page. A collection of lines that a human would perceive as a paragraph.
        """
        return pulumi.get(self, "paragraphs")

    @paragraphs.setter
    def paragraphs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageParagraphArgs']]]]):
        pulumi.set(self, "paragraphs", value)

    @property
    @pulumi.getter
    def provenance(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']]:
        """
        The history of this page.
        """
        return pulumi.get(self, "provenance")

    @provenance.setter
    def provenance(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']]):
        pulumi.set(self, "provenance", value)

    @property
    @pulumi.getter
    def symbols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageSymbolArgs']]]]:
        """
        A list of visually detected symbols on the page.
        """
        return pulumi.get(self, "symbols")

    @symbols.setter
    def symbols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageSymbolArgs']]]]):
        pulumi.set(self, "symbols", value)

    @property
    @pulumi.getter
    def tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTableArgs']]]]:
        """
        A list of visually detected tables on the page.
        """
        return pulumi.get(self, "tables")

    @tables.setter
    def tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTableArgs']]]]):
        pulumi.set(self, "tables", value)

    @property
    @pulumi.getter
    def tokens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTokenArgs']]]]:
        """
        A list of visually detected tokens on the page.
        """
        return pulumi.get(self, "tokens")

    @tokens.setter
    def tokens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageTokenArgs']]]]):
        pulumi.set(self, "tokens", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageMatrixArgs']]]]:
        """
        Transformation matrices that were applied to the original document image to produce Page.image.
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageMatrixArgs']]]]):
        pulumi.set(self, "transforms", value)

    @property
    @pulumi.getter(name="visualElements")
    def visual_elements(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageVisualElementArgs']]]]:
        """
        A list of detected non-text visual elements e.g. checkbox, signature etc. on the page.
        """
        return pulumi.get(self, "visual_elements")

    @visual_elements.setter
    def visual_elements(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageVisualElementArgs']]]]):
        pulumi.set(self, "visual_elements", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentProvenanceParentArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[int]] = None,
                 index: Optional[pulumi.Input[int]] = None,
                 revision: Optional[pulumi.Input[int]] = None):
        """
        The parent element the current element is based on. Used for referencing/aligning, removal and replacement operations.
        :param pulumi.Input[int] id: The id of the parent provenance.
        :param pulumi.Input[int] index: The index of the parent item in the corresponding item list (eg. list of entities, properties within entities, etc.) in the parent revision.
        :param pulumi.Input[int] revision: The index of the index into current revision's parent_ids list.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if revision is not None:
            pulumi.set(__self__, "revision", revision)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        The id of the parent provenance.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        """
        The index of the parent item in the corresponding item list (eg. list of entities, properties within entities, etc.) in the parent revision.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter
    def revision(self) -> Optional[pulumi.Input[int]]:
        """
        The index of the index into current revision's parent_ids list.
        """
        return pulumi.get(self, "revision")

    @revision.setter
    def revision(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "revision", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentProvenanceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[int]] = None,
                 parents: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceParentArgs']]]] = None,
                 revision: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceType']] = None):
        """
        Structure to identify provenance relationships between annotations in different revisions.
        :param pulumi.Input[int] id: The Id of this operation. Needs to be unique within the scope of the revision.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceParentArgs']]] parents: References to the original elements that are replaced.
        :param pulumi.Input[int] revision: The index of the revision that produced this element.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceType'] type: The type of provenance operation.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if parents is not None:
            pulumi.set(__self__, "parents", parents)
        if revision is not None:
            pulumi.set(__self__, "revision", revision)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        The Id of this operation. Needs to be unique within the scope of the revision.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def parents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceParentArgs']]]]:
        """
        References to the original elements that are replaced.
        """
        return pulumi.get(self, "parents")

    @parents.setter
    def parents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceParentArgs']]]]):
        pulumi.set(self, "parents", value)

    @property
    @pulumi.getter
    def revision(self) -> Optional[pulumi.Input[int]]:
        """
        The index of the revision that produced this element.
        """
        return pulumi.get(self, "revision")

    @revision.setter
    def revision(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "revision", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceType']]:
        """
        The type of provenance operation.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceType']]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentRevisionHumanReviewArgs:
    def __init__(__self__, *,
                 state: Optional[pulumi.Input[str]] = None,
                 state_message: Optional[pulumi.Input[str]] = None):
        """
        Human Review information of the document.
        :param pulumi.Input[str] state: Human review state. e.g. `requested`, `succeeded`, `rejected`.
        :param pulumi.Input[str] state_message: A message providing more details about the current state of processing. For example, the rejection reason when the state is `rejected`.
        """
        if state is not None:
            pulumi.set(__self__, "state", state)
        if state_message is not None:
            pulumi.set(__self__, "state_message", state_message)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        Human review state. e.g. `requested`, `succeeded`, `rejected`.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="stateMessage")
    def state_message(self) -> Optional[pulumi.Input[str]]:
        """
        A message providing more details about the current state of processing. For example, the rejection reason when the state is `rejected`.
        """
        return pulumi.get(self, "state_message")

    @state_message.setter
    def state_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state_message", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentRevisionArgs:
    def __init__(__self__, *,
                 agent: Optional[pulumi.Input[str]] = None,
                 create_time: Optional[pulumi.Input[str]] = None,
                 human_review: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentRevisionHumanReviewArgs']] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 parent: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 parent_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 processor: Optional[pulumi.Input[str]] = None):
        """
        Contains past or forward revisions of this document.
        :param pulumi.Input[str] agent: If the change was made by a person specify the name or id of that person.
        :param pulumi.Input[str] create_time: The time that the revision was created, internally generated by doc proto storage at the time of create.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentRevisionHumanReviewArgs'] human_review: Human Review information of this revision.
        :param pulumi.Input[str] id: Id of the revision, internally generated by doc proto storage. Unique within the context of the document.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] parent: The revisions that this revision is based on. This can include one or more parent (when documents are merged.) This field represents the index into the `revisions` field.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] parent_ids: The revisions that this revision is based on. Must include all the ids that have anything to do with this revision - eg. there are `provenance.parent.revision` fields that index into this field.
        :param pulumi.Input[str] processor: If the annotation was made by processor identify the processor by its resource name.
        """
        if agent is not None:
            pulumi.set(__self__, "agent", agent)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if human_review is not None:
            pulumi.set(__self__, "human_review", human_review)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if parent is not None:
            pulumi.set(__self__, "parent", parent)
        if parent_ids is not None:
            pulumi.set(__self__, "parent_ids", parent_ids)
        if processor is not None:
            pulumi.set(__self__, "processor", processor)

    @property
    @pulumi.getter
    def agent(self) -> Optional[pulumi.Input[str]]:
        """
        If the change was made by a person specify the name or id of that person.
        """
        return pulumi.get(self, "agent")

    @agent.setter
    def agent(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "agent", value)

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time that the revision was created, internally generated by doc proto storage at the time of create.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create_time", value)

    @property
    @pulumi.getter(name="humanReview")
    def human_review(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentRevisionHumanReviewArgs']]:
        """
        Human Review information of this revision.
        """
        return pulumi.get(self, "human_review")

    @human_review.setter
    def human_review(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentRevisionHumanReviewArgs']]):
        pulumi.set(self, "human_review", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Id of the revision, internally generated by doc proto storage. Unique within the context of the document.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def parent(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The revisions that this revision is based on. This can include one or more parent (when documents are merged.) This field represents the index into the `revisions` field.
        """
        return pulumi.get(self, "parent")

    @parent.setter
    def parent(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "parent", value)

    @property
    @pulumi.getter(name="parentIds")
    def parent_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The revisions that this revision is based on. Must include all the ids that have anything to do with this revision - eg. there are `provenance.parent.revision` fields that index into this field.
        """
        return pulumi.get(self, "parent_ids")

    @parent_ids.setter
    def parent_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "parent_ids", value)

    @property
    @pulumi.getter
    def processor(self) -> Optional[pulumi.Input[str]]:
        """
        If the annotation was made by processor identify the processor by its resource name.
        """
        return pulumi.get(self, "processor")

    @processor.setter
    def processor(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "processor", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentShardInfoArgs:
    def __init__(__self__, *,
                 shard_count: Optional[pulumi.Input[str]] = None,
                 shard_index: Optional[pulumi.Input[str]] = None,
                 text_offset: Optional[pulumi.Input[str]] = None):
        """
        For a large document, sharding may be performed to produce several document shards. Each document shard contains this field to detail which shard it is.
        :param pulumi.Input[str] shard_count: Total number of shards.
        :param pulumi.Input[str] shard_index: The 0-based index of this shard.
        :param pulumi.Input[str] text_offset: The index of the first character in Document.text in the overall document global text.
        """
        if shard_count is not None:
            pulumi.set(__self__, "shard_count", shard_count)
        if shard_index is not None:
            pulumi.set(__self__, "shard_index", shard_index)
        if text_offset is not None:
            pulumi.set(__self__, "text_offset", text_offset)

    @property
    @pulumi.getter(name="shardCount")
    def shard_count(self) -> Optional[pulumi.Input[str]]:
        """
        Total number of shards.
        """
        return pulumi.get(self, "shard_count")

    @shard_count.setter
    def shard_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shard_count", value)

    @property
    @pulumi.getter(name="shardIndex")
    def shard_index(self) -> Optional[pulumi.Input[str]]:
        """
        The 0-based index of this shard.
        """
        return pulumi.get(self, "shard_index")

    @shard_index.setter
    def shard_index(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shard_index", value)

    @property
    @pulumi.getter(name="textOffset")
    def text_offset(self) -> Optional[pulumi.Input[str]]:
        """
        The index of the first character in Document.text in the overall document global text.
        """
        return pulumi.get(self, "text_offset")

    @text_offset.setter
    def text_offset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_offset", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentStyleFontSizeArgs:
    def __init__(__self__, *,
                 size: Optional[pulumi.Input[float]] = None,
                 unit: Optional[pulumi.Input[str]] = None):
        """
        Font size with unit.
        :param pulumi.Input[float] size: Font size for the text.
        :param pulumi.Input[str] unit: Unit for the font size. Follows CSS naming (such as `in`, `px`, and `pt`).
        """
        if size is not None:
            pulumi.set(__self__, "size", size)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[float]]:
        """
        Font size for the text.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[str]]:
        """
        Unit for the font size. Follows CSS naming (such as `in`, `px`, and `pt`).
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unit", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentStyleArgs:
    def __init__(__self__, *,
                 background_color: Optional[pulumi.Input['GoogleTypeColorArgs']] = None,
                 color: Optional[pulumi.Input['GoogleTypeColorArgs']] = None,
                 font_family: Optional[pulumi.Input[str]] = None,
                 font_size: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentStyleFontSizeArgs']] = None,
                 font_weight: Optional[pulumi.Input[str]] = None,
                 text_anchor: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentTextAnchorArgs']] = None,
                 text_decoration: Optional[pulumi.Input[str]] = None,
                 text_style: Optional[pulumi.Input[str]] = None):
        """
        Annotation for common text style attributes. This adheres to CSS conventions as much as possible.
        :param pulumi.Input['GoogleTypeColorArgs'] background_color: Text background color.
        :param pulumi.Input['GoogleTypeColorArgs'] color: Text color.
        :param pulumi.Input[str] font_family: Font family such as `Arial`, `Times New Roman`. https://www.w3schools.com/cssref/pr_font_font-family.asp
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentStyleFontSizeArgs'] font_size: Font size.
        :param pulumi.Input[str] font_weight: [Font weight](https://www.w3schools.com/cssref/pr_font_weight.asp). Possible values are `normal`, `bold`, `bolder`, and `lighter`.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentTextAnchorArgs'] text_anchor: Text anchor indexing into the Document.text.
        :param pulumi.Input[str] text_decoration: [Text decoration](https://www.w3schools.com/cssref/pr_text_text-decoration.asp). Follows CSS standard. 
        :param pulumi.Input[str] text_style: [Text style](https://www.w3schools.com/cssref/pr_font_font-style.asp). Possible values are `normal`, `italic`, and `oblique`.
        """
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if font_family is not None:
            pulumi.set(__self__, "font_family", font_family)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if font_weight is not None:
            pulumi.set(__self__, "font_weight", font_weight)
        if text_anchor is not None:
            pulumi.set(__self__, "text_anchor", text_anchor)
        if text_decoration is not None:
            pulumi.set(__self__, "text_decoration", text_decoration)
        if text_style is not None:
            pulumi.set(__self__, "text_style", text_style)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[pulumi.Input['GoogleTypeColorArgs']]:
        """
        Text background color.
        """
        return pulumi.get(self, "background_color")

    @background_color.setter
    def background_color(self, value: Optional[pulumi.Input['GoogleTypeColorArgs']]):
        pulumi.set(self, "background_color", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input['GoogleTypeColorArgs']]:
        """
        Text color.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input['GoogleTypeColorArgs']]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="fontFamily")
    def font_family(self) -> Optional[pulumi.Input[str]]:
        """
        Font family such as `Arial`, `Times New Roman`. https://www.w3schools.com/cssref/pr_font_font-family.asp
        """
        return pulumi.get(self, "font_family")

    @font_family.setter
    def font_family(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "font_family", value)

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentStyleFontSizeArgs']]:
        """
        Font size.
        """
        return pulumi.get(self, "font_size")

    @font_size.setter
    def font_size(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentStyleFontSizeArgs']]):
        pulumi.set(self, "font_size", value)

    @property
    @pulumi.getter(name="fontWeight")
    def font_weight(self) -> Optional[pulumi.Input[str]]:
        """
        [Font weight](https://www.w3schools.com/cssref/pr_font_weight.asp). Possible values are `normal`, `bold`, `bolder`, and `lighter`.
        """
        return pulumi.get(self, "font_weight")

    @font_weight.setter
    def font_weight(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "font_weight", value)

    @property
    @pulumi.getter(name="textAnchor")
    def text_anchor(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentTextAnchorArgs']]:
        """
        Text anchor indexing into the Document.text.
        """
        return pulumi.get(self, "text_anchor")

    @text_anchor.setter
    def text_anchor(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentTextAnchorArgs']]):
        pulumi.set(self, "text_anchor", value)

    @property
    @pulumi.getter(name="textDecoration")
    def text_decoration(self) -> Optional[pulumi.Input[str]]:
        """
        [Text decoration](https://www.w3schools.com/cssref/pr_text_text-decoration.asp). Follows CSS standard. 
        """
        return pulumi.get(self, "text_decoration")

    @text_decoration.setter
    def text_decoration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_decoration", value)

    @property
    @pulumi.getter(name="textStyle")
    def text_style(self) -> Optional[pulumi.Input[str]]:
        """
        [Text style](https://www.w3schools.com/cssref/pr_font_font-style.asp). Possible values are `normal`, `italic`, and `oblique`.
        """
        return pulumi.get(self, "text_style")

    @text_style.setter
    def text_style(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_style", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentTextAnchorTextSegmentArgs:
    def __init__(__self__, *,
                 end_index: Optional[pulumi.Input[str]] = None,
                 start_index: Optional[pulumi.Input[str]] = None):
        """
        A text segment in the Document.text. The indices may be out of bounds which indicate that the text extends into another document shard for large sharded documents. See ShardInfo.text_offset
        :param pulumi.Input[str] end_index: TextSegment half open end UTF-8 char index in the Document.text.
        :param pulumi.Input[str] start_index: TextSegment start UTF-8 char index in the Document.text.
        """
        if end_index is not None:
            pulumi.set(__self__, "end_index", end_index)
        if start_index is not None:
            pulumi.set(__self__, "start_index", start_index)

    @property
    @pulumi.getter(name="endIndex")
    def end_index(self) -> Optional[pulumi.Input[str]]:
        """
        TextSegment half open end UTF-8 char index in the Document.text.
        """
        return pulumi.get(self, "end_index")

    @end_index.setter
    def end_index(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_index", value)

    @property
    @pulumi.getter(name="startIndex")
    def start_index(self) -> Optional[pulumi.Input[str]]:
        """
        TextSegment start UTF-8 char index in the Document.text.
        """
        return pulumi.get(self, "start_index")

    @start_index.setter
    def start_index(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_index", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentTextAnchorArgs:
    def __init__(__self__, *,
                 content: Optional[pulumi.Input[str]] = None,
                 text_segments: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentTextAnchorTextSegmentArgs']]]] = None):
        """
        Text reference indexing into the Document.text.
        :param pulumi.Input[str] content: Contains the content of the text span so that users do not have to look it up in the text_segments. It is always populated for formFields.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentTextAnchorTextSegmentArgs']]] text_segments: The text segments from the Document.text.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if text_segments is not None:
            pulumi.set(__self__, "text_segments", text_segments)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        """
        Contains the content of the text span so that users do not have to look it up in the text_segments. It is always populated for formFields.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="textSegments")
    def text_segments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentTextAnchorTextSegmentArgs']]]]:
        """
        The text segments from the Document.text.
        """
        return pulumi.get(self, "text_segments")

    @text_segments.setter
    def text_segments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentTextAnchorTextSegmentArgs']]]]):
        pulumi.set(self, "text_segments", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentTextChangeArgs:
    def __init__(__self__, *,
                 changed_text: Optional[pulumi.Input[str]] = None,
                 provenance: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']]]] = None,
                 text_anchor: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentTextAnchorArgs']] = None):
        """
        This message is used for text changes aka. OCR corrections.
        :param pulumi.Input[str] changed_text: The text that replaces the text identified in the `text_anchor`.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']]] provenance: The history of this annotation.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentTextAnchorArgs'] text_anchor: Provenance of the correction. Text anchor indexing into the Document.text. There can only be a single `TextAnchor.text_segments` element. If the start and end index of the text segment are the same, the text change is inserted before that index.
        """
        if changed_text is not None:
            pulumi.set(__self__, "changed_text", changed_text)
        if provenance is not None:
            pulumi.set(__self__, "provenance", provenance)
        if text_anchor is not None:
            pulumi.set(__self__, "text_anchor", text_anchor)

    @property
    @pulumi.getter(name="changedText")
    def changed_text(self) -> Optional[pulumi.Input[str]]:
        """
        The text that replaces the text identified in the `text_anchor`.
        """
        return pulumi.get(self, "changed_text")

    @changed_text.setter
    def changed_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "changed_text", value)

    @property
    @pulumi.getter
    def provenance(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']]]]:
        """
        The history of this annotation.
        """
        return pulumi.get(self, "provenance")

    @provenance.setter
    def provenance(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentProvenanceArgs']]]]):
        pulumi.set(self, "provenance", value)

    @property
    @pulumi.getter(name="textAnchor")
    def text_anchor(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentTextAnchorArgs']]:
        """
        Provenance of the correction. Text anchor indexing into the Document.text. There can only be a single `TextAnchor.text_segments` element. If the start and end index of the text segment are the same, the text change is inserted before that index.
        """
        return pulumi.get(self, "text_anchor")

    @text_anchor.setter
    def text_anchor(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentTextAnchorArgs']]):
        pulumi.set(self, "text_anchor", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1DocumentArgs:
    def __init__(__self__, *,
                 content: Optional[pulumi.Input[str]] = None,
                 entities: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentEntityArgs']]]] = None,
                 entity_relations: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentEntityRelationArgs']]]] = None,
                 error: Optional[pulumi.Input['GoogleRpcStatusArgs']] = None,
                 mime_type: Optional[pulumi.Input[str]] = None,
                 pages: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageArgs']]]] = None,
                 revisions: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentRevisionArgs']]]] = None,
                 shard_info: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentShardInfoArgs']] = None,
                 text: Optional[pulumi.Input[str]] = None,
                 text_changes: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentTextChangeArgs']]]] = None,
                 text_styles: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentStyleArgs']]]] = None,
                 uri: Optional[pulumi.Input[str]] = None):
        """
        Document represents the canonical document resource in Document AI. It is an interchange format that provides insights into documents and allows for collaboration between users and Document AI to iterate and optimize for quality.
        :param pulumi.Input[str] content: Optional. Inline document content, represented as a stream of bytes. Note: As with all `bytes` fields, protobuffers use a pure binary representation, whereas JSON representations use base64.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentEntityArgs']]] entities: A list of entities detected on Document.text. For document shards, entities in this list may cross shard boundaries.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentEntityRelationArgs']]] entity_relations: Placeholder. Relationship among Document.entities.
        :param pulumi.Input['GoogleRpcStatusArgs'] error: Any error that occurred while processing this document.
        :param pulumi.Input[str] mime_type: An IANA published [media type (MIME type)](https://www.iana.org/assignments/media-types/media-types.xhtml).
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageArgs']]] pages: Visual page layout for the Document.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentRevisionArgs']]] revisions: Placeholder. Revision history of this document.
        :param pulumi.Input['GoogleCloudDocumentaiV1DocumentShardInfoArgs'] shard_info: Information about the sharding if this document is sharded part of a larger document. If the document is not sharded, this message is not specified.
        :param pulumi.Input[str] text: Optional. UTF-8 encoded text in reading order from the document.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentTextChangeArgs']]] text_changes: Placeholder. A list of text corrections made to Document.text. This is usually used for annotating corrections to OCR mistakes. Text changes for a given revision may not overlap with each other.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentStyleArgs']]] text_styles: Styles for the Document.text.
        :param pulumi.Input[str] uri: Optional. Currently supports Google Cloud Storage URI of the form `gs://bucket_name/object_name`. Object versioning is not supported. For more information, refer to [Google Cloud Storage Request URIs](https://cloud.google.com/storage/docs/reference-uris).
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if entities is not None:
            pulumi.set(__self__, "entities", entities)
        if entity_relations is not None:
            pulumi.set(__self__, "entity_relations", entity_relations)
        if error is not None:
            pulumi.set(__self__, "error", error)
        if mime_type is not None:
            pulumi.set(__self__, "mime_type", mime_type)
        if pages is not None:
            pulumi.set(__self__, "pages", pages)
        if revisions is not None:
            pulumi.set(__self__, "revisions", revisions)
        if shard_info is not None:
            pulumi.set(__self__, "shard_info", shard_info)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if text_changes is not None:
            pulumi.set(__self__, "text_changes", text_changes)
        if text_styles is not None:
            pulumi.set(__self__, "text_styles", text_styles)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Inline document content, represented as a stream of bytes. Note: As with all `bytes` fields, protobuffers use a pure binary representation, whereas JSON representations use base64.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def entities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentEntityArgs']]]]:
        """
        A list of entities detected on Document.text. For document shards, entities in this list may cross shard boundaries.
        """
        return pulumi.get(self, "entities")

    @entities.setter
    def entities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentEntityArgs']]]]):
        pulumi.set(self, "entities", value)

    @property
    @pulumi.getter(name="entityRelations")
    def entity_relations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentEntityRelationArgs']]]]:
        """
        Placeholder. Relationship among Document.entities.
        """
        return pulumi.get(self, "entity_relations")

    @entity_relations.setter
    def entity_relations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentEntityRelationArgs']]]]):
        pulumi.set(self, "entity_relations", value)

    @property
    @pulumi.getter
    def error(self) -> Optional[pulumi.Input['GoogleRpcStatusArgs']]:
        """
        Any error that occurred while processing this document.
        """
        return pulumi.get(self, "error")

    @error.setter
    def error(self, value: Optional[pulumi.Input['GoogleRpcStatusArgs']]):
        pulumi.set(self, "error", value)

    @property
    @pulumi.getter(name="mimeType")
    def mime_type(self) -> Optional[pulumi.Input[str]]:
        """
        An IANA published [media type (MIME type)](https://www.iana.org/assignments/media-types/media-types.xhtml).
        """
        return pulumi.get(self, "mime_type")

    @mime_type.setter
    def mime_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mime_type", value)

    @property
    @pulumi.getter
    def pages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageArgs']]]]:
        """
        Visual page layout for the Document.
        """
        return pulumi.get(self, "pages")

    @pages.setter
    def pages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentPageArgs']]]]):
        pulumi.set(self, "pages", value)

    @property
    @pulumi.getter
    def revisions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentRevisionArgs']]]]:
        """
        Placeholder. Revision history of this document.
        """
        return pulumi.get(self, "revisions")

    @revisions.setter
    def revisions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentRevisionArgs']]]]):
        pulumi.set(self, "revisions", value)

    @property
    @pulumi.getter(name="shardInfo")
    def shard_info(self) -> Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentShardInfoArgs']]:
        """
        Information about the sharding if this document is sharded part of a larger document. If the document is not sharded, this message is not specified.
        """
        return pulumi.get(self, "shard_info")

    @shard_info.setter
    def shard_info(self, value: Optional[pulumi.Input['GoogleCloudDocumentaiV1DocumentShardInfoArgs']]):
        pulumi.set(self, "shard_info", value)

    @property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. UTF-8 encoded text in reading order from the document.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text", value)

    @property
    @pulumi.getter(name="textChanges")
    def text_changes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentTextChangeArgs']]]]:
        """
        Placeholder. A list of text corrections made to Document.text. This is usually used for annotating corrections to OCR mistakes. Text changes for a given revision may not overlap with each other.
        """
        return pulumi.get(self, "text_changes")

    @text_changes.setter
    def text_changes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentTextChangeArgs']]]]):
        pulumi.set(self, "text_changes", value)

    @property
    @pulumi.getter(name="textStyles")
    def text_styles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentStyleArgs']]]]:
        """
        Styles for the Document.text.
        """
        return pulumi.get(self, "text_styles")

    @text_styles.setter
    def text_styles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleCloudDocumentaiV1DocumentStyleArgs']]]]):
        pulumi.set(self, "text_styles", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Currently supports Google Cloud Storage URI of the form `gs://bucket_name/object_name`. Object versioning is not supported. For more information, refer to [Google Cloud Storage Request URIs](https://cloud.google.com/storage/docs/reference-uris).
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uri", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1NormalizedVertexArgs:
    def __init__(__self__, *,
                 x: Optional[pulumi.Input[float]] = None,
                 y: Optional[pulumi.Input[float]] = None):
        """
        A vertex represents a 2D point in the image. NOTE: the normalized vertex coordinates are relative to the original image and range from 0 to 1.
        :param pulumi.Input[float] x: X coordinate.
        :param pulumi.Input[float] y: Y coordinate (starts from the top of the image).
        """
        if x is not None:
            pulumi.set(__self__, "x", x)
        if y is not None:
            pulumi.set(__self__, "y", y)

    @property
    @pulumi.getter
    def x(self) -> Optional[pulumi.Input[float]]:
        """
        X coordinate.
        """
        return pulumi.get(self, "x")

    @x.setter
    def x(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "x", value)

    @property
    @pulumi.getter
    def y(self) -> Optional[pulumi.Input[float]]:
        """
        Y coordinate (starts from the top of the image).
        """
        return pulumi.get(self, "y")

    @y.setter
    def y(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "y", value)


@pulumi.input_type
class GoogleCloudDocumentaiV1VertexArgs:
    def __init__(__self__, *,
                 x: Optional[pulumi.Input[int]] = None,
                 y: Optional[pulumi.Input[int]] = None):
        """
        A vertex represents a 2D point in the image. NOTE: the vertex coordinates are in the same scale as the original image.
        :param pulumi.Input[int] x: X coordinate.
        :param pulumi.Input[int] y: Y coordinate (starts from the top of the image).
        """
        if x is not None:
            pulumi.set(__self__, "x", x)
        if y is not None:
            pulumi.set(__self__, "y", y)

    @property
    @pulumi.getter
    def x(self) -> Optional[pulumi.Input[int]]:
        """
        X coordinate.
        """
        return pulumi.get(self, "x")

    @x.setter
    def x(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "x", value)

    @property
    @pulumi.getter
    def y(self) -> Optional[pulumi.Input[int]]:
        """
        Y coordinate (starts from the top of the image).
        """
        return pulumi.get(self, "y")

    @y.setter
    def y(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "y", value)


@pulumi.input_type
class GoogleIamV1AuditConfigArgs:
    def __init__(__self__, *,
                 audit_log_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleIamV1AuditLogConfigArgs']]]] = None,
                 service: Optional[pulumi.Input[str]] = None):
        """
        Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts `jose@example.com` from DATA_READ logging, and `aliya@example.com` from DATA_WRITE logging.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleIamV1AuditLogConfigArgs']]] audit_log_configs: The configuration for logging of each type of permission.
        :param pulumi.Input[str] service: Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
        """
        if audit_log_configs is not None:
            pulumi.set(__self__, "audit_log_configs", audit_log_configs)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter(name="auditLogConfigs")
    def audit_log_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleIamV1AuditLogConfigArgs']]]]:
        """
        The configuration for logging of each type of permission.
        """
        return pulumi.get(self, "audit_log_configs")

    @audit_log_configs.setter
    def audit_log_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleIamV1AuditLogConfigArgs']]]]):
        pulumi.set(self, "audit_log_configs", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service", value)


@pulumi.input_type
class GoogleIamV1AuditLogConfigArgs:
    def __init__(__self__, *,
                 exempted_members: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 log_type: Optional[pulumi.Input['GoogleIamV1AuditLogConfigLogType']] = None):
        """
        Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exempted_members: Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
        :param pulumi.Input['GoogleIamV1AuditLogConfigLogType'] log_type: The log type that this config enables.
        """
        if exempted_members is not None:
            pulumi.set(__self__, "exempted_members", exempted_members)
        if log_type is not None:
            pulumi.set(__self__, "log_type", log_type)

    @property
    @pulumi.getter(name="exemptedMembers")
    def exempted_members(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
        """
        return pulumi.get(self, "exempted_members")

    @exempted_members.setter
    def exempted_members(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exempted_members", value)

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> Optional[pulumi.Input['GoogleIamV1AuditLogConfigLogType']]:
        """
        The log type that this config enables.
        """
        return pulumi.get(self, "log_type")

    @log_type.setter
    def log_type(self, value: Optional[pulumi.Input['GoogleIamV1AuditLogConfigLogType']]):
        pulumi.set(self, "log_type", value)


@pulumi.input_type
class GoogleIamV1BindingArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input['GoogleTypeExprArgs']] = None,
                 members: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 role: Optional[pulumi.Input[str]] = None):
        """
        Associates `members`, or principals, with a `role`.
        :param pulumi.Input['GoogleTypeExprArgs'] condition: The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] members: Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.
        :param pulumi.Input[str] role: Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if members is not None:
            pulumi.set(__self__, "members", members)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['GoogleTypeExprArgs']]:
        """
        The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['GoogleTypeExprArgs']]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def members(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.
        """
        return pulumi.get(self, "members")

    @members.setter
    def members(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "members", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)


@pulumi.input_type
class GoogleIamV1PolicyArgs:
    def __init__(__self__, *,
                 audit_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleIamV1AuditConfigArgs']]]] = None,
                 bindings: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleIamV1BindingArgs']]]] = None,
                 etag: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[int]] = None):
        """
        An Identity and Access Management (IAM) policy, which specifies access controls for Google Cloud resources. A `Policy` is a collection of `bindings`. A `binding` binds one or more `members`, or principals, to a single `role`. Principals can be user accounts, service accounts, Google groups, and domains (such as G Suite). A `role` is a named list of permissions; each `role` can be an IAM predefined role or a user-created custom role. For some types of Google Cloud resources, a `binding` can also specify a `condition`, which is a logical expression that allows access to a resource only if the expression evaluates to `true`. A condition can add constraints based on attributes of the request, the resource, or both. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies). **JSON example:** ``` { "bindings": [ { "role": "roles/resourcemanager.organizationAdmin", "members": [ "user:mike@example.com", "group:admins@example.com", "domain:google.com", "serviceAccount:my-project-id@appspot.gserviceaccount.com" ] }, { "role": "roles/resourcemanager.organizationViewer", "members": [ "user:eve@example.com" ], "condition": { "title": "expirable access", "description": "Does not grant access after Sep 2020", "expression": "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag": "BwWWja0YfJA=", "version": 3 } ``` **YAML example:** ``` bindings: - members: - user:mike@example.com - group:admins@example.com - domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com role: roles/resourcemanager.organizationAdmin - members: - user:eve@example.com role: roles/resourcemanager.organizationViewer condition: title: expirable access description: Does not grant access after Sep 2020 expression: request.time < timestamp('2020-10-01T00:00:00.000Z') etag: BwWWja0YfJA= version: 3 ``` For a description of IAM and its features, see the [IAM documentation](https://cloud.google.com/iam/docs/).
        :param pulumi.Input[Sequence[pulumi.Input['GoogleIamV1AuditConfigArgs']]] audit_configs: Specifies cloud audit logging configuration for this policy.
        :param pulumi.Input[Sequence[pulumi.Input['GoogleIamV1BindingArgs']]] bindings: Associates a list of `members`, or principals, with a `role`. Optionally, may specify a `condition` that determines how and when the `bindings` are applied. Each of the `bindings` must contain at least one principal. The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250 of these principals can be Google groups. Each occurrence of a principal counts towards these limits. For example, if the `bindings` grant 50 different roles to `user:alice@example.com`, and not to any other principal, then you can add another 1,450 principals to the `bindings` in the `Policy`.
        :param pulumi.Input[str] etag: `etag` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. It is strongly suggested that systems make use of the `etag` in the read-modify-write cycle to perform policy updates in order to avoid race conditions: An `etag` is returned in the response to `getIamPolicy`, and systems are expected to put that etag in the request to `setIamPolicy` to ensure that their change will be applied to the same version of the policy. **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost.
        :param pulumi.Input[int] version: Specifies the format of the policy. Valid values are `0`, `1`, and `3`. Requests that specify an invalid value are rejected. Any operation that affects conditional role bindings must specify version `3`. This requirement applies to the following operations: * Getting a policy that includes a conditional role binding * Adding a conditional role binding to a policy * Changing a conditional role binding in a policy * Removing any role binding, with or without a condition, from a policy that includes conditions **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost. If a policy does not include any conditions, operations on that policy may specify any valid version or leave the field unset. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
        """
        if audit_configs is not None:
            pulumi.set(__self__, "audit_configs", audit_configs)
        if bindings is not None:
            pulumi.set(__self__, "bindings", bindings)
        if etag is not None:
            pulumi.set(__self__, "etag", etag)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="auditConfigs")
    def audit_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleIamV1AuditConfigArgs']]]]:
        """
        Specifies cloud audit logging configuration for this policy.
        """
        return pulumi.get(self, "audit_configs")

    @audit_configs.setter
    def audit_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleIamV1AuditConfigArgs']]]]):
        pulumi.set(self, "audit_configs", value)

    @property
    @pulumi.getter
    def bindings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GoogleIamV1BindingArgs']]]]:
        """
        Associates a list of `members`, or principals, with a `role`. Optionally, may specify a `condition` that determines how and when the `bindings` are applied. Each of the `bindings` must contain at least one principal. The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250 of these principals can be Google groups. Each occurrence of a principal counts towards these limits. For example, if the `bindings` grant 50 different roles to `user:alice@example.com`, and not to any other principal, then you can add another 1,450 principals to the `bindings` in the `Policy`.
        """
        return pulumi.get(self, "bindings")

    @bindings.setter
    def bindings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GoogleIamV1BindingArgs']]]]):
        pulumi.set(self, "bindings", value)

    @property
    @pulumi.getter
    def etag(self) -> Optional[pulumi.Input[str]]:
        """
        `etag` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. It is strongly suggested that systems make use of the `etag` in the read-modify-write cycle to perform policy updates in order to avoid race conditions: An `etag` is returned in the response to `getIamPolicy`, and systems are expected to put that etag in the request to `setIamPolicy` to ensure that their change will be applied to the same version of the policy. **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost.
        """
        return pulumi.get(self, "etag")

    @etag.setter
    def etag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "etag", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the format of the policy. Valid values are `0`, `1`, and `3`. Requests that specify an invalid value are rejected. Any operation that affects conditional role bindings must specify version `3`. This requirement applies to the following operations: * Getting a policy that includes a conditional role binding * Adding a conditional role binding to a policy * Changing a conditional role binding in a policy * Removing any role binding, with or without a condition, from a policy that includes conditions **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost. If a policy does not include any conditions, operations on that policy may specify any valid version or leave the field unset. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class GoogleRpcStatusArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[int]] = None,
                 details: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]] = None,
                 message: Optional[pulumi.Input[str]] = None):
        """
        The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
        :param pulumi.Input[int] code: The status code, which should be an enum value of google.rpc.Code.
        :param pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]] details: A list of messages that carry the error details. There is a common set of message types for APIs to use.
        :param pulumi.Input[str] message: A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        """
        The status code, which should be an enum value of google.rpc.Code.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]:
        """
        A list of messages that carry the error details. There is a common set of message types for APIs to use.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)


@pulumi.input_type
class GoogleTypeColorArgs:
    def __init__(__self__, *,
                 alpha: Optional[pulumi.Input[float]] = None,
                 blue: Optional[pulumi.Input[float]] = None,
                 green: Optional[pulumi.Input[float]] = None,
                 red: Optional[pulumi.Input[float]] = None):
        """
        Represents a color in the RGBA color space. This representation is designed for simplicity of conversion to and from color representations in various languages over compactness. For example, the fields of this representation can be trivially provided to the constructor of `java.awt.Color` in Java; it can also be trivially provided to UIColor's `+colorWithRed:green:blue:alpha` method in iOS; and, with just a little work, it can be easily formatted into a CSS `rgba()` string in JavaScript. This reference page doesn't have information about the absolute color space that should be used to interpret the RGB valuefor example, sRGB, Adobe RGB, DCI-P3, and BT.2020. By default, applications should assume the sRGB color space. When color equality needs to be decided, implementations, unless documented otherwise, treat two colors as equal if all their red, green, blue, and alpha values each differ by at most `1e-5`. Example (Java): import com.google.type.Color; // ... public static java.awt.Color fromProto(Color protocolor) { float alpha = protocolor.hasAlpha() ? protocolor.getAlpha().getValue() : 1.0; return new java.awt.Color( protocolor.getRed(), protocolor.getGreen(), protocolor.getBlue(), alpha); } public static Color toProto(java.awt.Color color) { float red = (float) color.getRed(); float green = (float) color.getGreen(); float blue = (float) color.getBlue(); float denominator = 255.0; Color.Builder resultBuilder = Color .newBuilder() .setRed(red / denominator) .setGreen(green / denominator) .setBlue(blue / denominator); int alpha = color.getAlpha(); if (alpha != 255) { result.setAlpha( FloatValue .newBuilder() .setValue(((float) alpha) / denominator) .build()); } return resultBuilder.build(); } // ... Example (iOS / Obj-C): // ... static UIColor* fromProto(Color* protocolor) { float red = [protocolor red]; float green = [protocolor green]; float blue = [protocolor blue]; FloatValue* alpha_wrapper = [protocolor alpha]; float alpha = 1.0; if (alpha_wrapper != nil) { alpha = [alpha_wrapper value]; } return [UIColor colorWithRed:red green:green blue:blue alpha:alpha]; } static Color* toProto(UIColor* color) { CGFloat red, green, blue, alpha; if (![color getRed:&red green:&green blue:&blue alpha:&alpha]) { return nil; } Color* result = [[Color alloc] init]; [result setRed:red]; [result setGreen:green]; [result setBlue:blue]; if (alpha <= 0.9999) { [result setAlpha:floatWrapperWithValue(alpha)]; } [result autorelease]; return result; } // ... Example (JavaScript): // ... var protoToCssColor = function(rgb_color) { var redFrac = rgb_color.red || 0.0; var greenFrac = rgb_color.green || 0.0; var blueFrac = rgb_color.blue || 0.0; var red = Math.floor(redFrac * 255); var green = Math.floor(greenFrac * 255); var blue = Math.floor(blueFrac * 255); if (!('alpha' in rgb_color)) { return rgbToCssColor(red, green, blue); } var alphaFrac = rgb_color.alpha.value || 0.0; var rgbParams = [red, green, blue].join(','); return ['rgba(', rgbParams, ',', alphaFrac, ')'].join(''); }; var rgbToCssColor = function(red, green, blue) { var rgbNumber = new Number((red << 16) | (green << 8) | blue); var hexString = rgbNumber.toString(16); var missingZeros = 6 - hexString.length; var resultBuilder = ['#']; for (var i = 0; i < missingZeros; i++) { resultBuilder.push('0'); } resultBuilder.push(hexString); return resultBuilder.join(''); }; // ...
        :param pulumi.Input[float] alpha: The fraction of this color that should be applied to the pixel. That is, the final pixel color is defined by the equation: `pixel color = alpha * (this color) + (1.0 - alpha) * (background color)` This means that a value of 1.0 corresponds to a solid color, whereas a value of 0.0 corresponds to a completely transparent color. This uses a wrapper message rather than a simple float scalar so that it is possible to distinguish between a default value and the value being unset. If omitted, this color object is rendered as a solid color (as if the alpha value had been explicitly given a value of 1.0).
        :param pulumi.Input[float] blue: The amount of blue in the color as a value in the interval [0, 1].
        :param pulumi.Input[float] green: The amount of green in the color as a value in the interval [0, 1].
        :param pulumi.Input[float] red: The amount of red in the color as a value in the interval [0, 1].
        """
        if alpha is not None:
            pulumi.set(__self__, "alpha", alpha)
        if blue is not None:
            pulumi.set(__self__, "blue", blue)
        if green is not None:
            pulumi.set(__self__, "green", green)
        if red is not None:
            pulumi.set(__self__, "red", red)

    @property
    @pulumi.getter
    def alpha(self) -> Optional[pulumi.Input[float]]:
        """
        The fraction of this color that should be applied to the pixel. That is, the final pixel color is defined by the equation: `pixel color = alpha * (this color) + (1.0 - alpha) * (background color)` This means that a value of 1.0 corresponds to a solid color, whereas a value of 0.0 corresponds to a completely transparent color. This uses a wrapper message rather than a simple float scalar so that it is possible to distinguish between a default value and the value being unset. If omitted, this color object is rendered as a solid color (as if the alpha value had been explicitly given a value of 1.0).
        """
        return pulumi.get(self, "alpha")

    @alpha.setter
    def alpha(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "alpha", value)

    @property
    @pulumi.getter
    def blue(self) -> Optional[pulumi.Input[float]]:
        """
        The amount of blue in the color as a value in the interval [0, 1].
        """
        return pulumi.get(self, "blue")

    @blue.setter
    def blue(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "blue", value)

    @property
    @pulumi.getter
    def green(self) -> Optional[pulumi.Input[float]]:
        """
        The amount of green in the color as a value in the interval [0, 1].
        """
        return pulumi.get(self, "green")

    @green.setter
    def green(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "green", value)

    @property
    @pulumi.getter
    def red(self) -> Optional[pulumi.Input[float]]:
        """
        The amount of red in the color as a value in the interval [0, 1].
        """
        return pulumi.get(self, "red")

    @red.setter
    def red(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "red", value)


@pulumi.input_type
class GoogleTypeDateTimeArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[int]] = None,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 month: Optional[pulumi.Input[int]] = None,
                 nanos: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None,
                 time_zone: Optional[pulumi.Input['GoogleTypeTimeZoneArgs']] = None,
                 utc_offset: Optional[pulumi.Input[str]] = None,
                 year: Optional[pulumi.Input[int]] = None):
        """
        Represents civil time (or occasionally physical time). This type can represent a civil time in one of a few possible ways: * When utc_offset is set and time_zone is unset: a civil time on a calendar day with a particular offset from UTC. * When time_zone is set and utc_offset is unset: a civil time on a calendar day in a particular time zone. * When neither time_zone nor utc_offset is set: a civil time on a calendar day in local time. The date is relative to the Proleptic Gregorian Calendar. If year, month, or day are 0, the DateTime is considered not to have a specific year, month, or day respectively. This type may also be used to represent a physical time if all the date and time fields are set and either case of the `time_offset` oneof is set. Consider using `Timestamp` message for physical time instead. If your use case also would like to store the user's timezone, that can be done in another field. This type is more flexible than some applications may want. Make sure to document and validate your application's limitations.
        :param pulumi.Input[int] day: Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
        :param pulumi.Input[int] hours: Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param pulumi.Input[int] minutes: Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
        :param pulumi.Input[int] month: Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
        :param pulumi.Input[int] nanos: Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
        :param pulumi.Input[int] seconds: Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
        :param pulumi.Input['GoogleTypeTimeZoneArgs'] time_zone: Time zone.
        :param pulumi.Input[str] utc_offset: UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
        :param pulumi.Input[int] year: Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if utc_offset is not None:
            pulumi.set(__self__, "utc_offset", utc_offset)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[int]]:
        """
        Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[int]]:
        """
        Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[int]]:
        """
        Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input['GoogleTypeTimeZoneArgs']]:
        """
        Time zone.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input['GoogleTypeTimeZoneArgs']]):
        pulumi.set(self, "time_zone", value)

    @property
    @pulumi.getter(name="utcOffset")
    def utc_offset(self) -> Optional[pulumi.Input[str]]:
        """
        UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
        """
        return pulumi.get(self, "utc_offset")

    @utc_offset.setter
    def utc_offset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "utc_offset", value)

    @property
    @pulumi.getter
    def year(self) -> Optional[pulumi.Input[int]]:
        """
        Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "year", value)


@pulumi.input_type
class GoogleTypeDateArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[int]] = None,
                 month: Optional[pulumi.Input[int]] = None,
                 year: Optional[pulumi.Input[int]] = None):
        """
        Represents a whole or partial calendar date, such as a birthday. The time of day and time zone are either specified elsewhere or are insignificant. The date is relative to the Gregorian Calendar. This can represent one of the following: * A full date, with non-zero year, month, and day values. * A month and day, with a zero year (for example, an anniversary). * A year on its own, with a zero month and a zero day. * A year and month, with a zero day (for example, a credit card expiration date). Related types: * google.type.TimeOfDay * google.type.DateTime * google.protobuf.Timestamp
        :param pulumi.Input[int] day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
        :param pulumi.Input[int] month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        :param pulumi.Input[int] year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[int]]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[int]]:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter
    def year(self) -> Optional[pulumi.Input[int]]:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "year", value)


@pulumi.input_type
class GoogleTypeExprArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 expression: Optional[pulumi.Input[str]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
        :param pulumi.Input[str] description: Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        :param pulumi.Input[str] expression: Textual representation of an expression in Common Expression Language syntax.
        :param pulumi.Input[str] location: Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
        :param pulumi.Input[str] title: Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


@pulumi.input_type
class GoogleTypeMoneyArgs:
    def __init__(__self__, *,
                 currency_code: Optional[pulumi.Input[str]] = None,
                 nanos: Optional[pulumi.Input[int]] = None,
                 units: Optional[pulumi.Input[str]] = None):
        """
        Represents an amount of money with its currency type.
        :param pulumi.Input[str] currency_code: The three-letter currency code defined in ISO 4217.
        :param pulumi.Input[int] nanos: Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
        :param pulumi.Input[str] units: The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
        """
        if currency_code is not None:
            pulumi.set(__self__, "currency_code", currency_code)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if units is not None:
            pulumi.set(__self__, "units", units)

    @property
    @pulumi.getter(name="currencyCode")
    def currency_code(self) -> Optional[pulumi.Input[str]]:
        """
        The three-letter currency code defined in ISO 4217.
        """
        return pulumi.get(self, "currency_code")

    @currency_code.setter
    def currency_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "currency_code", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[int]]:
        """
        Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def units(self) -> Optional[pulumi.Input[str]]:
        """
        The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
        """
        return pulumi.get(self, "units")

    @units.setter
    def units(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "units", value)


@pulumi.input_type
class GoogleTypePostalAddressArgs:
    def __init__(__self__, *,
                 region_code: pulumi.Input[str],
                 address_lines: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 administrative_area: Optional[pulumi.Input[str]] = None,
                 language_code: Optional[pulumi.Input[str]] = None,
                 locality: Optional[pulumi.Input[str]] = None,
                 organization: Optional[pulumi.Input[str]] = None,
                 postal_code: Optional[pulumi.Input[str]] = None,
                 recipients: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 revision: Optional[pulumi.Input[int]] = None,
                 sorting_code: Optional[pulumi.Input[str]] = None,
                 sublocality: Optional[pulumi.Input[str]] = None):
        """
        Represents a postal address, e.g. for postal delivery or payments addresses. Given a postal address, a postal service can deliver items to a premise, P.O. Box or similar. It is not intended to model geographical locations (roads, towns, mountains). In typical usage an address would be created via user input or from importing existing data, depending on the type of process. Advice on address input / editing: - Use an internationalization-ready address widget such as https://github.com/google/libaddressinput) - Users should not be presented with UI elements for input or editing of fields outside countries where that field is used. For more guidance on how to use this schema, please see: https://support.google.com/business/answer/6397478
        :param pulumi.Input[str] region_code: CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See https://cldr.unicode.org/ and https://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] address_lines: Unstructured address lines describing the lower levels of an address. Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way, the most specific line of an address can be selected based on the language. The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved. Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
        :param pulumi.Input[str] administrative_area: Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
        :param pulumi.Input[str] language_code: Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations. If this value is not known, it should be omitted (rather than specifying a possibly incorrect default). Examples: "zh-Hant", "ja", "ja-Latn", "en".
        :param pulumi.Input[str] locality: Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
        :param pulumi.Input[str] organization: Optional. The name of the organization at the address.
        :param pulumi.Input[str] postal_code: Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] recipients: Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain "care of" information.
        :param pulumi.Input[int] revision: The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision. All new revisions **must** be backward compatible with old revisions.
        :param pulumi.Input[str] sorting_code: Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number alone, representing the "sector code" (Jamaica), "delivery area indicator" (Malawi) or "post office indicator" (e.g. Cte d'Ivoire).
        :param pulumi.Input[str] sublocality: Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
        """
        pulumi.set(__self__, "region_code", region_code)
        if address_lines is not None:
            pulumi.set(__self__, "address_lines", address_lines)
        if administrative_area is not None:
            pulumi.set(__self__, "administrative_area", administrative_area)
        if language_code is not None:
            pulumi.set(__self__, "language_code", language_code)
        if locality is not None:
            pulumi.set(__self__, "locality", locality)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if recipients is not None:
            pulumi.set(__self__, "recipients", recipients)
        if revision is not None:
            pulumi.set(__self__, "revision", revision)
        if sorting_code is not None:
            pulumi.set(__self__, "sorting_code", sorting_code)
        if sublocality is not None:
            pulumi.set(__self__, "sublocality", sublocality)

    @property
    @pulumi.getter(name="regionCode")
    def region_code(self) -> pulumi.Input[str]:
        """
        CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See https://cldr.unicode.org/ and https://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.
        """
        return pulumi.get(self, "region_code")

    @region_code.setter
    def region_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "region_code", value)

    @property
    @pulumi.getter(name="addressLines")
    def address_lines(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Unstructured address lines describing the lower levels of an address. Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way, the most specific line of an address can be selected based on the language. The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved. Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
        """
        return pulumi.get(self, "address_lines")

    @address_lines.setter
    def address_lines(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "address_lines", value)

    @property
    @pulumi.getter(name="administrativeArea")
    def administrative_area(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
        """
        return pulumi.get(self, "administrative_area")

    @administrative_area.setter
    def administrative_area(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "administrative_area", value)

    @property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations. If this value is not known, it should be omitted (rather than specifying a possibly incorrect default). Examples: "zh-Hant", "ja", "ja-Latn", "en".
        """
        return pulumi.get(self, "language_code")

    @language_code.setter
    def language_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "language_code", value)

    @property
    @pulumi.getter
    def locality(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
        """
        return pulumi.get(self, "locality")

    @locality.setter
    def locality(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locality", value)

    @property
    @pulumi.getter
    def organization(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The name of the organization at the address.
        """
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "organization", value)

    @property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
        """
        return pulumi.get(self, "postal_code")

    @postal_code.setter
    def postal_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "postal_code", value)

    @property
    @pulumi.getter
    def recipients(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain "care of" information.
        """
        return pulumi.get(self, "recipients")

    @recipients.setter
    def recipients(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "recipients", value)

    @property
    @pulumi.getter
    def revision(self) -> Optional[pulumi.Input[int]]:
        """
        The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision. All new revisions **must** be backward compatible with old revisions.
        """
        return pulumi.get(self, "revision")

    @revision.setter
    def revision(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "revision", value)

    @property
    @pulumi.getter(name="sortingCode")
    def sorting_code(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number alone, representing the "sector code" (Jamaica), "delivery area indicator" (Malawi) or "post office indicator" (e.g. Cte d'Ivoire).
        """
        return pulumi.get(self, "sorting_code")

    @sorting_code.setter
    def sorting_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sorting_code", value)

    @property
    @pulumi.getter
    def sublocality(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
        """
        return pulumi.get(self, "sublocality")

    @sublocality.setter
    def sublocality(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sublocality", value)


@pulumi.input_type
class GoogleTypeTimeZoneArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        Represents a time zone from the [IANA Time Zone Database](https://www.iana.org/time-zones).
        :param pulumi.Input[str] id: IANA Time Zone Database time zone, e.g. "America/New_York".
        :param pulumi.Input[str] version: Optional. IANA Time Zone Database version number, e.g. "2019a".
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        IANA Time Zone Database time zone, e.g. "America/New_York".
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. IANA Time Zone Database version number, e.g. "2019a".
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


